{"version":3,"file":"waveform-performance-BxG7lKLN.js","sources":["../../src/services/WaveformCache.js","../../src/services/WaveformMemoryManager.js","../../src/services/WaveformPerformanceMonitor.js"],"sourcesContent":["/**\r\n * Intelligent caching system for generated waveform data\r\n * Implements LRU cache with memory management and persistence\r\n * Requirements: 7.2, 7.3, 7.4\r\n */\r\n\r\nexport class WaveformCache {\r\n  constructor(options = {}) {\r\n    this.maxMemorySize = options.maxMemorySize || 100 * 1024 * 1024; // 100MB default\r\n    this.maxCacheEntries = options.maxCacheEntries || 50;\r\n    this.persistenceEnabled = options.persistenceEnabled !== false;\r\n    this.compressionEnabled = options.compressionEnabled !== false;\r\n    this.ttl = options.ttl || 24 * 60 * 60 * 1000; // 24 hours default\r\n    \r\n    // In-memory cache with LRU ordering\r\n    this.memoryCache = new Map();\r\n    this.accessOrder = new Map(); // Track access times for LRU\r\n    this.memorySizeUsed = 0;\r\n    \r\n    // Persistence layer\r\n    this.persistentCache = null;\r\n    this.initializePersistence();\r\n    \r\n    // Performance metrics\r\n    this.metrics = {\r\n      hits: 0,\r\n      misses: 0,\r\n      evictions: 0,\r\n      compressionSavings: 0,\r\n      averageCompressionRatio: 0,\r\n      persistenceHits: 0,\r\n      persistenceMisses: 0\r\n    };\r\n    \r\n    // Cleanup interval\r\n    this.cleanupInterval = setInterval(() => {\r\n      this.performMaintenance();\r\n    }, 5 * 60 * 1000); // Every 5 minutes\r\n  }\r\n\r\n  /**\r\n   * Initialize persistence layer using IndexedDB\r\n   */\r\n  async initializePersistence() {\r\n    if (!this.persistenceEnabled || typeof indexedDB === 'undefined') {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      this.persistentCache = await this.openIndexedDB();\r\n    } catch (error) {\r\n      console.warn('Failed to initialize persistent cache:', error);\r\n      this.persistenceEnabled = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Open IndexedDB for persistent caching\r\n   */\r\n  openIndexedDB() {\r\n    return new Promise((resolve, reject) => {\r\n      const request = indexedDB.open('WaveformCache', 1);\r\n      \r\n      request.onerror = () => reject(request.error);\r\n      \r\n      request.onsuccess = () => {\r\n        const db = request.result;\r\n        resolve(db);\r\n      };\r\n      \r\n      request.onupgradeneeded = (event) => {\r\n        const db = event.target.result;\r\n        \r\n        // Create object store for waveform data\r\n        if (!db.objectStoreNames.contains('waveforms')) {\r\n          const store = db.createObjectStore('waveforms', { keyPath: 'key' });\r\n          store.createIndex('timestamp', 'timestamp', { unique: false });\r\n          store.createIndex('size', 'size', { unique: false });\r\n        }\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Generate cache key from waveform parameters\r\n   */\r\n  generateCacheKey(audioSource, options = {}) {\r\n    const keyData = {\r\n      source: this.getSourceIdentifier(audioSource),\r\n      sampleRate: options.sampleRate || 1000,\r\n      quality: options.quality || 'medium',\r\n      analysisMethod: options.analysisMethod || 'auto',\r\n      duration: options.duration || 0\r\n    };\r\n    \r\n    // Create hash from key data\r\n    return this.hashObject(keyData);\r\n  }\r\n\r\n  /**\r\n   * Get waveform data from cache\r\n   */\r\n  async get(cacheKey) {\r\n    // Check memory cache first\r\n    const memoryResult = this.getFromMemory(cacheKey);\r\n    if (memoryResult) {\r\n      this.metrics.hits++;\r\n      return memoryResult;\r\n    }\r\n    \r\n    // Check persistent cache\r\n    if (this.persistenceEnabled && this.persistentCache) {\r\n      const persistentResult = await this.getFromPersistent(cacheKey);\r\n      if (persistentResult) {\r\n        this.metrics.persistenceHits++;\r\n        this.metrics.hits++;\r\n        \r\n        // Promote to memory cache\r\n        this.setInMemory(cacheKey, persistentResult);\r\n        return persistentResult;\r\n      } else {\r\n        this.metrics.persistenceMisses++;\r\n      }\r\n    }\r\n    \r\n    this.metrics.misses++;\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Store waveform data in cache\r\n   */\r\n  async set(cacheKey, waveformData, metadata = {}) {\r\n    const cacheEntry = {\r\n      key: cacheKey,\r\n      data: waveformData,\r\n      metadata: {\r\n        ...metadata,\r\n        timestamp: Date.now(),\r\n        accessCount: 1,\r\n        size: this.calculateDataSize(waveformData)\r\n      }\r\n    };\r\n    \r\n    // Compress data if enabled\r\n    if (this.compressionEnabled) {\r\n      const compressed = await this.compressData(cacheEntry);\r\n      if (compressed.size < cacheEntry.metadata.size) {\r\n        const savings = cacheEntry.metadata.size - compressed.size;\r\n        this.metrics.compressionSavings += savings;\r\n        this.updateCompressionRatio(cacheEntry.metadata.size, compressed.size);\r\n        cacheEntry.compressed = true;\r\n        cacheEntry.data = compressed.data;\r\n        cacheEntry.metadata.size = compressed.size;\r\n      }\r\n    }\r\n    \r\n    // Store in memory cache\r\n    this.setInMemory(cacheKey, cacheEntry);\r\n    \r\n    // Store in persistent cache\r\n    if (this.persistenceEnabled && this.persistentCache) {\r\n      await this.setInPersistent(cacheKey, cacheEntry);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get data from memory cache\r\n   */\r\n  getFromMemory(cacheKey) {\r\n    const entry = this.memoryCache.get(cacheKey);\r\n    if (!entry) return null;\r\n    \r\n    // Check TTL\r\n    if (Date.now() - entry.metadata.timestamp > this.ttl) {\r\n      this.memoryCache.delete(cacheKey);\r\n      this.accessOrder.delete(cacheKey);\r\n      this.memorySizeUsed -= entry.metadata.size;\r\n      return null;\r\n    }\r\n    \r\n    // Update access order for LRU\r\n    this.accessOrder.set(cacheKey, Date.now());\r\n    entry.metadata.accessCount++;\r\n    \r\n    // Decompress if needed\r\n    if (entry.compressed) {\r\n      const decompressed = this.decompressData(entry);\r\n      return {\r\n        ...entry,\r\n        data: decompressed,\r\n        compressed: false\r\n      };\r\n    }\r\n    \r\n    return entry;\r\n  }\r\n\r\n  /**\r\n   * Set data in memory cache with LRU eviction\r\n   */\r\n  setInMemory(cacheKey, cacheEntry) {\r\n    // Check if we need to evict entries\r\n    while (\r\n      (this.memorySizeUsed + cacheEntry.metadata.size > this.maxMemorySize) ||\r\n      (this.memoryCache.size >= this.maxCacheEntries)\r\n    ) {\r\n      this.evictLRU();\r\n    }\r\n    \r\n    // Remove existing entry if updating\r\n    if (this.memoryCache.has(cacheKey)) {\r\n      const existing = this.memoryCache.get(cacheKey);\r\n      this.memorySizeUsed -= existing.metadata.size;\r\n    }\r\n    \r\n    // Add new entry\r\n    this.memoryCache.set(cacheKey, cacheEntry);\r\n    this.accessOrder.set(cacheKey, Date.now());\r\n    this.memorySizeUsed += cacheEntry.metadata.size;\r\n  }\r\n\r\n  /**\r\n   * Get data from persistent cache\r\n   */\r\n  async getFromPersistent(cacheKey) {\r\n    if (!this.persistentCache) return null;\r\n    \r\n    try {\r\n      const transaction = this.persistentCache.transaction(['waveforms'], 'readonly');\r\n      const store = transaction.objectStore('waveforms');\r\n      const request = store.get(cacheKey);\r\n      \r\n      return new Promise((resolve, reject) => {\r\n        request.onsuccess = () => {\r\n          const result = request.result;\r\n          if (!result) {\r\n            resolve(null);\r\n            return;\r\n          }\r\n          \r\n          // Check TTL\r\n          if (Date.now() - result.timestamp > this.ttl) {\r\n            // Delete expired entry\r\n            this.deleteFromPersistent(cacheKey);\r\n            resolve(null);\r\n            return;\r\n          }\r\n          \r\n          // Decompress if needed\r\n          if (result.compressed) {\r\n            const decompressed = this.decompressData(result);\r\n            resolve({\r\n              ...result,\r\n              data: decompressed,\r\n              compressed: false\r\n            });\r\n          } else {\r\n            resolve(result);\r\n          }\r\n        };\r\n        \r\n        request.onerror = () => reject(request.error);\r\n      });\r\n    } catch (error) {\r\n      console.warn('Failed to get from persistent cache:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set data in persistent cache\r\n   */\r\n  async setInPersistent(cacheKey, cacheEntry) {\r\n    if (!this.persistentCache) return;\r\n    \r\n    try {\r\n      const transaction = this.persistentCache.transaction(['waveforms'], 'readwrite');\r\n      const store = transaction.objectStore('waveforms');\r\n      \r\n      // Create persistent entry\r\n      const persistentEntry = {\r\n        key: cacheKey,\r\n        data: cacheEntry.data,\r\n        metadata: cacheEntry.metadata,\r\n        compressed: cacheEntry.compressed || false,\r\n        timestamp: cacheEntry.metadata.timestamp,\r\n        size: cacheEntry.metadata.size\r\n      };\r\n      \r\n      store.put(persistentEntry);\r\n      \r\n      return new Promise((resolve, reject) => {\r\n        transaction.oncomplete = () => resolve();\r\n        transaction.onerror = () => reject(transaction.error);\r\n      });\r\n    } catch (error) {\r\n      console.warn('Failed to set in persistent cache:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete entry from persistent cache\r\n   */\r\n  async deleteFromPersistent(cacheKey) {\r\n    if (!this.persistentCache) return;\r\n    \r\n    try {\r\n      const transaction = this.persistentCache.transaction(['waveforms'], 'readwrite');\r\n      const store = transaction.objectStore('waveforms');\r\n      store.delete(cacheKey);\r\n    } catch (error) {\r\n      console.warn('Failed to delete from persistent cache:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Evict least recently used entry from memory cache\r\n   */\r\n  evictLRU() {\r\n    if (this.accessOrder.size === 0) return;\r\n    \r\n    // Find least recently used entry\r\n    let oldestKey = null;\r\n    let oldestTime = Date.now();\r\n    \r\n    for (const [key, accessTime] of this.accessOrder) {\r\n      if (accessTime < oldestTime) {\r\n        oldestTime = accessTime;\r\n        oldestKey = key;\r\n      }\r\n    }\r\n    \r\n    if (oldestKey) {\r\n      const entry = this.memoryCache.get(oldestKey);\r\n      if (entry) {\r\n        this.memorySizeUsed -= entry.metadata.size;\r\n      }\r\n      \r\n      this.memoryCache.delete(oldestKey);\r\n      this.accessOrder.delete(oldestKey);\r\n      this.metrics.evictions++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Compress waveform data\r\n   */\r\n  async compressData(cacheEntry) {\r\n    try {\r\n      // Simple compression using JSON stringify and compression\r\n      const jsonData = JSON.stringify(cacheEntry.data);\r\n      \r\n      // Use CompressionStream if available (modern browsers)\r\n      if (typeof CompressionStream !== 'undefined') {\r\n        const stream = new CompressionStream('gzip');\r\n        const writer = stream.writable.getWriter();\r\n        const reader = stream.readable.getReader();\r\n        \r\n        writer.write(new TextEncoder().encode(jsonData));\r\n        writer.close();\r\n        \r\n        const chunks = [];\r\n        let done = false;\r\n        \r\n        while (!done) {\r\n          const { value, done: readerDone } = await reader.read();\r\n          done = readerDone;\r\n          if (value) chunks.push(value);\r\n        }\r\n        \r\n        const compressed = new Uint8Array(chunks.reduce((acc, chunk) => acc + chunk.length, 0));\r\n        let offset = 0;\r\n        for (const chunk of chunks) {\r\n          compressed.set(chunk, offset);\r\n          offset += chunk.length;\r\n        }\r\n        \r\n        return {\r\n          data: compressed,\r\n          size: compressed.length,\r\n          originalSize: jsonData.length\r\n        };\r\n      } else {\r\n        // Fallback: simple string compression\r\n        const compressed = this.simpleCompress(jsonData);\r\n        return {\r\n          data: compressed,\r\n          size: compressed.length,\r\n          originalSize: jsonData.length\r\n        };\r\n      }\r\n    } catch (error) {\r\n      console.warn('Compression failed:', error);\r\n      return {\r\n        data: cacheEntry.data,\r\n        size: cacheEntry.metadata.size,\r\n        originalSize: cacheEntry.metadata.size\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Decompress waveform data\r\n   */\r\n  decompressData(cacheEntry) {\r\n    try {\r\n      if (cacheEntry.data instanceof Uint8Array) {\r\n        // Decompress using DecompressionStream if available\r\n        if (typeof DecompressionStream !== 'undefined') {\r\n          // This would need to be async, but for simplicity using fallback\r\n          return this.simpleDecompress(new TextDecoder().decode(cacheEntry.data));\r\n        } else {\r\n          return this.simpleDecompress(new TextDecoder().decode(cacheEntry.data));\r\n        }\r\n      } else if (typeof cacheEntry.data === 'string') {\r\n        return this.simpleDecompress(cacheEntry.data);\r\n      } else {\r\n        return cacheEntry.data;\r\n      }\r\n    } catch (error) {\r\n      console.warn('Decompression failed:', error);\r\n      return cacheEntry.data;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Simple compression fallback\r\n   */\r\n  simpleCompress(data) {\r\n    // Basic RLE compression for demonstration\r\n    let compressed = '';\r\n    let count = 1;\r\n    let current = data[0];\r\n    \r\n    for (let i = 1; i < data.length; i++) {\r\n      if (data[i] === current && count < 255) {\r\n        count++;\r\n      } else {\r\n        compressed += String.fromCharCode(count) + current;\r\n        current = data[i];\r\n        count = 1;\r\n      }\r\n    }\r\n    compressed += String.fromCharCode(count) + current;\r\n    \r\n    return compressed;\r\n  }\r\n\r\n  /**\r\n   * Simple decompression fallback\r\n   */\r\n  simpleDecompress(compressed) {\r\n    try {\r\n      return JSON.parse(compressed);\r\n    } catch {\r\n      // If not JSON, try RLE decompression\r\n      let decompressed = '';\r\n      for (let i = 0; i < compressed.length; i += 2) {\r\n        const count = compressed.charCodeAt(i);\r\n        const char = compressed[i + 1];\r\n        decompressed += char.repeat(count);\r\n      }\r\n      return JSON.parse(decompressed);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate data size in bytes\r\n   */\r\n  calculateDataSize(data) {\r\n    if (data instanceof ArrayBuffer) {\r\n      return data.byteLength;\r\n    } else if (data instanceof Float32Array || data instanceof Uint8Array) {\r\n      return data.length * data.BYTES_PER_ELEMENT;\r\n    } else if (typeof data === 'string') {\r\n      return data.length * 2; // Approximate UTF-16 size\r\n    } else {\r\n      // Estimate JSON size\r\n      return JSON.stringify(data).length * 2;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate source identifier for caching\r\n   */\r\n  getSourceIdentifier(audioSource) {\r\n    if (typeof audioSource === 'string') {\r\n      return audioSource; // URL or identifier\r\n    } else if (audioSource && audioSource.videoId) {\r\n      return `youtube:${audioSource.videoId}`;\r\n    } else if (audioSource && audioSource.src) {\r\n      return audioSource.src;\r\n    } else {\r\n      return 'unknown';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Hash object to create cache key\r\n   */\r\n  hashObject(obj) {\r\n    const str = JSON.stringify(obj, Object.keys(obj).sort());\r\n    let hash = 0;\r\n    \r\n    for (let i = 0; i < str.length; i++) {\r\n      const char = str.charCodeAt(i);\r\n      hash = ((hash << 5) - hash) + char;\r\n      hash = hash & hash; // Convert to 32-bit integer\r\n    }\r\n    \r\n    return `waveform_${Math.abs(hash).toString(36)}`;\r\n  }\r\n\r\n  /**\r\n   * Update compression ratio metrics\r\n   */\r\n  updateCompressionRatio(originalSize, compressedSize) {\r\n    const ratio = compressedSize / originalSize;\r\n    const count = this.metrics.hits + this.metrics.misses;\r\n    \r\n    this.metrics.averageCompressionRatio = \r\n      (this.metrics.averageCompressionRatio * (count - 1) + ratio) / count;\r\n  }\r\n\r\n  /**\r\n   * Perform cache maintenance\r\n   */\r\n  async performMaintenance() {\r\n    // Clean expired entries from memory cache\r\n    const now = Date.now();\r\n    const expiredKeys = [];\r\n    \r\n    for (const [key, entry] of this.memoryCache) {\r\n      if (now - entry.metadata.timestamp > this.ttl) {\r\n        expiredKeys.push(key);\r\n      }\r\n    }\r\n    \r\n    for (const key of expiredKeys) {\r\n      const entry = this.memoryCache.get(key);\r\n      if (entry) {\r\n        this.memorySizeUsed -= entry.metadata.size;\r\n      }\r\n      this.memoryCache.delete(key);\r\n      this.accessOrder.delete(key);\r\n    }\r\n    \r\n    // Clean expired entries from persistent cache\r\n    if (this.persistenceEnabled && this.persistentCache) {\r\n      await this.cleanExpiredPersistent();\r\n    }\r\n    \r\n    // Optimize memory usage if needed\r\n    if (this.memorySizeUsed > this.maxMemorySize * 0.8) {\r\n      this.optimizeMemoryUsage();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean expired entries from persistent cache\r\n   */\r\n  async cleanExpiredPersistent() {\r\n    try {\r\n      const transaction = this.persistentCache.transaction(['waveforms'], 'readwrite');\r\n      const store = transaction.objectStore('waveforms');\r\n      const index = store.index('timestamp');\r\n      \r\n      const cutoffTime = Date.now() - this.ttl;\r\n      const range = IDBKeyRange.upperBound(cutoffTime);\r\n      \r\n      const request = index.openCursor(range);\r\n      \r\n      request.onsuccess = (event) => {\r\n        const cursor = event.target.result;\r\n        if (cursor) {\r\n          cursor.delete();\r\n          cursor.continue();\r\n        }\r\n      };\r\n    } catch (error) {\r\n      console.warn('Failed to clean expired persistent cache:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Optimize memory usage by evicting less frequently used entries\r\n   */\r\n  optimizeMemoryUsage() {\r\n    // Sort entries by access frequency and recency\r\n    const entries = Array.from(this.memoryCache.entries()).map(([key, entry]) => ({\r\n      key,\r\n      entry,\r\n      score: entry.metadata.accessCount * (Date.now() - entry.metadata.timestamp)\r\n    }));\r\n    \r\n    entries.sort((a, b) => a.score - b.score);\r\n    \r\n    // Remove bottom 25% of entries\r\n    const toRemove = Math.floor(entries.length * 0.25);\r\n    for (let i = 0; i < toRemove; i++) {\r\n      const { key, entry } = entries[i];\r\n      this.memorySizeUsed -= entry.metadata.size;\r\n      this.memoryCache.delete(key);\r\n      this.accessOrder.delete(key);\r\n      this.metrics.evictions++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get cache statistics\r\n   */\r\n  getStats() {\r\n    const hitRate = this.metrics.hits / (this.metrics.hits + this.metrics.misses) || 0;\r\n    const persistentHitRate = this.metrics.persistenceHits / this.metrics.persistenceMisses || 0;\r\n    \r\n    return {\r\n      memoryCache: {\r\n        entries: this.memoryCache.size,\r\n        sizeUsed: this.memorySizeUsed,\r\n        maxSize: this.maxMemorySize,\r\n        utilizationPercent: (this.memorySizeUsed / this.maxMemorySize) * 100\r\n      },\r\n      performance: {\r\n        hitRate: hitRate * 100,\r\n        persistentHitRate: persistentHitRate * 100,\r\n        totalHits: this.metrics.hits,\r\n        totalMisses: this.metrics.misses,\r\n        evictions: this.metrics.evictions\r\n      },\r\n      compression: {\r\n        enabled: this.compressionEnabled,\r\n        totalSavings: this.metrics.compressionSavings,\r\n        averageRatio: this.metrics.averageCompressionRatio\r\n      },\r\n      persistence: {\r\n        enabled: this.persistenceEnabled,\r\n        hits: this.metrics.persistenceHits,\r\n        misses: this.metrics.persistenceMisses\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear all cache data\r\n   */\r\n  async clear() {\r\n    // Clear memory cache\r\n    this.memoryCache.clear();\r\n    this.accessOrder.clear();\r\n    this.memorySizeUsed = 0;\r\n    \r\n    // Clear persistent cache\r\n    if (this.persistenceEnabled && this.persistentCache) {\r\n      try {\r\n        const transaction = this.persistentCache.transaction(['waveforms'], 'readwrite');\r\n        const store = transaction.objectStore('waveforms');\r\n        store.clear();\r\n      } catch (error) {\r\n        console.warn('Failed to clear persistent cache:', error);\r\n      }\r\n    }\r\n    \r\n    // Reset metrics\r\n    this.metrics = {\r\n      hits: 0,\r\n      misses: 0,\r\n      evictions: 0,\r\n      compressionSavings: 0,\r\n      averageCompressionRatio: 0,\r\n      persistenceHits: 0,\r\n      persistenceMisses: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Destroy cache and cleanup resources\r\n   */\r\n  destroy() {\r\n    // Clear cleanup interval\r\n    if (this.cleanupInterval) {\r\n      clearInterval(this.cleanupInterval);\r\n      this.cleanupInterval = null;\r\n    }\r\n    \r\n    // Clear all data\r\n    this.clear();\r\n    \r\n    // Close persistent cache\r\n    if (this.persistentCache) {\r\n      this.persistentCache.close();\r\n      this.persistentCache = null;\r\n    }\r\n  }\r\n}\r\n\r\nexport default WaveformCache;","/**\r\n * Memory cleanup strategies for large audio files\r\n * Implements intelligent memory management and garbage collection\r\n * Requirements: 7.3, 7.4, 7.5\r\n */\r\n\r\nexport class WaveformMemoryManager {\r\n  constructor(options = {}) {\r\n    this.maxMemoryThreshold = options.maxMemoryThreshold || 150 * 1024 * 1024; // 150MB\r\n    this.warningThreshold = options.warningThreshold || 100 * 1024 * 1024; // 100MB\r\n    this.cleanupInterval = options.cleanupInterval || 30 * 1000; // 30 seconds\r\n    this.aggressiveCleanupThreshold = options.aggressiveCleanupThreshold || 200 * 1024 * 1024; // 200MB\r\n    \r\n    // Memory tracking\r\n    this.allocatedBuffers = new Map();\r\n    this.bufferPool = new Map(); // Reusable buffers\r\n    this.memoryUsage = {\r\n      current: 0,\r\n      peak: 0,\r\n      allocated: 0,\r\n      pooled: 0\r\n    };\r\n    \r\n    // Cleanup strategies\r\n    this.cleanupStrategies = new Map();\r\n    this.initializeCleanupStrategies();\r\n    \r\n    // Performance monitoring\r\n    this.performanceMetrics = {\r\n      cleanupCount: 0,\r\n      memoryReclaimed: 0,\r\n      bufferReuses: 0,\r\n      gcTriggers: 0,\r\n      averageCleanupTime: 0\r\n    };\r\n    \r\n    // Auto cleanup\r\n    this.cleanupTimer = setInterval(() => {\r\n      this.performAutomaticCleanup();\r\n    }, this.cleanupInterval);\r\n    \r\n    // Memory pressure monitoring\r\n    this.memoryPressureObserver = null;\r\n    this.initializeMemoryPressureMonitoring();\r\n  }\r\n\r\n  /**\r\n   * Initialize cleanup strategies\r\n   */\r\n  initializeCleanupStrategies() {\r\n    this.cleanupStrategies.set('buffer-pool', {\r\n      priority: 1,\r\n      execute: () => this.cleanupBufferPool(),\r\n      description: 'Clean unused buffers from pool'\r\n    });\r\n    \r\n    this.cleanupStrategies.set('old-allocations', {\r\n      priority: 2,\r\n      execute: () => this.cleanupOldAllocations(),\r\n      description: 'Remove old allocated buffers'\r\n    });\r\n    \r\n    this.cleanupStrategies.set('large-buffers', {\r\n      priority: 3,\r\n      execute: () => this.cleanupLargeBuffers(),\r\n      description: 'Clean up large unused buffers'\r\n    });\r\n    \r\n    this.cleanupStrategies.set('force-gc', {\r\n      priority: 4,\r\n      execute: () => this.forceGarbageCollection(),\r\n      description: 'Force garbage collection'\r\n    });\r\n    \r\n    this.cleanupStrategies.set('emergency-cleanup', {\r\n      priority: 5,\r\n      execute: () => this.emergencyCleanup(),\r\n      description: 'Emergency memory cleanup'\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Initialize memory pressure monitoring\r\n   */\r\n  initializeMemoryPressureMonitoring() {\r\n    // Use Performance Observer API if available\r\n    if (typeof PerformanceObserver !== 'undefined') {\r\n      try {\r\n        this.memoryPressureObserver = new PerformanceObserver((list) => {\r\n          const entries = list.getEntries();\r\n          for (const entry of entries) {\r\n            if (entry.entryType === 'measure' && entry.name.includes('memory')) {\r\n              this.handleMemoryPressure(entry);\r\n            }\r\n          }\r\n        });\r\n        \r\n        this.memoryPressureObserver.observe({ entryTypes: ['measure'] });\r\n      } catch (error) {\r\n        console.warn('Memory pressure monitoring not available:', error);\r\n      }\r\n    }\r\n    \r\n    // Fallback: monitor memory usage manually\r\n    setInterval(() => {\r\n      this.checkMemoryPressure();\r\n    }, 5000); // Check every 5 seconds\r\n  }\r\n\r\n  /**\r\n   * Allocate buffer with tracking\r\n   */\r\n  allocateBuffer(size, type = 'waveform', metadata = {}) {\r\n    const bufferId = this.generateBufferId();\r\n    \r\n    // Try to reuse buffer from pool\r\n    const pooledBuffer = this.getPooledBuffer(size, type);\r\n    if (pooledBuffer) {\r\n      this.allocatedBuffers.set(bufferId, {\r\n        buffer: pooledBuffer,\r\n        size,\r\n        type,\r\n        metadata: {\r\n          ...metadata,\r\n          allocatedAt: Date.now(),\r\n          reused: true\r\n        }\r\n      });\r\n      \r\n      this.performanceMetrics.bufferReuses++;\r\n      return { bufferId, buffer: pooledBuffer };\r\n    }\r\n    \r\n    // Allocate new buffer\r\n    let buffer;\r\n    try {\r\n      switch (type) {\r\n        case 'waveform':\r\n        case 'float32':\r\n          buffer = new Float32Array(size);\r\n          break;\r\n        case 'uint8':\r\n          buffer = new Uint8Array(size);\r\n          break;\r\n        case 'int16':\r\n          buffer = new Int16Array(size);\r\n          break;\r\n        case 'arraybuffer':\r\n          buffer = new ArrayBuffer(size);\r\n          break;\r\n        default:\r\n          buffer = new Float32Array(size);\r\n      }\r\n      \r\n      const actualSize = buffer.byteLength || (buffer.length * buffer.BYTES_PER_ELEMENT);\r\n      \r\n      this.allocatedBuffers.set(bufferId, {\r\n        buffer,\r\n        size: actualSize,\r\n        type,\r\n        metadata: {\r\n          ...metadata,\r\n          allocatedAt: Date.now(),\r\n          reused: false\r\n        }\r\n      });\r\n      \r\n      this.memoryUsage.current += actualSize;\r\n      this.memoryUsage.allocated += actualSize;\r\n      this.memoryUsage.peak = Math.max(this.memoryUsage.peak, this.memoryUsage.current);\r\n      \r\n      // Check if we need cleanup\r\n      if (this.memoryUsage.current > this.warningThreshold) {\r\n        this.scheduleCleanup('memory-warning');\r\n      }\r\n      \r\n      return { bufferId, buffer };\r\n      \r\n    } catch (error) {\r\n      console.error('Buffer allocation failed:', error);\r\n      \r\n      // Try emergency cleanup and retry once\r\n      if (this.memoryUsage.current > this.maxMemoryThreshold * 0.8) {\r\n        this.emergencyCleanup();\r\n        \r\n        try {\r\n          buffer = new Float32Array(size);\r\n          const actualSize = buffer.byteLength || (buffer.length * buffer.BYTES_PER_ELEMENT);\r\n          \r\n          this.allocatedBuffers.set(bufferId, {\r\n            buffer,\r\n            size: actualSize,\r\n            type,\r\n            metadata: {\r\n              ...metadata,\r\n              allocatedAt: Date.now(),\r\n              reused: false,\r\n              emergencyRetry: true\r\n            }\r\n          });\r\n          \r\n          this.memoryUsage.current += actualSize;\r\n          this.memoryUsage.allocated += actualSize;\r\n          \r\n          return { bufferId, buffer };\r\n        } catch (retryError) {\r\n          throw new Error(`Buffer allocation failed after emergency cleanup: ${retryError.message}`);\r\n        }\r\n      }\r\n      \r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deallocate buffer and optionally pool for reuse\r\n   */\r\n  deallocateBuffer(bufferId, options = {}) {\r\n    const allocation = this.allocatedBuffers.get(bufferId);\r\n    if (!allocation) {\r\n      console.warn(`Buffer ${bufferId} not found for deallocation`);\r\n      return false;\r\n    }\r\n    \r\n    const { buffer, size, type } = allocation;\r\n    const { poolForReuse = true, reason = 'manual' } = options;\r\n    \r\n    // Remove from allocated buffers\r\n    this.allocatedBuffers.delete(bufferId);\r\n    this.memoryUsage.current -= size;\r\n    \r\n    // Pool buffer for reuse if requested and suitable\r\n    if (poolForReuse && this.shouldPoolBuffer(buffer, size, type)) {\r\n      this.addToBufferPool(buffer, size, type);\r\n    }\r\n    \r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Get pooled buffer if available\r\n   */\r\n  getPooledBuffer(size, type) {\r\n    const poolKey = `${type}_${size}`;\r\n    const pool = this.bufferPool.get(poolKey);\r\n    \r\n    if (pool && pool.length > 0) {\r\n      const buffer = pool.pop();\r\n      \r\n      // Clear buffer data\r\n      if (buffer.fill) {\r\n        buffer.fill(0);\r\n      } else if (buffer instanceof ArrayBuffer) {\r\n        new Uint8Array(buffer).fill(0);\r\n      }\r\n      \r\n      // Update pool size tracking\r\n      this.memoryUsage.pooled -= size;\r\n      \r\n      return buffer;\r\n    }\r\n    \r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Add buffer to pool for reuse\r\n   */\r\n  addToBufferPool(buffer, size, type) {\r\n    const poolKey = `${type}_${size}`;\r\n    \r\n    if (!this.bufferPool.has(poolKey)) {\r\n      this.bufferPool.set(poolKey, []);\r\n    }\r\n    \r\n    const pool = this.bufferPool.get(poolKey);\r\n    \r\n    // Limit pool size to prevent excessive memory usage\r\n    const maxPoolSize = Math.max(2, Math.floor(this.maxMemoryThreshold / size / 10));\r\n    \r\n    if (pool.length < maxPoolSize) {\r\n      pool.push(buffer);\r\n      this.memoryUsage.pooled += size;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if buffer should be pooled\r\n   */\r\n  shouldPoolBuffer(buffer, size, type) {\r\n    // Don't pool very large buffers\r\n    if (size > 10 * 1024 * 1024) { // 10MB\r\n      return false;\r\n    }\r\n    \r\n    // Don't pool if we're already using too much memory\r\n    if (this.memoryUsage.current > this.warningThreshold) {\r\n      return false;\r\n    }\r\n    \r\n    // Only pool common buffer types\r\n    const poolableTypes = ['waveform', 'float32', 'uint8', 'int16'];\r\n    return poolableTypes.includes(type);\r\n  }\r\n\r\n  /**\r\n   * Perform automatic cleanup based on memory usage\r\n   */\r\n  performAutomaticCleanup() {\r\n    const currentUsage = this.getCurrentMemoryUsage();\r\n    \r\n    if (currentUsage > this.aggressiveCleanupThreshold) {\r\n      this.performCleanup(['emergency-cleanup', 'force-gc', 'large-buffers']);\r\n    } else if (currentUsage > this.maxMemoryThreshold) {\r\n      this.performCleanup(['large-buffers', 'old-allocations', 'buffer-pool']);\r\n    } else if (currentUsage > this.warningThreshold) {\r\n      this.performCleanup(['buffer-pool', 'old-allocations']);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Perform cleanup using specified strategies\r\n   */\r\n  async performCleanup(strategyNames = []) {\r\n    const startTime = performance.now();\r\n    const initialMemory = this.getCurrentMemoryUsage();\r\n    \r\n    // Sort strategies by priority\r\n    const strategies = strategyNames\r\n      .map(name => ({ name, ...this.cleanupStrategies.get(name) }))\r\n      .filter(strategy => strategy.execute)\r\n      .sort((a, b) => a.priority - b.priority);\r\n    \r\n    let totalReclaimed = 0;\r\n    \r\n    for (const strategy of strategies) {\r\n      try {\r\n        const beforeMemory = this.getCurrentMemoryUsage();\r\n        await strategy.execute();\r\n        const afterMemory = this.getCurrentMemoryUsage();\r\n        const reclaimed = beforeMemory - afterMemory;\r\n        \r\n        if (reclaimed > 0) {\r\n          totalReclaimed += reclaimed;\r\n          console.log(`Cleanup strategy '${strategy.name}' reclaimed ${this.formatBytes(reclaimed)}`);\r\n        }\r\n        \r\n        // Stop if we've reclaimed enough memory\r\n        if (afterMemory < this.warningThreshold) {\r\n          break;\r\n        }\r\n      } catch (error) {\r\n        console.error(`Cleanup strategy '${strategy.name}' failed:`, error);\r\n      }\r\n    }\r\n    \r\n    const cleanupTime = performance.now() - startTime;\r\n    this.updateCleanupMetrics(cleanupTime, totalReclaimed);\r\n    \r\n    return {\r\n      strategiesUsed: strategies.map(s => s.name),\r\n      memoryReclaimed: totalReclaimed,\r\n      cleanupTime,\r\n      finalMemoryUsage: this.getCurrentMemoryUsage()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Schedule cleanup for later execution\r\n   */\r\n  scheduleCleanup(reason = 'scheduled', delay = 0) {\r\n    setTimeout(() => {\r\n      this.performAutomaticCleanup();\r\n    }, delay);\r\n  }\r\n\r\n  /**\r\n   * Cleanup buffer pool\r\n   */\r\n  cleanupBufferPool() {\r\n    let reclaimed = 0;\r\n    const now = Date.now();\r\n    const maxAge = 5 * 60 * 1000; // 5 minutes\r\n    \r\n    for (const [poolKey, pool] of this.bufferPool) {\r\n      const [type, sizeStr] = poolKey.split('_');\r\n      const size = parseInt(sizeStr);\r\n      \r\n      // Remove old or excess buffers\r\n      const keepCount = Math.max(1, Math.floor(pool.length / 2));\r\n      const removed = pool.splice(keepCount);\r\n      \r\n      reclaimed += removed.length * size;\r\n      this.memoryUsage.pooled -= removed.length * size;\r\n    }\r\n    \r\n    return reclaimed;\r\n  }\r\n\r\n  /**\r\n   * Cleanup old allocations\r\n   */\r\n  cleanupOldAllocations() {\r\n    let reclaimed = 0;\r\n    const now = Date.now();\r\n    const maxAge = 10 * 60 * 1000; // 10 minutes\r\n    const toRemove = [];\r\n    \r\n    for (const [bufferId, allocation] of this.allocatedBuffers) {\r\n      const age = now - allocation.metadata.allocatedAt;\r\n      \r\n      // Remove old allocations that haven't been accessed recently\r\n      if (age > maxAge && !allocation.metadata.pinned) {\r\n        toRemove.push(bufferId);\r\n        reclaimed += allocation.size;\r\n      }\r\n    }\r\n    \r\n    for (const bufferId of toRemove) {\r\n      this.deallocateBuffer(bufferId, { poolForReuse: false, reason: 'age-cleanup' });\r\n    }\r\n    \r\n    return reclaimed;\r\n  }\r\n\r\n  /**\r\n   * Cleanup large buffers\r\n   */\r\n  cleanupLargeBuffers() {\r\n    let reclaimed = 0;\r\n    const largeBufferThreshold = 5 * 1024 * 1024; // 5MB\r\n    const toRemove = [];\r\n    \r\n    // Sort by size (largest first)\r\n    const sortedAllocations = Array.from(this.allocatedBuffers.entries())\r\n      .sort(([, a], [, b]) => b.size - a.size);\r\n    \r\n    for (const [bufferId, allocation] of sortedAllocations) {\r\n      if (allocation.size > largeBufferThreshold && !allocation.metadata.pinned) {\r\n        toRemove.push(bufferId);\r\n        reclaimed += allocation.size;\r\n        \r\n        // Stop after reclaiming significant memory\r\n        if (reclaimed > this.maxMemoryThreshold * 0.2) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    \r\n    for (const bufferId of toRemove) {\r\n      this.deallocateBuffer(bufferId, { poolForReuse: false, reason: 'size-cleanup' });\r\n    }\r\n    \r\n    return reclaimed;\r\n  }\r\n\r\n  /**\r\n   * Force garbage collection if available\r\n   */\r\n  forceGarbageCollection() {\r\n    if (typeof gc === 'function') {\r\n      try {\r\n        gc();\r\n        this.performanceMetrics.gcTriggers++;\r\n        return true;\r\n      } catch (error) {\r\n        console.warn('Garbage collection failed:', error);\r\n      }\r\n    }\r\n    \r\n    // Fallback: create memory pressure to trigger GC\r\n    try {\r\n      const tempArrays = [];\r\n      for (let i = 0; i < 100; i++) {\r\n        tempArrays.push(new Float32Array(1024));\r\n      }\r\n      // Let arrays go out of scope\r\n    } catch (error) {\r\n      // Ignore allocation errors\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Emergency cleanup - remove all non-pinned allocations\r\n   */\r\n  emergencyCleanup() {\r\n    let reclaimed = 0;\r\n    const toRemove = [];\r\n    \r\n    // Remove all non-pinned allocations\r\n    for (const [bufferId, allocation] of this.allocatedBuffers) {\r\n      if (!allocation.metadata.pinned) {\r\n        toRemove.push(bufferId);\r\n        reclaimed += allocation.size;\r\n      }\r\n    }\r\n    \r\n    for (const bufferId of toRemove) {\r\n      this.deallocateBuffer(bufferId, { poolForReuse: false, reason: 'emergency' });\r\n    }\r\n    \r\n    // Clear buffer pool\r\n    this.bufferPool.clear();\r\n    this.memoryUsage.pooled = 0;\r\n    \r\n    // Force GC\r\n    this.forceGarbageCollection();\r\n    \r\n    console.warn(`Emergency cleanup reclaimed ${this.formatBytes(reclaimed)}`);\r\n    return reclaimed;\r\n  }\r\n\r\n  /**\r\n   * Pin buffer to prevent cleanup\r\n   */\r\n  pinBuffer(bufferId, reason = 'user-request') {\r\n    const allocation = this.allocatedBuffers.get(bufferId);\r\n    if (allocation) {\r\n      allocation.metadata.pinned = true;\r\n      allocation.metadata.pinnedReason = reason;\r\n      allocation.metadata.pinnedAt = Date.now();\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Unpin buffer to allow cleanup\r\n   */\r\n  unpinBuffer(bufferId) {\r\n    const allocation = this.allocatedBuffers.get(bufferId);\r\n    if (allocation) {\r\n      allocation.metadata.pinned = false;\r\n      delete allocation.metadata.pinnedReason;\r\n      delete allocation.metadata.pinnedAt;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Get current memory usage\r\n   */\r\n  getCurrentMemoryUsage() {\r\n    // Try to get actual memory usage if available\r\n    if (typeof performance !== 'undefined' && performance.memory) {\r\n      return performance.memory.usedJSHeapSize;\r\n    }\r\n    \r\n    // Fallback to tracked usage\r\n    return this.memoryUsage.current + this.memoryUsage.pooled;\r\n  }\r\n\r\n  /**\r\n   * Check memory pressure and trigger cleanup if needed\r\n   */\r\n  checkMemoryPressure() {\r\n    const currentUsage = this.getCurrentMemoryUsage();\r\n    const pressureLevel = this.calculateMemoryPressure(currentUsage);\r\n    \r\n    if (pressureLevel > 0.8) {\r\n      this.performAutomaticCleanup();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate memory pressure level (0-1)\r\n   */\r\n  calculateMemoryPressure(currentUsage) {\r\n    return Math.min(1, currentUsage / this.maxMemoryThreshold);\r\n  }\r\n\r\n  /**\r\n   * Handle memory pressure events\r\n   */\r\n  handleMemoryPressure(entry) {\r\n    console.warn('Memory pressure detected:', entry);\r\n    this.performAutomaticCleanup();\r\n  }\r\n\r\n  /**\r\n   * Update cleanup metrics\r\n   */\r\n  updateCleanupMetrics(cleanupTime, memoryReclaimed) {\r\n    this.performanceMetrics.cleanupCount++;\r\n    this.performanceMetrics.memoryReclaimed += memoryReclaimed;\r\n    \r\n    const avgTime = this.performanceMetrics.averageCleanupTime;\r\n    const count = this.performanceMetrics.cleanupCount;\r\n    this.performanceMetrics.averageCleanupTime = \r\n      (avgTime * (count - 1) + cleanupTime) / count;\r\n  }\r\n\r\n  /**\r\n   * Generate unique buffer ID\r\n   */\r\n  generateBufferId() {\r\n    return `buffer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  /**\r\n   * Format bytes for display\r\n   */\r\n  formatBytes(bytes) {\r\n    if (bytes === 0) return '0 Bytes';\r\n    \r\n    const k = 1024;\r\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\r\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\r\n    \r\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\r\n  }\r\n\r\n  /**\r\n   * Get memory statistics\r\n   */\r\n  getMemoryStats() {\r\n    const currentUsage = this.getCurrentMemoryUsage();\r\n    const pressureLevel = this.calculateMemoryPressure(currentUsage);\r\n    \r\n    return {\r\n      usage: {\r\n        current: currentUsage,\r\n        peak: this.memoryUsage.peak,\r\n        allocated: this.memoryUsage.allocated,\r\n        pooled: this.memoryUsage.pooled,\r\n        formatted: {\r\n          current: this.formatBytes(currentUsage),\r\n          peak: this.formatBytes(this.memoryUsage.peak),\r\n          allocated: this.formatBytes(this.memoryUsage.allocated),\r\n          pooled: this.formatBytes(this.memoryUsage.pooled)\r\n        }\r\n      },\r\n      thresholds: {\r\n        warning: this.warningThreshold,\r\n        max: this.maxMemoryThreshold,\r\n        aggressive: this.aggressiveCleanupThreshold,\r\n        formatted: {\r\n          warning: this.formatBytes(this.warningThreshold),\r\n          max: this.formatBytes(this.maxMemoryThreshold),\r\n          aggressive: this.formatBytes(this.aggressiveCleanupThreshold)\r\n        }\r\n      },\r\n      pressure: {\r\n        level: pressureLevel,\r\n        status: pressureLevel > 0.8 ? 'high' : pressureLevel > 0.6 ? 'medium' : 'low'\r\n      },\r\n      allocations: {\r\n        count: this.allocatedBuffers.size,\r\n        pooledBuffers: Array.from(this.bufferPool.values()).reduce((sum, pool) => sum + pool.length, 0),\r\n        pinnedBuffers: Array.from(this.allocatedBuffers.values()).filter(a => a.metadata.pinned).length\r\n      },\r\n      performance: this.performanceMetrics\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Destroy memory manager and cleanup resources\r\n   */\r\n  destroy() {\r\n    // Clear cleanup timer\r\n    if (this.cleanupTimer) {\r\n      clearInterval(this.cleanupTimer);\r\n      this.cleanupTimer = null;\r\n    }\r\n    \r\n    // Disconnect memory pressure observer\r\n    if (this.memoryPressureObserver) {\r\n      this.memoryPressureObserver.disconnect();\r\n      this.memoryPressureObserver = null;\r\n    }\r\n    \r\n    // Emergency cleanup\r\n    this.emergencyCleanup();\r\n    \r\n    // Clear all data structures\r\n    this.allocatedBuffers.clear();\r\n    this.bufferPool.clear();\r\n    this.cleanupStrategies.clear();\r\n  }\r\n}\r\n\r\nexport default WaveformMemoryManager;","/**\r\n * Performance monitoring and graceful degradation for resource-constrained environments\r\n * Implements adaptive quality settings and performance optimization\r\n * Requirements: 7.4, 7.5\r\n */\r\n\r\nexport class WaveformPerformanceMonitor {\r\n  constructor(options = {}) {\r\n    this.options = {\r\n      targetFPS: options.targetFPS || 60,\r\n      minFPS: options.minFPS || 30,\r\n      performanceWindow: options.performanceWindow || 5000, // 5 seconds\r\n      degradationThreshold: options.degradationThreshold || 0.7, // 70% of target\r\n      recoveryThreshold: options.recoveryThreshold || 0.9, // 90% of target\r\n      maxDegradationLevel: options.maxDegradationLevel || 3,\r\n      ...options\r\n    };\r\n    \r\n    // Performance tracking\r\n    this.metrics = {\r\n      fps: {\r\n        current: 0,\r\n        average: 0,\r\n        min: Infinity,\r\n        max: 0,\r\n        samples: []\r\n      },\r\n      renderTime: {\r\n        current: 0,\r\n        average: 0,\r\n        min: Infinity,\r\n        max: 0,\r\n        samples: []\r\n      },\r\n      memoryUsage: {\r\n        current: 0,\r\n        peak: 0,\r\n        trend: 'stable' // 'increasing', 'decreasing', 'stable'\r\n      },\r\n      cpuUsage: {\r\n        estimated: 0,\r\n        trend: 'stable'\r\n      }\r\n    };\r\n    \r\n    // Performance state\r\n    this.currentQualityLevel = 'high';\r\n    this.degradationLevel = 0;\r\n    this.isMonitoring = false;\r\n    this.adaptiveSettings = this.getDefaultAdaptiveSettings();\r\n    \r\n    // Callbacks for quality changes\r\n    this.qualityChangeCallbacks = new Set();\r\n    this.performanceWarningCallbacks = new Set();\r\n    \r\n    // Monitoring intervals\r\n    this.monitoringInterval = null;\r\n    this.metricsCollectionInterval = null;\r\n    \r\n    // Frame timing\r\n    this.lastFrameTime = 0;\r\n    this.frameCount = 0;\r\n    this.renderStartTime = 0;\r\n    \r\n    // Device capabilities detection\r\n    this.deviceCapabilities = null;\r\n    this.detectDeviceCapabilities();\r\n  }\r\n\r\n  /**\r\n   * Start performance monitoring\r\n   */\r\n  startMonitoring() {\r\n    if (this.isMonitoring) return;\r\n    \r\n    this.isMonitoring = true;\r\n    this.lastFrameTime = performance.now();\r\n    \r\n    // Start metrics collection\r\n    this.metricsCollectionInterval = setInterval(() => {\r\n      this.collectMetrics();\r\n    }, 1000); // Collect every second\r\n    \r\n    // Start performance analysis\r\n    this.monitoringInterval = setInterval(() => {\r\n      this.analyzePerformance();\r\n    }, this.options.performanceWindow);\r\n    \r\n    console.log('Performance monitoring started');\r\n  }\r\n\r\n  /**\r\n   * Stop performance monitoring\r\n   */\r\n  stopMonitoring() {\r\n    if (!this.isMonitoring) return;\r\n    \r\n    this.isMonitoring = false;\r\n    \r\n    if (this.metricsCollectionInterval) {\r\n      clearInterval(this.metricsCollectionInterval);\r\n      this.metricsCollectionInterval = null;\r\n    }\r\n    \r\n    if (this.monitoringInterval) {\r\n      clearInterval(this.monitoringInterval);\r\n      this.monitoringInterval = null;\r\n    }\r\n    \r\n    console.log('Performance monitoring stopped');\r\n  }\r\n\r\n  /**\r\n   * Record frame render start\r\n   */\r\n  frameRenderStart() {\r\n    this.renderStartTime = performance.now();\r\n  }\r\n\r\n  /**\r\n   * Record frame render end and calculate metrics\r\n   */\r\n  frameRenderEnd() {\r\n    const now = performance.now();\r\n    const renderTime = now - this.renderStartTime;\r\n    const frameTime = now - this.lastFrameTime;\r\n    \r\n    // Calculate FPS\r\n    const fps = frameTime > 0 ? 1000 / frameTime : 0;\r\n    \r\n    // Update metrics\r\n    this.updateFPSMetrics(fps);\r\n    this.updateRenderTimeMetrics(renderTime);\r\n    \r\n    this.lastFrameTime = now;\r\n    this.frameCount++;\r\n    \r\n    // Check for immediate performance issues\r\n    if (fps < this.options.minFPS) {\r\n      this.handleLowPerformance('fps', fps);\r\n    }\r\n    \r\n    if (renderTime > 33) { // More than 2 frames at 60fps\r\n      this.handleLowPerformance('renderTime', renderTime);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update FPS metrics\r\n   */\r\n  updateFPSMetrics(fps) {\r\n    this.metrics.fps.current = fps;\r\n    this.metrics.fps.min = Math.min(this.metrics.fps.min, fps);\r\n    this.metrics.fps.max = Math.max(this.metrics.fps.max, fps);\r\n    \r\n    // Keep sliding window of samples\r\n    this.metrics.fps.samples.push(fps);\r\n    if (this.metrics.fps.samples.length > 60) { // Keep last 60 samples\r\n      this.metrics.fps.samples.shift();\r\n    }\r\n    \r\n    // Calculate average\r\n    this.metrics.fps.average = this.metrics.fps.samples.reduce((sum, sample) => sum + sample, 0) / this.metrics.fps.samples.length;\r\n  }\r\n\r\n  /**\r\n   * Update render time metrics\r\n   */\r\n  updateRenderTimeMetrics(renderTime) {\r\n    this.metrics.renderTime.current = renderTime;\r\n    this.metrics.renderTime.min = Math.min(this.metrics.renderTime.min, renderTime);\r\n    this.metrics.renderTime.max = Math.max(this.metrics.renderTime.max, renderTime);\r\n    \r\n    // Keep sliding window of samples\r\n    this.metrics.renderTime.samples.push(renderTime);\r\n    if (this.metrics.renderTime.samples.length > 60) {\r\n      this.metrics.renderTime.samples.shift();\r\n    }\r\n    \r\n    // Calculate average\r\n    this.metrics.renderTime.average = this.metrics.renderTime.samples.reduce((sum, sample) => sum + sample, 0) / this.metrics.renderTime.samples.length;\r\n  }\r\n\r\n  /**\r\n   * Collect system metrics\r\n   */\r\n  collectMetrics() {\r\n    // Memory usage\r\n    if (typeof performance !== 'undefined' && performance.memory) {\r\n      const memoryUsage = performance.memory.usedJSHeapSize;\r\n      this.metrics.memoryUsage.current = memoryUsage;\r\n      this.metrics.memoryUsage.peak = Math.max(this.metrics.memoryUsage.peak, memoryUsage);\r\n      \r\n      // Detect memory trend\r\n      this.updateMemoryTrend(memoryUsage);\r\n    }\r\n    \r\n    // Estimate CPU usage based on frame timing\r\n    this.estimateCPUUsage();\r\n  }\r\n\r\n  /**\r\n   * Update memory usage trend\r\n   */\r\n  updateMemoryTrend(currentMemory) {\r\n    if (!this.lastMemoryReading) {\r\n      this.lastMemoryReading = currentMemory;\r\n      return;\r\n    }\r\n    \r\n    const change = currentMemory - this.lastMemoryReading;\r\n    const changePercent = Math.abs(change) / this.lastMemoryReading;\r\n    \r\n    if (changePercent > 0.05) { // 5% change threshold\r\n      this.metrics.memoryUsage.trend = change > 0 ? 'increasing' : 'decreasing';\r\n    } else {\r\n      this.metrics.memoryUsage.trend = 'stable';\r\n    }\r\n    \r\n    this.lastMemoryReading = currentMemory;\r\n  }\r\n\r\n  /**\r\n   * Estimate CPU usage based on render performance\r\n   */\r\n  estimateCPUUsage() {\r\n    const targetRenderTime = 1000 / this.options.targetFPS;\r\n    const actualRenderTime = this.metrics.renderTime.average;\r\n    \r\n    // Rough estimation: higher render time indicates higher CPU usage\r\n    const estimatedUsage = Math.min(1, actualRenderTime / targetRenderTime);\r\n    this.metrics.cpuUsage.estimated = estimatedUsage;\r\n    \r\n    // Detect CPU trend\r\n    if (!this.lastCPUReading) {\r\n      this.lastCPUReading = estimatedUsage;\r\n      return;\r\n    }\r\n    \r\n    const change = estimatedUsage - this.lastCPUReading;\r\n    if (Math.abs(change) > 0.1) { // 10% change threshold\r\n      this.metrics.cpuUsage.trend = change > 0 ? 'increasing' : 'decreasing';\r\n    } else {\r\n      this.metrics.cpuUsage.trend = 'stable';\r\n    }\r\n    \r\n    this.lastCPUReading = estimatedUsage;\r\n  }\r\n\r\n  /**\r\n   * Analyze performance and trigger adaptations\r\n   */\r\n  analyzePerformance() {\r\n    const performanceScore = this.calculatePerformanceScore();\r\n    const shouldDegrade = performanceScore < this.options.degradationThreshold;\r\n    const shouldRecover = performanceScore > this.options.recoveryThreshold;\r\n    \r\n    if (shouldDegrade && this.degradationLevel < this.options.maxDegradationLevel) {\r\n      this.degradeQuality();\r\n    } else if (shouldRecover && this.degradationLevel > 0) {\r\n      this.improveQuality();\r\n    }\r\n    \r\n    // Check for critical performance issues\r\n    this.checkCriticalPerformance();\r\n  }\r\n\r\n  /**\r\n   * Calculate overall performance score (0-1)\r\n   */\r\n  calculatePerformanceScore() {\r\n    const fpsScore = Math.min(1, this.metrics.fps.average / this.options.targetFPS);\r\n    const renderTimeScore = Math.min(1, (1000 / this.options.targetFPS) / this.metrics.renderTime.average);\r\n    const memoryScore = this.calculateMemoryScore();\r\n    const cpuScore = 1 - this.metrics.cpuUsage.estimated;\r\n    \r\n    // Weighted average\r\n    return (fpsScore * 0.4 + renderTimeScore * 0.3 + memoryScore * 0.2 + cpuScore * 0.1);\r\n  }\r\n\r\n  /**\r\n   * Calculate memory performance score\r\n   */\r\n  calculateMemoryScore() {\r\n    if (!this.deviceCapabilities || !this.deviceCapabilities.memoryLimit) {\r\n      return 1; // Assume good if we can't measure\r\n    }\r\n    \r\n    const memoryUsageRatio = this.metrics.memoryUsage.current / this.deviceCapabilities.memoryLimit;\r\n    return Math.max(0, 1 - memoryUsageRatio);\r\n  }\r\n\r\n  /**\r\n   * Degrade quality to improve performance\r\n   */\r\n  degradeQuality() {\r\n    this.degradationLevel++;\r\n    \r\n    const newSettings = this.getAdaptiveSettings(this.degradationLevel);\r\n    this.applyAdaptiveSettings(newSettings);\r\n    \r\n    const qualityLevel = this.getQualityLevelName(this.degradationLevel);\r\n    console.log(`Performance degradation: level ${this.degradationLevel} (${qualityLevel})`);\r\n    \r\n    this.notifyQualityChange(qualityLevel, 'degraded', {\r\n      reason: 'performance',\r\n      score: this.calculatePerformanceScore(),\r\n      level: this.degradationLevel\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Improve quality when performance allows\r\n   */\r\n  improveQuality() {\r\n    this.degradationLevel--;\r\n    \r\n    const newSettings = this.getAdaptiveSettings(this.degradationLevel);\r\n    this.applyAdaptiveSettings(newSettings);\r\n    \r\n    const qualityLevel = this.getQualityLevelName(this.degradationLevel);\r\n    console.log(`Performance recovery: level ${this.degradationLevel} (${qualityLevel})`);\r\n    \r\n    this.notifyQualityChange(qualityLevel, 'improved', {\r\n      reason: 'performance-recovery',\r\n      score: this.calculatePerformanceScore(),\r\n      level: this.degradationLevel\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get adaptive settings for degradation level\r\n   */\r\n  getAdaptiveSettings(level) {\r\n    const settings = this.getDefaultAdaptiveSettings();\r\n    \r\n    switch (level) {\r\n      case 0: // High quality\r\n        return settings;\r\n        \r\n      case 1: // Medium-high quality\r\n        return {\r\n          ...settings,\r\n          renderQuality: 'medium',\r\n          waveformResolution: 0.8,\r\n          enableAntialiasing: true,\r\n          maxBatchSize: 800\r\n        };\r\n        \r\n      case 2: // Medium quality\r\n        return {\r\n          ...settings,\r\n          renderQuality: 'medium',\r\n          waveformResolution: 0.6,\r\n          enableAntialiasing: false,\r\n          maxBatchSize: 600,\r\n          enableViewportCulling: true,\r\n          chopRenderingDetail: 'medium'\r\n        };\r\n        \r\n      case 3: // Low quality\r\n        return {\r\n          ...settings,\r\n          renderQuality: 'low',\r\n          waveformResolution: 0.4,\r\n          enableAntialiasing: false,\r\n          maxBatchSize: 400,\r\n          enableViewportCulling: true,\r\n          chopRenderingDetail: 'low',\r\n          disableAnimations: true,\r\n          simplifiedRendering: true\r\n        };\r\n        \r\n      default:\r\n        return settings;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get default adaptive settings\r\n   */\r\n  getDefaultAdaptiveSettings() {\r\n    return {\r\n      renderQuality: 'high',\r\n      waveformResolution: 1.0,\r\n      enableAntialiasing: true,\r\n      maxBatchSize: 1000,\r\n      enableViewportCulling: true,\r\n      chopRenderingDetail: 'high',\r\n      disableAnimations: false,\r\n      simplifiedRendering: false,\r\n      targetFPS: this.options.targetFPS\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Apply adaptive settings\r\n   */\r\n  applyAdaptiveSettings(settings) {\r\n    this.adaptiveSettings = { ...settings };\r\n    this.currentQualityLevel = this.getQualityLevelName(this.degradationLevel);\r\n  }\r\n\r\n  /**\r\n   * Get quality level name\r\n   */\r\n  getQualityLevelName(level) {\r\n    const levels = ['high', 'medium-high', 'medium', 'low'];\r\n    return levels[Math.min(level, levels.length - 1)];\r\n  }\r\n\r\n  /**\r\n   * Handle immediate low performance\r\n   */\r\n  handleLowPerformance(metric, value) {\r\n    this.notifyPerformanceWarning({\r\n      metric,\r\n      value,\r\n      threshold: metric === 'fps' ? this.options.minFPS : 33,\r\n      timestamp: Date.now(),\r\n      currentQuality: this.currentQualityLevel,\r\n      degradationLevel: this.degradationLevel\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check for critical performance issues\r\n   */\r\n  checkCriticalPerformance() {\r\n    const criticalIssues = [];\r\n    \r\n    // Critical FPS drop\r\n    if (this.metrics.fps.average < this.options.minFPS * 0.5) {\r\n      criticalIssues.push({\r\n        type: 'critical-fps',\r\n        value: this.metrics.fps.average,\r\n        threshold: this.options.minFPS * 0.5\r\n      });\r\n    }\r\n    \r\n    // Critical memory usage\r\n    if (this.deviceCapabilities && this.deviceCapabilities.memoryLimit) {\r\n      const memoryUsageRatio = this.metrics.memoryUsage.current / this.deviceCapabilities.memoryLimit;\r\n      if (memoryUsageRatio > 0.9) {\r\n        criticalIssues.push({\r\n          type: 'critical-memory',\r\n          value: memoryUsageRatio,\r\n          threshold: 0.9\r\n        });\r\n      }\r\n    }\r\n    \r\n    // Critical render time\r\n    if (this.metrics.renderTime.average > 100) { // More than 6 frames at 60fps\r\n      criticalIssues.push({\r\n        type: 'critical-render-time',\r\n        value: this.metrics.renderTime.average,\r\n        threshold: 100\r\n      });\r\n    }\r\n    \r\n    if (criticalIssues.length > 0) {\r\n      this.handleCriticalPerformance(criticalIssues);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle critical performance issues\r\n   */\r\n  handleCriticalPerformance(issues) {\r\n    console.error('Critical performance issues detected:', issues);\r\n    \r\n    // Force maximum degradation\r\n    this.degradationLevel = this.options.maxDegradationLevel;\r\n    const emergencySettings = this.getEmergencySettings();\r\n    this.applyAdaptiveSettings(emergencySettings);\r\n    \r\n    this.notifyPerformanceWarning({\r\n      type: 'critical',\r\n      issues,\r\n      emergencyMode: true,\r\n      timestamp: Date.now()\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get emergency performance settings\r\n   */\r\n  getEmergencySettings() {\r\n    return {\r\n      renderQuality: 'low',\r\n      waveformResolution: 0.2,\r\n      enableAntialiasing: false,\r\n      maxBatchSize: 200,\r\n      enableViewportCulling: true,\r\n      chopRenderingDetail: 'minimal',\r\n      disableAnimations: true,\r\n      simplifiedRendering: true,\r\n      emergencyMode: true,\r\n      targetFPS: Math.max(15, this.options.minFPS * 0.5)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Detect device capabilities\r\n   */\r\n  detectDeviceCapabilities() {\r\n    this.deviceCapabilities = {\r\n      // Memory\r\n      memoryLimit: this.detectMemoryLimit(),\r\n      \r\n      // CPU estimation\r\n      cpuCores: navigator.hardwareConcurrency || 4,\r\n      \r\n      // GPU capabilities\r\n      webglSupport: this.detectWebGLSupport(),\r\n      \r\n      // Browser capabilities\r\n      performanceAPISupport: typeof performance !== 'undefined' && !!performance.memory,\r\n      \r\n      // Device type estimation\r\n      deviceType: this.detectDeviceType(),\r\n      \r\n      // Connection quality\r\n      connectionType: this.detectConnectionType()\r\n    };\r\n    \r\n    console.log('Device capabilities detected:', this.deviceCapabilities);\r\n  }\r\n\r\n  /**\r\n   * Detect memory limit\r\n   */\r\n  detectMemoryLimit() {\r\n    if (typeof performance !== 'undefined' && performance.memory) {\r\n      return performance.memory.jsHeapSizeLimit;\r\n    }\r\n    \r\n    // Fallback estimation based on device type\r\n    const deviceType = this.detectDeviceType();\r\n    switch (deviceType) {\r\n      case 'mobile': return 100 * 1024 * 1024; // 100MB\r\n      case 'tablet': return 200 * 1024 * 1024; // 200MB\r\n      case 'desktop': return 500 * 1024 * 1024; // 500MB\r\n      default: return 200 * 1024 * 1024; // 200MB default\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect WebGL support\r\n   */\r\n  detectWebGLSupport() {\r\n    try {\r\n      // Check if we're in a test environment\r\n      if (typeof document === 'undefined' || typeof HTMLCanvasElement === 'undefined') {\r\n        return false;\r\n      }\r\n      \r\n      const canvas = document.createElement('canvas');\r\n      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\r\n      return !!gl;\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect device type\r\n   */\r\n  detectDeviceType() {\r\n    const userAgent = navigator.userAgent.toLowerCase();\r\n    \r\n    if (/mobile|android|iphone|ipod|blackberry|iemobile|opera mini/i.test(userAgent)) {\r\n      return 'mobile';\r\n    } else if (/tablet|ipad/i.test(userAgent)) {\r\n      return 'tablet';\r\n    } else {\r\n      return 'desktop';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect connection type\r\n   */\r\n  detectConnectionType() {\r\n    if (navigator.connection) {\r\n      return {\r\n        effectiveType: navigator.connection.effectiveType,\r\n        downlink: navigator.connection.downlink,\r\n        rtt: navigator.connection.rtt\r\n      };\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Add quality change callback\r\n   */\r\n  onQualityChange(callback) {\r\n    this.qualityChangeCallbacks.add(callback);\r\n    return () => this.qualityChangeCallbacks.delete(callback);\r\n  }\r\n\r\n  /**\r\n   * Add performance warning callback\r\n   */\r\n  onPerformanceWarning(callback) {\r\n    this.performanceWarningCallbacks.add(callback);\r\n    return () => this.performanceWarningCallbacks.delete(callback);\r\n  }\r\n\r\n  /**\r\n   * Notify quality change\r\n   */\r\n  notifyQualityChange(newQuality, changeType, details) {\r\n    const event = {\r\n      newQuality,\r\n      changeType,\r\n      details,\r\n      settings: this.adaptiveSettings,\r\n      timestamp: Date.now()\r\n    };\r\n    \r\n    this.qualityChangeCallbacks.forEach(callback => {\r\n      try {\r\n        callback(event);\r\n      } catch (error) {\r\n        console.error('Quality change callback error:', error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Notify performance warning\r\n   */\r\n  notifyPerformanceWarning(warning) {\r\n    this.performanceWarningCallbacks.forEach(callback => {\r\n      try {\r\n        callback(warning);\r\n      } catch (error) {\r\n        console.error('Performance warning callback error:', error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get current performance metrics\r\n   */\r\n  getMetrics() {\r\n    return {\r\n      ...this.metrics,\r\n      performanceScore: this.calculatePerformanceScore(),\r\n      qualityLevel: this.currentQualityLevel,\r\n      degradationLevel: this.degradationLevel,\r\n      adaptiveSettings: this.adaptiveSettings,\r\n      deviceCapabilities: this.deviceCapabilities\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get current adaptive settings\r\n   */\r\n  getAdaptiveSettings() {\r\n    return { ...this.adaptiveSettings };\r\n  }\r\n\r\n  /**\r\n   * Force quality level\r\n   */\r\n  forceQualityLevel(level) {\r\n    const levelMap = { 'high': 0, 'medium-high': 1, 'medium': 2, 'low': 3 };\r\n    const degradationLevel = levelMap[level] || 0;\r\n    \r\n    this.degradationLevel = degradationLevel;\r\n    const settings = this.getAdaptiveSettings(degradationLevel);\r\n    this.applyAdaptiveSettings(settings);\r\n    \r\n    this.notifyQualityChange(level, 'forced', {\r\n      reason: 'user-override',\r\n      level: degradationLevel\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Reset to default quality\r\n   */\r\n  resetQuality() {\r\n    this.degradationLevel = 0;\r\n    const settings = this.getDefaultAdaptiveSettings();\r\n    this.applyAdaptiveSettings(settings);\r\n    \r\n    this.notifyQualityChange('high', 'reset', {\r\n      reason: 'user-reset'\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Destroy performance monitor\r\n   */\r\n  destroy() {\r\n    this.stopMonitoring();\r\n    this.qualityChangeCallbacks.clear();\r\n    this.performanceWarningCallbacks.clear();\r\n  }\r\n}\r\n\r\nexport default WaveformPerformanceMonitor;"],"names":["WaveformCache","constructor","options","this","maxMemorySize","maxCacheEntries","persistenceEnabled","compressionEnabled","ttl","memoryCache","Map","accessOrder","memorySizeUsed","persistentCache","initializePersistence","metrics","hits","misses","evictions","compressionSavings","averageCompressionRatio","persistenceHits","persistenceMisses","cleanupInterval","setInterval","performMaintenance","indexedDB","openIndexedDB","error","Promise","resolve","reject","request","open","onerror","onsuccess","db","result","onupgradeneeded","event","target","objectStoreNames","contains","store","createObjectStore","keyPath","createIndex","unique","generateCacheKey","audioSource","keyData","source","getSourceIdentifier","sampleRate","quality","analysisMethod","duration","hashObject","get","cacheKey","memoryResult","getFromMemory","persistentResult","getFromPersistent","setInMemory","set","waveformData","metadata","cacheEntry","key","data","timestamp","Date","now","accessCount","size","calculateDataSize","compressed","compressData","savings","updateCompressionRatio","setInPersistent","entry","delete","decompressed","decompressData","evictLRU","has","existing","transaction","objectStore","deleteFromPersistent","persistentEntry","put","oncomplete","oldestKey","oldestTime","accessTime","jsonData","JSON","stringify","CompressionStream","stream","writer","writable","getWriter","reader","readable","getReader","write","TextEncoder","encode","close","chunks","done","value","readerDone","read","push","Uint8Array","reduce","acc","chunk","length","offset","originalSize","simpleCompress","simpleDecompress","TextDecoder","decode","count","current","i","String","fromCharCode","parse","charCodeAt","repeat","ArrayBuffer","byteLength","Float32Array","BYTES_PER_ELEMENT","videoId","src","obj","str","Object","keys","sort","hash","Math","abs","toString","compressedSize","ratio","expiredKeys","cleanExpiredPersistent","optimizeMemoryUsage","index","cutoffTime","range","IDBKeyRange","upperBound","openCursor","cursor","continue","entries","Array","from","map","score","a","b","toRemove","floor","getStats","hitRate","persistentHitRate","sizeUsed","maxSize","utilizationPercent","performance","totalHits","totalMisses","compression","enabled","totalSavings","averageRatio","persistence","clear","destroy","clearInterval","WaveformMemoryManager","maxMemoryThreshold","warningThreshold","aggressiveCleanupThreshold","allocatedBuffers","bufferPool","memoryUsage","peak","allocated","pooled","cleanupStrategies","initializeCleanupStrategies","performanceMetrics","cleanupCount","memoryReclaimed","bufferReuses","gcTriggers","averageCleanupTime","cleanupTimer","performAutomaticCleanup","memoryPressureObserver","initializeMemoryPressureMonitoring","priority","execute","cleanupBufferPool","description","cleanupOldAllocations","cleanupLargeBuffers","forceGarbageCollection","emergencyCleanup","PerformanceObserver","list","getEntries","entryType","name","includes","handleMemoryPressure","observe","entryTypes","checkMemoryPressure","allocateBuffer","type","bufferId","generateBufferId","pooledBuffer","getPooledBuffer","buffer","allocatedAt","reused","Int16Array","actualSize","max","scheduleCleanup","emergencyRetry","retryError","Error","message","deallocateBuffer","allocation","poolForReuse","reason","shouldPoolBuffer","addToBufferPool","poolKey","pool","pop","fill","maxPoolSize","currentUsage","getCurrentMemoryUsage","performCleanup","strategyNames","startTime","strategies","filter","strategy","totalReclaimed","beforeMemory","afterMemory","reclaimed","cleanupTime","updateCleanupMetrics","strategiesUsed","s","finalMemoryUsage","delay","setTimeout","sizeStr","split","parseInt","keepCount","removed","splice","pinned","sortedAllocations","gc","tempArrays","pinBuffer","pinnedReason","pinnedAt","unpinBuffer","memory","usedJSHeapSize","calculateMemoryPressure","min","avgTime","random","substr","formatBytes","bytes","log","parseFloat","pow","toFixed","getMemoryStats","pressureLevel","usage","formatted","thresholds","warning","aggressive","pressure","level","status","allocations","pooledBuffers","values","sum","pinnedBuffers","disconnect","WaveformPerformanceMonitor","targetFPS","minFPS","performanceWindow","degradationThreshold","recoveryThreshold","maxDegradationLevel","fps","average","Infinity","samples","renderTime","trend","cpuUsage","estimated","currentQualityLevel","degradationLevel","isMonitoring","adaptiveSettings","getDefaultAdaptiveSettings","qualityChangeCallbacks","Set","performanceWarningCallbacks","monitoringInterval","metricsCollectionInterval","lastFrameTime","frameCount","renderStartTime","deviceCapabilities","detectDeviceCapabilities","startMonitoring","collectMetrics","analyzePerformance","stopMonitoring","frameRenderStart","frameRenderEnd","frameTime","updateFPSMetrics","updateRenderTimeMetrics","handleLowPerformance","shift","sample","updateMemoryTrend","estimateCPUUsage","currentMemory","lastMemoryReading","change","changePercent","targetRenderTime","actualRenderTime","estimatedUsage","lastCPUReading","performanceScore","calculatePerformanceScore","shouldDegrade","shouldRecover","degradeQuality","improveQuality","checkCriticalPerformance","calculateMemoryScore","memoryLimit","memoryUsageRatio","newSettings","getAdaptiveSettings","applyAdaptiveSettings","qualityLevel","getQualityLevelName","notifyQualityChange","settings","renderQuality","waveformResolution","enableAntialiasing","maxBatchSize","enableViewportCulling","chopRenderingDetail","disableAnimations","simplifiedRendering","levels","metric","notifyPerformanceWarning","threshold","currentQuality","criticalIssues","handleCriticalPerformance","issues","emergencySettings","getEmergencySettings","emergencyMode","detectMemoryLimit","cpuCores","navigator","hardwareConcurrency","webglSupport","detectWebGLSupport","performanceAPISupport","deviceType","detectDeviceType","connectionType","detectConnectionType","jsHeapSizeLimit","document","HTMLCanvasElement","canvas","createElement","getContext","userAgent","toLowerCase","test","connection","effectiveType","downlink","rtt","onQualityChange","callback","add","onPerformanceWarning","newQuality","changeType","details","forEach","getMetrics","forceQualityLevel","high","medium","low","resetQuality"],"mappings":"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"}