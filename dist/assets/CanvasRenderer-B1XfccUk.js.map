{"version":3,"file":"CanvasRenderer-B1XfccUk.js","sources":["../../src/components/waveform/CanvasLayerManager.js","../../src/components/waveform/ViewportManager.js","../../src/components/waveform/CanvasRenderer.js"],"sourcesContent":["/**\r\n * Canvas layer management system for multi-layer waveform rendering\r\n * Implements requirements: 7.1 - optimized canvas drawing techniques\r\n */\r\n\r\nexport class CanvasLayerManager {\r\n  constructor() {\r\n    this.layers = new Map();\r\n    this.container = null;\r\n    this.dimensions = { width: 0, height: 0 };\r\n    this.dpr = window.devicePixelRatio || 1;\r\n  }\r\n\r\n  /**\r\n   * Initialize layer manager with container element\r\n   */\r\n  initialize(container) {\r\n    this.container = container;\r\n    this.updateDimensions();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Update canvas dimensions based on container\r\n   */\r\n  updateDimensions() {\r\n    if (!this.container) return false;\r\n    \r\n    const rect = this.container.getBoundingClientRect();\r\n    this.dimensions = {\r\n      width: rect.width || 800,\r\n      height: rect.height || 200\r\n    };\r\n    \r\n    // Update all existing layers\r\n    this.layers.forEach(layer => {\r\n      this.resizeLayer(layer);\r\n    });\r\n    \r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Create a new canvas layer\r\n   */\r\n  createLayer(name, zIndex = 0, options = {}) {\r\n    if (this.layers.has(name)) {\r\n      console.warn(`Layer ${name} already exists`);\r\n      return this.layers.get(name);\r\n    }\r\n\r\n    const canvas = document.createElement('canvas');\r\n    const ctx = canvas.getContext('2d', {\r\n      alpha: options.alpha !== false,\r\n      desynchronized: options.desynchronized || false,\r\n      ...options.contextOptions\r\n    });\r\n\r\n    if (!ctx) {\r\n      throw new Error(`Failed to create 2D context for layer ${name}`);\r\n    }\r\n\r\n    const layer = {\r\n      name,\r\n      canvas,\r\n      ctx,\r\n      zIndex,\r\n      visible: true,\r\n      dirty: true,\r\n      options\r\n    };\r\n\r\n    this.setupLayer(layer);\r\n    this.layers.set(name, layer);\r\n    \r\n    return layer;\r\n  }  \r\n/**\r\n   * Setup canvas layer with proper styling and dimensions\r\n   */\r\n  setupLayer(layer) {\r\n    const { canvas, zIndex } = layer;\r\n    \r\n    // Set canvas styling\r\n    canvas.style.position = 'absolute';\r\n    canvas.style.top = '0';\r\n    canvas.style.left = '0';\r\n    canvas.style.zIndex = zIndex;\r\n    canvas.style.pointerEvents = 'none';\r\n    \r\n    this.resizeLayer(layer);\r\n    this.configureContext(layer);\r\n    \r\n    // Add to container\r\n    if (this.container) {\r\n      this.container.appendChild(canvas);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resize a canvas layer to current dimensions\r\n   */\r\n  resizeLayer(layer) {\r\n    const { canvas, ctx } = layer;\r\n    const { width, height } = this.dimensions;\r\n    \r\n    // Set display size\r\n    canvas.style.width = `${width}px`;\r\n    canvas.style.height = `${height}px`;\r\n    \r\n    // Set actual size for high DPI\r\n    canvas.width = width * this.dpr;\r\n    canvas.height = height * this.dpr;\r\n    \r\n    // Scale context for high DPI if context exists\r\n    if (ctx) {\r\n      ctx.scale(this.dpr, this.dpr);\r\n      // Reconfigure context after resize\r\n      this.configureContext(layer);\r\n    }\r\n    \r\n    layer.dirty = true;\r\n  }\r\n\r\n  /**\r\n   * Configure canvas context for optimal performance\r\n   */\r\n  configureContext(layer) {\r\n    const { ctx, options } = layer;\r\n    \r\n    // Performance optimizations\r\n    ctx.imageSmoothingEnabled = options.smoothing !== false;\r\n    ctx.textBaseline = 'middle';\r\n    ctx.textAlign = 'left';\r\n    \r\n    // Set default styles\r\n    ctx.fillStyle = '#ffffff';\r\n    ctx.strokeStyle = '#ffffff';\r\n    ctx.lineWidth = 1;\r\n    ctx.lineCap = 'round';\r\n    ctx.lineJoin = 'round';\r\n  }\r\n\r\n  /**\r\n   * Get a layer by name\r\n   */\r\n  getLayer(name) {\r\n    return this.layers.get(name);\r\n  }\r\n\r\n  /**\r\n   * Remove a layer\r\n   */\r\n  removeLayer(name) {\r\n    const layer = this.layers.get(name);\r\n    if (!layer) return false;\r\n    \r\n    if (layer.canvas.parentNode) {\r\n      layer.canvas.parentNode.removeChild(layer.canvas);\r\n    }\r\n    \r\n    this.layers.delete(name);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Clear a specific layer\r\n   */\r\n  clearLayer(name) {\r\n    const layer = this.layers.get(name);\r\n    if (!layer) return false;\r\n    \r\n    const { ctx } = layer;\r\n    const { width, height } = this.dimensions;\r\n    ctx.clearRect(0, 0, width, height);\r\n    \r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Clear all layers\r\n   */\r\n  clearAllLayers() {\r\n    this.layers.forEach((layer, name) => {\r\n      this.clearLayer(name);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set layer visibility\r\n   */\r\n  setLayerVisibility(name, visible) {\r\n    const layer = this.layers.get(name);\r\n    if (!layer) return false;\r\n    \r\n    layer.visible = visible;\r\n    layer.canvas.style.display = visible ? 'block' : 'none';\r\n    \r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Set layer z-index\r\n   */\r\n  setLayerZIndex(name, zIndex) {\r\n    const layer = this.layers.get(name);\r\n    if (!layer) return false;\r\n    \r\n    layer.zIndex = zIndex;\r\n    layer.canvas.style.zIndex = zIndex;\r\n    \r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Mark layer as dirty (needs redraw)\r\n   */\r\n  markLayerDirty(name) {\r\n    const layer = this.layers.get(name);\r\n    if (layer) {\r\n      layer.dirty = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mark all layers as dirty\r\n   */\r\n  markAllLayersDirty() {\r\n    this.layers.forEach(layer => {\r\n      layer.dirty = true;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check if layer is dirty\r\n   */\r\n  isLayerDirty(name) {\r\n    const layer = this.layers.get(name);\r\n    return layer ? layer.dirty : false;\r\n  }\r\n\r\n  /**\r\n   * Mark layer as clean (up to date)\r\n   */\r\n  markLayerClean(name) {\r\n    const layer = this.layers.get(name);\r\n    if (layer) {\r\n      layer.dirty = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all layer names\r\n   */\r\n  getLayerNames() {\r\n    return Array.from(this.layers.keys());\r\n  }\r\n\r\n  /**\r\n   * Get layers sorted by z-index\r\n   */\r\n  getLayersSorted() {\r\n    return Array.from(this.layers.values())\r\n      .sort((a, b) => a.zIndex - b.zIndex);\r\n  }\r\n\r\n  /**\r\n   * Enable pointer events for a layer\r\n   */\r\n  enableLayerInteraction(name) {\r\n    const layer = this.layers.get(name);\r\n    if (layer) {\r\n      layer.canvas.style.pointerEvents = 'auto';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disable pointer events for a layer\r\n   */\r\n  disableLayerInteraction(name) {\r\n    const layer = this.layers.get(name);\r\n    if (layer) {\r\n      layer.canvas.style.pointerEvents = 'none';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroy all layers and cleanup\r\n   */\r\n  destroy() {\r\n    this.layers.forEach((layer, name) => {\r\n      this.removeLayer(name);\r\n    });\r\n    \r\n    this.layers.clear();\r\n    this.container = null;\r\n  }\r\n\r\n  /**\r\n   * Get current dimensions\r\n   */\r\n  getDimensions() {\r\n    return { ...this.dimensions };\r\n  }\r\n\r\n  /**\r\n   * Get device pixel ratio\r\n   */\r\n  getDevicePixelRatio() {\r\n    return this.dpr;\r\n  }\r\n}\r\n\r\nexport default CanvasLayerManager;","/**\r\n * Viewport state management for waveform visualization\r\n * Handles zoom and pan operations with proper bounds checking\r\n * Implements requirements: 4.1, 4.4 - zoom and navigation controls\r\n */\r\n\r\nexport class ViewportManager {\r\n  constructor(initialState = {}) {\r\n    this.state = {\r\n      zoomLevel: 1.0,\r\n      centerTime: 0,\r\n      visibleTimeRange: { start: 0, end: 0 },\r\n      pixelsPerSecond: 100,\r\n      canvasDimensions: { width: 800, height: 200 },\r\n      audioDuration: 0,\r\n      minZoom: 0.1,\r\n      maxZoom: 100,\r\n      ...initialState\r\n    };\r\n    \r\n    this.listeners = new Set();\r\n    this.updateVisibleRange();\r\n  }\r\n\r\n  /**\r\n   * Add a listener for viewport changes\r\n   */\r\n  addListener(callback) {\r\n    this.listeners.add(callback);\r\n    return () => this.listeners.delete(callback);\r\n  }\r\n\r\n  /**\r\n   * Notify all listeners of state changes\r\n   */\r\n  notifyListeners() {\r\n    this.listeners.forEach(callback => callback(this.state));\r\n  }\r\n\r\n  /**\r\n   * Update canvas dimensions and recalculate viewport\r\n   */\r\n  setCanvasDimensions(width, height) {\r\n    this.state.canvasDimensions = { width, height };\r\n    this.updateVisibleRange();\r\n    this.notifyListeners();\r\n  }\r\n\r\n  /**\r\n   * Set audio duration and adjust viewport if needed\r\n   */\r\n  setAudioDuration(duration) {\r\n    this.state.audioDuration = duration;\r\n    \r\n    // Ensure center time is within bounds\r\n    if (this.state.centerTime > duration) {\r\n      this.state.centerTime = duration / 2;\r\n    }\r\n    \r\n    this.updateVisibleRange();\r\n    this.notifyListeners();\r\n  }\r\n\r\n  /**\r\n   * Calculate visible time range based on current zoom and center\r\n   */\r\n  updateVisibleRange() {\r\n    const { zoomLevel, centerTime, canvasDimensions, audioDuration } = this.state;\r\n    \r\n    // Calculate visible duration based on zoom level\r\n    // Base: 100 pixels per second at zoom level 1\r\n    const basePixelsPerSecond = 100;\r\n    const pixelsPerSecond = basePixelsPerSecond * zoomLevel;\r\n    const visibleDuration = canvasDimensions.width / pixelsPerSecond;\r\n    \r\n    // Calculate time range centered on centerTime\r\n    const halfDuration = visibleDuration / 2;\r\n    let startTime = centerTime - halfDuration;\r\n    let endTime = centerTime + halfDuration;\r\n    \r\n    // Clamp to audio bounds\r\n    if (audioDuration > 0) {\r\n      if (startTime < 0) {\r\n        startTime = 0;\r\n        endTime = Math.min(visibleDuration, audioDuration);\r\n      } else if (endTime > audioDuration) {\r\n        endTime = audioDuration;\r\n        startTime = Math.max(0, audioDuration - visibleDuration);\r\n      }\r\n    } else {\r\n      startTime = Math.max(0, startTime);\r\n    }\r\n    \r\n    this.state.visibleTimeRange = { start: startTime, end: endTime };\r\n    this.state.pixelsPerSecond = pixelsPerSecond;\r\n  }\r\n\r\n  /**\r\n   * Set zoom level with optional center point\r\n   */\r\n  setZoom(zoomLevel, centerTime = null) {\r\n    // Clamp zoom level to valid range\r\n    zoomLevel = Math.max(this.state.minZoom, Math.min(this.state.maxZoom, zoomLevel));\r\n    \r\n    this.state.zoomLevel = zoomLevel;\r\n    \r\n    if (centerTime !== null) {\r\n      this.state.centerTime = centerTime;\r\n    }\r\n    \r\n    this.updateVisibleRange();\r\n    this.notifyListeners();\r\n    \r\n    return this.state;\r\n  }\r\n\r\n  /**\r\n   * Zoom in by a factor (default 2x)\r\n   */\r\n  zoomIn(factor = 2, centerTime = null) {\r\n    return this.setZoom(this.state.zoomLevel * factor, centerTime);\r\n  }\r\n\r\n  /**\r\n   * Zoom out by a factor (default 2x)\r\n   */\r\n  zoomOut(factor = 2, centerTime = null) {\r\n    return this.setZoom(this.state.zoomLevel / factor, centerTime);\r\n  }\r\n\r\n  /**\r\n   * Zoom to fit entire audio duration\r\n   */\r\n  zoomToFit() {\r\n    if (this.state.audioDuration <= 0) return this.state;\r\n    \r\n    const { canvasDimensions, audioDuration } = this.state;\r\n    const basePixelsPerSecond = 100;\r\n    const requiredPixelsPerSecond = canvasDimensions.width / audioDuration;\r\n    const zoomLevel = Math.max(this.state.minZoom, requiredPixelsPerSecond / basePixelsPerSecond);\r\n    \r\n    return this.setZoom(zoomLevel, audioDuration / 2);\r\n  }\r\n\r\n  /**\r\n   * Pan to a specific time\r\n   */\r\n  panToTime(targetTime) {\r\n    // Clamp target time to valid range\r\n    if (this.state.audioDuration > 0) {\r\n      targetTime = Math.max(0, Math.min(this.state.audioDuration, targetTime));\r\n    } else {\r\n      targetTime = Math.max(0, targetTime);\r\n    }\r\n    \r\n    this.state.centerTime = targetTime;\r\n    this.updateVisibleRange();\r\n    this.notifyListeners();\r\n    \r\n    return this.state;\r\n  }\r\n\r\n  /**\r\n   * Pan by a relative amount (in seconds)\r\n   */\r\n  panBy(deltaTime) {\r\n    return this.panToTime(this.state.centerTime + deltaTime);\r\n  }\r\n\r\n  /**\r\n   * Pan by a relative amount (in pixels)\r\n   */\r\n  panByPixels(deltaPixels) {\r\n    const { pixelsPerSecond } = this.state;\r\n    const deltaTime = deltaPixels / pixelsPerSecond;\r\n    return this.panBy(deltaTime);\r\n  }\r\n\r\n  /**\r\n   * Convert time to pixel position within current viewport\r\n   */\r\n  timeToPixel(time) {\r\n    const { visibleTimeRange, canvasDimensions } = this.state;\r\n    const visibleDuration = visibleTimeRange.end - visibleTimeRange.start;\r\n    \r\n    if (visibleDuration <= 0) return 0;\r\n    \r\n    const relativeTime = time - visibleTimeRange.start;\r\n    return (relativeTime / visibleDuration) * canvasDimensions.width;\r\n  }\r\n\r\n  /**\r\n   * Convert pixel position to time within current viewport\r\n   */\r\n  pixelToTime(pixel) {\r\n    const { visibleTimeRange, canvasDimensions } = this.state;\r\n    const visibleDuration = visibleTimeRange.end - visibleTimeRange.start;\r\n    \r\n    if (canvasDimensions.width <= 0) {\r\n      return visibleTimeRange.start;\r\n    }\r\n    \r\n    const relativePixel = pixel / canvasDimensions.width;\r\n    return visibleTimeRange.start + (relativePixel * visibleDuration);\r\n  }\r\n\r\n  /**\r\n   * Check if a time is visible in current viewport\r\n   */\r\n  isTimeVisible(time) {\r\n    const { visibleTimeRange } = this.state;\r\n    return time >= visibleTimeRange.start && time <= visibleTimeRange.end;\r\n  }\r\n\r\n  /**\r\n   * Check if a time range is visible in current viewport\r\n   */\r\n  isRangeVisible(startTime, endTime) {\r\n    const { visibleTimeRange } = this.state;\r\n    return !(endTime < visibleTimeRange.start || startTime > visibleTimeRange.end);\r\n  }\r\n\r\n  /**\r\n   * Get viewport bounds for culling calculations\r\n   */\r\n  getViewportBounds() {\r\n    return {\r\n      ...this.state.visibleTimeRange,\r\n      duration: this.state.visibleTimeRange.end - this.state.visibleTimeRange.start,\r\n      pixelsPerSecond: this.state.pixelsPerSecond\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get current viewport state (read-only)\r\n   */\r\n  getState() {\r\n    return { ...this.state };\r\n  }\r\n\r\n  /**\r\n   * Reset viewport to default state\r\n   */\r\n  reset() {\r\n    this.state.zoomLevel = 1.0;\r\n    this.state.centerTime = this.state.audioDuration / 2;\r\n    this.updateVisibleRange();\r\n    this.notifyListeners();\r\n    \r\n    return this.state;\r\n  }\r\n\r\n  /**\r\n   * Set zoom and pan limits\r\n   */\r\n  setLimits({ minZoom, maxZoom }) {\r\n    if (minZoom !== undefined) {\r\n      this.state.minZoom = Math.max(0.01, minZoom);\r\n    }\r\n    if (maxZoom !== undefined) {\r\n      this.state.maxZoom = Math.min(1000, maxZoom);\r\n    }\r\n    \r\n    // Ensure current zoom is within new limits\r\n    if (this.state.zoomLevel < this.state.minZoom) {\r\n      this.setZoom(this.state.minZoom);\r\n    } else if (this.state.zoomLevel > this.state.maxZoom) {\r\n      this.setZoom(this.state.maxZoom);\r\n    }\r\n    \r\n    return this.state;\r\n  }\r\n\r\n  /**\r\n   * Calculate optimal zoom level for a specific time range\r\n   */\r\n  calculateZoomForRange(startTime, endTime, padding = 0.1) {\r\n    const duration = endTime - startTime;\r\n    if (duration <= 0) return this.state.zoomLevel;\r\n    \r\n    const paddedDuration = duration * (1 + padding * 2);\r\n    const { canvasDimensions } = this.state;\r\n    const basePixelsPerSecond = 100;\r\n    const requiredPixelsPerSecond = canvasDimensions.width / paddedDuration;\r\n    \r\n    return requiredPixelsPerSecond / basePixelsPerSecond;\r\n  }\r\n\r\n  /**\r\n   * Zoom to show a specific time range\r\n   */\r\n  zoomToRange(startTime, endTime, padding = 0.1) {\r\n    const centerTime = (startTime + endTime) / 2;\r\n    const zoomLevel = this.calculateZoomForRange(startTime, endTime, padding);\r\n    \r\n    return this.setZoom(zoomLevel, centerTime);\r\n  }\r\n\r\n  /**\r\n   * Get appropriate detail level for current zoom\r\n   * Implements requirement 4.3 - appropriate detail rendering at different scales\r\n   */\r\n  getDetailLevel() {\r\n    const { zoomLevel, pixelsPerSecond } = this.state;\r\n    \r\n    // Define detail levels based on pixels per second\r\n    if (pixelsPerSecond >= 1000) {\r\n      return 'sample'; // Individual sample points visible\r\n    } else if (pixelsPerSecond >= 400) {\r\n      return 'high'; // High detail waveform\r\n    } else if (pixelsPerSecond >= 100) {\r\n      return 'medium'; // Medium detail waveform\r\n    } else if (pixelsPerSecond >= 25) {\r\n      return 'low'; // Low detail waveform\r\n    } else {\r\n      return 'overview'; // Overview/summary view\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get rendering configuration for current detail level\r\n   */\r\n  getRenderingConfig() {\r\n    const detailLevel = this.getDetailLevel();\r\n    const { pixelsPerSecond, visibleTimeRange } = this.state;\r\n    \r\n    const config = {\r\n      detailLevel,\r\n      pixelsPerSecond,\r\n      visibleDuration: visibleTimeRange.end - visibleTimeRange.start,\r\n      showSamplePoints: false,\r\n      showZeroCrossings: false,\r\n      showGrid: false,\r\n      waveformResolution: 1,\r\n      antialiasing: true\r\n    };\r\n    \r\n    switch (detailLevel) {\r\n      case 'sample':\r\n        config.showSamplePoints = true;\r\n        config.showZeroCrossings = true;\r\n        config.showGrid = true;\r\n        config.waveformResolution = 1; // 1:1 sample resolution\r\n        config.antialiasing = false; // Crisp pixels for sample view\r\n        break;\r\n        \r\n      case 'high':\r\n        config.showZeroCrossings = true;\r\n        config.showGrid = true;\r\n        config.waveformResolution = 2; // 2:1 sample resolution\r\n        config.antialiasing = true;\r\n        break;\r\n        \r\n      case 'medium':\r\n        config.showGrid = pixelsPerSecond >= 150;\r\n        config.waveformResolution = 4; // 4:1 sample resolution\r\n        config.antialiasing = true;\r\n        break;\r\n        \r\n      case 'low':\r\n        config.waveformResolution = 8; // 8:1 sample resolution\r\n        config.antialiasing = true;\r\n        break;\r\n        \r\n      case 'overview':\r\n        config.waveformResolution = 16; // 16:1 sample resolution\r\n        config.antialiasing = true;\r\n        break;\r\n    }\r\n    \r\n    return config;\r\n  }\r\n\r\n  /**\r\n   * Get zoom level presets for quick navigation\r\n   */\r\n  getZoomPresets() {\r\n    const { audioDuration, canvasDimensions } = this.state;\r\n    const basePixelsPerSecond = 100;\r\n    \r\n    const presets = [\r\n      {\r\n        name: 'Fit All',\r\n        zoomLevel: this.calculateZoomForRange(0, audioDuration, 0.05),\r\n        description: 'Show entire audio file'\r\n      },\r\n      {\r\n        name: '1:1',\r\n        zoomLevel: 1.0,\r\n        description: 'Default zoom level'\r\n      },\r\n      {\r\n        name: '2x',\r\n        zoomLevel: 2.0,\r\n        description: 'Double zoom'\r\n      },\r\n      {\r\n        name: '5x',\r\n        zoomLevel: 5.0,\r\n        description: '5x zoom for detailed editing'\r\n      },\r\n      {\r\n        name: '10x',\r\n        zoomLevel: 10.0,\r\n        description: '10x zoom for precise editing'\r\n      },\r\n      {\r\n        name: 'Sample',\r\n        zoomLevel: Math.max(10, canvasDimensions.width / (audioDuration * 44100) * basePixelsPerSecond),\r\n        description: 'Sample-level detail'\r\n      }\r\n    ];\r\n    \r\n    return presets.filter(preset => \r\n      preset.zoomLevel >= this.state.minZoom && \r\n      preset.zoomLevel <= this.state.maxZoom\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get navigation info for current viewport\r\n   */\r\n  getNavigationInfo() {\r\n    const { visibleTimeRange, audioDuration, zoomLevel } = this.state;\r\n    const visibleDuration = visibleTimeRange.end - visibleTimeRange.start;\r\n    \r\n    return {\r\n      visiblePercentage: audioDuration > 0 ? (visibleDuration / audioDuration) * 100 : 100,\r\n      startPercentage: audioDuration > 0 ? (visibleTimeRange.start / audioDuration) * 100 : 0,\r\n      endPercentage: audioDuration > 0 ? (visibleTimeRange.end / audioDuration) * 100 : 100,\r\n      zoomLevel: zoomLevel,\r\n      detailLevel: this.getDetailLevel(),\r\n      canZoomIn: zoomLevel < this.state.maxZoom,\r\n      canZoomOut: zoomLevel > this.state.minZoom,\r\n      canPanLeft: visibleTimeRange.start > 0,\r\n      canPanRight: visibleTimeRange.end < audioDuration\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Smart zoom that maintains context\r\n   */\r\n  smartZoom(factor, mouseTime = null) {\r\n    const centerTime = mouseTime || this.state.centerTime;\r\n    const newZoomLevel = this.state.zoomLevel * factor;\r\n    \r\n    // Clamp to limits\r\n    const clampedZoom = Math.max(this.state.minZoom, Math.min(this.state.maxZoom, newZoomLevel));\r\n    \r\n    // If we hit a limit, provide feedback\r\n    const hitLimit = clampedZoom !== newZoomLevel;\r\n    \r\n    this.setZoom(clampedZoom, centerTime);\r\n    \r\n    return {\r\n      newZoomLevel: clampedZoom,\r\n      hitLimit,\r\n      limitType: clampedZoom === this.state.maxZoom ? 'max' : 'min'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get optimal zoom for time selection\r\n   */\r\n  getOptimalZoomForSelection(startTime, endTime, targetPercentage = 0.8) {\r\n    const duration = endTime - startTime;\r\n    const { canvasDimensions } = this.state;\r\n    const targetWidth = canvasDimensions.width * targetPercentage;\r\n    const basePixelsPerSecond = 100;\r\n    \r\n    const requiredPixelsPerSecond = targetWidth / duration;\r\n    return requiredPixelsPerSecond / basePixelsPerSecond;\r\n  }\r\n}\r\n\r\nexport default ViewportManager;","/**\r\n * High-performance canvas rendering system for waveform visualization\r\n * Implements optimized drawing algorithms with viewport culling\r\n * Requirements: 1.3, 4.4, 7.1, 7.2\r\n */\r\n\r\nimport { CanvasLayerManager } from './CanvasLayerManager.js';\r\nimport { ViewportManager } from './ViewportManager.js';\r\n\r\nexport class CanvasRenderer {\r\n  constructor(container, options = {}) {\r\n    this.container = container;\r\n    this.options = {\r\n      enableViewportCulling: true,\r\n      enableBatching: true,\r\n      maxBatchSize: 1000,\r\n      renderQuality: 'high', // 'low', 'medium', 'high'\r\n      enableAntialiasing: true,\r\n      ...options\r\n    };\r\n\r\n    // Initialize managers\r\n    this.layerManager = new CanvasLayerManager();\r\n    this.viewportManager = new ViewportManager();\r\n    \r\n    // Performance tracking\r\n    this.performanceMetrics = {\r\n      frameCount: 0,\r\n      lastFrameTime: 0,\r\n      averageFPS: 0,\r\n      renderTime: 0,\r\n      culledElements: 0\r\n    };\r\n\r\n    // Rendering state\r\n    this.isRendering = false;\r\n    this.renderQueue = [];\r\n    this.animationFrameId = null;\r\n    \r\n    // Cached drawing operations\r\n    this.drawingCache = new Map();\r\n    this.pathCache = new Map();\r\n    \r\n    this.initialize();\r\n  }\r\n\r\n  /**\r\n   * Initialize the renderer with canvas layers\r\n   */\r\n  initialize() {\r\n    this.layerManager.initialize(this.container);\r\n    \r\n    // Create standard layers with optimized configurations\r\n    this.createStandardLayers();\r\n    \r\n    // Setup viewport change listener\r\n    this.viewportManager.addListener((viewport) => {\r\n      this.handleViewportChange(viewport);\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Create standard canvas layers for waveform rendering\r\n   */\r\n  createStandardLayers() {\r\n    const layers = [\r\n      {\r\n        name: 'background',\r\n        zIndex: 1,\r\n        options: { \r\n          alpha: false, // Opaque background for better performance\r\n          desynchronized: true // Allow async rendering\r\n        }\r\n      },\r\n      {\r\n        name: 'waveform',\r\n        zIndex: 2,\r\n        options: { \r\n          alpha: true,\r\n          desynchronized: true\r\n        }\r\n      },\r\n      {\r\n        name: 'chops',\r\n        zIndex: 3,\r\n        options: { \r\n          alpha: true,\r\n          desynchronized: false // Sync for precise interaction\r\n        }\r\n      },\r\n      {\r\n        name: 'playhead',\r\n        zIndex: 4,\r\n        options: { \r\n          alpha: true,\r\n          desynchronized: true\r\n        }\r\n      },\r\n      {\r\n        name: 'interaction',\r\n        zIndex: 5,\r\n        options: { \r\n          alpha: true,\r\n          desynchronized: false\r\n        }\r\n      },\r\n      {\r\n        name: 'ui',\r\n        zIndex: 6,\r\n        options: { \r\n          alpha: true,\r\n          desynchronized: true\r\n        }\r\n      }\r\n    ];\r\n\r\n    layers.forEach(({ name, zIndex, options }) => {\r\n      this.layerManager.createLayer(name, zIndex, options);\r\n    });\r\n\r\n    // Enable interaction only on interaction layer\r\n    this.layerManager.enableLayerInteraction('interaction');\r\n  }\r\n\r\n  /**\r\n   * Handle viewport changes and trigger appropriate redraws\r\n   */\r\n  handleViewportChange(viewport) {\r\n    // Mark layers that need redraw based on viewport change\r\n    this.layerManager.markLayerDirty('waveform');\r\n    this.layerManager.markLayerDirty('chops');\r\n    this.layerManager.markLayerDirty('playhead');\r\n    this.layerManager.markLayerDirty('ui');\r\n    \r\n    // Schedule render\r\n    this.scheduleRender();\r\n  }\r\n\r\n  /**\r\n   * Render waveform data with viewport culling and optimization\r\n   */\r\n  renderWaveform(waveformData, options = {}) {\r\n    const layer = this.layerManager.getLayer('waveform');\r\n    if (!layer || !waveformData) return;\r\n\r\n    const startTime = performance.now();\r\n    const viewport = this.viewportManager.getViewportBounds();\r\n    const { ctx } = layer;\r\n    const { width, height } = this.layerManager.getDimensions();\r\n\r\n    // Clear layer\r\n    this.layerManager.clearLayer('waveform');\r\n\r\n    // Get rendering configuration based on current zoom level\r\n    // Implements requirement 4.3 - appropriate detail rendering at different scales\r\n    const renderingConfig = this.viewportManager.getRenderingConfig();\r\n    \r\n    // Merge options with rendering config\r\n    const enhancedOptions = {\r\n      ...options,\r\n      ...renderingConfig,\r\n      quality: options.quality || renderingConfig.detailLevel\r\n    };\r\n\r\n    // Apply viewport culling with resolution adjustment\r\n    const visibleSamples = this.cullWaveformData(waveformData, viewport, renderingConfig.waveformResolution);\r\n    \r\n    if (visibleSamples.length === 0) {\r\n      this.updatePerformanceMetrics('waveform', startTime, 0);\r\n      return;\r\n    }\r\n\r\n    // Choose rendering method based on zoom level and data density\r\n    const renderMethod = this.selectOptimalRenderMethod(visibleSamples, viewport, renderingConfig);\r\n    \r\n    // Configure context for waveform rendering with enhanced options\r\n    this.configureWaveformContext(ctx, enhancedOptions);\r\n\r\n    // Render grid if enabled for current detail level\r\n    if (renderingConfig.showGrid) {\r\n      this.renderGrid(ctx, viewport, width, height);\r\n    }\r\n\r\n    // Render using selected method with enhanced options\r\n    switch (renderMethod) {\r\n      case 'sample':\r\n        this.renderWaveformSamples(ctx, visibleSamples, viewport, width, height, enhancedOptions);\r\n        break;\r\n      case 'peaks':\r\n        this.renderWaveformPeaks(ctx, visibleSamples, viewport, width, height, enhancedOptions);\r\n        break;\r\n      case 'bars':\r\n        this.renderWaveformBars(ctx, visibleSamples, viewport, width, height, enhancedOptions);\r\n        break;\r\n      case 'line':\r\n        this.renderWaveformLine(ctx, visibleSamples, viewport, width, height, enhancedOptions);\r\n        break;\r\n      default:\r\n        this.renderWaveformPeaks(ctx, visibleSamples, viewport, width, height, enhancedOptions);\r\n    }\r\n\r\n    // Render zero-crossings if enabled\r\n    if (renderingConfig.showZeroCrossings) {\r\n      this.renderZeroCrossings(ctx, visibleSamples, viewport, width, height);\r\n    }\r\n\r\n    // Update performance metrics\r\n    this.updatePerformanceMetrics('waveform', startTime, visibleSamples.length);\r\n    this.layerManager.markLayerClean('waveform');\r\n  }\r\n\r\n  /**\r\n   * Cull waveform data to only include visible samples\r\n   */\r\n  cullWaveformData(waveformData, viewport, resolution = 1) {\r\n    if (!this.options.enableViewportCulling) {\r\n      return waveformData.samples || [];\r\n    }\r\n\r\n    const { samples, sampleRate } = waveformData;\r\n    if (!samples || !sampleRate) return [];\r\n\r\n    // Calculate sample indices for visible time range\r\n    const startSample = Math.floor(viewport.start * sampleRate);\r\n    const endSample = Math.ceil(viewport.end * sampleRate);\r\n    \r\n    // Add small buffer to avoid edge artifacts\r\n    const bufferSamples = Math.ceil(sampleRate * 0.1); // 100ms buffer\r\n    const cullStart = Math.max(0, startSample - bufferSamples);\r\n    const cullEnd = Math.min(samples.length, endSample + bufferSamples);\r\n\r\n    let culledSamples = samples.slice(cullStart, cullEnd);\r\n    \r\n    // Apply resolution downsampling if needed\r\n    if (resolution > 1 && culledSamples.length > resolution) {\r\n      const downsampledSamples = [];\r\n      for (let i = 0; i < culledSamples.length; i += resolution) {\r\n        // Use RMS for better quality downsampling\r\n        let sum = 0;\r\n        let count = 0;\r\n        for (let j = i; j < Math.min(i + resolution, culledSamples.length); j++) {\r\n          sum += culledSamples[j] * culledSamples[j];\r\n          count++;\r\n        }\r\n        downsampledSamples.push(Math.sqrt(sum / count) * Math.sign(culledSamples[i]));\r\n      }\r\n      culledSamples = downsampledSamples;\r\n    }\r\n\r\n    this.performanceMetrics.culledElements = samples.length - culledSamples.length;\r\n    \r\n    return {\r\n      samples: culledSamples,\r\n      startIndex: cullStart,\r\n      endIndex: cullEnd,\r\n      sampleRate: sampleRate / resolution\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Select optimal rendering method based on data density and zoom level\r\n   * Enhanced with detail level support for different zoom scales\r\n   */\r\n  selectOptimalRenderMethod(visibleSamples, viewport, renderingConfig = {}) {\r\n    const { samples } = visibleSamples;\r\n    if (!samples || samples.length === 0) {\r\n      return 'peaks'; // Default fallback\r\n    }\r\n    \r\n    const { width } = this.layerManager.getDimensions();\r\n    if (width <= 0) {\r\n      return 'peaks'; // Default fallback\r\n    }\r\n    \r\n    const samplesPerPixel = samples.length / width;\r\n    const { detailLevel } = renderingConfig;\r\n\r\n    // Use detail level to determine rendering method\r\n    switch (detailLevel) {\r\n      case 'sample':\r\n        return 'sample'; // Individual sample points\r\n        \r\n      case 'high':\r\n        return samplesPerPixel < 2 ? 'line' : 'bars';\r\n        \r\n      case 'medium':\r\n        return samplesPerPixel < 5 ? 'bars' : 'peaks';\r\n        \r\n      case 'low':\r\n      case 'overview':\r\n        return 'peaks';\r\n        \r\n      default:\r\n        // Fallback to original logic\r\n        if (samplesPerPixel < 1) {\r\n          return 'sample';\r\n        } else if (samplesPerPixel < 2) {\r\n          return 'line';\r\n        } else if (samplesPerPixel < 10) {\r\n          return 'bars';\r\n        } else {\r\n          return 'peaks';\r\n        }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Configure canvas context for waveform rendering\r\n   */\r\n  configureWaveformContext(ctx, options) {\r\n    const quality = options.quality || this.options.renderQuality;\r\n    \r\n    // Set rendering quality\r\n    switch (quality) {\r\n      case 'low':\r\n        ctx.imageSmoothingEnabled = false;\r\n        ctx.lineWidth = 1;\r\n        break;\r\n      case 'medium':\r\n        ctx.imageSmoothingEnabled = true;\r\n        ctx.lineWidth = 1.5;\r\n        break;\r\n      case 'high':\r\n        ctx.imageSmoothingEnabled = this.options.enableAntialiasing;\r\n        ctx.lineWidth = 2;\r\n        break;\r\n    }\r\n\r\n    // Set waveform colors\r\n    const gradient = ctx.createLinearGradient(0, 0, 0, this.layerManager.getDimensions().height);\r\n    gradient.addColorStop(0, options.topColor || 'rgba(6, 182, 212, 0.8)');\r\n    gradient.addColorStop(0.5, options.centerColor || 'rgba(6, 182, 212, 0.4)');\r\n    gradient.addColorStop(1, options.bottomColor || 'rgba(6, 182, 212, 0.8)');\r\n    \r\n    ctx.fillStyle = gradient;\r\n    ctx.strokeStyle = options.strokeColor || 'rgba(6, 182, 212, 1)';\r\n  }\r\n\r\n  /**\r\n   * Render waveform using peak detection (for high data density)\r\n   */\r\n  renderWaveformPeaks(ctx, visibleSamples, viewport, width, height) {\r\n    const { samples } = visibleSamples;\r\n    if (!samples || samples.length === 0 || width <= 0) return;\r\n    \r\n    const centerY = height / 2;\r\n    const samplesPerPixel = samples.length / width;\r\n    \r\n    ctx.beginPath();\r\n    \r\n    for (let x = 0; x < width; x++) {\r\n      const sampleStart = Math.floor(x * samplesPerPixel);\r\n      const sampleEnd = Math.floor((x + 1) * samplesPerPixel);\r\n      \r\n      // Find min and max in this pixel range\r\n      let min = 0, max = 0;\r\n      for (let i = sampleStart; i < Math.min(sampleEnd, samples.length); i++) {\r\n        const sample = samples[i] || 0;\r\n        min = Math.min(min, sample);\r\n        max = Math.max(max, sample);\r\n      }\r\n      \r\n      // Convert to pixel coordinates\r\n      const minY = centerY - (min * centerY);\r\n      const maxY = centerY - (max * centerY);\r\n      \r\n      // Draw vertical line from min to max\r\n      ctx.moveTo(x, minY);\r\n      ctx.lineTo(x, maxY);\r\n    }\r\n    \r\n    ctx.stroke();\r\n  }\r\n\r\n  /**\r\n   * Render waveform using bar visualization (for medium data density)\r\n   */\r\n  renderWaveformBars(ctx, visibleSamples, viewport, width, height) {\r\n    const { samples } = visibleSamples;\r\n    if (!samples || samples.length === 0) return;\r\n    \r\n    const centerY = height / 2;\r\n    const barWidth = Math.max(1, width / samples.length);\r\n    \r\n    for (let i = 0; i < samples.length; i++) {\r\n      const sample = samples[i] || 0;\r\n      const x = i * barWidth;\r\n      const barHeight = Math.abs(sample) * centerY;\r\n      \r\n      if (sample >= 0) {\r\n        ctx.fillRect(x, centerY - barHeight, barWidth, barHeight);\r\n      } else {\r\n        ctx.fillRect(x, centerY, barWidth, barHeight);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render waveform using line visualization (for low data density)\r\n   */\r\n  renderWaveformLine(ctx, visibleSamples, viewport, width, height) {\r\n    const { samples } = visibleSamples;\r\n    if (!samples || samples.length === 0) return;\r\n    \r\n    const centerY = height / 2;\r\n    const stepX = width / samples.length;\r\n    \r\n    ctx.beginPath();\r\n    \r\n    for (let i = 0; i < samples.length; i++) {\r\n      const x = i * stepX;\r\n      const y = centerY - ((samples[i] || 0) * centerY);\r\n      \r\n      if (i === 0) {\r\n        ctx.moveTo(x, y);\r\n      } else {\r\n        ctx.lineTo(x, y);\r\n      }\r\n    }\r\n    \r\n    ctx.stroke();\r\n    \r\n    // Fill area under curve for better visibility\r\n    ctx.lineTo(width, centerY);\r\n    ctx.lineTo(0, centerY);\r\n    ctx.closePath();\r\n    ctx.globalAlpha = 0.3;\r\n    ctx.fill();\r\n    ctx.globalAlpha = 1.0;\r\n  }\r\n\r\n  /**\r\n   * Render waveform at sample level (for maximum zoom)\r\n   * Shows individual sample points and zero-crossings\r\n   */\r\n  renderWaveformSamples(ctx, visibleSamples, viewport, width, height, options = {}) {\r\n    const { samples } = visibleSamples;\r\n    if (!samples || samples.length === 0) return;\r\n    \r\n    const centerY = height / 2;\r\n    const stepX = width / samples.length;\r\n    \r\n    // Draw sample points\r\n    ctx.fillStyle = options.strokeColor || 'rgba(6, 182, 212, 1)';\r\n    \r\n    for (let i = 0; i < samples.length; i++) {\r\n      const x = i * stepX;\r\n      const y = centerY - ((samples[i] || 0) * centerY);\r\n      \r\n      // Draw sample point\r\n      ctx.beginPath();\r\n      ctx.arc(x, y, 2, 0, Math.PI * 2);\r\n      ctx.fill();\r\n      \r\n      // Connect with lines if not too dense\r\n      if (stepX > 4 && i > 0) {\r\n        const prevY = centerY - ((samples[i - 1] || 0) * centerY);\r\n        ctx.strokeStyle = options.strokeColor || 'rgba(6, 182, 212, 0.6)';\r\n        ctx.lineWidth = 1;\r\n        ctx.beginPath();\r\n        ctx.moveTo((i - 1) * stepX, prevY);\r\n        ctx.lineTo(x, y);\r\n        ctx.stroke();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render time grid for navigation reference\r\n   */\r\n  renderGrid(ctx, viewport, width, height) {\r\n    const { start, end } = viewport;\r\n    const duration = end - start;\r\n    \r\n    // Calculate appropriate grid interval\r\n    let gridInterval = 1; // seconds\r\n    if (duration > 300) gridInterval = 60; // 1 minute\r\n    else if (duration > 60) gridInterval = 10; // 10 seconds\r\n    else if (duration > 10) gridInterval = 1; // 1 second\r\n    else if (duration > 1) gridInterval = 0.1; // 100ms\r\n    else gridInterval = 0.01; // 10ms\r\n    \r\n    // Draw vertical grid lines\r\n    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';\r\n    ctx.lineWidth = 1;\r\n    if (ctx.setLineDash) {\r\n      ctx.setLineDash([2, 4]);\r\n    }\r\n    \r\n    const startGrid = Math.ceil(start / gridInterval) * gridInterval;\r\n    \r\n    for (let time = startGrid; time <= end; time += gridInterval) {\r\n      const x = ((time - start) / duration) * width;\r\n      \r\n      ctx.beginPath();\r\n      ctx.moveTo(x, 0);\r\n      ctx.lineTo(x, height);\r\n      ctx.stroke();\r\n    }\r\n    \r\n    // Draw center line\r\n    if (ctx.setLineDash) {\r\n      ctx.setLineDash([]);\r\n    }\r\n    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';\r\n    ctx.lineWidth = 1;\r\n    ctx.beginPath();\r\n    ctx.moveTo(0, height / 2);\r\n    ctx.lineTo(width, height / 2);\r\n    ctx.stroke();\r\n  }\r\n\r\n  /**\r\n   * Render zero-crossing indicators\r\n   */\r\n  renderZeroCrossings(ctx, visibleSamples, viewport, width, height) {\r\n    const { samples } = visibleSamples;\r\n    if (!samples || samples.length === 0) return;\r\n    \r\n    const centerY = height / 2;\r\n    const stepX = width / samples.length;\r\n    \r\n    // Find zero crossings\r\n    ctx.strokeStyle = 'rgba(255, 165, 0, 0.8)';\r\n    ctx.lineWidth = 1;\r\n    \r\n    for (let i = 1; i < samples.length; i++) {\r\n      const prev = samples[i - 1] || 0;\r\n      const curr = samples[i] || 0;\r\n      \r\n      // Check for zero crossing\r\n      if ((prev >= 0 && curr < 0) || (prev < 0 && curr >= 0)) {\r\n        const x = i * stepX;\r\n        \r\n        ctx.beginPath();\r\n        ctx.moveTo(x, centerY - 10);\r\n        ctx.lineTo(x, centerY + 10);\r\n        ctx.stroke();\r\n        \r\n        // Draw small circle at crossing point\r\n        ctx.fillStyle = 'rgba(255, 165, 0, 1)';\r\n        ctx.beginPath();\r\n        ctx.arc(x, centerY, 2, 0, Math.PI * 2);\r\n        ctx.fill();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render chops with enhanced visualization and relationship display\r\n   * Implements requirements: 2.4, 2.5, 5.4, 5.5\r\n   */\r\n  renderChops(chops, selectedChopId = null, options = {}) {\r\n    const layer = this.layerManager.getLayer('chops');\r\n    if (!layer || !chops.length) return;\r\n\r\n    const startTime = performance.now();\r\n    const viewport = this.viewportManager.getViewportBounds();\r\n    const { ctx } = layer;\r\n    const { width, height } = this.layerManager.getDimensions();\r\n\r\n    // Clear layer\r\n    this.layerManager.clearLayer('chops');\r\n\r\n    // Cull chops outside viewport\r\n    const visibleChops = this.cullChops(chops, viewport);\r\n    \r\n    if (visibleChops.length === 0) {\r\n      this.updatePerformanceMetrics('chops', startTime, 0);\r\n      return;\r\n    }\r\n\r\n    // Enhanced rendering with relationship analysis\r\n    visibleChops.forEach((chop, index) => {\r\n      this.renderSingleChop(ctx, chop, viewport, width, height, {\r\n        isSelected: chop.id === selectedChopId,\r\n        isHovered: chop.id === options.hoveredChopId,\r\n        isActive: chop.id === options.activeChopId,\r\n        allChops: chops, // Pass all chops for relationship analysis\r\n        ...options\r\n      });\r\n    });\r\n\r\n    this.updatePerformanceMetrics('chops', startTime, visibleChops.length);\r\n    this.layerManager.markLayerClean('chops');\r\n  }\r\n\r\n  /**\r\n   * Cull chops to only include those visible in viewport\r\n   */\r\n  cullChops(chops, viewport) {\r\n    if (!this.options.enableViewportCulling) {\r\n      return chops;\r\n    }\r\n\r\n    return chops.filter(chop => {\r\n      // Check if chop overlaps with viewport\r\n      return !(chop.endTime < viewport.start || chop.startTime > viewport.end);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Render a single chop with enhanced visualization and relationship display\r\n   * Implements requirements: 2.4, 2.5, 5.4, 5.5\r\n   */\r\n  renderSingleChop(ctx, chop, viewport, width, height, options = {}) {\r\n    const startPixel = this.viewportManager.timeToPixel(chop.startTime);\r\n    const endPixel = this.viewportManager.timeToPixel(chop.endTime);\r\n    \r\n    // Clamp to viewport bounds\r\n    const clampedStart = Math.max(0, startPixel);\r\n    const clampedEnd = Math.min(width, endPixel);\r\n    const chopWidth = clampedEnd - clampedStart;\r\n    \r\n    if (chopWidth <= 0) return;\r\n    \r\n    // Use cached color or generate one with enhanced color scheme\r\n    const color = chop.color || this.generateChopColor(chop.id);\r\n    const isSelected = options.isSelected;\r\n    const isHovered = options.isHovered;\r\n    const isActive = options.isActive; // Currently playing\r\n    \r\n    // Enhanced visual states\r\n    const baseAlpha = isSelected ? 0.6 : isHovered ? 0.4 : 0.25;\r\n    const borderAlpha = isSelected ? 1.0 : isHovered ? 0.8 : 0.6;\r\n    \r\n    // Draw chop background with gradient for depth\r\n    const gradient = ctx.createLinearGradient(clampedStart, 0, clampedStart, height);\r\n    if (isActive) {\r\n      // Active chop gets animated gradient\r\n      const pulseOffset = Math.sin(Date.now() / 300) * 0.1;\r\n      gradient.addColorStop(0, this.hexToRgba(color, baseAlpha + pulseOffset));\r\n      gradient.addColorStop(0.5, this.hexToRgba(color, baseAlpha * 0.7 + pulseOffset));\r\n      gradient.addColorStop(1, this.hexToRgba(color, baseAlpha + pulseOffset));\r\n    } else {\r\n      gradient.addColorStop(0, this.hexToRgba(color, baseAlpha));\r\n      gradient.addColorStop(0.5, this.hexToRgba(color, baseAlpha * 0.7));\r\n      gradient.addColorStop(1, this.hexToRgba(color, baseAlpha));\r\n    }\r\n    \r\n    ctx.fillStyle = gradient;\r\n    ctx.fillRect(clampedStart, 0, chopWidth, height);\r\n    \r\n    // Draw enhanced chop boundaries with clear start/end indicators\r\n    this.renderChopBoundaries(ctx, chop, startPixel, endPixel, width, height, {\r\n      color,\r\n      isSelected,\r\n      isHovered,\r\n      isActive,\r\n      borderAlpha\r\n    });\r\n    \r\n    // Draw relationship indicators for overlapping or adjacent chops\r\n    this.renderChopRelationships(ctx, chop, startPixel, endPixel, width, height, options);\r\n    \r\n    // Draw enhanced chop label with better visibility\r\n    this.renderChopLabel(ctx, chop, clampedStart, chopWidth, height, {\r\n      color,\r\n      isSelected,\r\n      isHovered,\r\n      isActive\r\n    });\r\n    \r\n    // Draw duration indicator for longer chops\r\n    if (chopWidth > 80) {\r\n      this.renderDurationIndicator(ctx, chop, clampedStart, chopWidth, height, color);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render enhanced chop boundaries with clear start/end indicators\r\n   */\r\n  renderChopBoundaries(ctx, chop, startPixel, endPixel, width, height, options) {\r\n    const { color, isSelected, isHovered, isActive, borderAlpha } = options;\r\n    \r\n    // Enhanced boundary styling\r\n    const lineWidth = isSelected ? 4 : isHovered ? 3 : 2;\r\n    const shadowBlur = isSelected ? 6 : isHovered ? 4 : 0;\r\n    \r\n    // Set shadow for glow effect\r\n    if (shadowBlur > 0) {\r\n      ctx.shadowColor = this.hexToRgba(color, 0.6);\r\n      ctx.shadowBlur = shadowBlur;\r\n    }\r\n    \r\n    ctx.strokeStyle = this.hexToRgba(color, borderAlpha);\r\n    ctx.lineWidth = lineWidth;\r\n    ctx.beginPath();\r\n    \r\n    // Start boundary with indicator\r\n    if (startPixel >= 0 && startPixel <= width) {\r\n      ctx.moveTo(startPixel, 0);\r\n      ctx.lineTo(startPixel, height);\r\n      \r\n      // Start indicator triangle\r\n      this.renderBoundaryIndicator(ctx, startPixel, 15, 'start', color, isSelected);\r\n    }\r\n    \r\n    // End boundary with indicator\r\n    if (endPixel >= 0 && endPixel <= width) {\r\n      ctx.moveTo(endPixel, 0);\r\n      ctx.lineTo(endPixel, height);\r\n      \r\n      // End indicator triangle\r\n      this.renderBoundaryIndicator(ctx, endPixel, 15, 'end', color, isSelected);\r\n    }\r\n    \r\n    ctx.stroke();\r\n    \r\n    // Reset shadow\r\n    ctx.shadowColor = 'transparent';\r\n    ctx.shadowBlur = 0;\r\n    \r\n    // Add active chop animation\r\n    if (isActive) {\r\n      this.renderActiveChopAnimation(ctx, startPixel, endPixel, width, height, color);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render boundary indicators (triangular markers)\r\n   */\r\n  renderBoundaryIndicator(ctx, x, y, type, color, isSelected) {\r\n    const size = isSelected ? 8 : 6;\r\n    const direction = type === 'start' ? 1 : -1;\r\n    \r\n    ctx.fillStyle = this.hexToRgba(color, 0.9);\r\n    ctx.beginPath();\r\n    ctx.moveTo(x, y);\r\n    ctx.lineTo(x + (direction * size), y - size);\r\n    ctx.lineTo(x + (direction * size), y + size);\r\n    ctx.closePath();\r\n    ctx.fill();\r\n    \r\n    // Add white outline for better visibility\r\n    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';\r\n    ctx.lineWidth = 1;\r\n    ctx.stroke();\r\n  }\r\n\r\n  /**\r\n   * Render active chop animation (pulsing border)\r\n   */\r\n  renderActiveChopAnimation(ctx, startPixel, endPixel, width, height, color) {\r\n    const pulseAlpha = 0.3 + 0.2 * Math.sin(Date.now() / 200);\r\n    \r\n    ctx.strokeStyle = this.hexToRgba(color, pulseAlpha);\r\n    ctx.lineWidth = 6;\r\n    ctx.setLineDash([8, 4]);\r\n    ctx.lineDashOffset = (Date.now() / 50) % 12;\r\n    \r\n    ctx.beginPath();\r\n    if (startPixel >= 0 && startPixel <= width) {\r\n      ctx.moveTo(startPixel, 0);\r\n      ctx.lineTo(startPixel, height);\r\n    }\r\n    if (endPixel >= 0 && endPixel <= width) {\r\n      ctx.moveTo(endPixel, 0);\r\n      ctx.lineTo(endPixel, height);\r\n    }\r\n    ctx.stroke();\r\n    \r\n    // Reset line dash\r\n    ctx.setLineDash([]);\r\n    ctx.lineDashOffset = 0;\r\n  }\r\n\r\n  /**\r\n   * Render visual relationship indicators for overlapping or adjacent chops\r\n   */\r\n  renderChopRelationships(ctx, chop, startPixel, endPixel, width, height, options) {\r\n    const allChops = options.allChops || [];\r\n    const relationships = this.analyzeChopRelationships(chop, allChops);\r\n    \r\n    relationships.forEach(relationship => {\r\n      this.renderRelationshipIndicator(ctx, relationship, startPixel, endPixel, width, height);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Analyze relationships between chops\r\n   */\r\n  analyzeChopRelationships(currentChop, allChops) {\r\n    const relationships = [];\r\n    const tolerance = 0.05; // 50ms tolerance for adjacency\r\n    \r\n    allChops.forEach(otherChop => {\r\n      if (otherChop.id === currentChop.id) return;\r\n      \r\n      // Check for overlap\r\n      if (!(currentChop.endTime <= otherChop.startTime || currentChop.startTime >= otherChop.endTime)) {\r\n        relationships.push({\r\n          type: 'overlap',\r\n          chop: otherChop,\r\n          severity: this.calculateOverlapSeverity(currentChop, otherChop)\r\n        });\r\n      }\r\n      // Check for adjacency\r\n      else if (Math.abs(currentChop.endTime - otherChop.startTime) <= tolerance) {\r\n        relationships.push({\r\n          type: 'adjacent-after',\r\n          chop: otherChop,\r\n          gap: otherChop.startTime - currentChop.endTime\r\n        });\r\n      }\r\n      else if (Math.abs(otherChop.endTime - currentChop.startTime) <= tolerance) {\r\n        relationships.push({\r\n          type: 'adjacent-before',\r\n          chop: otherChop,\r\n          gap: currentChop.startTime - otherChop.endTime\r\n        });\r\n      }\r\n    });\r\n    \r\n    return relationships;\r\n  }\r\n\r\n  /**\r\n   * Calculate overlap severity (0-1)\r\n   */\r\n  calculateOverlapSeverity(chop1, chop2) {\r\n    const overlapStart = Math.max(chop1.startTime, chop2.startTime);\r\n    const overlapEnd = Math.min(chop1.endTime, chop2.endTime);\r\n    const overlapDuration = overlapEnd - overlapStart;\r\n    \r\n    const chop1Duration = chop1.endTime - chop1.startTime;\r\n    const chop2Duration = chop2.endTime - chop2.startTime;\r\n    const minDuration = Math.min(chop1Duration, chop2Duration);\r\n    \r\n    return overlapDuration / minDuration;\r\n  }\r\n\r\n  /**\r\n   * Render relationship indicator\r\n   */\r\n  renderRelationshipIndicator(ctx, relationship, startPixel, endPixel, width, height) {\r\n    const otherStartPixel = this.viewportManager.timeToPixel(relationship.chop.startTime);\r\n    const otherEndPixel = this.viewportManager.timeToPixel(relationship.chop.endTime);\r\n    \r\n    switch (relationship.type) {\r\n      case 'overlap':\r\n        this.renderOverlapIndicator(ctx, startPixel, endPixel, otherStartPixel, otherEndPixel, height, relationship.severity);\r\n        break;\r\n      case 'adjacent-after':\r\n      case 'adjacent-before':\r\n        this.renderAdjacencyIndicator(ctx, startPixel, endPixel, otherStartPixel, otherEndPixel, height, relationship.type);\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render overlap indicator\r\n   */\r\n  renderOverlapIndicator(ctx, start1, end1, start2, end2, height, severity) {\r\n    const overlapStart = Math.max(start1, start2);\r\n    const overlapEnd = Math.min(end1, end2);\r\n    \r\n    if (overlapEnd <= overlapStart) return;\r\n    \r\n    // Draw overlap warning pattern\r\n    const warningColor = severity > 0.5 ? 'rgba(239, 68, 68, 0.6)' : 'rgba(245, 158, 11, 0.6)';\r\n    \r\n    ctx.fillStyle = warningColor;\r\n    ctx.fillRect(overlapStart, height - 8, overlapEnd - overlapStart, 8);\r\n    \r\n    // Draw warning stripes\r\n    ctx.strokeStyle = severity > 0.5 ? 'rgba(239, 68, 68, 0.8)' : 'rgba(245, 158, 11, 0.8)';\r\n    ctx.lineWidth = 1;\r\n    ctx.setLineDash([3, 3]);\r\n    \r\n    for (let x = overlapStart; x < overlapEnd; x += 6) {\r\n      ctx.beginPath();\r\n      ctx.moveTo(x, height - 8);\r\n      ctx.lineTo(x, height);\r\n      ctx.stroke();\r\n    }\r\n    \r\n    ctx.setLineDash([]);\r\n  }\r\n\r\n  /**\r\n   * Render adjacency indicator\r\n   */\r\n  renderAdjacencyIndicator(ctx, start1, end1, start2, end2, height, type) {\r\n    const connectionPoint = type === 'adjacent-after' ? end1 : start1;\r\n    const otherPoint = type === 'adjacent-after' ? start2 : end2;\r\n    \r\n    // Draw connection line\r\n    ctx.strokeStyle = 'rgba(34, 197, 94, 0.6)';\r\n    ctx.lineWidth = 2;\r\n    ctx.setLineDash([4, 2]);\r\n    \r\n    ctx.beginPath();\r\n    ctx.moveTo(connectionPoint, height - 20);\r\n    ctx.lineTo(otherPoint, height - 20);\r\n    ctx.stroke();\r\n    \r\n    // Draw connection dots\r\n    ctx.fillStyle = 'rgba(34, 197, 94, 0.8)';\r\n    ctx.beginPath();\r\n    ctx.arc(connectionPoint, height - 20, 3, 0, Math.PI * 2);\r\n    ctx.fill();\r\n    \r\n    ctx.beginPath();\r\n    ctx.arc(otherPoint, height - 20, 3, 0, Math.PI * 2);\r\n    ctx.fill();\r\n    \r\n    ctx.setLineDash([]);\r\n  }\r\n\r\n  /**\r\n   * Render enhanced chop label with better visibility\r\n   */\r\n  renderChopLabel(ctx, chop, startX, width, height, options) {\r\n    const { color, isSelected, isHovered, isActive } = options;\r\n    \r\n    if (width < 30) return; // Too narrow for label\r\n    \r\n    const centerX = startX + width / 2;\r\n    const centerY = height / 2;\r\n    \r\n    // Prepare label text\r\n    const labelText = chop.padId || chop.name || chop.id.slice(0, 3);\r\n    const fontSize = isSelected ? 14 : 12;\r\n    const fontWeight = isSelected ? 'bold' : 'normal';\r\n    \r\n    ctx.font = `${fontWeight} ${fontSize}px monospace`;\r\n    ctx.textAlign = 'center';\r\n    ctx.textBaseline = 'middle';\r\n    \r\n    // Measure text for background\r\n    const textMetrics = ctx.measureText(labelText);\r\n    const textWidth = textMetrics.width;\r\n    const textHeight = fontSize;\r\n    \r\n    const padding = 4;\r\n    const bgWidth = textWidth + padding * 2;\r\n    const bgHeight = textHeight + padding * 2;\r\n    \r\n    // Draw label background for better readability\r\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\r\n    ctx.fillRect(centerX - bgWidth / 2, centerY - bgHeight / 2, bgWidth, bgHeight);\r\n    \r\n    // Draw label border\r\n    ctx.strokeStyle = this.hexToRgba(color, 0.8);\r\n    ctx.lineWidth = 1;\r\n    ctx.strokeRect(centerX - bgWidth / 2, centerY - bgHeight / 2, bgWidth, bgHeight);\r\n    \r\n    // Draw label text\r\n    ctx.fillStyle = isActive ? '#ffffff' : this.hexToRgba(color, 1.0);\r\n    ctx.fillText(labelText, centerX, centerY);\r\n    \r\n    // Add active indicator\r\n    if (isActive) {\r\n      ctx.fillStyle = 'rgba(34, 197, 94, 0.8)';\r\n      ctx.beginPath();\r\n      ctx.arc(centerX + textWidth / 2 + 8, centerY, 3, 0, Math.PI * 2);\r\n      ctx.fill();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render duration indicator for longer chops\r\n   */\r\n  renderDurationIndicator(ctx, chop, startX, width, height, color) {\r\n    const duration = chop.endTime - chop.startTime;\r\n    const durationText = duration < 1 ? `${(duration * 1000).toFixed(0)}ms` : `${duration.toFixed(2)}s`;\r\n    \r\n    ctx.font = '10px monospace';\r\n    ctx.textAlign = 'center';\r\n    ctx.fillStyle = this.hexToRgba(color, 0.8);\r\n    \r\n    const centerX = startX + width / 2;\r\n    ctx.fillText(durationText, centerX, height - 10);\r\n  }\r\n\r\n  /**\r\n   * Convert hex color to rgba with alpha\r\n   */\r\n  hexToRgba(hex, alpha) {\r\n    // Handle HSL colors\r\n    if (hex.startsWith('hsl')) {\r\n      return hex.replace('hsl', 'hsla').replace(')', `, ${alpha})`);\r\n    }\r\n    \r\n    // Handle hex colors\r\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n    if (result) {\r\n      const r = parseInt(result[1], 16);\r\n      const g = parseInt(result[2], 16);\r\n      const b = parseInt(result[3], 16);\r\n      return `rgba(${r}, ${g}, ${b}, ${alpha})`;\r\n    }\r\n    \r\n    // Fallback for other formats\r\n    return hex;\r\n  }\r\n\r\n  /**\r\n   * Generate consistent color for chop based on ID\r\n   */\r\n  generateChopColor(chopId) {\r\n    // Use cached color if available\r\n    if (this.drawingCache.has(`color_${chopId}`)) {\r\n      return this.drawingCache.get(`color_${chopId}`);\r\n    }\r\n    \r\n    // Generate color based on hash of ID\r\n    let hash = 0;\r\n    for (let i = 0; i < chopId.length; i++) {\r\n      hash = ((hash << 5) - hash + chopId.charCodeAt(i)) & 0xffffffff;\r\n    }\r\n    \r\n    const hue = Math.abs(hash) % 360;\r\n    const color = `hsl(${hue}, 70%, 50%)`;\r\n    \r\n    // Cache the color\r\n    this.drawingCache.set(`color_${chopId}`, color);\r\n    \r\n    return color;\r\n  }\r\n\r\n  /**\r\n   * Render playhead with smooth animation\r\n   */\r\n  renderPlayhead(currentTime, isPlaying = false, options = {}) {\r\n    const layer = this.layerManager.getLayer('playhead');\r\n    if (!layer) return;\r\n\r\n    const viewport = this.viewportManager.getViewportBounds();\r\n    const { ctx } = layer;\r\n    const { width, height } = this.layerManager.getDimensions();\r\n\r\n    // Clear layer\r\n    this.layerManager.clearLayer('playhead');\r\n\r\n    // Check if playhead is visible\r\n    if (!this.viewportManager.isTimeVisible(currentTime)) {\r\n      this.layerManager.markLayerClean('playhead');\r\n      return;\r\n    }\r\n\r\n    const playheadPixel = this.viewportManager.timeToPixel(currentTime);\r\n    \r\n    // Playhead line\r\n    ctx.strokeStyle = options.color || '#ef4444';\r\n    ctx.lineWidth = options.width || 2;\r\n    ctx.beginPath();\r\n    ctx.moveTo(playheadPixel, 0);\r\n    ctx.lineTo(playheadPixel, height);\r\n    ctx.stroke();\r\n    \r\n    // Playhead indicator at top\r\n    ctx.fillStyle = options.color || '#ef4444';\r\n    const indicatorSize = options.indicatorSize || 6;\r\n    ctx.beginPath();\r\n    ctx.moveTo(playheadPixel - indicatorSize, 0);\r\n    ctx.lineTo(playheadPixel + indicatorSize, 0);\r\n    ctx.lineTo(playheadPixel, indicatorSize * 2);\r\n    ctx.closePath();\r\n    ctx.fill();\r\n    \r\n    // Time display for high zoom levels\r\n    if (viewport.pixelsPerSecond > 200 && options.showTime !== false) {\r\n      ctx.fillStyle = '#ffffff';\r\n      ctx.font = '10px monospace';\r\n      ctx.textAlign = 'center';\r\n      ctx.strokeStyle = '#000000';\r\n      ctx.lineWidth = 3;\r\n      const timeText = `${currentTime.toFixed(2)}s`;\r\n      ctx.strokeText(timeText, playheadPixel, height - 10);\r\n      ctx.fillText(timeText, playheadPixel, height - 10);\r\n    }\r\n\r\n    this.layerManager.markLayerClean('playhead');\r\n  }\r\n\r\n  /**\r\n   * Render UI elements (time scale, labels, etc.)\r\n   */\r\n  renderUI(options = {}) {\r\n    const layer = this.layerManager.getLayer('ui');\r\n    if (!layer) return;\r\n\r\n    const viewport = this.viewportManager.getViewportBounds();\r\n    const { ctx } = layer;\r\n    const { width, height } = this.layerManager.getDimensions();\r\n\r\n    // Clear layer\r\n    this.layerManager.clearLayer('ui');\r\n\r\n    // Render time scale\r\n    this.renderTimeScale(ctx, viewport, width, height, options);\r\n    \r\n    // Render zoom indicator\r\n    if (options.showZoomIndicator !== false) {\r\n      this.renderZoomIndicator(ctx, width, height, options);\r\n    }\r\n\r\n    this.layerManager.markLayerClean('ui');\r\n  }\r\n\r\n  /**\r\n   * Render time scale at bottom of waveform\r\n   */\r\n  renderTimeScale(ctx, viewport, width, height, options) {\r\n    ctx.fillStyle = options.textColor || 'rgba(255, 255, 255, 0.7)';\r\n    ctx.font = options.font || '10px monospace';\r\n    ctx.textAlign = 'center';\r\n    \r\n    // Calculate appropriate time step\r\n    const visibleDuration = viewport.end - viewport.start;\r\n    let timeStep;\r\n    \r\n    if (visibleDuration > 300) timeStep = 60;      // 1 minute\r\n    else if (visibleDuration > 60) timeStep = 10;  // 10 seconds\r\n    else if (visibleDuration > 10) timeStep = 1;   // 1 second\r\n    else if (visibleDuration > 1) timeStep = 0.1;  // 100ms\r\n    else timeStep = 0.01;                          // 10ms\r\n    \r\n    // Draw time markers\r\n    for (let time = Math.ceil(viewport.start / timeStep) * timeStep; \r\n         time <= viewport.end; \r\n         time += timeStep) {\r\n      const pixel = this.viewportManager.timeToPixel(time);\r\n      \r\n      if (pixel >= 0 && pixel <= width) {\r\n        // Draw tick mark\r\n        ctx.strokeStyle = options.tickColor || 'rgba(255, 255, 255, 0.3)';\r\n        ctx.lineWidth = 1;\r\n        ctx.beginPath();\r\n        ctx.moveTo(pixel, height - 10);\r\n        ctx.lineTo(pixel, height);\r\n        ctx.stroke();\r\n        \r\n        // Draw time label\r\n        const timeText = timeStep >= 1 ? `${time.toFixed(0)}s` : `${time.toFixed(2)}s`;\r\n        ctx.fillText(timeText, pixel, height - 15);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render zoom level indicator\r\n   */\r\n  renderZoomIndicator(ctx, width, height, options) {\r\n    const zoomLevel = this.viewportManager.getState().zoomLevel;\r\n    \r\n    ctx.fillStyle = options.zoomIndicatorColor || 'rgba(255, 255, 255, 0.8)';\r\n    ctx.font = options.zoomIndicatorFont || 'bold 12px monospace';\r\n    ctx.textAlign = 'right';\r\n    \r\n    const zoomText = `${zoomLevel.toFixed(1)}x`;\r\n    ctx.fillText(zoomText, width - 10, 20);\r\n  }\r\n\r\n  /**\r\n   * Schedule a render using requestAnimationFrame\r\n   */\r\n  scheduleRender() {\r\n    if (this.animationFrameId) return;\r\n    \r\n    this.animationFrameId = requestAnimationFrame(() => {\r\n      this.performRender();\r\n      this.animationFrameId = null;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Perform the actual rendering\r\n   */\r\n  performRender() {\r\n    if (this.isRendering) return;\r\n    \r\n    this.isRendering = true;\r\n    const startTime = performance.now();\r\n    \r\n    try {\r\n      // Process render queue\r\n      while (this.renderQueue.length > 0) {\r\n        const renderTask = this.renderQueue.shift();\r\n        renderTask();\r\n      }\r\n      \r\n      // Update FPS metrics\r\n      this.updateFPSMetrics(startTime);\r\n      \r\n    } finally {\r\n      this.isRendering = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a render task to the queue\r\n   */\r\n  queueRender(renderTask) {\r\n    this.renderQueue.push(renderTask);\r\n    this.scheduleRender();\r\n  }\r\n\r\n  /**\r\n   * Update performance metrics\r\n   */\r\n  updatePerformanceMetrics(operation, startTime, elementCount) {\r\n    const endTime = performance.now();\r\n    this.performanceMetrics.renderTime = endTime - startTime;\r\n    \r\n    // Track specific operation metrics\r\n    if (!this.performanceMetrics[operation]) {\r\n      this.performanceMetrics[operation] = {\r\n        totalTime: 0,\r\n        callCount: 0,\r\n        averageTime: 0\r\n      };\r\n    }\r\n    \r\n    const opMetrics = this.performanceMetrics[operation];\r\n    opMetrics.totalTime += this.performanceMetrics.renderTime;\r\n    opMetrics.callCount++;\r\n    opMetrics.averageTime = opMetrics.totalTime / opMetrics.callCount;\r\n  }\r\n\r\n  /**\r\n   * Update FPS metrics\r\n   */\r\n  updateFPSMetrics(startTime) {\r\n    const now = performance.now();\r\n    const frameTime = now - this.performanceMetrics.lastFrameTime;\r\n    \r\n    if (frameTime > 0 && this.performanceMetrics.lastFrameTime > 0) {\r\n      const fps = 1000 / frameTime;\r\n      this.performanceMetrics.frameCount++;\r\n      \r\n      // Calculate rolling average FPS\r\n      const alpha = 0.1; // Smoothing factor\r\n      if (this.performanceMetrics.averageFPS === 0) {\r\n        this.performanceMetrics.averageFPS = fps;\r\n      } else {\r\n        this.performanceMetrics.averageFPS = \r\n          this.performanceMetrics.averageFPS * (1 - alpha) + fps * alpha;\r\n      }\r\n    }\r\n    \r\n    this.performanceMetrics.lastFrameTime = now;\r\n  }\r\n\r\n  /**\r\n   * Get current performance metrics\r\n   */\r\n  getPerformanceMetrics() {\r\n    return { ...this.performanceMetrics };\r\n  }\r\n\r\n  /**\r\n   * Reset performance metrics\r\n   */\r\n  resetPerformanceMetrics() {\r\n    this.performanceMetrics = {\r\n      frameCount: 0,\r\n      lastFrameTime: performance.now(),\r\n      averageFPS: 0,\r\n      renderTime: 0,\r\n      culledElements: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Set rendering quality\r\n   */\r\n  setRenderQuality(quality) {\r\n    this.options.renderQuality = quality;\r\n    this.layerManager.markAllLayersDirty();\r\n    this.scheduleRender();\r\n  }\r\n\r\n  /**\r\n   * Enable or disable viewport culling\r\n   */\r\n  setViewportCulling(enabled) {\r\n    this.options.enableViewportCulling = enabled;\r\n    this.layerManager.markAllLayersDirty();\r\n    this.scheduleRender();\r\n  }\r\n\r\n  /**\r\n   * Resize renderer\r\n   */\r\n  resize(width, height) {\r\n    this.layerManager.updateDimensions();\r\n    this.viewportManager.setCanvasDimensions(width, height);\r\n    this.scheduleRender();\r\n  }\r\n\r\n  /**\r\n   * Get layer manager instance\r\n   */\r\n  getLayerManager() {\r\n    return this.layerManager;\r\n  }\r\n\r\n  /**\r\n   * Get viewport manager instance\r\n   */\r\n  getViewportManager() {\r\n    return this.viewportManager;\r\n  }\r\n\r\n  /**\r\n   * Destroy renderer and cleanup resources\r\n   */\r\n  destroy() {\r\n    if (this.animationFrameId) {\r\n      cancelAnimationFrame(this.animationFrameId);\r\n      this.animationFrameId = null;\r\n    }\r\n    \r\n    this.renderQueue = [];\r\n    this.drawingCache.clear();\r\n    this.pathCache.clear();\r\n    \r\n    this.layerManager.destroy();\r\n    this.isRendering = false;\r\n  }\r\n}\r\n\r\nexport default CanvasRenderer;"],"names":["CanvasLayerManager","constructor","this","layers","Map","container","dimensions","width","height","dpr","window","devicePixelRatio","initialize","updateDimensions","rect","getBoundingClientRect","forEach","layer","resizeLayer","createLayer","name","zIndex","options","has","get","canvas","document","createElement","ctx","getContext","alpha","desynchronized","contextOptions","Error","visible","dirty","setupLayer","set","style","position","top","left","pointerEvents","configureContext","appendChild","scale","imageSmoothingEnabled","smoothing","textBaseline","textAlign","fillStyle","strokeStyle","lineWidth","lineCap","lineJoin","getLayer","removeLayer","parentNode","removeChild","delete","clearLayer","clearRect","clearAllLayers","setLayerVisibility","display","setLayerZIndex","markLayerDirty","markAllLayersDirty","isLayerDirty","markLayerClean","getLayerNames","Array","from","keys","getLayersSorted","values","sort","a","b","enableLayerInteraction","disableLayerInteraction","destroy","clear","getDimensions","getDevicePixelRatio","ViewportManager","initialState","state","zoomLevel","centerTime","visibleTimeRange","start","end","pixelsPerSecond","canvasDimensions","audioDuration","minZoom","maxZoom","listeners","Set","updateVisibleRange","addListener","callback","add","notifyListeners","setCanvasDimensions","setAudioDuration","duration","visibleDuration","halfDuration","startTime","endTime","Math","min","max","setZoom","zoomIn","factor","zoomOut","zoomToFit","requiredPixelsPerSecond","panToTime","targetTime","panBy","deltaTime","panByPixels","deltaPixels","timeToPixel","time","pixelToTime","pixel","relativePixel","isTimeVisible","isRangeVisible","getViewportBounds","getState","reset","setLimits","calculateZoomForRange","padding","paddedDuration","zoomToRange","getDetailLevel","getRenderingConfig","detailLevel","config","showSamplePoints","showZeroCrossings","showGrid","waveformResolution","antialiasing","getZoomPresets","description","filter","preset","getNavigationInfo","visiblePercentage","startPercentage","endPercentage","canZoomIn","canZoomOut","canPanLeft","canPanRight","smartZoom","mouseTime","newZoomLevel","clampedZoom","hitLimit","limitType","getOptimalZoomForSelection","targetPercentage","CanvasRenderer","enableViewportCulling","enableBatching","maxBatchSize","renderQuality","enableAntialiasing","layerManager","viewportManager","performanceMetrics","frameCount","lastFrameTime","averageFPS","renderTime","culledElements","isRendering","renderQueue","animationFrameId","drawingCache","pathCache","createStandardLayers","viewport","handleViewportChange","scheduleRender","renderWaveform","waveformData","performance","now","renderingConfig","enhancedOptions","quality","visibleSamples","cullWaveformData","length","updatePerformanceMetrics","renderMethod","selectOptimalRenderMethod","configureWaveformContext","renderGrid","renderWaveformSamples","renderWaveformPeaks","renderWaveformBars","renderWaveformLine","renderZeroCrossings","resolution","samples","sampleRate","startSample","floor","endSample","ceil","bufferSamples","cullStart","cullEnd","culledSamples","slice","downsampledSamples","i","sum","count","j","push","sqrt","sign","startIndex","endIndex","samplesPerPixel","gradient","createLinearGradient","addColorStop","topColor","centerColor","bottomColor","strokeColor","centerY","beginPath","x","sampleStart","sampleEnd","sample","minY","maxY","moveTo","lineTo","stroke","barWidth","barHeight","abs","fillRect","stepX","y","closePath","globalAlpha","fill","arc","PI","prevY","gridInterval","setLineDash","prev","curr","renderChops","chops","selectedChopId","visibleChops","cullChops","chop","index","renderSingleChop","isSelected","id","isHovered","hoveredChopId","isActive","activeChopId","allChops","startPixel","endPixel","clampedStart","chopWidth","color","generateChopColor","baseAlpha","borderAlpha","pulseOffset","sin","Date","hexToRgba","renderChopBoundaries","renderChopRelationships","renderChopLabel","renderDurationIndicator","shadowBlur","shadowColor","renderBoundaryIndicator","renderActiveChopAnimation","type","size","direction","pulseAlpha","lineDashOffset","analyzeChopRelationships","relationship","renderRelationshipIndicator","currentChop","relationships","otherChop","gap","severity","calculateOverlapSeverity","chop1","chop2","overlapStart","overlapDuration","chop1Duration","chop2Duration","otherStartPixel","otherEndPixel","renderOverlapIndicator","renderAdjacencyIndicator","start1","end1","start2","end2","overlapEnd","warningColor","connectionPoint","otherPoint","startX","centerX","labelText","padId","fontSize","fontWeight","font","textWidth","measureText","bgWidth","bgHeight","strokeRect","fillText","durationText","toFixed","hex","startsWith","replace","result","exec","parseInt","chopId","hash","charCodeAt","renderPlayhead","currentTime","isPlaying","playheadPixel","indicatorSize","showTime","timeText","strokeText","renderUI","renderTimeScale","showZoomIndicator","renderZoomIndicator","textColor","timeStep","tickColor","zoomIndicatorColor","zoomIndicatorFont","zoomText","requestAnimationFrame","performRender","shift","renderTask","updateFPSMetrics","queueRender","operation","elementCount","totalTime","callCount","averageTime","opMetrics","frameTime","fps","getPerformanceMetrics","resetPerformanceMetrics","setRenderQuality","setViewportCulling","enabled","resize","getLayerManager","getViewportManager","cancelAnimationFrame"],"mappings":"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"}