{"version":3,"file":"InteractionManager-Bm6YdUAt.js","sources":["../../src/services/ZeroCrossingDetector.js","../../src/services/SmartSnapping.js","../../src/components/waveform/InteractionManager.js"],"sourcesContent":["/**\r\n * Zero-crossing detection service for clean sample cuts\r\n * Implements requirement 3.3 - zero-crossing detection algorithm\r\n */\r\n\r\nexport class ZeroCrossingDetector {\r\n  constructor(options = {}) {\r\n    this.options = {\r\n      // Minimum distance between zero-crossings (in samples)\r\n      minDistance: 32,\r\n      // Amplitude threshold for considering a zero-crossing significant\r\n      amplitudeThreshold: 0.01,\r\n      // Window size for analyzing zero-crossing quality\r\n      analysisWindow: 64,\r\n      // Maximum search distance from target time (in seconds)\r\n      maxSearchDistance: 0.1,\r\n      ...options\r\n    };\r\n    \r\n    // Cache for zero-crossing data\r\n    this.zeroCrossingCache = new Map();\r\n  }\r\n\r\n  /**\r\n   * Find zero-crossings in waveform data\r\n   * @param {Float32Array} samples - Audio sample data\r\n   * @param {number} sampleRate - Sample rate in Hz\r\n   * @returns {Array} Array of zero-crossing positions (in sample indices)\r\n   */\r\n  findZeroCrossings(samples, sampleRate) {\r\n    const cacheKey = this.generateCacheKey(samples, sampleRate);\r\n    \r\n    if (this.zeroCrossingCache.has(cacheKey)) {\r\n      return this.zeroCrossingCache.get(cacheKey);\r\n    }\r\n\r\n    const zeroCrossings = [];\r\n    const { minDistance, amplitudeThreshold, analysisWindow } = this.options;\r\n    \r\n    let lastZeroCrossing = -minDistance;\r\n    \r\n    for (let i = 1; i < samples.length; i++) {\r\n      const prevSample = samples[i - 1];\r\n      const currentSample = samples[i];\r\n      \r\n      // Check for sign change (zero-crossing)\r\n      if ((prevSample <= 0 && currentSample > 0) || (prevSample >= 0 && currentSample < 0)) {\r\n        // Ensure minimum distance from last zero-crossing\r\n        if (i - lastZeroCrossing >= minDistance) {\r\n          // Analyze the quality of this zero-crossing\r\n          const quality = this.analyzeZeroCrossingQuality(samples, i, analysisWindow, amplitudeThreshold);\r\n          \r\n          if (quality.isSignificant) {\r\n            zeroCrossings.push({\r\n              sampleIndex: i,\r\n              time: i / sampleRate,\r\n              quality: quality.score,\r\n              amplitude: Math.abs(currentSample),\r\n              slope: Math.abs(currentSample - prevSample)\r\n            });\r\n            \r\n            lastZeroCrossing = i;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Cache the results\r\n    this.zeroCrossingCache.set(cacheKey, zeroCrossings);\r\n    \r\n    return zeroCrossings;\r\n  }\r\n\r\n  /**\r\n   * Find the nearest zero-crossing to a target time\r\n   * @param {Float32Array} samples - Audio sample data\r\n   * @param {number} sampleRate - Sample rate in Hz\r\n   * @param {number} targetTime - Target time in seconds\r\n   * @param {number} tolerance - Search tolerance in seconds\r\n   * @returns {Object|null} Nearest zero-crossing or null if none found\r\n   */\r\n  findNearestZeroCrossing(samples, sampleRate, targetTime, tolerance = null) {\r\n    const searchTolerance = tolerance || this.options.maxSearchDistance;\r\n    const zeroCrossings = this.findZeroCrossings(samples, sampleRate);\r\n    \r\n    if (zeroCrossings.length === 0) {\r\n      return null;\r\n    }\r\n    \r\n    let nearestCrossing = null;\r\n    let minDistance = Infinity;\r\n    \r\n    for (const crossing of zeroCrossings) {\r\n      const distance = Math.abs(crossing.time - targetTime);\r\n      \r\n      if (distance <= searchTolerance && distance < minDistance) {\r\n        minDistance = distance;\r\n        nearestCrossing = crossing;\r\n      }\r\n    }\r\n    \r\n    return nearestCrossing;\r\n  }\r\n\r\n  /**\r\n   * Find optimal cut points within a time range\r\n   * @param {Float32Array} samples - Audio sample data\r\n   * @param {number} sampleRate - Sample rate in Hz\r\n   * @param {number} startTime - Start time in seconds\r\n   * @param {number} endTime - End time in seconds\r\n   * @returns {Object} Optimal start and end cut points\r\n   */\r\n  findOptimalCutPoints(samples, sampleRate, startTime, endTime) {\r\n    const startSample = Math.floor(startTime * sampleRate);\r\n    const endSample = Math.floor(endTime * sampleRate);\r\n    \r\n    // Find zero-crossings near the boundaries\r\n    const startZeroCrossing = this.findNearestZeroCrossing(samples, sampleRate, startTime);\r\n    const endZeroCrossing = this.findNearestZeroCrossing(samples, sampleRate, endTime);\r\n    \r\n    const result = {\r\n      originalStart: startTime,\r\n      originalEnd: endTime,\r\n      optimizedStart: startTime,\r\n      optimizedEnd: endTime,\r\n      startImprovement: 0,\r\n      endImprovement: 0,\r\n      quality: 'original'\r\n    };\r\n    \r\n    // Apply start boundary optimization\r\n    if (startZeroCrossing) {\r\n      const improvement = this.calculateCutQualityImprovement(\r\n        samples, startSample, startZeroCrossing.sampleIndex\r\n      );\r\n      \r\n      if (improvement > 0.1) { // Only apply if significant improvement\r\n        result.optimizedStart = startZeroCrossing.time;\r\n        result.startImprovement = improvement;\r\n      }\r\n    }\r\n    \r\n    // Apply end boundary optimization\r\n    if (endZeroCrossing) {\r\n      const improvement = this.calculateCutQualityImprovement(\r\n        samples, endSample, endZeroCrossing.sampleIndex\r\n      );\r\n      \r\n      if (improvement > 0.1) { // Only apply if significant improvement\r\n        result.optimizedEnd = endZeroCrossing.time;\r\n        result.endImprovement = improvement;\r\n      }\r\n    }\r\n    \r\n    // Determine overall quality\r\n    if (result.startImprovement > 0 || result.endImprovement > 0) {\r\n      const avgImprovement = (result.startImprovement + result.endImprovement) / 2;\r\n      if (avgImprovement > 0.7) {\r\n        result.quality = 'excellent';\r\n      } else if (avgImprovement > 0.4) {\r\n        result.quality = 'good';\r\n      } else {\r\n        result.quality = 'improved';\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Analyze the quality of a zero-crossing\r\n   * @param {Float32Array} samples - Audio sample data\r\n   * @param {number} crossingIndex - Index of the zero-crossing\r\n   * @param {number} windowSize - Analysis window size\r\n   * @param {number} threshold - Amplitude threshold\r\n   * @returns {Object} Quality analysis result\r\n   */\r\n  analyzeZeroCrossingQuality(samples, crossingIndex, windowSize, threshold) {\r\n    const halfWindow = Math.floor(windowSize / 2);\r\n    const startIndex = Math.max(0, crossingIndex - halfWindow);\r\n    const endIndex = Math.min(samples.length - 1, crossingIndex + halfWindow);\r\n    \r\n    // Calculate RMS amplitude in the analysis window\r\n    let rmsSum = 0;\r\n    let sampleCount = 0;\r\n    \r\n    for (let i = startIndex; i <= endIndex; i++) {\r\n      rmsSum += samples[i] * samples[i];\r\n      sampleCount++;\r\n    }\r\n    \r\n    const rmsAmplitude = Math.sqrt(rmsSum / sampleCount);\r\n    \r\n    // Calculate slope at zero-crossing\r\n    const prevSample = samples[crossingIndex - 1] || 0;\r\n    const nextSample = samples[crossingIndex + 1] || 0;\r\n    const slope = Math.abs(nextSample - prevSample);\r\n    \r\n    // Calculate quality score (0-1)\r\n    const amplitudeScore = Math.min(rmsAmplitude / threshold, 1.0);\r\n    const slopeScore = Math.min(slope * 10, 1.0); // Normalize slope\r\n    const qualityScore = (amplitudeScore + slopeScore) / 2;\r\n    \r\n    return {\r\n      isSignificant: rmsAmplitude >= threshold && slope > 0.001,\r\n      score: qualityScore,\r\n      rmsAmplitude,\r\n      slope,\r\n      windowStart: startIndex,\r\n      windowEnd: endIndex\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate improvement in cut quality when moving from original to zero-crossing\r\n   * @param {Float32Array} samples - Audio sample data\r\n   * @param {number} originalIndex - Original cut sample index\r\n   * @param {number} zeroCrossingIndex - Zero-crossing sample index\r\n   * @returns {number} Improvement score (0-1)\r\n   */\r\n  calculateCutQualityImprovement(samples, originalIndex, zeroCrossingIndex) {\r\n    if (originalIndex < 0 || originalIndex >= samples.length ||\r\n        zeroCrossingIndex < 0 || zeroCrossingIndex >= samples.length) {\r\n      return 0;\r\n    }\r\n    \r\n    // Calculate click/pop potential at original position\r\n    const originalAmplitude = Math.abs(samples[originalIndex]);\r\n    const originalClickPotential = originalAmplitude;\r\n    \r\n    // Zero-crossings have minimal click potential\r\n    const zeroCrossingClickPotential = 0.01;\r\n    \r\n    // Calculate improvement (reduction in click potential)\r\n    const improvement = Math.max(0, originalClickPotential - zeroCrossingClickPotential);\r\n    \r\n    // Normalize to 0-1 scale\r\n    return Math.min(improvement * 2, 1.0);\r\n  }\r\n\r\n  /**\r\n   * Get zero-crossings within a specific time range\r\n   * @param {Float32Array} samples - Audio sample data\r\n   * @param {number} sampleRate - Sample rate in Hz\r\n   * @param {number} startTime - Start time in seconds\r\n   * @param {number} endTime - End time in seconds\r\n   * @returns {Array} Zero-crossings within the time range\r\n   */\r\n  getZeroCrossingsInRange(samples, sampleRate, startTime, endTime) {\r\n    const zeroCrossings = this.findZeroCrossings(samples, sampleRate);\r\n    \r\n    return zeroCrossings.filter(crossing => \r\n      crossing.time >= startTime && crossing.time <= endTime\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Generate cache key for waveform data\r\n   * @param {Float32Array} samples - Audio sample data\r\n   * @param {number} sampleRate - Sample rate in Hz\r\n   * @returns {string} Cache key\r\n   */\r\n  generateCacheKey(samples, sampleRate) {\r\n    // Create a simple hash based on sample data characteristics\r\n    const sampleCount = samples.length;\r\n    const checksum = samples.reduce((sum, sample, index) => {\r\n      if (index % 1000 === 0) { // Sample every 1000th sample for performance\r\n        return sum + Math.abs(sample);\r\n      }\r\n      return sum;\r\n    }, 0);\r\n    \r\n    return `${sampleCount}_${sampleRate}_${checksum.toFixed(6)}`;\r\n  }\r\n\r\n  /**\r\n   * Clear the zero-crossing cache\r\n   */\r\n  clearCache() {\r\n    this.zeroCrossingCache.clear();\r\n  }\r\n\r\n  /**\r\n   * Get cache statistics\r\n   * @returns {Object} Cache statistics\r\n   */\r\n  getCacheStats() {\r\n    return {\r\n      size: this.zeroCrossingCache.size,\r\n      keys: Array.from(this.zeroCrossingCache.keys())\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Update detector options\r\n   * @param {Object} newOptions - New options to merge\r\n   */\r\n  updateOptions(newOptions) {\r\n    this.options = { ...this.options, ...newOptions };\r\n    // Clear cache when options change as results may be different\r\n    this.clearCache();\r\n  }\r\n}\r\n\r\nexport default ZeroCrossingDetector;","/**\r\n * Smart snapping service for waveform interactions\r\n * Implements requirement 3.4 - smart snapping with configurable tolerance\r\n */\r\n\r\nimport { ZeroCrossingDetector } from './ZeroCrossingDetector.js';\r\n\r\nexport class SmartSnapping {\r\n  constructor(options = {}) {\r\n    this.options = {\r\n      // Snap tolerance in pixels\r\n      snapTolerance: 10,\r\n      // Snap tolerance in seconds (fallback when pixel conversion not available)\r\n      snapToleranceTime: 0.05,\r\n      // Enable different snap types\r\n      enableZeroCrossingSnap: true,\r\n      enableChopBoundarySnap: true,\r\n      enableGridSnap: false,\r\n      enableBeatSnap: false,\r\n      // Snap priorities (higher number = higher priority)\r\n      snapPriorities: {\r\n        zeroCrossing: 3,\r\n        chopBoundary: 2,\r\n        grid: 1,\r\n        beat: 1\r\n      },\r\n      // Visual feedback options\r\n      showSnapIndicators: true,\r\n      snapIndicatorColor: 'rgba(255, 165, 0, 0.8)',\r\n      snapIndicatorWidth: 2,\r\n      // Zero-crossing detector options\r\n      zeroCrossingOptions: {\r\n        minDistance: 32,\r\n        amplitudeThreshold: 0.01,\r\n        analysisWindow: 64,\r\n        maxSearchDistance: 0.1\r\n      },\r\n      ...options\r\n    };\r\n\r\n    // Initialize zero-crossing detector\r\n    this.zeroCrossingDetector = new ZeroCrossingDetector(this.options.zeroCrossingOptions);\r\n    \r\n    // Current snap targets\r\n    this.snapTargets = [];\r\n    \r\n    // Current waveform data\r\n    this.waveformData = null;\r\n    this.chops = [];\r\n  }\r\n\r\n  /**\r\n   * Update waveform data for zero-crossing detection\r\n   * @param {Object} waveformData - Waveform data with samples and sample rate\r\n   */\r\n  setWaveformData(waveformData) {\r\n    this.waveformData = waveformData;\r\n    \r\n    // Pre-calculate zero-crossings if data is available\r\n    if (waveformData?.samples && waveformData?.sampleRate) {\r\n      this.zeroCrossingDetector.findZeroCrossings(\r\n        waveformData.samples, \r\n        waveformData.sampleRate\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update chop data for boundary snapping\r\n   * @param {Array} chops - Array of chop objects\r\n   */\r\n  setChops(chops) {\r\n    this.chops = chops || [];\r\n  }\r\n\r\n  /**\r\n   * Find the best snap target for a given time position\r\n   * @param {number} targetTime - Target time in seconds\r\n   * @param {number} pixelsPerSecond - Current viewport pixels per second\r\n   * @param {string} excludeChopId - Chop ID to exclude from boundary snapping\r\n   * @returns {Object|null} Best snap target or null if none found\r\n   */\r\n  findSnapTarget(targetTime, pixelsPerSecond = null, excludeChopId = null) {\r\n    const snapTargets = this.findAllSnapTargets(targetTime, pixelsPerSecond, excludeChopId);\r\n    \r\n    if (snapTargets.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    // Sort by priority and distance\r\n    snapTargets.sort((a, b) => {\r\n      // First sort by priority (higher is better)\r\n      if (a.priority !== b.priority) {\r\n        return b.priority - a.priority;\r\n      }\r\n      // Then sort by distance (closer is better)\r\n      return a.distance - b.distance;\r\n    });\r\n\r\n    return snapTargets[0];\r\n  }\r\n\r\n  /**\r\n   * Find all potential snap targets for a given time position\r\n   * @param {number} targetTime - Target time in seconds\r\n   * @param {number} pixelsPerSecond - Current viewport pixels per second\r\n   * @param {string} excludeChopId - Chop ID to exclude from boundary snapping\r\n   * @returns {Array} Array of snap targets\r\n   */\r\n  findAllSnapTargets(targetTime, pixelsPerSecond = null, excludeChopId = null) {\r\n    const snapTargets = [];\r\n    const tolerance = this.calculateSnapTolerance(pixelsPerSecond);\r\n\r\n    // Find zero-crossing snap targets\r\n    if (this.options.enableZeroCrossingSnap && this.waveformData) {\r\n      const zeroCrossingTarget = this.findZeroCrossingSnapTarget(targetTime, tolerance);\r\n      if (zeroCrossingTarget) {\r\n        snapTargets.push(zeroCrossingTarget);\r\n      }\r\n    }\r\n\r\n    // Find chop boundary snap targets\r\n    if (this.options.enableChopBoundarySnap) {\r\n      const boundaryTargets = this.findChopBoundarySnapTargets(targetTime, tolerance, excludeChopId);\r\n      snapTargets.push(...boundaryTargets);\r\n    }\r\n\r\n    // Find grid snap targets (if enabled)\r\n    if (this.options.enableGridSnap) {\r\n      const gridTarget = this.findGridSnapTarget(targetTime, tolerance);\r\n      if (gridTarget) {\r\n        snapTargets.push(gridTarget);\r\n      }\r\n    }\r\n\r\n    return snapTargets;\r\n  }\r\n\r\n  /**\r\n   * Find zero-crossing snap target\r\n   * @param {number} targetTime - Target time in seconds\r\n   * @param {number} tolerance - Snap tolerance in seconds\r\n   * @returns {Object|null} Zero-crossing snap target or null\r\n   */\r\n  findZeroCrossingSnapTarget(targetTime, tolerance) {\r\n    if (!this.waveformData?.samples || !this.waveformData?.sampleRate) {\r\n      return null;\r\n    }\r\n\r\n    const nearestZeroCrossing = this.zeroCrossingDetector.findNearestZeroCrossing(\r\n      this.waveformData.samples,\r\n      this.waveformData.sampleRate,\r\n      targetTime,\r\n      tolerance\r\n    );\r\n\r\n    if (!nearestZeroCrossing) {\r\n      return null;\r\n    }\r\n\r\n    const distance = Math.abs(nearestZeroCrossing.time - targetTime);\r\n\r\n    return {\r\n      type: 'zero-crossing',\r\n      time: nearestZeroCrossing.time,\r\n      distance,\r\n      priority: this.options.snapPriorities.zeroCrossing,\r\n      quality: nearestZeroCrossing.quality,\r\n      data: nearestZeroCrossing\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Find chop boundary snap targets\r\n   * @param {number} targetTime - Target time in seconds\r\n   * @param {number} tolerance - Snap tolerance in seconds\r\n   * @param {string} excludeChopId - Chop ID to exclude\r\n   * @returns {Array} Array of boundary snap targets\r\n   */\r\n  findChopBoundarySnapTargets(targetTime, tolerance, excludeChopId = null) {\r\n    const targets = [];\r\n\r\n    for (const chop of this.chops) {\r\n      if (chop.id === excludeChopId) continue;\r\n\r\n      // Check start boundary\r\n      const startDistance = Math.abs(chop.startTime - targetTime);\r\n      if (startDistance <= tolerance) {\r\n        targets.push({\r\n          type: 'chop-boundary',\r\n          subType: 'start',\r\n          time: chop.startTime,\r\n          distance: startDistance,\r\n          priority: this.options.snapPriorities.chopBoundary,\r\n          chopId: chop.id,\r\n          data: chop\r\n        });\r\n      }\r\n\r\n      // Check end boundary\r\n      const endDistance = Math.abs(chop.endTime - targetTime);\r\n      if (endDistance <= tolerance) {\r\n        targets.push({\r\n          type: 'chop-boundary',\r\n          subType: 'end',\r\n          time: chop.endTime,\r\n          distance: endDistance,\r\n          priority: this.options.snapPriorities.chopBoundary,\r\n          chopId: chop.id,\r\n          data: chop\r\n        });\r\n      }\r\n    }\r\n\r\n    return targets;\r\n  }\r\n\r\n  /**\r\n   * Find grid snap target (for regular time intervals)\r\n   * @param {number} targetTime - Target time in seconds\r\n   * @param {number} tolerance - Snap tolerance in seconds\r\n   * @returns {Object|null} Grid snap target or null\r\n   */\r\n  findGridSnapTarget(targetTime, tolerance) {\r\n    // Default grid interval (can be made configurable)\r\n    const gridInterval = 1.0; // 1 second intervals\r\n    \r\n    const nearestGridTime = Math.round(targetTime / gridInterval) * gridInterval;\r\n    const distance = Math.abs(nearestGridTime - targetTime);\r\n\r\n    if (distance <= tolerance) {\r\n      return {\r\n        type: 'grid',\r\n        time: nearestGridTime,\r\n        distance,\r\n        priority: this.options.snapPriorities.grid,\r\n        interval: gridInterval\r\n      };\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Apply smart snapping to a time position\r\n   * @param {number} targetTime - Target time in seconds\r\n   * @param {number} pixelsPerSecond - Current viewport pixels per second\r\n   * @param {string} excludeChopId - Chop ID to exclude from boundary snapping\r\n   * @returns {Object} Snapping result with snapped time and snap info\r\n   */\r\n  applySnapping(targetTime, pixelsPerSecond = null, excludeChopId = null) {\r\n    const snapTarget = this.findSnapTarget(targetTime, pixelsPerSecond, excludeChopId);\r\n\r\n    if (snapTarget) {\r\n      return {\r\n        originalTime: targetTime,\r\n        snappedTime: snapTarget.time,\r\n        wasSnapped: true,\r\n        snapTarget,\r\n        snapDistance: snapTarget.distance\r\n      };\r\n    }\r\n\r\n    return {\r\n      originalTime: targetTime,\r\n      snappedTime: targetTime,\r\n      wasSnapped: false,\r\n      snapTarget: null,\r\n      snapDistance: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get visual snap indicators for rendering\r\n   * @param {number} targetTime - Target time in seconds\r\n   * @param {number} pixelsPerSecond - Current viewport pixels per second\r\n   * @param {string} excludeChopId - Chop ID to exclude from boundary snapping\r\n   * @returns {Array} Array of snap indicators for rendering\r\n   */\r\n  getSnapIndicators(targetTime, pixelsPerSecond = null, excludeChopId = null) {\r\n    if (!this.options.showSnapIndicators) {\r\n      return [];\r\n    }\r\n\r\n    const snapTargets = this.findAllSnapTargets(targetTime, pixelsPerSecond, excludeChopId);\r\n    const tolerance = this.calculateSnapTolerance(pixelsPerSecond);\r\n\r\n    return snapTargets\r\n      .filter(target => target.distance <= tolerance)\r\n      .map(target => ({\r\n        type: target.type,\r\n        time: target.time,\r\n        priority: target.priority,\r\n        color: this.getSnapIndicatorColor(target.type),\r\n        width: this.options.snapIndicatorWidth,\r\n        style: this.getSnapIndicatorStyle(target.type),\r\n        label: this.getSnapIndicatorLabel(target)\r\n      }));\r\n  }\r\n\r\n  /**\r\n   * Get snap indicator color based on snap type\r\n   * @param {string} snapType - Type of snap target\r\n   * @returns {string} Color string\r\n   */\r\n  getSnapIndicatorColor(snapType) {\r\n    const colors = {\r\n      'zero-crossing': 'rgba(34, 197, 94, 0.8)', // Green\r\n      'chop-boundary': 'rgba(59, 130, 246, 0.8)', // Blue\r\n      'grid': 'rgba(156, 163, 175, 0.6)', // Gray\r\n      'beat': 'rgba(245, 101, 101, 0.8)' // Red\r\n    };\r\n\r\n    return colors[snapType] || this.options.snapIndicatorColor;\r\n  }\r\n\r\n  /**\r\n   * Get snap indicator style based on snap type\r\n   * @param {string} snapType - Type of snap target\r\n   * @returns {string} Style identifier\r\n   */\r\n  getSnapIndicatorStyle(snapType) {\r\n    const styles = {\r\n      'zero-crossing': 'solid',\r\n      'chop-boundary': 'dashed',\r\n      'grid': 'dotted',\r\n      'beat': 'solid'\r\n    };\r\n\r\n    return styles[snapType] || 'solid';\r\n  }\r\n\r\n  /**\r\n   * Get snap indicator label\r\n   * @param {Object} snapTarget - Snap target object\r\n   * @returns {string} Label text\r\n   */\r\n  getSnapIndicatorLabel(snapTarget) {\r\n    switch (snapTarget.type) {\r\n      case 'zero-crossing':\r\n        return `Zero crossing (${snapTarget.time.toFixed(3)}s)`;\r\n      case 'chop-boundary':\r\n        return `Chop ${snapTarget.subType} (${snapTarget.time.toFixed(3)}s)`;\r\n      case 'grid':\r\n        return `Grid (${snapTarget.time.toFixed(1)}s)`;\r\n      case 'beat':\r\n        return `Beat (${snapTarget.time.toFixed(3)}s)`;\r\n      default:\r\n        return `Snap (${snapTarget.time.toFixed(3)}s)`;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate snap tolerance in seconds based on viewport\r\n   * @param {number} pixelsPerSecond - Current viewport pixels per second\r\n   * @returns {number} Snap tolerance in seconds\r\n   */\r\n  calculateSnapTolerance(pixelsPerSecond) {\r\n    if (pixelsPerSecond && pixelsPerSecond > 0) {\r\n      return this.options.snapTolerance / pixelsPerSecond;\r\n    }\r\n    return this.options.snapToleranceTime;\r\n  }\r\n\r\n  /**\r\n   * Update snapping options\r\n   * @param {Object} newOptions - New options to merge\r\n   */\r\n  updateOptions(newOptions) {\r\n    this.options = { ...this.options, ...newOptions };\r\n    \r\n    // Update zero-crossing detector options if provided\r\n    if (newOptions.zeroCrossingOptions) {\r\n      this.zeroCrossingDetector.updateOptions(newOptions.zeroCrossingOptions);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current snapping configuration\r\n   * @returns {Object} Current options\r\n   */\r\n  getOptions() {\r\n    return { ...this.options };\r\n  }\r\n\r\n  /**\r\n   * Enable or disable specific snap types\r\n   * @param {Object} snapTypes - Object with snap type keys and boolean values\r\n   */\r\n  setSnapTypes(snapTypes) {\r\n    Object.keys(snapTypes).forEach(key => {\r\n      const optionKey = `enable${key.charAt(0).toUpperCase() + key.slice(1)}Snap`;\r\n      if (this.options.hasOwnProperty(optionKey)) {\r\n        this.options[optionKey] = snapTypes[key];\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get statistics about current snap targets\r\n   * @returns {Object} Statistics object\r\n   */\r\n  getSnapStatistics() {\r\n    const stats = {\r\n      zeroCrossings: 0,\r\n      chopBoundaries: this.chops.length * 2,\r\n      cacheStats: this.zeroCrossingDetector.getCacheStats()\r\n    };\r\n\r\n    if (this.waveformData?.samples && this.waveformData?.sampleRate) {\r\n      const zeroCrossings = this.zeroCrossingDetector.findZeroCrossings(\r\n        this.waveformData.samples,\r\n        this.waveformData.sampleRate\r\n      );\r\n      stats.zeroCrossings = zeroCrossings.length;\r\n    }\r\n\r\n    return stats;\r\n  }\r\n\r\n  /**\r\n   * Clear all caches\r\n   */\r\n  clearCaches() {\r\n    this.zeroCrossingDetector.clearCache();\r\n  }\r\n}\r\n\r\nexport default SmartSnapping;","/**\r\n * InteractionManager for handling mouse events on waveform canvas\r\n * Implements click-to-create-chop functionality and hover effects\r\n * Requirements: 2.1, 2.3, 5.5, 3.3, 3.4\r\n */\r\n\r\nimport { SmartSnapping } from '../../services/SmartSnapping.js';\r\n\r\nexport class InteractionManager {\r\n  constructor(canvasRenderer, options = {}) {\r\n    this.canvasRenderer = canvasRenderer;\r\n    this.options = {\r\n      clickThreshold: 5, // pixels - max movement for click vs drag\r\n      hoverDelay: 100, // ms - delay before showing hover info\r\n      snapTolerance: 10, // pixels - snap distance for boundaries\r\n      enableHover: true,\r\n      enableClick: true,\r\n      enableDrag: true,\r\n      enableSmartSnapping: true, // Enable snapping to boundaries and zero-crossings\r\n      enableVisualFeedback: true, // Enable enhanced visual feedback during drag\r\n      enableConflictPrevention: true, // Prevent overlapping chops\r\n      dragSensitivity: 1.0, // Multiplier for drag sensitivity\r\n      // Smart snapping configuration\r\n      snapToleranceTime: 0.05, // seconds\r\n      enableZeroCrossingSnap: true,\r\n      enableChopBoundarySnap: true,\r\n      showSnapIndicators: true,\r\n      ...options\r\n    };\r\n\r\n    // Initialize smart snapping service\r\n    this.smartSnapping = new SmartSnapping({\r\n      snapTolerance: this.options.snapTolerance,\r\n      snapToleranceTime: this.options.snapToleranceTime,\r\n      enableZeroCrossingSnap: this.options.enableZeroCrossingSnap,\r\n      enableChopBoundarySnap: this.options.enableChopBoundarySnap,\r\n      showSnapIndicators: this.options.showSnapIndicators\r\n    });\r\n\r\n    // Interaction state\r\n    this.isMouseDown = false;\r\n    this.isDragging = false;\r\n    this.mouseDownPosition = { x: 0, y: 0 };\r\n    this.currentMousePosition = { x: 0, y: 0 };\r\n    this.hoverTimeout = null;\r\n    this.hoveredElement = null;\r\n    \r\n    // Drag state\r\n    this.dragState = {\r\n      type: null, // 'create-chop', 'move-boundary', 'seek'\r\n      startTime: 0,\r\n      endTime: 0,\r\n      chopId: null,\r\n      boundaryType: null // 'start' or 'end'\r\n    };\r\n\r\n    // Event callbacks\r\n    this.callbacks = {\r\n      onChopCreate: null,\r\n      onChopUpdate: null,\r\n      onTimeSeek: null,\r\n      onHover: null\r\n    };\r\n\r\n    // Current waveform data for zero-crossing detection\r\n    this.waveformData = null;\r\n    \r\n    // Current snap result for visual feedback\r\n    this.currentSnapResult = null;\r\n    \r\n    // Current chops for interaction\r\n    this.currentChops = [];\r\n\r\n    this.initialize();\r\n  }\r\n\r\n  /**\r\n   * Initialize event listeners on interaction layer\r\n   */\r\n  initialize() {\r\n    const layerManager = this.canvasRenderer.getLayerManager();\r\n    const interactionLayer = layerManager.getLayer('interaction');\r\n    \r\n    if (!interactionLayer) {\r\n      console.error('InteractionManager: interaction layer not found');\r\n      return;\r\n    }\r\n\r\n    const canvas = interactionLayer.canvas;\r\n    \r\n    // Mouse event listeners\r\n    canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));\r\n    canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));\r\n    canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));\r\n    canvas.addEventListener('mouseleave', this.handleMouseLeave.bind(this));\r\n    canvas.addEventListener('wheel', this.handleWheel.bind(this));\r\n    \r\n    // Touch event listeners for mobile support\r\n    canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));\r\n    canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));\r\n    canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));\r\n    \r\n    // Prevent context menu on right click\r\n    canvas.addEventListener('contextmenu', (e) => e.preventDefault());\r\n    \r\n    // Keyboard event listeners for navigation shortcuts\r\n    // Make canvas focusable for keyboard events\r\n    canvas.tabIndex = 0;\r\n    canvas.addEventListener('keydown', this.handleKeyDown.bind(this));\r\n    canvas.addEventListener('keyup', this.handleKeyUp.bind(this));\r\n    \r\n    // Set cursor style\r\n    canvas.style.cursor = 'crosshair';\r\n    \r\n    // Track keyboard state\r\n    this.keyState = {\r\n      shift: false,\r\n      ctrl: false,\r\n      alt: false\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Set event callbacks\r\n   */\r\n  setCallbacks(callbacks) {\r\n    this.callbacks = { ...this.callbacks, ...callbacks };\r\n  }\r\n\r\n  /**\r\n   * Set waveform data for zero-crossing detection\r\n   * @param {Object} waveformData - Waveform data with samples and sample rate\r\n   */\r\n  setWaveformData(waveformData) {\r\n    this.waveformData = waveformData;\r\n    this.smartSnapping.setWaveformData(waveformData);\r\n  }\r\n\r\n  /**\r\n   * Set current chops for boundary snapping\r\n   * @param {Array} chops - Array of chop objects\r\n   */\r\n  setCurrentChops(chops) {\r\n    this.currentChops = chops || [];\r\n    this.smartSnapping.setChops(chops);\r\n  }\r\n\r\n  /**\r\n   * Get current chops\r\n   * @returns {Array} Current chops array\r\n   */\r\n  getCurrentChops() {\r\n    return this.currentChops || [];\r\n  }\r\n\r\n  /**\r\n   * Handle mouse down events\r\n   */\r\n  handleMouseDown(event) {\r\n    if (!this.options.enableClick && !this.options.enableDrag) return;\r\n    \r\n    event.preventDefault();\r\n    \r\n    const rect = event.target.getBoundingClientRect();\r\n    const x = event.clientX - rect.left;\r\n    const y = event.clientY - rect.top;\r\n    \r\n    this.isMouseDown = true;\r\n    this.mouseDownPosition = { x, y };\r\n    this.currentMousePosition = { x, y };\r\n    \r\n    // Clear any existing hover state\r\n    this.clearHover();\r\n    \r\n    // Check what was clicked\r\n    const clickedElement = this.getElementAtPosition(x, y);\r\n    \r\n    if (clickedElement) {\r\n      this.handleElementClick(clickedElement, x, y, event);\r\n    } else {\r\n      // Clicked on empty waveform area\r\n      this.initializeChopCreation(x, y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle mouse move events\r\n   */\r\n  handleMouseMove(event) {\r\n    const rect = event.target.getBoundingClientRect();\r\n    const x = event.clientX - rect.left;\r\n    const y = event.clientY - rect.top;\r\n    \r\n    this.currentMousePosition = { x, y };\r\n    \r\n    if (this.isMouseDown) {\r\n      this.handleDragMove(x, y);\r\n    } else if (this.options.enableHover) {\r\n      this.handleHoverMove(x, y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle mouse up events\r\n   */\r\n  handleMouseUp(event) {\r\n    if (!this.isMouseDown) return;\r\n    \r\n    event.preventDefault();\r\n    \r\n    const rect = event.target.getBoundingClientRect();\r\n    const x = event.clientX - rect.left;\r\n    const y = event.clientY - rect.top;\r\n    \r\n    if (this.isDragging) {\r\n      this.finalizeDrag(x, y);\r\n    } else {\r\n      this.handleClick(x, y);\r\n    }\r\n    \r\n    this.resetInteractionState();\r\n  }\r\n\r\n  /**\r\n   * Handle mouse leave events\r\n   */\r\n  handleMouseLeave(event) {\r\n    this.clearHover();\r\n    this.resetInteractionState();\r\n  }\r\n\r\n  /**\r\n   * Handle wheel events for zoom with smooth scaling transitions\r\n   * Implements requirement 4.1 - mouse wheel zoom functionality\r\n   */\r\n  handleWheel(event) {\r\n    event.preventDefault();\r\n    \r\n    const rect = event.target.getBoundingClientRect();\r\n    const x = event.clientX - rect.left;\r\n    \r\n    // Convert mouse position to time for zoom center\r\n    const viewportManager = this.canvasRenderer.getViewportManager();\r\n    const centerTime = viewportManager.pixelToTime(x);\r\n    \r\n    // Calculate zoom factor based on wheel delta and modifiers\r\n    let zoomFactor = 1.25;\r\n    \r\n    // Fine zoom with Shift key\r\n    if (event.shiftKey) {\r\n      zoomFactor = 1.1;\r\n    }\r\n    \r\n    // Coarse zoom with Ctrl key\r\n    if (event.ctrlKey) {\r\n      zoomFactor = 2.0;\r\n    }\r\n    \r\n    // Apply zoom with smooth transition\r\n    if (event.deltaY > 0) {\r\n      this.smoothZoom(viewportManager, 1 / zoomFactor, centerTime);\r\n    } else {\r\n      this.smoothZoom(viewportManager, zoomFactor, centerTime);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply smooth zoom transition\r\n   * Implements requirement 4.1 - smooth scaling transitions\r\n   */\r\n  smoothZoom(viewportManager, zoomFactor, centerTime) {\r\n    const currentZoom = viewportManager.getState().zoomLevel;\r\n    const targetZoom = currentZoom * zoomFactor;\r\n    \r\n    // Clamp to zoom limits\r\n    const { minZoom, maxZoom } = viewportManager.getState();\r\n    const clampedZoom = Math.max(minZoom, Math.min(maxZoom, targetZoom));\r\n    \r\n    if (clampedZoom === currentZoom) return; // No change needed\r\n    \r\n    // Animate zoom transition\r\n    this.animateZoom(viewportManager, currentZoom, clampedZoom, centerTime, 150);\r\n  }\r\n\r\n  /**\r\n   * Animate zoom transition over time\r\n   */\r\n  animateZoom(viewportManager, startZoom, endZoom, centerTime, duration) {\r\n    const startTime = performance.now();\r\n    \r\n    const animate = (currentTime) => {\r\n      const elapsed = currentTime - startTime;\r\n      const progress = Math.min(elapsed / duration, 1);\r\n      \r\n      // Use easeOutCubic for smooth deceleration\r\n      const easeProgress = 1 - Math.pow(1 - progress, 3);\r\n      \r\n      const currentZoom = startZoom + (endZoom - startZoom) * easeProgress;\r\n      viewportManager.setZoom(currentZoom, centerTime);\r\n      \r\n      if (progress < 1) {\r\n        requestAnimationFrame(animate);\r\n      }\r\n    };\r\n    \r\n    requestAnimationFrame(animate);\r\n  }\r\n\r\n  /**\r\n   * Get element at specific position (chop boundary, chop region, etc.)\r\n   */\r\n  getElementAtPosition(x, y) {\r\n    const viewportManager = this.canvasRenderer.getViewportManager();\r\n    const time = viewportManager.pixelToTime(x);\r\n    \r\n    // Check for chop boundaries first (higher priority)\r\n    const chops = this.getCurrentChops();\r\n    \r\n    for (const chop of chops) {\r\n      const startPixel = viewportManager.timeToPixel(chop.startTime);\r\n      const endPixel = viewportManager.timeToPixel(chop.endTime);\r\n      \r\n      // Check start boundary\r\n      if (Math.abs(x - startPixel) <= this.options.snapTolerance) {\r\n        return {\r\n          type: 'chop-boundary',\r\n          chopId: chop.id,\r\n          boundaryType: 'start',\r\n          time: chop.startTime,\r\n          pixel: startPixel\r\n        };\r\n      }\r\n      \r\n      // Check end boundary\r\n      if (Math.abs(x - endPixel) <= this.options.snapTolerance) {\r\n        return {\r\n          type: 'chop-boundary',\r\n          chopId: chop.id,\r\n          boundaryType: 'end',\r\n          time: chop.endTime,\r\n          pixel: endPixel\r\n        };\r\n      }\r\n      \r\n      // Check chop region\r\n      if (time >= chop.startTime && time <= chop.endTime) {\r\n        return {\r\n          type: 'chop-region',\r\n          chopId: chop.id,\r\n          chop: chop,\r\n          time: time,\r\n          pixel: x\r\n        };\r\n      }\r\n    }\r\n    \r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Handle click on specific elements\r\n   */\r\n  handleElementClick(element, x, y, event) {\r\n    switch (element.type) {\r\n      case 'chop-boundary':\r\n        this.initializeBoundaryDrag(element, x, y);\r\n        break;\r\n      case 'chop-region':\r\n        if (event.shiftKey) {\r\n          // Shift+click to select chop\r\n          this.selectChop(element.chopId);\r\n        } else {\r\n          // Regular click to seek to position\r\n          this.seekToTime(element.time);\r\n        }\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize chop creation drag\r\n   */\r\n  initializeChopCreation(x, y) {\r\n    const viewportManager = this.canvasRenderer.getViewportManager();\r\n    const time = viewportManager.pixelToTime(x);\r\n    \r\n    this.dragState = {\r\n      type: 'create-chop',\r\n      startTime: time,\r\n      endTime: time,\r\n      chopId: null,\r\n      boundaryType: null\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Initialize boundary drag operation\r\n   */\r\n  initializeBoundaryDrag(element, x, y) {\r\n    this.dragState = {\r\n      type: 'move-boundary',\r\n      startTime: element.time,\r\n      endTime: element.time,\r\n      chopId: element.chopId,\r\n      boundaryType: element.boundaryType\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Handle drag movement\r\n   */\r\n  handleDragMove(x, y) {\r\n    const distance = Math.sqrt(\r\n      Math.pow(x - this.mouseDownPosition.x, 2) + \r\n      Math.pow(y - this.mouseDownPosition.y, 2)\r\n    );\r\n    \r\n    if (!this.isDragging && distance > this.options.clickThreshold) {\r\n      this.isDragging = true;\r\n      this.startDrag();\r\n    }\r\n    \r\n    if (this.isDragging) {\r\n      this.updateDrag(x, y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start drag operation\r\n   */\r\n  startDrag() {\r\n    const canvas = this.canvasRenderer.getLayerManager().getLayer('interaction').canvas;\r\n    \r\n    switch (this.dragState.type) {\r\n      case 'create-chop':\r\n        canvas.style.cursor = 'col-resize';\r\n        break;\r\n      case 'move-boundary':\r\n        canvas.style.cursor = 'ew-resize';\r\n        break;\r\n      default:\r\n        canvas.style.cursor = 'grabbing';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update drag operation\r\n   */\r\n  updateDrag(x, y) {\r\n    const viewportManager = this.canvasRenderer.getViewportManager();\r\n    const currentTime = viewportManager.pixelToTime(x);\r\n    \r\n    switch (this.dragState.type) {\r\n      case 'create-chop':\r\n        this.dragState.endTime = currentTime;\r\n        this.renderDragPreview();\r\n        break;\r\n      case 'move-boundary':\r\n        this.updateBoundaryDrag(currentTime);\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update boundary drag with constraints and smart snapping\r\n   */\r\n  updateBoundaryDrag(newTime) {\r\n    const chops = this.getCurrentChops();\r\n    const chop = chops.find(c => c.id === this.dragState.chopId);\r\n    \r\n    if (!chop) return;\r\n    \r\n    // Apply smart snapping if enabled\r\n    const snappedTime = this.applySmartSnapping(newTime);\r\n    \r\n    // Apply constraints based on boundary type\r\n    if (this.dragState.boundaryType === 'start') {\r\n      // Start boundary cannot go past end boundary\r\n      this.dragState.startTime = Math.min(snappedTime, chop.endTime - 0.01);\r\n      \r\n      // Check for conflicts with other chops\r\n      const conflictingChop = this.findConflictingChop(this.dragState.startTime, chop.endTime, chop.id);\r\n      if (conflictingChop) {\r\n        this.dragState.startTime = Math.max(this.dragState.startTime, conflictingChop.endTime);\r\n      }\r\n    } else {\r\n      // End boundary cannot go before start boundary\r\n      this.dragState.endTime = Math.max(snappedTime, chop.startTime + 0.01);\r\n      \r\n      // Check for conflicts with other chops\r\n      const conflictingChop = this.findConflictingChop(chop.startTime, this.dragState.endTime, chop.id);\r\n      if (conflictingChop) {\r\n        this.dragState.endTime = Math.min(this.dragState.endTime, conflictingChop.startTime);\r\n      }\r\n    }\r\n    \r\n    this.renderDragPreview();\r\n  }\r\n\r\n  /**\r\n   * Apply smart snapping to zero-crossings and other chop boundaries\r\n   */\r\n  applySmartSnapping(time) {\r\n    if (!this.options.enableSmartSnapping) {\r\n      return time;\r\n    }\r\n\r\n    const viewportManager = this.canvasRenderer.getViewportManager();\r\n    const pixelsPerSecond = viewportManager.getViewportBounds()?.pixelsPerSecond || 80;\r\n    \r\n    // Use smart snapping service\r\n    const snapResult = this.smartSnapping.applySnapping(\r\n      time, \r\n      pixelsPerSecond, \r\n      this.dragState.chopId\r\n    );\r\n    \r\n    // Store snap information for visual feedback\r\n    this.currentSnapResult = snapResult;\r\n    \r\n    return snapResult.snappedTime;\r\n  }\r\n\r\n  /**\r\n   * Find chop that would conflict with the given time range\r\n   */\r\n  findConflictingChop(startTime, endTime, excludeChopId) {\r\n    const chops = this.getCurrentChops();\r\n    \r\n    for (const chop of chops) {\r\n      if (chop.id === excludeChopId) continue;\r\n      \r\n      // Check for overlap\r\n      if (!(endTime <= chop.startTime || startTime >= chop.endTime)) {\r\n        return chop;\r\n      }\r\n    }\r\n    \r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Render drag preview on interaction layer\r\n   */\r\n  renderDragPreview() {\r\n    const layerManager = this.canvasRenderer.getLayerManager();\r\n    const interactionLayer = layerManager.getLayer('interaction');\r\n    \r\n    if (!interactionLayer) return;\r\n    \r\n    const { ctx } = interactionLayer;\r\n    const { width, height } = layerManager.getDimensions();\r\n    const viewportManager = this.canvasRenderer.getViewportManager();\r\n    \r\n    // Clear interaction layer\r\n    layerManager.clearLayer('interaction');\r\n    \r\n    switch (this.dragState.type) {\r\n      case 'create-chop':\r\n        this.renderChopCreationPreview(ctx, viewportManager, width, height);\r\n        break;\r\n      case 'move-boundary':\r\n        this.renderBoundaryMovePreview(ctx, viewportManager, width, height);\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render chop creation preview with enhanced visual feedback\r\n   */\r\n  renderChopCreationPreview(ctx, viewportManager, width, height) {\r\n    const startPixel = viewportManager.timeToPixel(this.dragState.startTime);\r\n    const endPixel = viewportManager.timeToPixel(this.dragState.endTime);\r\n    \r\n    const leftPixel = Math.min(startPixel, endPixel);\r\n    const rightPixel = Math.max(startPixel, endPixel);\r\n    const regionWidth = rightPixel - leftPixel;\r\n    \r\n    if (regionWidth > 1) {\r\n      // Draw preview region with gradient\r\n      const gradient = ctx.createLinearGradient(leftPixel, 0, rightPixel, 0);\r\n      gradient.addColorStop(0, 'rgba(59, 130, 246, 0.4)');\r\n      gradient.addColorStop(0.5, 'rgba(59, 130, 246, 0.2)');\r\n      gradient.addColorStop(1, 'rgba(59, 130, 246, 0.4)');\r\n      \r\n      ctx.fillStyle = gradient;\r\n      ctx.fillRect(leftPixel, 0, regionWidth, height);\r\n      \r\n      // Draw animated boundaries\r\n      const animationOffset = (Date.now() % 1000) / 1000 * 10; // 10px animation cycle\r\n      ctx.strokeStyle = 'rgba(59, 130, 246, 0.9)';\r\n      ctx.lineWidth = 2;\r\n      ctx.setLineDash([8, 4]);\r\n      ctx.lineDashOffset = animationOffset;\r\n      \r\n      ctx.beginPath();\r\n      ctx.moveTo(leftPixel, 0);\r\n      ctx.lineTo(leftPixel, height);\r\n      ctx.moveTo(rightPixel, 0);\r\n      ctx.lineTo(rightPixel, height);\r\n      ctx.stroke();\r\n      \r\n      ctx.setLineDash([]);\r\n      ctx.lineDashOffset = 0;\r\n      \r\n      // Draw drag handles\r\n      this.renderDragHandles(ctx, leftPixel, rightPixel, height);\r\n    }\r\n    \r\n    // Show enhanced timing information\r\n    this.renderEnhancedTimingInfo(ctx, leftPixel, rightPixel, height);\r\n  }\r\n\r\n  /**\r\n   * Render boundary move preview with snap indicators\r\n   */\r\n  renderBoundaryMovePreview(ctx, viewportManager, width, height) {\r\n    const chops = this.getCurrentChops();\r\n    const chop = chops.find(c => c.id === this.dragState.chopId);\r\n    \r\n    if (!chop) return;\r\n    \r\n    // Calculate new boundary position\r\n    let startTime = chop.startTime;\r\n    let endTime = chop.endTime;\r\n    \r\n    if (this.dragState.boundaryType === 'start') {\r\n      startTime = this.dragState.startTime;\r\n    } else {\r\n      endTime = this.dragState.endTime;\r\n    }\r\n    \r\n    const startPixel = viewportManager.timeToPixel(startTime);\r\n    const endPixel = viewportManager.timeToPixel(endTime);\r\n    \r\n    // Draw updated chop region with subtle animation\r\n    const pulseAlpha = 0.2 + 0.1 * Math.sin(Date.now() / 200);\r\n    ctx.fillStyle = `rgba(34, 197, 94, ${pulseAlpha})`;\r\n    ctx.fillRect(startPixel, 0, endPixel - startPixel, height);\r\n    \r\n    // Draw static boundary (not being moved)\r\n    const staticBoundaryPixel = this.dragState.boundaryType === 'start' ? endPixel : startPixel;\r\n    ctx.strokeStyle = 'rgba(34, 197, 94, 0.6)';\r\n    ctx.lineWidth = 1;\r\n    ctx.beginPath();\r\n    ctx.moveTo(staticBoundaryPixel, 0);\r\n    ctx.lineTo(staticBoundaryPixel, height);\r\n    ctx.stroke();\r\n    \r\n    // Highlight the boundary being moved with enhanced visuals\r\n    const boundaryPixel = this.dragState.boundaryType === 'start' ? startPixel : endPixel;\r\n    \r\n    // Draw glow effect\r\n    ctx.shadowColor = 'rgba(34, 197, 94, 0.8)';\r\n    ctx.shadowBlur = 8;\r\n    ctx.strokeStyle = 'rgba(34, 197, 94, 1)';\r\n    ctx.lineWidth = 3;\r\n    ctx.beginPath();\r\n    ctx.moveTo(boundaryPixel, 0);\r\n    ctx.lineTo(boundaryPixel, height);\r\n    ctx.stroke();\r\n    \r\n    // Reset shadow\r\n    ctx.shadowColor = 'transparent';\r\n    ctx.shadowBlur = 0;\r\n    \r\n    // Draw drag handle\r\n    this.renderDragHandle(ctx, boundaryPixel, height / 2, 'active');\r\n    \r\n    // Show snap indicators\r\n    this.renderSnapIndicators(ctx, viewportManager, width, height);\r\n    \r\n    // Show enhanced timing information\r\n    this.renderEnhancedTimingInfo(ctx, startPixel, endPixel, height);\r\n  }\r\n\r\n  /**\r\n   * Render drag handles for boundaries\r\n   */\r\n  renderDragHandles(ctx, leftPixel, rightPixel, height) {\r\n    this.renderDragHandle(ctx, leftPixel, height / 2, 'start');\r\n    this.renderDragHandle(ctx, rightPixel, height / 2, 'end');\r\n  }\r\n\r\n  /**\r\n   * Render individual drag handle\r\n   */\r\n  renderDragHandle(ctx, x, y, type) {\r\n    const handleSize = 8;\r\n    const handleColor = type === 'active' ? 'rgba(34, 197, 94, 1)' : 'rgba(59, 130, 246, 1)';\r\n    \r\n    // Draw handle background\r\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\r\n    ctx.fillRect(x - handleSize / 2, y - handleSize / 2, handleSize, handleSize);\r\n    \r\n    // Draw handle border\r\n    ctx.strokeStyle = handleColor;\r\n    ctx.lineWidth = 2;\r\n    ctx.strokeRect(x - handleSize / 2, y - handleSize / 2, handleSize, handleSize);\r\n    \r\n    // Draw handle grip lines\r\n    ctx.strokeStyle = handleColor;\r\n    ctx.lineWidth = 1;\r\n    ctx.beginPath();\r\n    ctx.moveTo(x - 2, y - 3);\r\n    ctx.lineTo(x - 2, y + 3);\r\n    ctx.moveTo(x, y - 3);\r\n    ctx.lineTo(x, y + 3);\r\n    ctx.moveTo(x + 2, y - 3);\r\n    ctx.lineTo(x + 2, y + 3);\r\n    ctx.stroke();\r\n  }\r\n\r\n  /**\r\n   * Render snap indicators for nearby boundaries and zero-crossings\r\n   */\r\n  renderSnapIndicators(ctx, viewportManager, width, height) {\r\n    if (!this.options.enableSmartSnapping || !this.options.showSnapIndicators) return;\r\n    \r\n    const currentTime = this.dragState.boundaryType === 'start' ? \r\n      this.dragState.startTime : this.dragState.endTime;\r\n    const pixelsPerSecond = viewportManager.getViewportBounds()?.pixelsPerSecond || 80;\r\n    \r\n    // Get snap indicators from smart snapping service\r\n    const snapIndicators = this.smartSnapping.getSnapIndicators(\r\n      currentTime, \r\n      pixelsPerSecond, \r\n      this.dragState.chopId\r\n    );\r\n    \r\n    // Render each snap indicator\r\n    snapIndicators.forEach(indicator => {\r\n      const pixel = viewportManager.timeToPixel(indicator.time);\r\n      \r\n      // Set line style based on indicator type\r\n      ctx.strokeStyle = indicator.color;\r\n      ctx.lineWidth = indicator.width;\r\n      \r\n      switch (indicator.style) {\r\n        case 'dashed':\r\n          ctx.setLineDash([6, 4]);\r\n          break;\r\n        case 'dotted':\r\n          ctx.setLineDash([2, 2]);\r\n          break;\r\n        default:\r\n          ctx.setLineDash([]);\r\n      }\r\n      \r\n      // Draw indicator line\r\n      ctx.beginPath();\r\n      ctx.moveTo(pixel, 0);\r\n      ctx.lineTo(pixel, height);\r\n      ctx.stroke();\r\n      \r\n      // Draw indicator icon based on type\r\n      this.renderSnapIcon(ctx, pixel, height, indicator);\r\n      \r\n      // Reset line dash\r\n      ctx.setLineDash([]);\r\n    });\r\n    \r\n    // Highlight active snap if available\r\n    if (this.currentSnapResult?.wasSnapped) {\r\n      const snapPixel = viewportManager.timeToPixel(this.currentSnapResult.snappedTime);\r\n      \r\n      // Draw glow effect for active snap\r\n      ctx.shadowColor = 'rgba(255, 165, 0, 0.6)';\r\n      ctx.shadowBlur = 8;\r\n      ctx.strokeStyle = 'rgba(255, 165, 0, 1)';\r\n      ctx.lineWidth = 3;\r\n      \r\n      ctx.beginPath();\r\n      ctx.moveTo(snapPixel, 0);\r\n      ctx.lineTo(snapPixel, height);\r\n      ctx.stroke();\r\n      \r\n      // Reset shadow\r\n      ctx.shadowColor = 'transparent';\r\n      ctx.shadowBlur = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render snap icon based on indicator type\r\n   */\r\n  renderSnapIcon(ctx, x, height, indicator) {\r\n    const iconSize = 8;\r\n    const iconY = height - 20;\r\n    \r\n    ctx.fillStyle = indicator.color;\r\n    \r\n    switch (indicator.type) {\r\n      case 'zero-crossing':\r\n        // Draw sine wave icon\r\n        ctx.beginPath();\r\n        ctx.arc(x, iconY, iconSize / 2, 0, Math.PI * 2);\r\n        ctx.fill();\r\n        \r\n        // Draw small wave inside\r\n        ctx.strokeStyle = 'white';\r\n        ctx.lineWidth = 1;\r\n        ctx.beginPath();\r\n        ctx.moveTo(x - 3, iconY);\r\n        ctx.quadraticCurveTo(x - 1, iconY - 2, x + 1, iconY);\r\n        ctx.quadraticCurveTo(x + 3, iconY + 2, x + 3, iconY);\r\n        ctx.stroke();\r\n        break;\r\n        \r\n      case 'chop-boundary':\r\n        // Draw boundary marker\r\n        ctx.fillRect(x - iconSize / 2, iconY - iconSize / 2, iconSize, iconSize);\r\n        \r\n        // Draw direction indicator\r\n        ctx.fillStyle = 'white';\r\n        if (indicator.subType === 'start') {\r\n          // Left arrow\r\n          ctx.beginPath();\r\n          ctx.moveTo(x - 2, iconY);\r\n          ctx.lineTo(x + 1, iconY - 2);\r\n          ctx.lineTo(x + 1, iconY + 2);\r\n          ctx.fill();\r\n        } else {\r\n          // Right arrow\r\n          ctx.beginPath();\r\n          ctx.moveTo(x + 2, iconY);\r\n          ctx.lineTo(x - 1, iconY - 2);\r\n          ctx.lineTo(x - 1, iconY + 2);\r\n          ctx.fill();\r\n        }\r\n        break;\r\n        \r\n      case 'grid':\r\n        // Draw grid icon\r\n        ctx.fillRect(x - 1, iconY - iconSize / 2, 2, iconSize);\r\n        ctx.fillRect(x - iconSize / 2, iconY - 1, iconSize, 2);\r\n        break;\r\n        \r\n      default:\r\n        // Default snap icon\r\n        ctx.fillRect(x - iconSize / 2, iconY - iconSize / 2, iconSize, iconSize);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render enhanced timing information during drag\r\n   */\r\n  renderEnhancedTimingInfo(ctx, startPixel, endPixel, height) {\r\n    const startTime = Math.min(this.dragState.startTime, this.dragState.endTime);\r\n    const endTime = Math.max(this.dragState.startTime, this.dragState.endTime);\r\n    const duration = endTime - startTime;\r\n    const centerPixel = (startPixel + endPixel) / 2;\r\n    \r\n    // Prepare timing text\r\n    const durationText = `${duration.toFixed(3)}s`;\r\n    const startText = `${startTime.toFixed(3)}s`;\r\n    const endText = `${endTime.toFixed(3)}s`;\r\n    \r\n    // Calculate text dimensions\r\n    ctx.font = '11px monospace';\r\n    const durationWidth = ctx.measureText(durationText).width;\r\n    const startWidth = ctx.measureText(startText).width;\r\n    const endWidth = ctx.measureText(endText).width;\r\n    \r\n    const padding = 6;\r\n    const lineHeight = 14;\r\n    const totalHeight = lineHeight * 3 + padding * 2;\r\n    const maxWidth = Math.max(durationWidth, startWidth, endWidth) + padding * 2;\r\n    \r\n    // Position tooltip\r\n    let tooltipX = centerPixel - maxWidth / 2;\r\n    let tooltipY = height - totalHeight - 10;\r\n    \r\n    // Adjust position if near edges\r\n    const { width } = this.canvasRenderer.getLayerManager().getDimensions();\r\n    if (tooltipX < 5) tooltipX = 5;\r\n    if (tooltipX + maxWidth > width - 5) tooltipX = width - maxWidth - 5;\r\n    if (tooltipY < 5) tooltipY = Math.min(startPixel, endPixel) + 20;\r\n    \r\n    // Draw tooltip background with rounded corners\r\n    this.drawRoundedRect(ctx, tooltipX, tooltipY, maxWidth, totalHeight, 4);\r\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';\r\n    ctx.fill();\r\n    \r\n    // Draw tooltip border\r\n    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';\r\n    ctx.lineWidth = 1;\r\n    ctx.stroke();\r\n    \r\n    // Draw timing text\r\n    ctx.fillStyle = 'white';\r\n    ctx.textAlign = 'center';\r\n    const textX = tooltipX + maxWidth / 2;\r\n    \r\n    ctx.fillText(durationText, textX, tooltipY + padding + lineHeight);\r\n    \r\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';\r\n    ctx.font = '10px monospace';\r\n    ctx.fillText(`Start: ${startText}`, textX, tooltipY + padding + lineHeight * 2);\r\n    ctx.fillText(`End: ${endText}`, textX, tooltipY + padding + lineHeight * 3);\r\n  }\r\n\r\n  /**\r\n   * Draw rounded rectangle helper\r\n   */\r\n  drawRoundedRect(ctx, x, y, width, height, radius) {\r\n    ctx.beginPath();\r\n    ctx.moveTo(x + radius, y);\r\n    ctx.lineTo(x + width - radius, y);\r\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\r\n    ctx.lineTo(x + width, y + height - radius);\r\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\r\n    ctx.lineTo(x + radius, y + height);\r\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\r\n    ctx.lineTo(x, y + radius);\r\n    ctx.quadraticCurveTo(x, y, x + radius, y);\r\n    ctx.closePath();\r\n  }\r\n\r\n  /**\r\n   * Handle click events (non-drag)\r\n   */\r\n  handleClick(x, y) {\r\n    if (!this.options.enableClick) return;\r\n    \r\n    const viewportManager = this.canvasRenderer.getViewportManager();\r\n    const time = viewportManager.pixelToTime(x);\r\n    \r\n    // Create chop at click position\r\n    this.createChopAtTime(time);\r\n  }\r\n\r\n  /**\r\n   * Finalize drag operation\r\n   */\r\n  finalizeDrag(x, y) {\r\n    switch (this.dragState.type) {\r\n      case 'create-chop':\r\n        this.finalizeChopCreation();\r\n        break;\r\n      case 'move-boundary':\r\n        this.finalizeBoundaryMove();\r\n        break;\r\n    }\r\n    \r\n    // Clear interaction layer\r\n    const layerManager = this.canvasRenderer.getLayerManager();\r\n    layerManager.clearLayer('interaction');\r\n  }\r\n\r\n  /**\r\n   * Finalize chop creation with conflict prevention\r\n   */\r\n  finalizeChopCreation() {\r\n    let startTime = Math.min(this.dragState.startTime, this.dragState.endTime);\r\n    let endTime = Math.max(this.dragState.startTime, this.dragState.endTime);\r\n    const duration = endTime - startTime;\r\n    \r\n    // Only create chop if duration is meaningful (> 10ms)\r\n    if (duration > 0.01) {\r\n      // Apply conflict prevention if enabled\r\n      if (this.options.enableConflictPrevention) {\r\n        const conflictingChop = this.findConflictingChop(startTime, endTime, null);\r\n        if (conflictingChop) {\r\n          // Adjust boundaries to avoid conflict\r\n          if (startTime < conflictingChop.startTime) {\r\n            endTime = Math.min(endTime, conflictingChop.startTime);\r\n          } else {\r\n            startTime = Math.max(startTime, conflictingChop.endTime);\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Ensure minimum duration after conflict resolution\r\n      if (endTime - startTime > 0.01) {\r\n        this.createChop(startTime, endTime);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Finalize boundary move\r\n   */\r\n  finalizeBoundaryMove() {\r\n    const chops = this.getCurrentChops();\r\n    const chop = chops.find(c => c.id === this.dragState.chopId);\r\n    \r\n    if (!chop) return;\r\n    \r\n    const updates = {};\r\n    \r\n    if (this.dragState.boundaryType === 'start') {\r\n      updates.startTime = this.dragState.startTime;\r\n    } else {\r\n      updates.endTime = this.dragState.endTime;\r\n    }\r\n    \r\n    this.updateChop(this.dragState.chopId, updates);\r\n  }\r\n\r\n  /**\r\n   * Handle hover movement\r\n   */\r\n  handleHoverMove(x, y) {\r\n    // Clear existing hover timeout\r\n    if (this.hoverTimeout) {\r\n      clearTimeout(this.hoverTimeout);\r\n    }\r\n    \r\n    // Set new hover timeout\r\n    this.hoverTimeout = setTimeout(() => {\r\n      this.showHoverInfo(x, y);\r\n    }, this.options.hoverDelay);\r\n  }\r\n\r\n  /**\r\n   * Show hover information\r\n   */\r\n  showHoverInfo(x, y) {\r\n    const element = this.getElementAtPosition(x, y);\r\n    const viewportManager = this.canvasRenderer.getViewportManager();\r\n    const time = viewportManager.pixelToTime(x);\r\n    \r\n    if (element) {\r\n      this.showElementHover(element, x, y);\r\n    } else {\r\n      this.showTimeHover(time, x, y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Show enhanced hover info for specific elements with detailed timing information\r\n   * Implements requirement 5.5 - detailed timing and duration information\r\n   */\r\n  showElementHover(element, x, y) {\r\n    const layerManager = this.canvasRenderer.getLayerManager();\r\n    const interactionLayer = layerManager.getLayer('interaction');\r\n    \r\n    if (!interactionLayer) return;\r\n    \r\n    const { ctx } = interactionLayer;\r\n    const { height } = layerManager.getDimensions();\r\n    \r\n    // Clear previous hover\r\n    layerManager.clearLayer('interaction');\r\n    \r\n    let tooltipData = null;\r\n    \r\n    switch (element.type) {\r\n      case 'chop-boundary':\r\n        tooltipData = this.createBoundaryTooltipData(element);\r\n        break;\r\n      case 'chop-region':\r\n        tooltipData = this.createChopTooltipData(element);\r\n        break;\r\n    }\r\n    \r\n    if (tooltipData) {\r\n      this.renderEnhancedTooltip(ctx, tooltipData, x, y);\r\n      this.hoveredElement = element;\r\n      \r\n      // Notify parent component about hover state for visual feedback\r\n      if (this.callbacks.onHover) {\r\n        this.callbacks.onHover(element, x, y);\r\n      }\r\n    }\r\n    \r\n    // Update cursor\r\n    const canvas = interactionLayer.canvas;\r\n    switch (element.type) {\r\n      case 'chop-boundary':\r\n        canvas.style.cursor = 'ew-resize';\r\n        break;\r\n      case 'chop-region':\r\n        canvas.style.cursor = 'pointer';\r\n        break;\r\n      default:\r\n        canvas.style.cursor = 'crosshair';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create detailed tooltip data for chop boundaries\r\n   */\r\n  createBoundaryTooltipData(element) {\r\n    const chop = this.getCurrentChops().find(c => c.id === element.chopId);\r\n    if (!chop) return null;\r\n    \r\n    const duration = chop.endTime - chop.startTime;\r\n    const boundaryType = element.boundaryType === 'start' ? 'Start' : 'End';\r\n    \r\n    return {\r\n      title: `${boundaryType} Boundary`,\r\n      color: 'rgba(34, 197, 94, 0.9)',\r\n      lines: [\r\n        `Time: ${element.time.toFixed(3)}s`,\r\n        `Chop: ${chop.padId || chop.name || chop.id.slice(0, 8)}`,\r\n        `Duration: ${duration.toFixed(3)}s`,\r\n        `Range: ${chop.startTime.toFixed(3)}s - ${chop.endTime.toFixed(3)}s`\r\n      ],\r\n      actions: [\r\n        'Drag to adjust boundary',\r\n        'Shift+Click to select chop'\r\n      ]\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create detailed tooltip data for chop regions\r\n   */\r\n  createChopTooltipData(element) {\r\n    const chop = element.chop;\r\n    const duration = chop.endTime - chop.startTime;\r\n    const currentTime = element.time;\r\n    const relativeTime = currentTime - chop.startTime;\r\n    const progress = (relativeTime / duration) * 100;\r\n    \r\n    // Analyze relationships with other chops\r\n    const relationships = this.analyzeChopRelationships(chop);\r\n    \r\n    const tooltipData = {\r\n      title: `Chop ${chop.padId || chop.name || chop.id.slice(0, 8)}`,\r\n      color: chop.color || 'rgba(59, 130, 246, 0.9)',\r\n      lines: [\r\n        `Duration: ${duration.toFixed(3)}s`,\r\n        `Start: ${chop.startTime.toFixed(3)}s`,\r\n        `End: ${chop.endTime.toFixed(3)}s`,\r\n        `Position: ${relativeTime.toFixed(3)}s (${progress.toFixed(1)}%)`\r\n      ],\r\n      actions: [\r\n        'Click to seek to position',\r\n        'Shift+Click to select',\r\n        'Drag boundaries to adjust'\r\n      ]\r\n    };\r\n    \r\n    // Add relationship information\r\n    if (relationships.length > 0) {\r\n      tooltipData.lines.push(''); // Separator\r\n      tooltipData.lines.push('Relationships:');\r\n      relationships.forEach(rel => {\r\n        switch (rel.type) {\r\n          case 'overlap':\r\n            const severity = rel.severity > 0.5 ? 'Major' : 'Minor';\r\n            tooltipData.lines.push(` ${severity} overlap with ${rel.chop.padId || rel.chop.id.slice(0, 3)}`);\r\n            break;\r\n          case 'adjacent-after':\r\n            tooltipData.lines.push(` Adjacent to ${rel.chop.padId || rel.chop.id.slice(0, 3)}`);\r\n            break;\r\n          case 'adjacent-before':\r\n            tooltipData.lines.push(` Adjacent from ${rel.chop.padId || rel.chop.id.slice(0, 3)}`);\r\n            break;\r\n        }\r\n      });\r\n    }\r\n    \r\n    return tooltipData;\r\n  }\r\n\r\n  /**\r\n   * Analyze relationships between current chop and others\r\n   */\r\n  analyzeChopRelationships(currentChop) {\r\n    const allChops = this.getCurrentChops();\r\n    const relationships = [];\r\n    const tolerance = 0.05; // 50ms tolerance for adjacency\r\n    \r\n    allChops.forEach(otherChop => {\r\n      if (otherChop.id === currentChop.id) return;\r\n      \r\n      // Check for overlap\r\n      if (!(currentChop.endTime <= otherChop.startTime || currentChop.startTime >= otherChop.endTime)) {\r\n        const overlapStart = Math.max(currentChop.startTime, otherChop.startTime);\r\n        const overlapEnd = Math.min(currentChop.endTime, otherChop.endTime);\r\n        const overlapDuration = overlapEnd - overlapStart;\r\n        \r\n        const currentDuration = currentChop.endTime - currentChop.startTime;\r\n        const otherDuration = otherChop.endTime - otherChop.startTime;\r\n        const minDuration = Math.min(currentDuration, otherDuration);\r\n        \r\n        relationships.push({\r\n          type: 'overlap',\r\n          chop: otherChop,\r\n          severity: overlapDuration / minDuration\r\n        });\r\n      }\r\n      // Check for adjacency\r\n      else if (Math.abs(currentChop.endTime - otherChop.startTime) <= tolerance) {\r\n        relationships.push({\r\n          type: 'adjacent-after',\r\n          chop: otherChop,\r\n          gap: otherChop.startTime - currentChop.endTime\r\n        });\r\n      }\r\n      else if (Math.abs(otherChop.endTime - currentChop.startTime) <= tolerance) {\r\n        relationships.push({\r\n          type: 'adjacent-before',\r\n          chop: otherChop,\r\n          gap: currentChop.startTime - otherChop.endTime\r\n        });\r\n      }\r\n    });\r\n    \r\n    return relationships;\r\n  }\r\n\r\n  /**\r\n   * Show hover info for time position\r\n   */\r\n  showTimeHover(time, x, y) {\r\n    const layerManager = this.canvasRenderer.getLayerManager();\r\n    const interactionLayer = layerManager.getLayer('interaction');\r\n    \r\n    if (!interactionLayer) return;\r\n    \r\n    const { ctx } = interactionLayer;\r\n    \r\n    // Clear previous hover\r\n    layerManager.clearLayer('interaction');\r\n    \r\n    const timeText = `${time.toFixed(3)}s`;\r\n    this.renderHoverTooltip(ctx, timeText, x, y, 'rgba(255, 255, 255, 0.9)');\r\n    \r\n    // Reset cursor\r\n    interactionLayer.canvas.style.cursor = 'crosshair';\r\n  }\r\n\r\n  /**\r\n   * Render enhanced tooltip with detailed information that doesn't interfere with UI\r\n   * Implements requirement: hover tooltips that do not interfere with the rest of the ui\r\n   */\r\n  renderEnhancedTooltip(ctx, tooltipData, x, y) {\r\n    const padding = 10;\r\n    const lineHeight = 14;\r\n    const titleHeight = 16;\r\n    const fontSize = 11;\r\n    const titleFontSize = 12;\r\n    \r\n    // Calculate tooltip dimensions\r\n    ctx.font = `${fontSize}px monospace`;\r\n    let maxWidth = 0;\r\n    \r\n    // Measure title\r\n    ctx.font = `bold ${titleFontSize}px monospace`;\r\n    const titleWidth = ctx.measureText(tooltipData.title).width;\r\n    maxWidth = Math.max(maxWidth, titleWidth);\r\n    \r\n    // Measure content lines\r\n    ctx.font = `${fontSize}px monospace`;\r\n    tooltipData.lines.forEach(line => {\r\n      if (line.trim()) {\r\n        const lineWidth = ctx.measureText(line).width;\r\n        maxWidth = Math.max(maxWidth, lineWidth);\r\n      }\r\n    });\r\n    \r\n    // Measure action lines (smaller font)\r\n    ctx.font = `${fontSize - 1}px monospace`;\r\n    if (tooltipData.actions) {\r\n      tooltipData.actions.forEach(action => {\r\n        const actionWidth = ctx.measureText(action).width;\r\n        maxWidth = Math.max(maxWidth, actionWidth);\r\n      });\r\n    }\r\n    \r\n    const tooltipWidth = maxWidth + padding * 2;\r\n    const contentLines = tooltipData.lines.filter(line => line.trim()).length;\r\n    const actionLines = tooltipData.actions ? tooltipData.actions.length : 0;\r\n    const separatorHeight = (tooltipData.actions && actionLines > 0) ? 6 : 0;\r\n    const tooltipHeight = titleHeight + (contentLines * lineHeight) + separatorHeight + (actionLines * (lineHeight - 2)) + padding * 2;\r\n    \r\n    // Smart positioning to avoid UI interference\r\n    const { width, height } = this.canvasRenderer.getLayerManager().getDimensions();\r\n    let tooltipX = x + 15; // Offset from cursor\r\n    let tooltipY = y - tooltipHeight - 10;\r\n    \r\n    // Adjust horizontal position\r\n    if (tooltipX + tooltipWidth > width - 10) {\r\n      tooltipX = x - tooltipWidth - 15; // Show on left side\r\n    }\r\n    if (tooltipX < 10) {\r\n      tooltipX = 10; // Minimum margin\r\n    }\r\n    \r\n    // Adjust vertical position\r\n    if (tooltipY < 10) {\r\n      tooltipY = y + 20; // Show below cursor\r\n    }\r\n    if (tooltipY + tooltipHeight > height - 10) {\r\n      tooltipY = height - tooltipHeight - 10; // Keep within bounds\r\n    }\r\n    \r\n    // Draw tooltip with rounded corners and shadow\r\n    this.drawTooltipBackground(ctx, tooltipX, tooltipY, tooltipWidth, tooltipHeight, tooltipData.color);\r\n    \r\n    // Draw content\r\n    let currentY = tooltipY + padding + titleHeight - 2;\r\n    \r\n    // Draw title\r\n    ctx.font = `bold ${titleFontSize}px monospace`;\r\n    ctx.fillStyle = tooltipData.color;\r\n    ctx.textAlign = 'left';\r\n    ctx.fillText(tooltipData.title, tooltipX + padding, currentY);\r\n    \r\n    currentY += 4; // Small gap after title\r\n    \r\n    // Draw content lines\r\n    ctx.font = `${fontSize}px monospace`;\r\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\r\n    \r\n    tooltipData.lines.forEach(line => {\r\n      if (line.trim()) {\r\n        currentY += lineHeight;\r\n        \r\n        // Color-code special lines\r\n        if (line.includes('')) {\r\n          ctx.fillStyle = 'rgba(245, 158, 11, 0.9)'; // Warning color\r\n        } else if (line.includes('') || line.includes('')) {\r\n          ctx.fillStyle = 'rgba(34, 197, 94, 0.9)'; // Success color\r\n        } else if (line.includes('Relationships:')) {\r\n          ctx.fillStyle = 'rgba(156, 163, 175, 0.9)'; // Gray color\r\n        } else {\r\n          ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\r\n        }\r\n        \r\n        ctx.fillText(line, tooltipX + padding, currentY);\r\n      }\r\n    });\r\n    \r\n    // Draw separator line if actions exist\r\n    if (tooltipData.actions && actionLines > 0) {\r\n      currentY += separatorHeight;\r\n      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';\r\n      ctx.lineWidth = 1;\r\n      ctx.beginPath();\r\n      ctx.moveTo(tooltipX + padding, currentY - 2);\r\n      ctx.lineTo(tooltipX + tooltipWidth - padding, currentY - 2);\r\n      ctx.stroke();\r\n    }\r\n    \r\n    // Draw action lines\r\n    if (tooltipData.actions) {\r\n      ctx.font = `${fontSize - 1}px monospace`;\r\n      ctx.fillStyle = 'rgba(156, 163, 175, 0.8)';\r\n      \r\n      tooltipData.actions.forEach(action => {\r\n        currentY += lineHeight - 2;\r\n        ctx.fillText(` ${action}`, tooltipX + padding, currentY);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Draw tooltip background with rounded corners and shadow\r\n   */\r\n  drawTooltipBackground(ctx, x, y, width, height, accentColor) {\r\n    const radius = 6;\r\n    \r\n    // Draw shadow\r\n    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';\r\n    ctx.shadowBlur = 8;\r\n    ctx.shadowOffsetX = 2;\r\n    ctx.shadowOffsetY = 2;\r\n    \r\n    // Draw background\r\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.92)';\r\n    this.drawRoundedRect(ctx, x, y, width, height, radius);\r\n    ctx.fill();\r\n    \r\n    // Reset shadow\r\n    ctx.shadowColor = 'transparent';\r\n    ctx.shadowBlur = 0;\r\n    ctx.shadowOffsetX = 0;\r\n    ctx.shadowOffsetY = 0;\r\n    \r\n    // Draw border with accent color\r\n    ctx.strokeStyle = accentColor;\r\n    ctx.lineWidth = 2;\r\n    this.drawRoundedRect(ctx, x, y, width, height, radius);\r\n    ctx.stroke();\r\n    \r\n    // Draw subtle inner glow\r\n    ctx.strokeStyle = `${accentColor}40`;\r\n    ctx.lineWidth = 1;\r\n    this.drawRoundedRect(ctx, x + 1, y + 1, width - 2, height - 2, radius - 1);\r\n    ctx.stroke();\r\n  }\r\n\r\n  /**\r\n   * Render simple hover tooltip (fallback)\r\n   */\r\n  renderHoverTooltip(ctx, text, x, y, color) {\r\n    const tooltipData = {\r\n      title: text,\r\n      color: color,\r\n      lines: [],\r\n      actions: null\r\n    };\r\n    \r\n    this.renderEnhancedTooltip(ctx, tooltipData, x, y);\r\n  }\r\n\r\n  /**\r\n   * Clear hover state\r\n   */\r\n  clearHover() {\r\n    if (this.hoverTimeout) {\r\n      clearTimeout(this.hoverTimeout);\r\n      this.hoverTimeout = null;\r\n    }\r\n    \r\n    if (this.hoveredElement) {\r\n      const layerManager = this.canvasRenderer.getLayerManager();\r\n      layerManager.clearLayer('interaction');\r\n      \r\n      // Reset cursor\r\n      const interactionLayer = layerManager.getLayer('interaction');\r\n      if (interactionLayer) {\r\n        interactionLayer.canvas.style.cursor = 'crosshair';\r\n      }\r\n      \r\n      this.hoveredElement = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reset interaction state\r\n   */\r\n  resetInteractionState() {\r\n    this.isMouseDown = false;\r\n    this.isDragging = false;\r\n    this.dragState = {\r\n      type: null,\r\n      startTime: 0,\r\n      endTime: 0,\r\n      chopId: null,\r\n      boundaryType: null\r\n    };\r\n    \r\n    // Reset cursor\r\n    const layerManager = this.canvasRenderer.getLayerManager();\r\n    const interactionLayer = layerManager.getLayer('interaction');\r\n    if (interactionLayer) {\r\n      interactionLayer.canvas.style.cursor = 'crosshair';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Touch event handlers for mobile support\r\n   */\r\n  handleTouchStart(event) {\r\n    event.preventDefault();\r\n    const touch = event.touches[0];\r\n    const mouseEvent = {\r\n      type: 'mousedown',\r\n      clientX: touch.clientX,\r\n      clientY: touch.clientY,\r\n      preventDefault: () => {},\r\n      target: event.target\r\n    };\r\n    this.handleMouseDown(mouseEvent);\r\n  }\r\n\r\n  handleTouchMove(event) {\r\n    event.preventDefault();\r\n    const touch = event.touches[0];\r\n    const mouseEvent = {\r\n      type: 'mousemove',\r\n      clientX: touch.clientX,\r\n      clientY: touch.clientY,\r\n      preventDefault: () => {},\r\n      target: event.target\r\n    };\r\n    this.handleMouseMove(mouseEvent);\r\n  }\r\n\r\n  handleTouchEnd(event) {\r\n    event.preventDefault();\r\n    const mouseEvent = {\r\n      type: 'mouseup',\r\n      clientX: this.currentMousePosition.x,\r\n      clientY: this.currentMousePosition.y,\r\n      preventDefault: () => {},\r\n      target: event.target\r\n    };\r\n    this.handleMouseUp(mouseEvent);\r\n  }\r\n\r\n  /**\r\n   * Handle keyboard down events for navigation shortcuts\r\n   * Implements requirement 4.4 - keyboard shortcuts for zoom and navigation\r\n   */\r\n  handleKeyDown(event) {\r\n    // Update key state\r\n    this.keyState.shift = event.shiftKey;\r\n    this.keyState.ctrl = event.ctrlKey;\r\n    this.keyState.alt = event.altKey;\r\n    \r\n    const viewportManager = this.canvasRenderer.getViewportManager();\r\n    const viewport = viewportManager.getState();\r\n    \r\n    switch (event.code) {\r\n      // Zoom controls\r\n      case 'Equal': // Plus key\r\n      case 'NumpadAdd':\r\n        if (event.ctrlKey || event.metaKey) {\r\n          event.preventDefault();\r\n          this.smoothZoom(viewportManager, 1.5, viewport.centerTime);\r\n        }\r\n        break;\r\n        \r\n      case 'Minus':\r\n      case 'NumpadSubtract':\r\n        if (event.ctrlKey || event.metaKey) {\r\n          event.preventDefault();\r\n          this.smoothZoom(viewportManager, 1 / 1.5, viewport.centerTime);\r\n        }\r\n        break;\r\n        \r\n      case 'Digit0':\r\n      case 'Numpad0':\r\n        if (event.ctrlKey || event.metaKey) {\r\n          event.preventDefault();\r\n          this.animateZoomToFit(viewportManager);\r\n        }\r\n        break;\r\n        \r\n      // Navigation controls\r\n      case 'ArrowLeft':\r\n        event.preventDefault();\r\n        this.handleKeyboardPan(viewportManager, 'left', event.shiftKey);\r\n        break;\r\n        \r\n      case 'ArrowRight':\r\n        event.preventDefault();\r\n        this.handleKeyboardPan(viewportManager, 'right', event.shiftKey);\r\n        break;\r\n        \r\n      case 'Home':\r\n        event.preventDefault();\r\n        this.animatePanToTime(viewportManager, 0);\r\n        break;\r\n        \r\n      case 'End':\r\n        event.preventDefault();\r\n        this.animatePanToTime(viewportManager, viewport.audioDuration);\r\n        break;\r\n        \r\n      // Zoom presets\r\n      case 'Digit1':\r\n        if (event.ctrlKey || event.metaKey) {\r\n          event.preventDefault();\r\n          this.animateZoomToLevel(viewportManager, 1.0, viewport.centerTime);\r\n        }\r\n        break;\r\n        \r\n      case 'Digit2':\r\n        if (event.ctrlKey || event.metaKey) {\r\n          event.preventDefault();\r\n          this.animateZoomToLevel(viewportManager, 2.0, viewport.centerTime);\r\n        }\r\n        break;\r\n        \r\n      case 'Digit5':\r\n        if (event.ctrlKey || event.metaKey) {\r\n          event.preventDefault();\r\n          this.animateZoomToLevel(viewportManager, 5.0, viewport.centerTime);\r\n        }\r\n        break;\r\n        \r\n      // Fine navigation with Page keys\r\n      case 'PageUp':\r\n        event.preventDefault();\r\n        this.handleKeyboardPan(viewportManager, 'left', true);\r\n        break;\r\n        \r\n      case 'PageDown':\r\n        event.preventDefault();\r\n        this.handleKeyboardPan(viewportManager, 'right', true);\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle keyboard up events\r\n   */\r\n  handleKeyUp(event) {\r\n    // Update key state\r\n    this.keyState.shift = event.shiftKey;\r\n    this.keyState.ctrl = event.ctrlKey;\r\n    this.keyState.alt = event.altKey;\r\n  }\r\n\r\n  /**\r\n   * Handle keyboard-based panning\r\n   * Implements requirement 4.2 - pan/scroll navigation\r\n   */\r\n  handleKeyboardPan(viewportManager, direction, isLarge = false) {\r\n    const viewport = viewportManager.getState();\r\n    const visibleDuration = viewport.visibleTimeRange.end - viewport.visibleTimeRange.start;\r\n    \r\n    // Calculate pan distance based on current zoom level\r\n    let panDistance = visibleDuration * 0.1; // 10% of visible range\r\n    \r\n    if (isLarge) {\r\n      panDistance = visibleDuration * 0.5; // 50% for large steps\r\n    }\r\n    \r\n    const targetTime = direction === 'left' ? \r\n      viewport.centerTime - panDistance : \r\n      viewport.centerTime + panDistance;\r\n    \r\n    this.animatePanToTime(viewportManager, targetTime);\r\n  }\r\n\r\n  /**\r\n   * Animate pan to specific time with smooth transition\r\n   */\r\n  animatePanToTime(viewportManager, targetTime, duration = 200) {\r\n    const startTime = performance.now();\r\n    const currentCenterTime = viewportManager.getState().centerTime;\r\n    \r\n    const animate = (currentTime) => {\r\n      const elapsed = currentTime - startTime;\r\n      const progress = Math.min(elapsed / duration, 1);\r\n      \r\n      // Use easeOutCubic for smooth deceleration\r\n      const easeProgress = 1 - Math.pow(1 - progress, 3);\r\n      \r\n      const newTime = currentCenterTime + (targetTime - currentCenterTime) * easeProgress;\r\n      viewportManager.panToTime(newTime);\r\n      \r\n      if (progress < 1) {\r\n        requestAnimationFrame(animate);\r\n      }\r\n    };\r\n    \r\n    requestAnimationFrame(animate);\r\n  }\r\n\r\n  /**\r\n   * Animate zoom to specific level\r\n   */\r\n  animateZoomToLevel(viewportManager, targetZoom, centerTime, duration = 200) {\r\n    const startTime = performance.now();\r\n    const currentZoom = viewportManager.getState().zoomLevel;\r\n    \r\n    const animate = (currentTime) => {\r\n      const elapsed = currentTime - startTime;\r\n      const progress = Math.min(elapsed / duration, 1);\r\n      \r\n      // Use easeOutCubic for smooth deceleration\r\n      const easeProgress = 1 - Math.pow(1 - progress, 3);\r\n      \r\n      const zoom = currentZoom + (targetZoom - currentZoom) * easeProgress;\r\n      viewportManager.setZoom(zoom, centerTime);\r\n      \r\n      if (progress < 1) {\r\n        requestAnimationFrame(animate);\r\n      }\r\n    };\r\n    \r\n    requestAnimationFrame(animate);\r\n  }\r\n\r\n  /**\r\n   * Animate zoom to fit with smooth transition\r\n   */\r\n  animateZoomToFit(viewportManager, duration = 300) {\r\n    const viewport = viewportManager.getState();\r\n    const targetCenterTime = viewport.audioDuration / 2;\r\n    \r\n    // Calculate zoom to fit\r\n    const { canvasDimensions, audioDuration } = viewport;\r\n    const basePixelsPerSecond = 100;\r\n    const requiredPixelsPerSecond = canvasDimensions.width / audioDuration;\r\n    const targetZoom = Math.max(viewport.minZoom, requiredPixelsPerSecond / basePixelsPerSecond);\r\n    \r\n    // Animate both zoom and pan simultaneously\r\n    const startTime = performance.now();\r\n    const currentZoom = viewport.zoomLevel;\r\n    const currentCenterTime = viewport.centerTime;\r\n    \r\n    const animate = (currentTime) => {\r\n      const elapsed = currentTime - startTime;\r\n      const progress = Math.min(elapsed / duration, 1);\r\n      \r\n      // Use easeOutCubic for smooth deceleration\r\n      const easeProgress = 1 - Math.pow(1 - progress, 3);\r\n      \r\n      const zoom = currentZoom + (targetZoom - currentZoom) * easeProgress;\r\n      const centerTime = currentCenterTime + (targetCenterTime - currentCenterTime) * easeProgress;\r\n      \r\n      viewportManager.setZoom(zoom, centerTime);\r\n      \r\n      if (progress < 1) {\r\n        requestAnimationFrame(animate);\r\n      }\r\n    };\r\n    \r\n    requestAnimationFrame(animate);\r\n  }\r\n\r\n  /**\r\n   * Utility methods for external integration\r\n   */\r\n\r\n  /**\r\n   * Create chop at specific time (click functionality)\r\n   */\r\n  createChopAtTime(time) {\r\n    if (this.callbacks.onChopCreate) {\r\n      // Create a small chop (100ms) centered on click time\r\n      const duration = 0.1;\r\n      const startTime = Math.max(0, time - duration / 2);\r\n      const endTime = startTime + duration;\r\n      \r\n      this.callbacks.onChopCreate(startTime, endTime);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create chop with specific start and end times\r\n   */\r\n  createChop(startTime, endTime) {\r\n    if (this.callbacks.onChopCreate) {\r\n      this.callbacks.onChopCreate(startTime, endTime);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update existing chop\r\n   */\r\n  updateChop(chopId, updates) {\r\n    if (this.callbacks.onChopUpdate) {\r\n      this.callbacks.onChopUpdate(chopId, updates);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Seek to specific time\r\n   */\r\n  seekToTime(time) {\r\n    if (this.callbacks.onTimeSeek) {\r\n      this.callbacks.onTimeSeek(time);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Select chop\r\n   */\r\n  selectChop(chopId) {\r\n    if (this.callbacks.onChopUpdate) {\r\n      this.callbacks.onChopUpdate(chopId, { selected: true });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current chops from parent component\r\n   * This should be set by the parent component\r\n   */\r\n  getCurrentChops() {\r\n    return this.currentChops || [];\r\n  }\r\n\r\n  /**\r\n   * Set current chops for interaction detection\r\n   */\r\n  setCurrentChops(chops) {\r\n    this.currentChops = chops;\r\n  }\r\n\r\n  /**\r\n   * Convert pixel position to time with precision\r\n   */\r\n  pixelToTime(pixel) {\r\n    const viewportManager = this.canvasRenderer.getViewportManager();\r\n    return viewportManager.pixelToTime(pixel);\r\n  }\r\n\r\n  /**\r\n   * Convert time to pixel position with precision\r\n   */\r\n  timeToPixel(time) {\r\n    const viewportManager = this.canvasRenderer.getViewportManager();\r\n    return viewportManager.timeToPixel(time);\r\n  }\r\n\r\n  /**\r\n   * Enable or disable specific interaction types\r\n   */\r\n  setInteractionEnabled(type, enabled) {\r\n    switch (type) {\r\n      case 'click':\r\n        this.options.enableClick = enabled;\r\n        break;\r\n      case 'drag':\r\n        this.options.enableDrag = enabled;\r\n        break;\r\n      case 'hover':\r\n        this.options.enableHover = enabled;\r\n        if (!enabled) {\r\n          this.clearHover();\r\n        }\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroy interaction manager and cleanup\r\n   */\r\n  destroy() {\r\n    this.clearHover();\r\n    this.resetInteractionState();\r\n    \r\n    const layerManager = this.canvasRenderer.getLayerManager();\r\n    const interactionLayer = layerManager.getLayer('interaction');\r\n    \r\n    if (interactionLayer) {\r\n      const canvas = interactionLayer.canvas;\r\n      \r\n      // Remove event listeners\r\n      canvas.removeEventListener('mousedown', this.handleMouseDown);\r\n      canvas.removeEventListener('mousemove', this.handleMouseMove);\r\n      canvas.removeEventListener('mouseup', this.handleMouseUp);\r\n      canvas.removeEventListener('mouseleave', this.handleMouseLeave);\r\n      canvas.removeEventListener('wheel', this.handleWheel);\r\n      canvas.removeEventListener('touchstart', this.handleTouchStart);\r\n      canvas.removeEventListener('touchmove', this.handleTouchMove);\r\n      canvas.removeEventListener('touchend', this.handleTouchEnd);\r\n    }\r\n  }\r\n}\r\n\r\nexport default InteractionManager;"],"names":["ZeroCrossingDetector","constructor","options","this","minDistance","amplitudeThreshold","analysisWindow","maxSearchDistance","zeroCrossingCache","Map","findZeroCrossings","samples","sampleRate","cacheKey","generateCacheKey","has","get","zeroCrossings","lastZeroCrossing","i","length","prevSample","currentSample","quality","analyzeZeroCrossingQuality","isSignificant","push","sampleIndex","time","score","amplitude","Math","abs","slope","set","findNearestZeroCrossing","targetTime","tolerance","searchTolerance","nearestCrossing","Infinity","crossing","distance","findOptimalCutPoints","startTime","endTime","startSample","floor","endSample","startZeroCrossing","endZeroCrossing","result","originalStart","originalEnd","optimizedStart","optimizedEnd","startImprovement","endImprovement","improvement","calculateCutQualityImprovement","avgImprovement","crossingIndex","windowSize","threshold","halfWindow","startIndex","max","endIndex","min","rmsSum","sampleCount","rmsAmplitude","sqrt","nextSample","windowStart","windowEnd","originalIndex","zeroCrossingIndex","originalClickPotential","getZeroCrossingsInRange","filter","reduce","sum","sample","index","toFixed","clearCache","clear","getCacheStats","size","keys","Array","from","updateOptions","newOptions","SmartSnapping","snapTolerance","snapToleranceTime","enableZeroCrossingSnap","enableChopBoundarySnap","enableGridSnap","enableBeatSnap","snapPriorities","zeroCrossing","chopBoundary","grid","beat","showSnapIndicators","snapIndicatorColor","snapIndicatorWidth","zeroCrossingOptions","zeroCrossingDetector","snapTargets","waveformData","chops","setWaveformData","setChops","findSnapTarget","pixelsPerSecond","excludeChopId","findAllSnapTargets","sort","a","b","priority","calculateSnapTolerance","zeroCrossingTarget","findZeroCrossingSnapTarget","boundaryTargets","findChopBoundarySnapTargets","gridTarget","findGridSnapTarget","nearestZeroCrossing","type","data","targets","chop","id","startDistance","subType","chopId","endDistance","nearestGridTime","round","interval","applySnapping","snapTarget","originalTime","snappedTime","wasSnapped","snapDistance","getSnapIndicators","target","map","color","getSnapIndicatorColor","width","style","getSnapIndicatorStyle","label","getSnapIndicatorLabel","snapType","getOptions","setSnapTypes","snapTypes","Object","forEach","key","optionKey","charAt","toUpperCase","slice","hasOwnProperty","getSnapStatistics","stats","chopBoundaries","cacheStats","clearCaches","InteractionManager","canvasRenderer","clickThreshold","hoverDelay","enableHover","enableClick","enableDrag","enableSmartSnapping","enableVisualFeedback","enableConflictPrevention","dragSensitivity","smartSnapping","isMouseDown","isDragging","mouseDownPosition","x","y","currentMousePosition","hoverTimeout","hoveredElement","dragState","boundaryType","callbacks","onChopCreate","onChopUpdate","onTimeSeek","onHover","currentSnapResult","currentChops","initialize","interactionLayer","getLayerManager","getLayer","canvas","addEventListener","handleMouseDown","bind","handleMouseMove","handleMouseUp","handleMouseLeave","handleWheel","handleTouchStart","handleTouchMove","handleTouchEnd","e","preventDefault","tabIndex","handleKeyDown","handleKeyUp","cursor","keyState","shift","ctrl","alt","setCallbacks","setCurrentChops","getCurrentChops","event","rect","getBoundingClientRect","clientX","left","clientY","top","clearHover","clickedElement","getElementAtPosition","handleElementClick","initializeChopCreation","handleDragMove","handleHoverMove","finalizeDrag","handleClick","resetInteractionState","viewportManager","getViewportManager","centerTime","pixelToTime","zoomFactor","shiftKey","ctrlKey","deltaY","smoothZoom","currentZoom","getState","zoomLevel","targetZoom","minZoom","maxZoom","clampedZoom","animateZoom","startZoom","endZoom","duration","performance","now","animate","currentTime","elapsed","progress","easeProgress","pow","setZoom","requestAnimationFrame","startPixel","timeToPixel","endPixel","pixel","element","initializeBoundaryDrag","selectChop","seekToTime","startDrag","updateDrag","renderDragPreview","updateBoundaryDrag","newTime","find","c","applySmartSnapping","conflictingChop","findConflictingChop","getViewportBounds","snapResult","layerManager","ctx","height","getDimensions","clearLayer","renderChopCreationPreview","renderBoundaryMovePreview","leftPixel","rightPixel","regionWidth","gradient","createLinearGradient","addColorStop","fillStyle","fillRect","animationOffset","Date","strokeStyle","lineWidth","setLineDash","lineDashOffset","beginPath","moveTo","lineTo","stroke","renderDragHandles","renderEnhancedTimingInfo","pulseAlpha","sin","staticBoundaryPixel","boundaryPixel","shadowColor","shadowBlur","renderDragHandle","renderSnapIndicators","handleColor","handleSize","strokeRect","indicator","renderSnapIcon","snapPixel","iconY","arc","iconSize","PI","fill","quadraticCurveTo","centerPixel","durationText","startText","endText","font","durationWidth","measureText","startWidth","endWidth","maxWidth","padding","tooltipX","tooltipY","lineHeight","drawRoundedRect","textAlign","textX","fillText","radius","closePath","createChopAtTime","finalizeChopCreation","finalizeBoundaryMove","createChop","updates","updateChop","clearTimeout","setTimeout","showHoverInfo","showElementHover","showTimeHover","tooltipData","createBoundaryTooltipData","createChopTooltipData","renderEnhancedTooltip","title","lines","padId","name","actions","relativeTime","relationships","analyzeChopRelationships","rel","severity","currentChop","allChops","otherChop","gap","overlapStart","overlapDuration","currentDuration","otherDuration","minDuration","timeText","renderHoverTooltip","titleWidth","line","trim","action","actionWidth","tooltipWidth","contentLines","actionLines","separatorHeight","tooltipHeight","drawTooltipBackground","currentY","includes","accentColor","shadowOffsetX","shadowOffsetY","text","touch","touches","mouseEvent","altKey","viewport","code","metaKey","animateZoomToFit","handleKeyboardPan","animatePanToTime","audioDuration","animateZoomToLevel","direction","isLarge","visibleDuration","visibleTimeRange","end","start","panDistance","currentCenterTime","panToTime","zoom","targetCenterTime","canvasDimensions","requiredPixelsPerSecond","selected","setInteractionEnabled","enabled","destroy","removeEventListener"],"mappings":"AAKO,MAAMA,EACX,WAAAC,CAAYC,EAAU,IACpBC,KAAKD,QAAU,CAEbE,YAAa,GAEbC,mBAAoB,IAEpBC,eAAgB,GAEhBC,kBAAmB,MAChBL,GAILC,KAAKK,sBAAwBC,GAC/B,CAQA,iBAAAC,CAAkBC,EAASC,GACzB,MAAMC,EAAWV,KAAKW,iBAAiBH,EAASC,GAEhD,GAAIT,KAAKK,kBAAkBO,IAAIF,GAC7B,OAAOV,KAAKK,kBAAkBQ,IAAIH,GAGpC,MAAMI,EAAgB,IAChBb,YAAEA,EAAAC,mBAAaA,EAAAC,eAAoBA,GAAmBH,KAAKD,QAEjE,IAAIgB,GAAoBd,EAExB,IAAA,IAASe,EAAI,EAAGA,EAAIR,EAAQS,OAAQD,IAAK,CACvC,MAAME,EAAaV,EAAQQ,EAAI,GACzBG,EAAgBX,EAAQQ,GAG9B,IAAKE,GAAc,GAAKC,EAAgB,GAAOD,GAAc,GAAKC,EAAgB,IAE5EH,EAAID,GAAoBd,EAAa,CAEvC,MAAMmB,EAAUpB,KAAKqB,2BAA2Bb,EAASQ,EAAGb,EAAgBD,GAExEkB,EAAQE,gBACVR,EAAcS,KAAK,CACjBC,YAAaR,EACbS,KAAMT,EAAIP,EACVW,QAASA,EAAQM,MACjBC,UAAWC,KAAKC,IAAIV,GACpBW,MAAOF,KAAKC,IAAIV,EAAgBD,KAGlCH,EAAmBC,EAEvB,CAEJ,CAKA,OAFAhB,KAAKK,kBAAkB0B,IAAIrB,EAAUI,GAE9BA,CACT,CAUA,uBAAAkB,CAAwBxB,EAASC,EAAYwB,EAAYC,EAAY,MACnE,MAAMC,EAAkBD,GAAalC,KAAKD,QAAQK,kBAC5CU,EAAgBd,KAAKO,kBAAkBC,EAASC,GAEtD,GAA6B,IAAzBK,EAAcG,OAChB,OAAO,KAGT,IAAImB,EAAkB,KAClBnC,EAAcoC,IAElB,IAAA,MAAWC,KAAYxB,EAAe,CACpC,MAAMyB,EAAWX,KAAKC,IAAIS,EAASb,KAAOQ,GAEtCM,GAAYJ,GAAmBI,EAAWtC,IAC5CA,EAAcsC,EACdH,EAAkBE,EAEtB,CAEA,OAAOF,CACT,CAUA,oBAAAI,CAAqBhC,EAASC,EAAYgC,EAAWC,GACnD,MAAMC,EAAcf,KAAKgB,MAAMH,EAAYhC,GACrCoC,EAAYjB,KAAKgB,MAAMF,EAAUjC,GAGjCqC,EAAoB9C,KAAKgC,wBAAwBxB,EAASC,EAAYgC,GACtEM,EAAkB/C,KAAKgC,wBAAwBxB,EAASC,EAAYiC,GAEpEM,EAAS,CACbC,cAAeR,EACfS,YAAaR,EACbS,eAAgBV,EAChBW,aAAcV,EACdW,iBAAkB,EAClBC,eAAgB,EAChBlC,QAAS,YAIX,GAAI0B,EAAmB,CACrB,MAAMS,EAAcvD,KAAKwD,+BACvBhD,EAASmC,EAAaG,EAAkBtB,aAGtC+B,EAAc,KAChBP,EAAOG,eAAiBL,EAAkBrB,KAC1CuB,EAAOK,iBAAmBE,EAE9B,CAGA,GAAIR,EAAiB,CACnB,MAAMQ,EAAcvD,KAAKwD,+BACvBhD,EAASqC,EAAWE,EAAgBvB,aAGlC+B,EAAc,KAChBP,EAAOI,aAAeL,EAAgBtB,KACtCuB,EAAOM,eAAiBC,EAE5B,CAGA,GAAIP,EAAOK,iBAAmB,GAAKL,EAAOM,eAAiB,EAAG,CAC5D,MAAMG,GAAkBT,EAAOK,iBAAmBL,EAAOM,gBAAkB,EAEzEN,EAAO5B,QADLqC,EAAiB,GACF,YACRA,EAAiB,GACT,OAEA,UAErB,CAEA,OAAOT,CACT,CAUA,0BAAA3B,CAA2Bb,EAASkD,EAAeC,EAAYC,GAC7D,MAAMC,EAAajC,KAAKgB,MAAMe,EAAa,GACrCG,EAAalC,KAAKmC,IAAI,EAAGL,EAAgBG,GACzCG,EAAWpC,KAAKqC,IAAIzD,EAAQS,OAAS,EAAGyC,EAAgBG,GAG9D,IAAIK,EAAS,EACTC,EAAc,EAElB,IAAA,IAASnD,EAAI8C,EAAY9C,GAAKgD,EAAUhD,IACtCkD,GAAU1D,EAAQQ,GAAKR,EAAQQ,GAC/BmD,IAGF,MAAMC,EAAexC,KAAKyC,KAAKH,EAASC,GAGlCjD,EAAaV,EAAQkD,EAAgB,IAAM,EAC3CY,EAAa9D,EAAQkD,EAAgB,IAAM,EAC3C5B,EAAQF,KAAKC,IAAIyC,EAAapD,GAOpC,MAAO,CACLI,cAAe8C,GAAgBR,GAAa9B,EAAQ,KACpDJ,OANqBE,KAAKqC,IAAIG,EAAeR,EAAW,GACvChC,KAAKqC,IAAY,GAARnC,EAAY,IACa,EAKnDsC,eACAtC,QACAyC,YAAaT,EACbU,UAAWR,EAEf,CASA,8BAAAR,CAA+BhD,EAASiE,EAAeC,GACrD,GAAID,EAAgB,GAAKA,GAAiBjE,EAAQS,QAC9CyD,EAAoB,GAAKA,GAAqBlE,EAAQS,OACxD,OAAO,EAIT,MACM0D,EADoB/C,KAAKC,IAAIrB,EAAQiE,IAOrClB,EAAc3B,KAAKmC,IAAI,EAAGY,EAHG,KAMnC,OAAO/C,KAAKqC,IAAkB,EAAdV,EAAiB,EACnC,CAUA,uBAAAqB,CAAwBpE,EAASC,EAAYgC,EAAWC,GAGtD,OAFsB1C,KAAKO,kBAAkBC,EAASC,GAEjCoE,OAAOvC,GAC1BA,EAASb,MAAQgB,GAAaH,EAASb,MAAQiB,EAEnD,CAQA,gBAAA/B,CAAiBH,EAASC,GAUxB,MAAO,GARaD,EAAQS,UAQHR,KAPRD,EAAQsE,OAAO,CAACC,EAAKC,EAAQC,IACxCA,EAAQ,KAAS,EACZF,EAAMnD,KAAKC,IAAImD,GAEjBD,EACN,GAE6CG,QAAQ,IAC1D,CAKA,UAAAC,GACEnF,KAAKK,kBAAkB+E,OACzB,CAMA,aAAAC,GACE,MAAO,CACLC,KAAMtF,KAAKK,kBAAkBiF,KAC7BC,KAAMC,MAAMC,KAAKzF,KAAKK,kBAAkBkF,QAE5C,CAMA,aAAAG,CAAcC,GACZ3F,KAAKD,QAAU,IAAKC,KAAKD,WAAY4F,GAErC3F,KAAKmF,YACP,ECtSK,MAAMS,EACX,WAAA9F,CAAYC,EAAU,IACpBC,KAAKD,QAAU,CAEb8F,cAAe,GAEfC,kBAAmB,IAEnBC,wBAAwB,EACxBC,wBAAwB,EACxBC,gBAAgB,EAChBC,gBAAgB,EAEhBC,eAAgB,CACdC,aAAc,EACdC,aAAc,EACdC,KAAM,EACNC,KAAM,GAGRC,oBAAoB,EACpBC,mBAAoB,yBACpBC,mBAAoB,EAEpBC,oBAAqB,CACnB1G,YAAa,GACbC,mBAAoB,IACpBC,eAAgB,GAChBC,kBAAmB,OAElBL,GAILC,KAAK4G,qBAAuB,IAAI/G,EAAqBG,KAAKD,QAAQ4G,qBAGlE3G,KAAK6G,YAAc,GAGnB7G,KAAK8G,aAAe,KACpB9G,KAAK+G,MAAQ,EACf,CAMA,eAAAC,CAAgBF,GACd9G,KAAK8G,aAAeA,EAGhBA,GAActG,SAAWsG,GAAcrG,YACzCT,KAAK4G,qBAAqBrG,kBACxBuG,EAAatG,QACbsG,EAAarG,WAGnB,CAMA,QAAAwG,CAASF,GACP/G,KAAK+G,MAAQA,GAAS,EACxB,CASA,cAAAG,CAAejF,EAAYkF,EAAkB,KAAMC,EAAgB,MACjE,MAAMP,EAAc7G,KAAKqH,mBAAmBpF,EAAYkF,EAAiBC,GAEzE,OAA2B,IAAvBP,EAAY5F,OACP,MAIT4F,EAAYS,KAAK,CAACC,EAAGC,IAEfD,EAAEE,WAAaD,EAAEC,SACZD,EAAEC,SAAWF,EAAEE,SAGjBF,EAAEhF,SAAWiF,EAAEjF,UAGjBsE,EAAY,GACrB,CASA,kBAAAQ,CAAmBpF,EAAYkF,EAAkB,KAAMC,EAAgB,MACrE,MAAMP,EAAc,GACd3E,EAAYlC,KAAK0H,uBAAuBP,GAG9C,GAAInH,KAAKD,QAAQgG,wBAA0B/F,KAAK8G,aAAc,CAC5D,MAAMa,EAAqB3H,KAAK4H,2BAA2B3F,EAAYC,GACnEyF,GACFd,EAAYtF,KAAKoG,EAErB,CAGA,GAAI3H,KAAKD,QAAQiG,uBAAwB,CACvC,MAAM6B,EAAkB7H,KAAK8H,4BAA4B7F,EAAYC,EAAWkF,GAChFP,EAAYtF,QAAQsG,EACtB,CAGA,GAAI7H,KAAKD,QAAQkG,eAAgB,CAC/B,MAAM8B,EAAa/H,KAAKgI,mBAAmB/F,EAAYC,GACnD6F,GACFlB,EAAYtF,KAAKwG,EAErB,CAEA,OAAOlB,CACT,CAQA,0BAAAe,CAA2B3F,EAAYC,GACrC,IAAKlC,KAAK8G,cAActG,UAAYR,KAAK8G,cAAcrG,WACrD,OAAO,KAGT,MAAMwH,EAAsBjI,KAAK4G,qBAAqB5E,wBACpDhC,KAAK8G,aAAatG,QAClBR,KAAK8G,aAAarG,WAClBwB,EACAC,GAGF,IAAK+F,EACH,OAAO,KAGT,MAAM1F,EAAWX,KAAKC,IAAIoG,EAAoBxG,KAAOQ,GAErD,MAAO,CACLiG,KAAM,gBACNzG,KAAMwG,EAAoBxG,KAC1Bc,WACAkF,SAAUzH,KAAKD,QAAQoG,eAAeC,aACtChF,QAAS6G,EAAoB7G,QAC7B+G,KAAMF,EAEV,CASA,2BAAAH,CAA4B7F,EAAYC,EAAWkF,EAAgB,MACjE,MAAMgB,EAAU,GAEhB,IAAA,MAAWC,KAAQrI,KAAK+G,MAAO,CAC7B,GAAIsB,EAAKC,KAAOlB,EAAe,SAG/B,MAAMmB,EAAgB3G,KAAKC,IAAIwG,EAAK5F,UAAYR,GAC5CsG,GAAiBrG,GACnBkG,EAAQ7G,KAAK,CACX2G,KAAM,gBACNM,QAAS,QACT/G,KAAM4G,EAAK5F,UACXF,SAAUgG,EACVd,SAAUzH,KAAKD,QAAQoG,eAAeE,aACtCoC,OAAQJ,EAAKC,GACbH,KAAME,IAKV,MAAMK,EAAc9G,KAAKC,IAAIwG,EAAK3F,QAAUT,GACxCyG,GAAexG,GACjBkG,EAAQ7G,KAAK,CACX2G,KAAM,gBACNM,QAAS,MACT/G,KAAM4G,EAAK3F,QACXH,SAAUmG,EACVjB,SAAUzH,KAAKD,QAAQoG,eAAeE,aACtCoC,OAAQJ,EAAKC,GACbH,KAAME,GAGZ,CAEA,OAAOD,CACT,CAQA,kBAAAJ,CAAmB/F,EAAYC,GAE7B,MAEMyG,EAFe,EAEG/G,KAAKgH,MAAM3G,EAFd,GAGfM,EAAWX,KAAKC,IAAI8G,EAAkB1G,GAE5C,OAAIM,GAAYL,EACP,CACLgG,KAAM,OACNzG,KAAMkH,EACNpG,WACAkF,SAAUzH,KAAKD,QAAQoG,eAAeG,KACtCuC,SAXiB,GAed,IACT,CASA,aAAAC,CAAc7G,EAAYkF,EAAkB,KAAMC,EAAgB,MAChE,MAAM2B,EAAa/I,KAAKkH,eAAejF,EAAYkF,EAAiBC,GAEpE,OAAI2B,EACK,CACLC,aAAc/G,EACdgH,YAAaF,EAAWtH,KACxByH,YAAY,EACZH,aACAI,aAAcJ,EAAWxG,UAItB,CACLyG,aAAc/G,EACdgH,YAAahH,EACbiH,YAAY,EACZH,WAAY,KACZI,aAAc,EAElB,CASA,iBAAAC,CAAkBnH,EAAYkF,EAAkB,KAAMC,EAAgB,MACpE,IAAKpH,KAAKD,QAAQyG,mBAChB,MAAO,GAGT,MAAMK,EAAc7G,KAAKqH,mBAAmBpF,EAAYkF,EAAiBC,GACnElF,EAAYlC,KAAK0H,uBAAuBP,GAE9C,OAAON,EACJhC,OAAOwE,GAAUA,EAAO9G,UAAYL,GACpCoH,IAAID,IAAA,CACHnB,KAAMmB,EAAOnB,KACbzG,KAAM4H,EAAO5H,KACbgG,SAAU4B,EAAO5B,SACjB8B,MAAOvJ,KAAKwJ,sBAAsBH,EAAOnB,MACzCuB,MAAOzJ,KAAKD,QAAQ2G,mBACpBgD,MAAO1J,KAAK2J,sBAAsBN,EAAOnB,MACzC0B,MAAO5J,KAAK6J,sBAAsBR,KAExC,CAOA,qBAAAG,CAAsBM,GAQpB,MAPe,CACb,gBAAiB,yBACjB,gBAAiB,0BACjBxD,KAAQ,2BACRC,KAAQ,4BAGIuD,IAAa9J,KAAKD,QAAQ0G,kBAC1C,CAOA,qBAAAkD,CAAsBG,GAQpB,MAPe,CACb,gBAAiB,QACjB,gBAAiB,SACjBxD,KAAQ,SACRC,KAAQ,SAGIuD,IAAa,OAC7B,CAOA,qBAAAD,CAAsBd,GACpB,OAAQA,EAAWb,MACjB,IAAK,gBACH,MAAO,kBAAkBa,EAAWtH,KAAKyD,QAAQ,OACnD,IAAK,gBACH,MAAO,QAAQ6D,EAAWP,YAAYO,EAAWtH,KAAKyD,QAAQ,OAChE,IAAK,OACH,MAAO,SAAS6D,EAAWtH,KAAKyD,QAAQ,OAC1C,IAAK,OACH,MAAO,SAAS6D,EAAWtH,KAAKyD,QAAQ,OAC1C,QACE,MAAO,SAAS6D,EAAWtH,KAAKyD,QAAQ,OAE9C,CAOA,sBAAAwC,CAAuBP,GACrB,OAAIA,GAAmBA,EAAkB,EAChCnH,KAAKD,QAAQ8F,cAAgBsB,EAE/BnH,KAAKD,QAAQ+F,iBACtB,CAMA,aAAAJ,CAAcC,GACZ3F,KAAKD,QAAU,IAAKC,KAAKD,WAAY4F,GAGjCA,EAAWgB,qBACb3G,KAAK4G,qBAAqBlB,cAAcC,EAAWgB,oBAEvD,CAMA,UAAAoD,GACE,MAAO,IAAK/J,KAAKD,QACnB,CAMA,YAAAiK,CAAaC,GACXC,OAAO3E,KAAK0E,GAAWE,QAAQC,IAC7B,MAAMC,EAAY,SAASD,EAAIE,OAAO,GAAGC,cAAgBH,EAAII,MAAM,SAC/DxK,KAAKD,QAAQ0K,eAAeJ,KAC9BrK,KAAKD,QAAQsK,GAAaJ,EAAUG,KAG1C,CAMA,iBAAAM,GACE,MAAMC,EAAQ,CACZ7J,cAAe,EACf8J,eAAoC,EAApB5K,KAAK+G,MAAM9F,OAC3B4J,WAAY7K,KAAK4G,qBAAqBvB,iBAGxC,GAAIrF,KAAK8G,cAActG,SAAWR,KAAK8G,cAAcrG,WAAY,CAC/D,MAAMK,EAAgBd,KAAK4G,qBAAqBrG,kBAC9CP,KAAK8G,aAAatG,QAClBR,KAAK8G,aAAarG,YAEpBkK,EAAM7J,cAAgBA,EAAcG,MACtC,CAEA,OAAO0J,CACT,CAKA,WAAAG,GACE9K,KAAK4G,qBAAqBzB,YAC5B,ECjaK,MAAM4F,EACX,WAAAjL,CAAYkL,EAAgBjL,EAAU,IACpCC,KAAKgL,eAAiBA,EACtBhL,KAAKD,QAAU,CACbkL,eAAgB,EAChBC,WAAY,IACZrF,cAAe,GACfsF,aAAa,EACbC,aAAa,EACbC,YAAY,EACZC,qBAAqB,EACrBC,sBAAsB,EACtBC,0BAA0B,EAC1BC,gBAAiB,EAEjB3F,kBAAmB,IACnBC,wBAAwB,EACxBC,wBAAwB,EACxBQ,oBAAoB,KACjBzG,GAILC,KAAK0L,cAAgB,IAAI9F,EAAc,CACrCC,cAAe7F,KAAKD,QAAQ8F,cAC5BC,kBAAmB9F,KAAKD,QAAQ+F,kBAChCC,uBAAwB/F,KAAKD,QAAQgG,uBACrCC,uBAAwBhG,KAAKD,QAAQiG,uBACrCQ,mBAAoBxG,KAAKD,QAAQyG,qBAInCxG,KAAK2L,aAAc,EACnB3L,KAAK4L,YAAa,EAClB5L,KAAK6L,kBAAoB,CAAEC,EAAG,EAAGC,EAAG,GACpC/L,KAAKgM,qBAAuB,CAAEF,EAAG,EAAGC,EAAG,GACvC/L,KAAKiM,aAAe,KACpBjM,KAAKkM,eAAiB,KAGtBlM,KAAKmM,UAAY,CACfjE,KAAM,KACNzF,UAAW,EACXC,QAAS,EACT+F,OAAQ,KACR2D,aAAc,MAIhBpM,KAAKqM,UAAY,CACfC,aAAc,KACdC,aAAc,KACdC,WAAY,KACZC,QAAS,MAIXzM,KAAK8G,aAAe,KAGpB9G,KAAK0M,kBAAoB,KAGzB1M,KAAK2M,aAAe,GAEpB3M,KAAK4M,YACP,CAKA,UAAAA,GACE,MACMC,EADe7M,KAAKgL,eAAe8B,kBACHC,SAAS,eAE/C,IAAKF,EAEH,OAGF,MAAMG,EAASH,EAAiBG,OAGhCA,EAAOC,iBAAiB,YAAajN,KAAKkN,gBAAgBC,KAAKnN,OAC/DgN,EAAOC,iBAAiB,YAAajN,KAAKoN,gBAAgBD,KAAKnN,OAC/DgN,EAAOC,iBAAiB,UAAWjN,KAAKqN,cAAcF,KAAKnN,OAC3DgN,EAAOC,iBAAiB,aAAcjN,KAAKsN,iBAAiBH,KAAKnN,OACjEgN,EAAOC,iBAAiB,QAASjN,KAAKuN,YAAYJ,KAAKnN,OAGvDgN,EAAOC,iBAAiB,aAAcjN,KAAKwN,iBAAiBL,KAAKnN,OACjEgN,EAAOC,iBAAiB,YAAajN,KAAKyN,gBAAgBN,KAAKnN,OAC/DgN,EAAOC,iBAAiB,WAAYjN,KAAK0N,eAAeP,KAAKnN,OAG7DgN,EAAOC,iBAAiB,cAAgBU,GAAMA,EAAEC,kBAIhDZ,EAAOa,SAAW,EAClBb,EAAOC,iBAAiB,UAAWjN,KAAK8N,cAAcX,KAAKnN,OAC3DgN,EAAOC,iBAAiB,QAASjN,KAAK+N,YAAYZ,KAAKnN,OAGvDgN,EAAOtD,MAAMsE,OAAS,YAGtBhO,KAAKiO,SAAW,CACdC,OAAO,EACPC,MAAM,EACNC,KAAK,EAET,CAKA,YAAAC,CAAahC,GACXrM,KAAKqM,UAAY,IAAKrM,KAAKqM,aAAcA,EAC3C,CAMA,eAAArF,CAAgBF,GACd9G,KAAK8G,aAAeA,EACpB9G,KAAK0L,cAAc1E,gBAAgBF,EACrC,CAMA,eAAAwH,CAAgBvH,GACd/G,KAAK2M,aAAe5F,GAAS,GAC7B/G,KAAK0L,cAAczE,SAASF,EAC9B,CAMA,eAAAwH,GACE,OAAOvO,KAAK2M,cAAgB,EAC9B,CAKA,eAAAO,CAAgBsB,GACd,IAAKxO,KAAKD,QAAQqL,cAAgBpL,KAAKD,QAAQsL,WAAY,OAE3DmD,EAAMZ,iBAEN,MAAMa,EAAOD,EAAMnF,OAAOqF,wBACpB5C,EAAI0C,EAAMG,QAAUF,EAAKG,KACzB7C,EAAIyC,EAAMK,QAAUJ,EAAKK,IAE/B9O,KAAK2L,aAAc,EACnB3L,KAAK6L,kBAAoB,CAAEC,IAAGC,KAC9B/L,KAAKgM,qBAAuB,CAAEF,IAAGC,KAGjC/L,KAAK+O,aAGL,MAAMC,EAAiBhP,KAAKiP,qBAAqBnD,EAAGC,GAEhDiD,EACFhP,KAAKkP,mBAAmBF,EAAgBlD,EAAGC,EAAGyC,GAG9CxO,KAAKmP,uBAAuBrD,EAAGC,EAEnC,CAKA,eAAAqB,CAAgBoB,GACd,MAAMC,EAAOD,EAAMnF,OAAOqF,wBACpB5C,EAAI0C,EAAMG,QAAUF,EAAKG,KACzB7C,EAAIyC,EAAMK,QAAUJ,EAAKK,IAE/B9O,KAAKgM,qBAAuB,CAAEF,IAAGC,KAE7B/L,KAAK2L,YACP3L,KAAKoP,eAAetD,EAAGC,GACd/L,KAAKD,QAAQoL,aACtBnL,KAAKqP,gBAAgBvD,EAAGC,EAE5B,CAKA,aAAAsB,CAAcmB,GACZ,IAAKxO,KAAK2L,YAAa,OAEvB6C,EAAMZ,iBAEN,MAAMa,EAAOD,EAAMnF,OAAOqF,wBACpB5C,EAAI0C,EAAMG,QAAUF,EAAKG,KACzB7C,EAAIyC,EAAMK,QAAUJ,EAAKK,IAE3B9O,KAAK4L,WACP5L,KAAKsP,aAAaxD,EAAGC,GAErB/L,KAAKuP,YAAYzD,EAAGC,GAGtB/L,KAAKwP,uBACP,CAKA,gBAAAlC,CAAiBkB,GACfxO,KAAK+O,aACL/O,KAAKwP,uBACP,CAMA,WAAAjC,CAAYiB,GACVA,EAAMZ,iBAEN,MAAMa,EAAOD,EAAMnF,OAAOqF,wBACpB5C,EAAI0C,EAAMG,QAAUF,EAAKG,KAGzBa,EAAkBzP,KAAKgL,eAAe0E,qBACtCC,EAAaF,EAAgBG,YAAY9D,GAG/C,IAAI+D,EAAa,KAGbrB,EAAMsB,WACRD,EAAa,KAIXrB,EAAMuB,UACRF,EAAa,GAIXrB,EAAMwB,OAAS,EACjBhQ,KAAKiQ,WAAWR,EAAiB,EAAII,EAAYF,GAEjD3P,KAAKiQ,WAAWR,EAAiBI,EAAYF,EAEjD,CAMA,UAAAM,CAAWR,EAAiBI,EAAYF,GACtC,MAAMO,EAAcT,EAAgBU,WAAWC,UACzCC,EAAaH,EAAcL,GAG3BS,QAAEA,EAAAC,QAASA,GAAYd,EAAgBU,WACvCK,EAAc5O,KAAKmC,IAAIuM,EAAS1O,KAAKqC,IAAIsM,EAASF,IAEpDG,IAAgBN,GAGpBlQ,KAAKyQ,YAAYhB,EAAiBS,EAAaM,EAAab,EAAY,IAC1E,CAKA,WAAAc,CAAYhB,EAAiBiB,EAAWC,EAAShB,EAAYiB,GAC3D,MAAMnO,EAAYoO,YAAYC,MAExBC,EAAWC,IACf,MAAMC,EAAUD,EAAcvO,EACxByO,EAAWtP,KAAKqC,IAAIgN,EAAUL,EAAU,GAGxCO,EAAe,EAAIvP,KAAKwP,IAAI,EAAIF,EAAU,GAE1ChB,EAAcQ,GAAaC,EAAUD,GAAaS,EACxD1B,EAAgB4B,QAAQnB,EAAaP,GAEjCuB,EAAW,GACbI,sBAAsBP,IAI1BO,sBAAsBP,EACxB,CAKA,oBAAA9B,CAAqBnD,EAAGC,GACtB,MAAM0D,EAAkBzP,KAAKgL,eAAe0E,qBACtCjO,EAAOgO,EAAgBG,YAAY9D,GAGnC/E,EAAQ/G,KAAKuO,kBAEnB,IAAA,MAAWlG,KAAQtB,EAAO,CACxB,MAAMwK,EAAa9B,EAAgB+B,YAAYnJ,EAAK5F,WAC9CgP,EAAWhC,EAAgB+B,YAAYnJ,EAAK3F,SAGlD,GAAId,KAAKC,IAAIiK,EAAIyF,IAAevR,KAAKD,QAAQ8F,cAC3C,MAAO,CACLqC,KAAM,gBACNO,OAAQJ,EAAKC,GACb8D,aAAc,QACd3K,KAAM4G,EAAK5F,UACXiP,MAAOH,GAKX,GAAI3P,KAAKC,IAAIiK,EAAI2F,IAAazR,KAAKD,QAAQ8F,cACzC,MAAO,CACLqC,KAAM,gBACNO,OAAQJ,EAAKC,GACb8D,aAAc,MACd3K,KAAM4G,EAAK3F,QACXgP,MAAOD,GAKX,GAAIhQ,GAAQ4G,EAAK5F,WAAahB,GAAQ4G,EAAK3F,QACzC,MAAO,CACLwF,KAAM,cACNO,OAAQJ,EAAKC,GACbD,OACA5G,OACAiQ,MAAO5F,EAGb,CAEA,OAAO,IACT,CAKA,kBAAAoD,CAAmByC,EAAS7F,EAAGC,EAAGyC,GAChC,OAAQmD,EAAQzJ,MACd,IAAK,gBACHlI,KAAK4R,uBAAuBD,EAAS7F,EAAGC,GACxC,MACF,IAAK,cACCyC,EAAMsB,SAER9P,KAAK6R,WAAWF,EAAQlJ,QAGxBzI,KAAK8R,WAAWH,EAAQlQ,MAIhC,CAKA,sBAAA0N,CAAuBrD,EAAGC,GACxB,MACMtK,EADkBzB,KAAKgL,eAAe0E,qBACfE,YAAY9D,GAEzC9L,KAAKmM,UAAY,CACfjE,KAAM,cACNzF,UAAWhB,EACXiB,QAASjB,EACTgH,OAAQ,KACR2D,aAAc,KAElB,CAKA,sBAAAwF,CAAuBD,EAAS7F,EAAGC,GACjC/L,KAAKmM,UAAY,CACfjE,KAAM,gBACNzF,UAAWkP,EAAQlQ,KACnBiB,QAASiP,EAAQlQ,KACjBgH,OAAQkJ,EAAQlJ,OAChB2D,aAAcuF,EAAQvF,aAE1B,CAKA,cAAAgD,CAAetD,EAAGC,GAChB,MAAMxJ,EAAWX,KAAKyC,KACpBzC,KAAKwP,IAAItF,EAAI9L,KAAK6L,kBAAkBC,EAAG,GACvClK,KAAKwP,IAAIrF,EAAI/L,KAAK6L,kBAAkBE,EAAG,KAGpC/L,KAAK4L,YAAcrJ,EAAWvC,KAAKD,QAAQkL,iBAC9CjL,KAAK4L,YAAa,EAClB5L,KAAK+R,aAGH/R,KAAK4L,YACP5L,KAAKgS,WAAWlG,EAAGC,EAEvB,CAKA,SAAAgG,GACE,MAAM/E,EAAShN,KAAKgL,eAAe8B,kBAAkBC,SAAS,eAAeC,OAE7E,OAAQhN,KAAKmM,UAAUjE,MACrB,IAAK,cACH8E,EAAOtD,MAAMsE,OAAS,aACtB,MACF,IAAK,gBACHhB,EAAOtD,MAAMsE,OAAS,YACtB,MACF,QACEhB,EAAOtD,MAAMsE,OAAS,WAE5B,CAKA,UAAAgE,CAAWlG,EAAGC,GACZ,MACMiF,EADkBhR,KAAKgL,eAAe0E,qBACRE,YAAY9D,GAEhD,OAAQ9L,KAAKmM,UAAUjE,MACrB,IAAK,cACHlI,KAAKmM,UAAUzJ,QAAUsO,EACzBhR,KAAKiS,oBACL,MACF,IAAK,gBACHjS,KAAKkS,mBAAmBlB,GAG9B,CAKA,kBAAAkB,CAAmBC,GACjB,MACM9J,EADQrI,KAAKuO,kBACA6D,KAAKC,GAAKA,EAAE/J,KAAOtI,KAAKmM,UAAU1D,QAErD,IAAKJ,EAAM,OAGX,MAAMY,EAAcjJ,KAAKsS,mBAAmBH,GAG5C,GAAoC,UAAhCnS,KAAKmM,UAAUC,aAA0B,CAE3CpM,KAAKmM,UAAU1J,UAAYb,KAAKqC,IAAIgF,EAAaZ,EAAK3F,QAAU,KAGhE,MAAM6P,EAAkBvS,KAAKwS,oBAAoBxS,KAAKmM,UAAU1J,UAAW4F,EAAK3F,QAAS2F,EAAKC,IAC1FiK,IACFvS,KAAKmM,UAAU1J,UAAYb,KAAKmC,IAAI/D,KAAKmM,UAAU1J,UAAW8P,EAAgB7P,SAElF,KAAO,CAEL1C,KAAKmM,UAAUzJ,QAAUd,KAAKmC,IAAIkF,EAAaZ,EAAK5F,UAAY,KAGhE,MAAM8P,EAAkBvS,KAAKwS,oBAAoBnK,EAAK5F,UAAWzC,KAAKmM,UAAUzJ,QAAS2F,EAAKC,IAC1FiK,IACFvS,KAAKmM,UAAUzJ,QAAUd,KAAKqC,IAAIjE,KAAKmM,UAAUzJ,QAAS6P,EAAgB9P,WAE9E,CAEAzC,KAAKiS,mBACP,CAKA,kBAAAK,CAAmB7Q,GACjB,IAAKzB,KAAKD,QAAQuL,oBAChB,OAAO7J,EAGT,MAAMgO,EAAkBzP,KAAKgL,eAAe0E,qBACtCvI,EAAkBsI,EAAgBgD,qBAAqBtL,iBAAmB,GAG1EuL,EAAa1S,KAAK0L,cAAc5C,cACpCrH,EACA0F,EACAnH,KAAKmM,UAAU1D,QAMjB,OAFAzI,KAAK0M,kBAAoBgG,EAElBA,EAAWzJ,WACpB,CAKA,mBAAAuJ,CAAoB/P,EAAWC,EAAS0E,GACtC,MAAML,EAAQ/G,KAAKuO,kBAEnB,IAAA,MAAWlG,KAAQtB,EACjB,GAAIsB,EAAKC,KAAOlB,KAGV1E,GAAW2F,EAAK5F,WAAaA,GAAa4F,EAAK3F,SACnD,OAAO2F,EAIX,OAAO,IACT,CAKA,iBAAA4J,GACE,MAAMU,EAAe3S,KAAKgL,eAAe8B,kBACnCD,EAAmB8F,EAAa5F,SAAS,eAE/C,IAAKF,EAAkB,OAEvB,MAAM+F,IAAEA,GAAQ/F,GACVpD,MAAEA,EAAAoJ,OAAOA,GAAWF,EAAaG,gBACjCrD,EAAkBzP,KAAKgL,eAAe0E,qBAK5C,OAFAiD,EAAaI,WAAW,eAEhB/S,KAAKmM,UAAUjE,MACrB,IAAK,cACHlI,KAAKgT,0BAA0BJ,EAAKnD,EAAiBhG,EAAOoJ,GAC5D,MACF,IAAK,gBACH7S,KAAKiT,0BAA0BL,EAAKnD,EAAiBhG,EAAOoJ,GAGlE,CAKA,yBAAAG,CAA0BJ,EAAKnD,EAAiBhG,EAAOoJ,GACrD,MAAMtB,EAAa9B,EAAgB+B,YAAYxR,KAAKmM,UAAU1J,WACxDgP,EAAWhC,EAAgB+B,YAAYxR,KAAKmM,UAAUzJ,SAEtDwQ,EAAYtR,KAAKqC,IAAIsN,EAAYE,GACjC0B,EAAavR,KAAKmC,IAAIwN,EAAYE,GAClC2B,EAAcD,EAAaD,EAEjC,GAAIE,EAAc,EAAG,CAEnB,MAAMC,EAAWT,EAAIU,qBAAqBJ,EAAW,EAAGC,EAAY,GACpEE,EAASE,aAAa,EAAG,2BACzBF,EAASE,aAAa,GAAK,2BAC3BF,EAASE,aAAa,EAAG,2BAEzBX,EAAIY,UAAYH,EAChBT,EAAIa,SAASP,EAAW,EAAGE,EAAaP,GAGxC,MAAMa,EAAmBC,KAAK7C,MAAQ,IAAQ,IAAO,GACrD8B,EAAIgB,YAAc,0BAClBhB,EAAIiB,UAAY,EAChBjB,EAAIkB,YAAY,CAAC,EAAG,IACpBlB,EAAImB,eAAiBL,EAErBd,EAAIoB,YACJpB,EAAIqB,OAAOf,EAAW,GACtBN,EAAIsB,OAAOhB,EAAWL,GACtBD,EAAIqB,OAAOd,EAAY,GACvBP,EAAIsB,OAAOf,EAAYN,GACvBD,EAAIuB,SAEJvB,EAAIkB,YAAY,IAChBlB,EAAImB,eAAiB,EAGrB/T,KAAKoU,kBAAkBxB,EAAKM,EAAWC,EAAYN,EACrD,CAGA7S,KAAKqU,yBAAyBzB,EAAKM,EAAWC,EAAYN,EAC5D,CAKA,yBAAAI,CAA0BL,EAAKnD,EAAiBhG,EAAOoJ,GACrD,MACMxK,EADQrI,KAAKuO,kBACA6D,KAAKC,GAAKA,EAAE/J,KAAOtI,KAAKmM,UAAU1D,QAErD,IAAKJ,EAAM,OAGX,IAAI5F,EAAY4F,EAAK5F,UACjBC,EAAU2F,EAAK3F,QAEiB,UAAhC1C,KAAKmM,UAAUC,aACjB3J,EAAYzC,KAAKmM,UAAU1J,UAE3BC,EAAU1C,KAAKmM,UAAUzJ,QAG3B,MAAM6O,EAAa9B,EAAgB+B,YAAY/O,GACzCgP,EAAWhC,EAAgB+B,YAAY9O,GAGvC4R,EAAa,GAAM,GAAM1S,KAAK2S,IAAIZ,KAAK7C,MAAQ,KACrD8B,EAAIY,UAAY,qBAAqBc,KACrC1B,EAAIa,SAASlC,EAAY,EAAGE,EAAWF,EAAYsB,GAGnD,MAAM2B,EAAsD,UAAhCxU,KAAKmM,UAAUC,aAA2BqF,EAAWF,EACjFqB,EAAIgB,YAAc,yBAClBhB,EAAIiB,UAAY,EAChBjB,EAAIoB,YACJpB,EAAIqB,OAAOO,EAAqB,GAChC5B,EAAIsB,OAAOM,EAAqB3B,GAChCD,EAAIuB,SAGJ,MAAMM,EAAgD,UAAhCzU,KAAKmM,UAAUC,aAA2BmF,EAAaE,EAG7EmB,EAAI8B,YAAc,yBAClB9B,EAAI+B,WAAa,EACjB/B,EAAIgB,YAAc,uBAClBhB,EAAIiB,UAAY,EAChBjB,EAAIoB,YACJpB,EAAIqB,OAAOQ,EAAe,GAC1B7B,EAAIsB,OAAOO,EAAe5B,GAC1BD,EAAIuB,SAGJvB,EAAI8B,YAAc,cAClB9B,EAAI+B,WAAa,EAGjB3U,KAAK4U,iBAAiBhC,EAAK6B,EAAe5B,EAAS,EAAG,UAGtD7S,KAAK6U,qBAAqBjC,EAAKnD,EAAiBhG,EAAOoJ,GAGvD7S,KAAKqU,yBAAyBzB,EAAKrB,EAAYE,EAAUoB,EAC3D,CAKA,iBAAAuB,CAAkBxB,EAAKM,EAAWC,EAAYN,GAC5C7S,KAAK4U,iBAAiBhC,EAAKM,EAAWL,EAAS,EAAG,SAClD7S,KAAK4U,iBAAiBhC,EAAKO,EAAYN,EAAS,EAAG,MACrD,CAKA,gBAAA+B,CAAiBhC,EAAK9G,EAAGC,EAAG7D,GAC1B,MACM4M,EAAuB,WAAT5M,EAAoB,uBAAyB,wBAGjE0K,EAAIY,UAAY,2BAChBZ,EAAIa,SAAS3H,EAAIiJ,EAAgBhJ,EAAIgJ,EALlB,KAQnBnC,EAAIgB,YAAckB,EAClBlC,EAAIiB,UAAY,EAChBjB,EAAIoC,WAAWlJ,EAAIiJ,EAAgBhJ,EAAIgJ,EAVpB,KAanBnC,EAAIgB,YAAckB,EAClBlC,EAAIiB,UAAY,EAChBjB,EAAIoB,YACJpB,EAAIqB,OAAOnI,EAAI,EAAGC,EAAI,GACtB6G,EAAIsB,OAAOpI,EAAI,EAAGC,EAAI,GACtB6G,EAAIqB,OAAOnI,EAAGC,EAAI,GAClB6G,EAAIsB,OAAOpI,EAAGC,EAAI,GAClB6G,EAAIqB,OAAOnI,EAAI,EAAGC,EAAI,GACtB6G,EAAIsB,OAAOpI,EAAI,EAAGC,EAAI,GACtB6G,EAAIuB,QACN,CAKA,oBAAAU,CAAqBjC,EAAKnD,EAAiBhG,EAAOoJ,GAChD,IAAK7S,KAAKD,QAAQuL,sBAAwBtL,KAAKD,QAAQyG,mBAAoB,OAE3E,MAAMwK,EAA8C,UAAhChR,KAAKmM,UAAUC,aACjCpM,KAAKmM,UAAU1J,UAAYzC,KAAKmM,UAAUzJ,QACtCyE,EAAkBsI,EAAgBgD,qBAAqBtL,iBAAmB,GA0ChF,GAvCuBnH,KAAK0L,cAActC,kBACxC4H,EACA7J,EACAnH,KAAKmM,UAAU1D,QAIF0B,QAAQ8K,IACrB,MAAMvD,EAAQjC,EAAgB+B,YAAYyD,EAAUxT,MAMpD,OAHAmR,EAAIgB,YAAcqB,EAAU1L,MAC5BqJ,EAAIiB,UAAYoB,EAAUxL,MAElBwL,EAAUvL,OAChB,IAAK,SACHkJ,EAAIkB,YAAY,CAAC,EAAG,IACpB,MACF,IAAK,SACHlB,EAAIkB,YAAY,CAAC,EAAG,IACpB,MACF,QACElB,EAAIkB,YAAY,IAIpBlB,EAAIoB,YACJpB,EAAIqB,OAAOvC,EAAO,GAClBkB,EAAIsB,OAAOxC,EAAOmB,GAClBD,EAAIuB,SAGJnU,KAAKkV,eAAetC,EAAKlB,EAAOmB,EAAQoC,GAGxCrC,EAAIkB,YAAY,MAId9T,KAAK0M,mBAAmBxD,WAAY,CACtC,MAAMiM,EAAY1F,EAAgB+B,YAAYxR,KAAK0M,kBAAkBzD,aAGrE2J,EAAI8B,YAAc,yBAClB9B,EAAI+B,WAAa,EACjB/B,EAAIgB,YAAc,uBAClBhB,EAAIiB,UAAY,EAEhBjB,EAAIoB,YACJpB,EAAIqB,OAAOkB,EAAW,GACtBvC,EAAIsB,OAAOiB,EAAWtC,GACtBD,EAAIuB,SAGJvB,EAAI8B,YAAc,cAClB9B,EAAI+B,WAAa,CACnB,CACF,CAKA,cAAAO,CAAetC,EAAK9G,EAAG+G,EAAQoC,GAC7B,MACMG,EAAQvC,EAAS,GAIvB,OAFAD,EAAIY,UAAYyB,EAAU1L,MAElB0L,EAAU/M,MAChB,IAAK,gBAEH0K,EAAIoB,YACJpB,EAAIyC,IAAIvJ,EAAGsJ,EAAOE,EAAc,EAAa,EAAV1T,KAAK2T,IACxC3C,EAAI4C,OAGJ5C,EAAIgB,YAAc,QAClBhB,EAAIiB,UAAY,EAChBjB,EAAIoB,YACJpB,EAAIqB,OAAOnI,EAAI,EAAGsJ,GAClBxC,EAAI6C,iBAAiB3J,EAAI,EAAGsJ,EAAQ,EAAGtJ,EAAI,EAAGsJ,GAC9CxC,EAAI6C,iBAAiB3J,EAAI,EAAGsJ,EAAQ,EAAGtJ,EAAI,EAAGsJ,GAC9CxC,EAAIuB,SACJ,MAEF,IAAK,gBAEHvB,EAAIa,SAAS3H,EAAIwJ,EAAcF,EAAQE,EAxB1B,KA2Bb1C,EAAIY,UAAY,QACU,UAAtByB,EAAUzM,SAEZoK,EAAIoB,YACJpB,EAAIqB,OAAOnI,EAAI,EAAGsJ,GAClBxC,EAAIsB,OAAOpI,EAAI,EAAGsJ,EAAQ,GAC1BxC,EAAIsB,OAAOpI,EAAI,EAAGsJ,EAAQ,GAC1BxC,EAAI4C,SAGJ5C,EAAIoB,YACJpB,EAAIqB,OAAOnI,EAAI,EAAGsJ,GAClBxC,EAAIsB,OAAOpI,EAAI,EAAGsJ,EAAQ,GAC1BxC,EAAIsB,OAAOpI,EAAI,EAAGsJ,EAAQ,GAC1BxC,EAAI4C,QAEN,MAEF,IAAK,OAEH5C,EAAIa,SAAS3H,EAAI,EAAGsJ,EAAQE,EAAc,EA/C7B,GAgDb1C,EAAIa,SAAS3H,EAAIwJ,EAAcF,EAAQ,EAhD1B,EAgDuC,GACpD,MAEF,QAEExC,EAAIa,SAAS3H,EAAIwJ,EAAcF,EAAQE,EArD1B,KAuDnB,CAKA,wBAAAjB,CAAyBzB,EAAKrB,EAAYE,EAAUoB,GAClD,MAAMpQ,EAAYb,KAAKqC,IAAIjE,KAAKmM,UAAU1J,UAAWzC,KAAKmM,UAAUzJ,SAC9DA,EAAUd,KAAKmC,IAAI/D,KAAKmM,UAAU1J,UAAWzC,KAAKmM,UAAUzJ,SAE5DgT,GAAenE,EAAaE,GAAY,EAGxCkE,EAAe,IAJJjT,EAAUD,GAIMyC,QAAQ,MACnC0Q,EAAY,GAAGnT,EAAUyC,QAAQ,MACjC2Q,EAAU,GAAGnT,EAAQwC,QAAQ,MAGnC0N,EAAIkD,KAAO,iBACX,MAAMC,EAAgBnD,EAAIoD,YAAYL,GAAclM,MAC9CwM,EAAarD,EAAIoD,YAAYJ,GAAWnM,MACxCyM,EAAWtD,EAAIoD,YAAYH,GAASpM,MAKpC0M,EAAWvU,KAAKmC,IAAIgS,EAAeE,EAAYC,GAAYE,GAGjE,IAAIC,EAAWX,EAAcS,EAAW,EACpCG,EAAWzD,EALK0D,GAKkB,GAGtC,MAAM9M,MAAEA,GAAUzJ,KAAKgL,eAAe8B,kBAAkBgG,gBACpDuD,EAAW,IAAGA,EAAW,GACzBA,EAAWF,EAAW1M,EAAQ,IAAG4M,EAAW5M,EAAQ0M,EAAW,GAC/DG,EAAW,IAAGA,EAAW1U,KAAKqC,IAAIsN,EAAYE,GAAY,IAG9DzR,KAAKwW,gBAAgB5D,EAAKyD,EAAUC,EAAUH,EAd1BI,GAciD,GACrE3D,EAAIY,UAAY,qBAChBZ,EAAI4C,OAGJ5C,EAAIgB,YAAc,2BAClBhB,EAAIiB,UAAY,EAChBjB,EAAIuB,SAGJvB,EAAIY,UAAY,QAChBZ,EAAI6D,UAAY,SAChB,MAAMC,EAAQL,EAAWF,EAAW,EAEpCvD,EAAI+D,SAAShB,EAAce,EAAOJ,EA9BlB,EACG,IA+BnB1D,EAAIY,UAAY,2BAChBZ,EAAIkD,KAAO,iBACXlD,EAAI+D,SAAS,UAAUf,IAAac,EAAOJ,EAlC3B,EAkCgDC,IAChE3D,EAAI+D,SAAS,QAAQd,IAAWa,EAAOJ,EAnCvB,EAmC4CC,GAC9D,CAKA,eAAAC,CAAgB5D,EAAK9G,EAAGC,EAAGtC,EAAOoJ,EAAQ+D,GACxChE,EAAIoB,YACJpB,EAAIqB,OAAOnI,EAAI8K,EAAQ7K,GACvB6G,EAAIsB,OAAOpI,EAAIrC,EAAQmN,EAAQ7K,GAC/B6G,EAAI6C,iBAAiB3J,EAAIrC,EAAOsC,EAAGD,EAAIrC,EAAOsC,EAAI6K,GAClDhE,EAAIsB,OAAOpI,EAAIrC,EAAOsC,EAAI8G,EAAS+D,GACnChE,EAAI6C,iBAAiB3J,EAAIrC,EAAOsC,EAAI8G,EAAQ/G,EAAIrC,EAAQmN,EAAQ7K,EAAI8G,GACpED,EAAIsB,OAAOpI,EAAI8K,EAAQ7K,EAAI8G,GAC3BD,EAAI6C,iBAAiB3J,EAAGC,EAAI8G,EAAQ/G,EAAGC,EAAI8G,EAAS+D,GACpDhE,EAAIsB,OAAOpI,EAAGC,EAAI6K,GAClBhE,EAAI6C,iBAAiB3J,EAAGC,EAAGD,EAAI8K,EAAQ7K,GACvC6G,EAAIiE,WACN,CAKA,WAAAtH,CAAYzD,EAAGC,GACb,IAAK/L,KAAKD,QAAQqL,YAAa,OAE/B,MACM3J,EADkBzB,KAAKgL,eAAe0E,qBACfE,YAAY9D,GAGzC9L,KAAK8W,iBAAiBrV,EACxB,CAKA,YAAA6N,CAAaxD,EAAGC,GACd,OAAQ/L,KAAKmM,UAAUjE,MACrB,IAAK,cACHlI,KAAK+W,uBACL,MACF,IAAK,gBACH/W,KAAKgX,uBAKYhX,KAAKgL,eAAe8B,kBAC5BiG,WAAW,cAC1B,CAKA,oBAAAgE,GACE,IAAItU,EAAYb,KAAKqC,IAAIjE,KAAKmM,UAAU1J,UAAWzC,KAAKmM,UAAUzJ,SAC9DA,EAAUd,KAAKmC,IAAI/D,KAAKmM,UAAU1J,UAAWzC,KAAKmM,UAAUzJ,SAIhE,GAHiBA,EAAUD,EAGZ,IAAM,CAEnB,GAAIzC,KAAKD,QAAQyL,yBAA0B,CACzC,MAAM+G,EAAkBvS,KAAKwS,oBAAoB/P,EAAWC,EAAS,MACjE6P,IAEE9P,EAAY8P,EAAgB9P,UAC9BC,EAAUd,KAAKqC,IAAIvB,EAAS6P,EAAgB9P,WAE5CA,EAAYb,KAAKmC,IAAItB,EAAW8P,EAAgB7P,SAGtD,CAGIA,EAAUD,EAAY,KACxBzC,KAAKiX,WAAWxU,EAAWC,EAE/B,CACF,CAKA,oBAAAsU,GAIE,IAHchX,KAAKuO,kBACA6D,KAAKC,GAAKA,EAAE/J,KAAOtI,KAAKmM,UAAU1D,QAE1C,OAEX,MAAMyO,EAAU,CAAA,EAEoB,UAAhClX,KAAKmM,UAAUC,aACjB8K,EAAQzU,UAAYzC,KAAKmM,UAAU1J,UAEnCyU,EAAQxU,QAAU1C,KAAKmM,UAAUzJ,QAGnC1C,KAAKmX,WAAWnX,KAAKmM,UAAU1D,OAAQyO,EACzC,CAKA,eAAA7H,CAAgBvD,EAAGC,GAEb/L,KAAKiM,cACPmL,aAAapX,KAAKiM,cAIpBjM,KAAKiM,aAAeoL,WAAW,KAC7BrX,KAAKsX,cAAcxL,EAAGC,IACrB/L,KAAKD,QAAQmL,WAClB,CAKA,aAAAoM,CAAcxL,EAAGC,GACf,MAAM4F,EAAU3R,KAAKiP,qBAAqBnD,EAAGC,GAEvCtK,EADkBzB,KAAKgL,eAAe0E,qBACfE,YAAY9D,GAErC6F,EACF3R,KAAKuX,iBAAiB5F,EAAS7F,EAAGC,GAElC/L,KAAKwX,cAAc/V,EAAMqK,EAAGC,EAEhC,CAMA,gBAAAwL,CAAiB5F,EAAS7F,EAAGC,GAC3B,MAAM4G,EAAe3S,KAAKgL,eAAe8B,kBACnCD,EAAmB8F,EAAa5F,SAAS,eAE/C,IAAKF,EAAkB,OAEvB,MAAM+F,IAAEA,GAAQ/F,GACVgG,OAAEA,GAAWF,EAAaG,gBAGhCH,EAAaI,WAAW,eAExB,IAAI0E,EAAc,KAElB,OAAQ9F,EAAQzJ,MACd,IAAK,gBACHuP,EAAczX,KAAK0X,0BAA0B/F,GAC7C,MACF,IAAK,cACH8F,EAAczX,KAAK2X,sBAAsBhG,GAIzC8F,IACFzX,KAAK4X,sBAAsBhF,EAAK6E,EAAa3L,EAAGC,GAChD/L,KAAKkM,eAAiByF,EAGlB3R,KAAKqM,UAAUI,SACjBzM,KAAKqM,UAAUI,QAAQkF,EAAS7F,EAAGC,IAKvC,MAAMiB,EAASH,EAAiBG,OAChC,OAAQ2E,EAAQzJ,MACd,IAAK,gBACH8E,EAAOtD,MAAMsE,OAAS,YACtB,MACF,IAAK,cACHhB,EAAOtD,MAAMsE,OAAS,UACtB,MACF,QACEhB,EAAOtD,MAAMsE,OAAS,YAE5B,CAKA,yBAAA0J,CAA0B/F,GACxB,MAAMtJ,EAAOrI,KAAKuO,kBAAkB6D,KAAKC,GAAKA,EAAE/J,KAAOqJ,EAAQlJ,QAC/D,IAAKJ,EAAM,OAAO,KAElB,MAAMuI,EAAWvI,EAAK3F,QAAU2F,EAAK5F,UAGrC,MAAO,CACLoV,MAAO,GAHqC,UAAzBlG,EAAQvF,aAA2B,QAAU,iBAIhE7C,MAAO,yBACPuO,MAAO,CACL,SAASnG,EAAQlQ,KAAKyD,QAAQ,MAC9B,SAASmD,EAAK0P,OAAS1P,EAAK2P,MAAQ3P,EAAKC,GAAGkC,MAAM,EAAG,KACrD,aAAaoG,EAAS1L,QAAQ,MAC9B,UAAUmD,EAAK5F,UAAUyC,QAAQ,SAASmD,EAAK3F,QAAQwC,QAAQ,OAEjE+S,QAAS,CACP,0BACA,8BAGN,CAKA,qBAAAN,CAAsBhG,GACpB,MAAMtJ,EAAOsJ,EAAQtJ,KACfuI,EAAWvI,EAAK3F,QAAU2F,EAAK5F,UAE/ByV,EADcvG,EAAQlQ,KACO4G,EAAK5F,UAClCyO,EAAYgH,EAAetH,EAAY,IAGvCuH,EAAgBnY,KAAKoY,yBAAyB/P,GAE9CoP,EAAc,CAClBI,MAAO,QAAQxP,EAAK0P,OAAS1P,EAAK2P,MAAQ3P,EAAKC,GAAGkC,MAAM,EAAG,KAC3DjB,MAAOlB,EAAKkB,OAAS,0BACrBuO,MAAO,CACL,aAAalH,EAAS1L,QAAQ,MAC9B,UAAUmD,EAAK5F,UAAUyC,QAAQ,MACjC,QAAQmD,EAAK3F,QAAQwC,QAAQ,MAC7B,aAAagT,EAAahT,QAAQ,QAAQgM,EAAShM,QAAQ,QAE7D+S,QAAS,CACP,4BACA,wBACA,8BAwBJ,OAnBIE,EAAclX,OAAS,IACzBwW,EAAYK,MAAMvW,KAAK,IACvBkW,EAAYK,MAAMvW,KAAK,kBACvB4W,EAAchO,QAAQkO,IACpB,OAAQA,EAAInQ,MACV,IAAK,UACH,MAAMoQ,EAAWD,EAAIC,SAAW,GAAM,QAAU,QAChDb,EAAYK,MAAMvW,KAAK,KAAK+W,kBAAyBD,EAAIhQ,KAAK0P,OAASM,EAAIhQ,KAAKC,GAAGkC,MAAM,EAAG,MAC5F,MACF,IAAK,iBACHiN,EAAYK,MAAMvW,KAAK,iBAAiB8W,EAAIhQ,KAAK0P,OAASM,EAAIhQ,KAAKC,GAAGkC,MAAM,EAAG,MAC/E,MACF,IAAK,kBACHiN,EAAYK,MAAMvW,KAAK,mBAAmB8W,EAAIhQ,KAAK0P,OAASM,EAAIhQ,KAAKC,GAAGkC,MAAM,EAAG,UAMlFiN,CACT,CAKA,wBAAAW,CAAyBG,GACvB,MAAMC,EAAWxY,KAAKuO,kBAChB4J,EAAgB,GAuCtB,OApCAK,EAASrO,QAAQsO,IACf,GAAIA,EAAUnQ,KAAOiQ,EAAYjQ,GAGjC,GAAMiQ,EAAY7V,SAAW+V,EAAUhW,WAAa8V,EAAY9V,WAAagW,EAAU/V,QAgB9Ed,KAAKC,IAAI0W,EAAY7V,QAAU+V,EAAUhW,YAtBlC,IAuBd0V,EAAc5W,KAAK,CACjB2G,KAAM,iBACNG,KAAMoQ,EACNC,IAAKD,EAAUhW,UAAY8V,EAAY7V,UAGlCd,KAAKC,IAAI4W,EAAU/V,QAAU6V,EAAY9V,YA7BlC,KA8Bd0V,EAAc5W,KAAK,CACjB2G,KAAM,kBACNG,KAAMoQ,EACNC,IAAKH,EAAY9V,UAAYgW,EAAU/V,cA3BsD,CAC/F,MAAMiW,EAAe/W,KAAKmC,IAAIwU,EAAY9V,UAAWgW,EAAUhW,WAEzDmW,EADahX,KAAKqC,IAAIsU,EAAY7V,QAAS+V,EAAU/V,SACtBiW,EAE/BE,EAAkBN,EAAY7V,QAAU6V,EAAY9V,UACpDqW,EAAgBL,EAAU/V,QAAU+V,EAAUhW,UAC9CsW,EAAcnX,KAAKqC,IAAI4U,EAAiBC,GAE9CX,EAAc5W,KAAK,CACjB2G,KAAM,UACNG,KAAMoQ,EACNH,SAAUM,EAAkBG,GAEhC,IAkBKZ,CACT,CAKA,aAAAX,CAAc/V,EAAMqK,EAAGC,GACrB,MAAM4G,EAAe3S,KAAKgL,eAAe8B,kBACnCD,EAAmB8F,EAAa5F,SAAS,eAE/C,IAAKF,EAAkB,OAEvB,MAAM+F,IAAEA,GAAQ/F,EAGhB8F,EAAaI,WAAW,eAExB,MAAMiG,EAAW,GAAGvX,EAAKyD,QAAQ,MACjClF,KAAKiZ,mBAAmBrG,EAAKoG,EAAUlN,EAAGC,EAAG,4BAG7Cc,EAAiBG,OAAOtD,MAAMsE,OAAS,WACzC,CAMA,qBAAA4J,CAAsBhF,EAAK6E,EAAa3L,EAAGC,GACzC,MAAMqK,EAAU,GAOhBxD,EAAIkD,KAAO,iBACX,IAAIK,EAAW,EAGfvD,EAAIkD,KAAO,sBACX,MAAMoD,EAAatG,EAAIoD,YAAYyB,EAAYI,OAAOpO,MACtD0M,EAAWvU,KAAKmC,IAAIoS,EAAU+C,GAG9BtG,EAAIkD,KAAO,iBACX2B,EAAYK,MAAM3N,QAAQgP,IACxB,GAAIA,EAAKC,OAAQ,CACf,MAAMvF,EAAYjB,EAAIoD,YAAYmD,GAAM1P,MACxC0M,EAAWvU,KAAKmC,IAAIoS,EAAUtC,EAChC,IAIFjB,EAAIkD,KAAO,iBACP2B,EAAYQ,SACdR,EAAYQ,QAAQ9N,QAAQkP,IAC1B,MAAMC,EAAc1G,EAAIoD,YAAYqD,GAAQ5P,MAC5C0M,EAAWvU,KAAKmC,IAAIoS,EAAUmD,KAIlC,MAAMC,EAAepD,EAAWC,GAC1BoD,EAAe/B,EAAYK,MAAMjT,UAAesU,EAAKC,QAAQnY,OAC7DwY,EAAchC,EAAYQ,QAAUR,EAAYQ,QAAQhX,OAAS,EACjEyY,EAAmBjC,EAAYQ,SAAWwB,EAAc,EAAK,EAAI,EACjEE,EAnCc,GADD,GAoCkBH,EAA6BE,EAAmB,GAAAD,EAAkCrD,IAGjH3M,MAAEA,SAAOoJ,GAAW7S,KAAKgL,eAAe8B,kBAAkBgG,gBAChE,IAAIuD,EAAWvK,EAAI,GACfwK,EAAWvK,EAAI4N,EAAgB,GAG/BtD,EAAWkD,EAAe9P,EAAQ,KACpC4M,EAAWvK,EAAIyN,EAAe,IAE5BlD,EAAW,KACbA,EAAW,IAITC,EAAW,KACbA,EAAWvK,EAAI,IAEbuK,EAAWqD,EAAgB9G,EAAS,KACtCyD,EAAWzD,EAAS8G,EAAgB,IAItC3Z,KAAK4Z,sBAAsBhH,EAAKyD,EAAUC,EAAUiD,EAAcI,EAAelC,EAAYlO,OAG7F,IAAIsQ,EAAWvD,EAAWF,EA9DN,GA8D8B,EAGlDxD,EAAIkD,KAAO,sBACXlD,EAAIY,UAAYiE,EAAYlO,MAC5BqJ,EAAI6D,UAAY,OAChB7D,EAAI+D,SAASc,EAAYI,MAAOxB,EAAWD,EAASyD,GAEpDA,GAAY,EAGZjH,EAAIkD,KAAO,iBACXlD,EAAIY,UAAY,2BAEhBiE,EAAYK,MAAM3N,QAAQgP,IACpBA,EAAKC,SACPS,GA/Ee,GAkFXV,EAAKW,SAAS,KAChBlH,EAAIY,UAAY,0BACP2F,EAAKW,SAAS,MAAQX,EAAKW,SAAS,KAC7ClH,EAAIY,UAAY,yBACP2F,EAAKW,SAAS,kBACvBlH,EAAIY,UAAY,2BAEhBZ,EAAIY,UAAY,2BAGlBZ,EAAI+D,SAASwC,EAAM9C,EAAWD,EAASyD,MAKvCpC,EAAYQ,SAAWwB,EAAc,IACvCI,GAAYH,EACZ9G,EAAIgB,YAAc,2BAClBhB,EAAIiB,UAAY,EAChBjB,EAAIoB,YACJpB,EAAIqB,OAAOoC,EAAWD,EAASyD,EAAW,GAC1CjH,EAAIsB,OAAOmC,EAAWkD,EAAenD,EAASyD,EAAW,GACzDjH,EAAIuB,UAIFsD,EAAYQ,UACdrF,EAAIkD,KAAO,iBACXlD,EAAIY,UAAY,2BAEhBiE,EAAYQ,QAAQ9N,QAAQkP,IAC1BQ,GAAYtD,GACZ3D,EAAI+D,SAAS,KAAK0C,IAAUhD,EAAWD,EAASyD,KAGtD,CAKA,qBAAAD,CAAsBhH,EAAK9G,EAAGC,EAAGtC,EAAOoJ,EAAQkH,GAI9CnH,EAAI8B,YAAc,qBAClB9B,EAAI+B,WAAa,EACjB/B,EAAIoH,cAAgB,EACpBpH,EAAIqH,cAAgB,EAGpBrH,EAAIY,UAAY,sBAChBxT,KAAKwW,gBAAgB5D,EAAK9G,EAAGC,EAAGtC,EAAOoJ,EAVxB,GAWfD,EAAI4C,OAGJ5C,EAAI8B,YAAc,cAClB9B,EAAI+B,WAAa,EACjB/B,EAAIoH,cAAgB,EACpBpH,EAAIqH,cAAgB,EAGpBrH,EAAIgB,YAAcmG,EAClBnH,EAAIiB,UAAY,EAChB7T,KAAKwW,gBAAgB5D,EAAK9G,EAAGC,EAAGtC,EAAOoJ,EAtBxB,GAuBfD,EAAIuB,SAGJvB,EAAIgB,YAAc,GAAGmG,MACrBnH,EAAIiB,UAAY,EAChB7T,KAAKwW,gBAAgB5D,EAAK9G,EAAI,EAAGC,EAAI,EAAGtC,EAAQ,EAAGoJ,EAAS,EAAG+D,GAC/DhE,EAAIuB,QACN,CAKA,kBAAA8E,CAAmBrG,EAAKsH,EAAMpO,EAAGC,EAAGxC,GAClC,MAAMkO,EAAc,CAClBI,MAAOqC,EACP3Q,QACAuO,MAAO,GACPG,QAAS,MAGXjY,KAAK4X,sBAAsBhF,EAAK6E,EAAa3L,EAAGC,EAClD,CAKA,UAAAgD,GAME,GALI/O,KAAKiM,eACPmL,aAAapX,KAAKiM,cAClBjM,KAAKiM,aAAe,MAGlBjM,KAAKkM,eAAgB,CACvB,MAAMyG,EAAe3S,KAAKgL,eAAe8B,kBACzC6F,EAAaI,WAAW,eAGxB,MAAMlG,EAAmB8F,EAAa5F,SAAS,eAC3CF,IACFA,EAAiBG,OAAOtD,MAAMsE,OAAS,aAGzChO,KAAKkM,eAAiB,IACxB,CACF,CAKA,qBAAAsD,GACExP,KAAK2L,aAAc,EACnB3L,KAAK4L,YAAa,EAClB5L,KAAKmM,UAAY,CACfjE,KAAM,KACNzF,UAAW,EACXC,QAAS,EACT+F,OAAQ,KACR2D,aAAc,MAIhB,MACMS,EADe7M,KAAKgL,eAAe8B,kBACHC,SAAS,eAC3CF,IACFA,EAAiBG,OAAOtD,MAAMsE,OAAS,YAE3C,CAKA,gBAAAR,CAAiBgB,GACfA,EAAMZ,iBACN,MAAMuM,EAAQ3L,EAAM4L,QAAQ,GACtBC,EAAa,CACjBnS,KAAM,YACNyG,QAASwL,EAAMxL,QACfE,QAASsL,EAAMtL,QACfjB,eAAgB,OAChBvE,OAAQmF,EAAMnF,QAEhBrJ,KAAKkN,gBAAgBmN,EACvB,CAEA,eAAA5M,CAAgBe,GACdA,EAAMZ,iBACN,MAAMuM,EAAQ3L,EAAM4L,QAAQ,GACtBC,EAAa,CACjBnS,KAAM,YACNyG,QAASwL,EAAMxL,QACfE,QAASsL,EAAMtL,QACfjB,eAAgB,OAChBvE,OAAQmF,EAAMnF,QAEhBrJ,KAAKoN,gBAAgBiN,EACvB,CAEA,cAAA3M,CAAec,GACbA,EAAMZ,iBACN,MAAMyM,EAAa,CACjBnS,KAAM,UACNyG,QAAS3O,KAAKgM,qBAAqBF,EACnC+C,QAAS7O,KAAKgM,qBAAqBD,EACnC6B,eAAgB,OAChBvE,OAAQmF,EAAMnF,QAEhBrJ,KAAKqN,cAAcgN,EACrB,CAMA,aAAAvM,CAAcU,GAEZxO,KAAKiO,SAASC,MAAQM,EAAMsB,SAC5B9P,KAAKiO,SAASE,KAAOK,EAAMuB,QAC3B/P,KAAKiO,SAASG,IAAMI,EAAM8L,OAE1B,MAAM7K,EAAkBzP,KAAKgL,eAAe0E,qBACtC6K,EAAW9K,EAAgBU,WAEjC,OAAQ3B,EAAMgM,MAEZ,IAAK,QACL,IAAK,aACChM,EAAMuB,SAAWvB,EAAMiM,WACzBjM,EAAMZ,iBACN5N,KAAKiQ,WAAWR,EAAiB,IAAK8K,EAAS5K,aAEjD,MAEF,IAAK,QACL,IAAK,kBACCnB,EAAMuB,SAAWvB,EAAMiM,WACzBjM,EAAMZ,iBACN5N,KAAKiQ,WAAWR,EAAiB,EAAI,IAAK8K,EAAS5K,aAErD,MAEF,IAAK,SACL,IAAK,WACCnB,EAAMuB,SAAWvB,EAAMiM,WACzBjM,EAAMZ,iBACN5N,KAAK0a,iBAAiBjL,IAExB,MAGF,IAAK,YACHjB,EAAMZ,iBACN5N,KAAK2a,kBAAkBlL,EAAiB,OAAQjB,EAAMsB,UACtD,MAEF,IAAK,aACHtB,EAAMZ,iBACN5N,KAAK2a,kBAAkBlL,EAAiB,QAASjB,EAAMsB,UACvD,MAEF,IAAK,OACHtB,EAAMZ,iBACN5N,KAAK4a,iBAAiBnL,EAAiB,GACvC,MAEF,IAAK,MACHjB,EAAMZ,iBACN5N,KAAK4a,iBAAiBnL,EAAiB8K,EAASM,eAChD,MAGF,IAAK,UACCrM,EAAMuB,SAAWvB,EAAMiM,WACzBjM,EAAMZ,iBACN5N,KAAK8a,mBAAmBrL,EAAiB,EAAK8K,EAAS5K,aAEzD,MAEF,IAAK,UACCnB,EAAMuB,SAAWvB,EAAMiM,WACzBjM,EAAMZ,iBACN5N,KAAK8a,mBAAmBrL,EAAiB,EAAK8K,EAAS5K,aAEzD,MAEF,IAAK,UACCnB,EAAMuB,SAAWvB,EAAMiM,WACzBjM,EAAMZ,iBACN5N,KAAK8a,mBAAmBrL,EAAiB,EAAK8K,EAAS5K,aAEzD,MAGF,IAAK,SACHnB,EAAMZ,iBACN5N,KAAK2a,kBAAkBlL,EAAiB,QAAQ,GAChD,MAEF,IAAK,WACHjB,EAAMZ,iBACN5N,KAAK2a,kBAAkBlL,EAAiB,SAAS,GAGvD,CAKA,WAAA1B,CAAYS,GAEVxO,KAAKiO,SAASC,MAAQM,EAAMsB,SAC5B9P,KAAKiO,SAASE,KAAOK,EAAMuB,QAC3B/P,KAAKiO,SAASG,IAAMI,EAAM8L,MAC5B,CAMA,iBAAAK,CAAkBlL,EAAiBsL,EAAWC,GAAU,GACtD,MAAMT,EAAW9K,EAAgBU,WAC3B8K,EAAkBV,EAASW,iBAAiBC,IAAMZ,EAASW,iBAAiBE,MAGlF,IAAIC,EAAgC,GAAlBJ,EAEdD,IACFK,EAAgC,GAAlBJ,GAGhB,MAAMhZ,EAA2B,SAAd8Y,EACjBR,EAAS5K,WAAa0L,EACtBd,EAAS5K,WAAa0L,EAExBrb,KAAK4a,iBAAiBnL,EAAiBxN,EACzC,CAKA,gBAAA2Y,CAAiBnL,EAAiBxN,EAAY2O,EAAW,KACvD,MAAMnO,EAAYoO,YAAYC,MACxBwK,EAAoB7L,EAAgBU,WAAWR,WAE/CoB,EAAWC,IACf,MAAMC,EAAUD,EAAcvO,EACxByO,EAAWtP,KAAKqC,IAAIgN,EAAUL,EAAU,GAGxCO,EAAe,EAAIvP,KAAKwP,IAAI,EAAIF,EAAU,GAE1CiB,EAAUmJ,GAAqBrZ,EAAaqZ,GAAqBnK,EACvE1B,EAAgB8L,UAAUpJ,GAEtBjB,EAAW,GACbI,sBAAsBP,IAI1BO,sBAAsBP,EACxB,CAKA,kBAAA+J,CAAmBrL,EAAiBY,EAAYV,EAAYiB,EAAW,KACrE,MAAMnO,EAAYoO,YAAYC,MACxBZ,EAAcT,EAAgBU,WAAWC,UAEzCW,EAAWC,IACf,MAAMC,EAAUD,EAAcvO,EACxByO,EAAWtP,KAAKqC,IAAIgN,EAAUL,EAAU,GAGxCO,EAAe,EAAIvP,KAAKwP,IAAI,EAAIF,EAAU,GAE1CsK,EAAOtL,GAAeG,EAAaH,GAAeiB,EACxD1B,EAAgB4B,QAAQmK,EAAM7L,GAE1BuB,EAAW,GACbI,sBAAsBP,IAI1BO,sBAAsBP,EACxB,CAKA,gBAAA2J,CAAiBjL,EAAiBmB,EAAW,KAC3C,MAAM2J,EAAW9K,EAAgBU,WAC3BsL,EAAmBlB,EAASM,cAAgB,GAG5Ca,iBAAEA,EAAAb,cAAkBA,GAAkBN,EAEtCoB,EAA0BD,EAAiBjS,MAAQoR,EACnDxK,EAAazO,KAAKmC,IAAIwW,EAASjK,QAASqL,EAFlB,KAKtBlZ,EAAYoO,YAAYC,MACxBZ,EAAcqK,EAASnK,UACvBkL,EAAoBf,EAAS5K,WAE7BoB,EAAWC,IACf,MAAMC,EAAUD,EAAcvO,EACxByO,EAAWtP,KAAKqC,IAAIgN,EAAUL,EAAU,GAGxCO,EAAe,EAAIvP,KAAKwP,IAAI,EAAIF,EAAU,GAE1CsK,EAAOtL,GAAeG,EAAaH,GAAeiB,EAClDxB,EAAa2L,GAAqBG,EAAmBH,GAAqBnK,EAEhF1B,EAAgB4B,QAAQmK,EAAM7L,GAE1BuB,EAAW,GACbI,sBAAsBP,IAI1BO,sBAAsBP,EACxB,CASA,gBAAA+F,CAAiBrV,GACf,GAAIzB,KAAKqM,UAAUC,aAAc,CAE/B,MAAMsE,EAAW,GACXnO,EAAYb,KAAKmC,IAAI,EAAGtC,EAAOmP,EAAW,GAC1ClO,EAAUD,EAAYmO,EAE5B5Q,KAAKqM,UAAUC,aAAa7J,EAAWC,EACzC,CACF,CAKA,UAAAuU,CAAWxU,EAAWC,GAChB1C,KAAKqM,UAAUC,cACjBtM,KAAKqM,UAAUC,aAAa7J,EAAWC,EAE3C,CAKA,UAAAyU,CAAW1O,EAAQyO,GACblX,KAAKqM,UAAUE,cACjBvM,KAAKqM,UAAUE,aAAa9D,EAAQyO,EAExC,CAKA,UAAApF,CAAWrQ,GACLzB,KAAKqM,UAAUG,YACjBxM,KAAKqM,UAAUG,WAAW/K,EAE9B,CAKA,UAAAoQ,CAAWpJ,GACLzI,KAAKqM,UAAUE,cACjBvM,KAAKqM,UAAUE,aAAa9D,EAAQ,CAAEmT,UAAU,GAEpD,CAMA,eAAArN,GACE,OAAOvO,KAAK2M,cAAgB,EAC9B,CAKA,eAAA2B,CAAgBvH,GACd/G,KAAK2M,aAAe5F,CACtB,CAKA,WAAA6I,CAAY8B,GAEV,OADwB1R,KAAKgL,eAAe0E,qBACrBE,YAAY8B,EACrC,CAKA,WAAAF,CAAY/P,GAEV,OADwBzB,KAAKgL,eAAe0E,qBACrB8B,YAAY/P,EACrC,CAKA,qBAAAoa,CAAsB3T,EAAM4T,GAC1B,OAAQ5T,GACN,IAAK,QACHlI,KAAKD,QAAQqL,YAAc0Q,EAC3B,MACF,IAAK,OACH9b,KAAKD,QAAQsL,WAAayQ,EAC1B,MACF,IAAK,QACH9b,KAAKD,QAAQoL,YAAc2Q,EACtBA,GACH9b,KAAK+O,aAIb,CAKA,OAAAgN,GACE/b,KAAK+O,aACL/O,KAAKwP,wBAEL,MACM3C,EADe7M,KAAKgL,eAAe8B,kBACHC,SAAS,eAE/C,GAAIF,EAAkB,CACpB,MAAMG,EAASH,EAAiBG,OAGhCA,EAAOgP,oBAAoB,YAAahc,KAAKkN,iBAC7CF,EAAOgP,oBAAoB,YAAahc,KAAKoN,iBAC7CJ,EAAOgP,oBAAoB,UAAWhc,KAAKqN,eAC3CL,EAAOgP,oBAAoB,aAAchc,KAAKsN,kBAC9CN,EAAOgP,oBAAoB,QAAShc,KAAKuN,aACzCP,EAAOgP,oBAAoB,aAAchc,KAAKwN,kBAC9CR,EAAOgP,oBAAoB,YAAahc,KAAKyN,iBAC7CT,EAAOgP,oBAAoB,WAAYhc,KAAK0N,eAC9C,CACF"}