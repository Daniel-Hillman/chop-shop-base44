{"version":3,"file":"waveform-core-ygTHjRxL.js","sources":["../../node_modules/react/jsx-runtime.js","../../node_modules/react/cjs/react-jsx-runtime.production.js","../../node_modules/react/cjs/react.production.js","../../node_modules/react/index.js","../../node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs","../../node_modules/framer-motion/dist/es/utils/use-constant.mjs","../../node_modules/framer-motion/dist/es/context/PresenceContext.mjs","../../node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs","../../node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs","../../node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs","../../node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs","../../node_modules/framer-motion/dist/es/components/AnimatePresence/utils.mjs","../../node_modules/framer-motion/dist/es/utils/is-browser.mjs","../../node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs","../../node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs","../../node_modules/motion-utils/dist/es/noop.mjs","../../node_modules/motion-utils/dist/es/errors.mjs","../../node_modules/motion-utils/dist/es/memo.mjs","../../node_modules/motion-utils/dist/es/progress.mjs","../../node_modules/motion-utils/dist/es/time-conversion.mjs","../../node_modules/framer-motion/dist/es/utils/GlobalConfig.mjs","../../node_modules/framer-motion/dist/es/frameloop/batcher.mjs","../../node_modules/framer-motion/dist/es/frameloop/render-step.mjs","../../node_modules/framer-motion/dist/es/frameloop/frame.mjs","../../node_modules/framer-motion/dist/es/context/LazyContext.mjs","../../node_modules/framer-motion/dist/es/motion/features/definitions.mjs","../../node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs","../../node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs","../../node_modules/framer-motion/dist/es/render/components/create-proxy.mjs","../../node_modules/framer-motion/dist/es/context/MotionContext/index.mjs","../../node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs","../../node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs","../../node_modules/framer-motion/dist/es/render/utils/variant-props.mjs","../../node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs","../../node_modules/framer-motion/dist/es/context/MotionContext/create.mjs","../../node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs","../../node_modules/framer-motion/dist/es/motion/utils/symbol.mjs","../../node_modules/framer-motion/dist/es/utils/is-ref-object.mjs","../../node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs","../../node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs","../../node_modules/framer-motion/dist/es/animation/optimized-appear/data-id.mjs","../../node_modules/framer-motion/dist/es/frameloop/microtask.mjs","../../node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs","../../node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs","../../node_modules/framer-motion/dist/es/motion/index.mjs","../../node_modules/framer-motion/dist/es/motion/features/load-features.mjs","../../node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs","../../node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs","../../node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs","../../node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs","../../node_modules/framer-motion/dist/es/utils/resolve-value.mjs","../../node_modules/framer-motion/dist/es/value/utils/is-motion-value.mjs","../../node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs","../../node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs","../../node_modules/framer-motion/dist/es/render/html/utils/keys-transform.mjs","../../node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs","../../node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs","../../node_modules/framer-motion/dist/es/utils/clamp.mjs","../../node_modules/framer-motion/dist/es/value/types/numbers/index.mjs","../../node_modules/framer-motion/dist/es/value/types/numbers/units.mjs","../../node_modules/framer-motion/dist/es/render/dom/value-types/number-browser.mjs","../../node_modules/framer-motion/dist/es/render/dom/value-types/transform.mjs","../../node_modules/framer-motion/dist/es/render/dom/value-types/type-int.mjs","../../node_modules/framer-motion/dist/es/render/dom/value-types/number.mjs","../../node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs","../../node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs","../../node_modules/framer-motion/dist/es/render/svg/utils/path.mjs","../../node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.mjs","../../node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs","../../node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs","../../node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs","../../node_modules/framer-motion/dist/es/render/svg/utils/is-svg-tag.mjs","../../node_modules/framer-motion/dist/es/render/html/utils/render.mjs","../../node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs","../../node_modules/framer-motion/dist/es/render/svg/utils/render.mjs","../../node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs","../../node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs","../../node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs","../../node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs","../../node_modules/framer-motion/dist/es/render/svg/config-motion.mjs","../../node_modules/framer-motion/dist/es/render/html/config-motion.mjs","../../node_modules/framer-motion/dist/es/render/html/use-props.mjs","../../node_modules/framer-motion/dist/es/render/svg/use-props.mjs","../../node_modules/framer-motion/dist/es/render/dom/use-render.mjs","../../node_modules/framer-motion/dist/es/render/components/create-factory.mjs","../../node_modules/framer-motion/dist/es/utils/shallow-compare.mjs","../../node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs","../../node_modules/motion-dom/dist/es/utils/supports/scroll-timeline.mjs","../../node_modules/motion-dom/dist/es/animation/controls/BaseGroup.mjs","../../node_modules/motion-dom/dist/es/animation/controls/Group.mjs","../../node_modules/motion-dom/dist/es/animation/utils/get-value-transition.mjs","../../node_modules/motion-dom/dist/es/animation/generators/utils/calc-duration.mjs","../../node_modules/motion-dom/dist/es/animation/generators/utils/is-generator.mjs","../../node_modules/motion-dom/dist/es/animation/waapi/utils/attach-timeline.mjs","../../node_modules/motion-dom/dist/es/utils/is-bezier-definition.mjs","../../node_modules/motion-dom/dist/es/utils/supports/flags.mjs","../../node_modules/motion-dom/dist/es/utils/supports/memo.mjs","../../node_modules/motion-dom/dist/es/utils/supports/linear-easing.mjs","../../node_modules/motion-dom/dist/es/animation/waapi/utils/linear.mjs","../../node_modules/motion-dom/dist/es/animation/waapi/utils/easing.mjs","../../node_modules/motion-dom/dist/es/gestures/drag/state/is-active.mjs","../../node_modules/motion-dom/dist/es/gestures/utils/setup.mjs","../../node_modules/motion-dom/dist/es/utils/resolve-elements.mjs","../../node_modules/motion-dom/dist/es/gestures/hover.mjs","../../node_modules/motion-dom/dist/es/gestures/utils/is-node-or-child.mjs","../../node_modules/motion-dom/dist/es/gestures/utils/is-primary-pointer.mjs","../../node_modules/motion-dom/dist/es/gestures/press/utils/is-keyboard-accessible.mjs","../../node_modules/motion-dom/dist/es/gestures/press/utils/state.mjs","../../node_modules/motion-dom/dist/es/gestures/press/utils/keyboard.mjs","../../node_modules/motion-dom/dist/es/gestures/press/index.mjs","../../node_modules/framer-motion/dist/es/render/html/utils/keys-position.mjs","../../node_modules/framer-motion/dist/es/frameloop/sync-time.mjs","../../node_modules/framer-motion/dist/es/utils/array.mjs","../../node_modules/framer-motion/dist/es/utils/subscription-manager.mjs","../../node_modules/framer-motion/dist/es/utils/velocity-per-second.mjs","../../node_modules/framer-motion/dist/es/value/index.mjs","../../node_modules/framer-motion/dist/es/render/utils/setters.mjs","../../node_modules/framer-motion/dist/es/value/use-will-change/add-will-change.mjs","../../node_modules/framer-motion/dist/es/value/use-will-change/is.mjs","../../node_modules/framer-motion/dist/es/animation/optimized-appear/get-appear-id.mjs","../../node_modules/framer-motion/dist/es/easing/cubic-bezier.mjs","../../node_modules/framer-motion/dist/es/easing/modifiers/mirror.mjs","../../node_modules/framer-motion/dist/es/easing/modifiers/reverse.mjs","../../node_modules/framer-motion/dist/es/easing/back.mjs","../../node_modules/framer-motion/dist/es/easing/anticipate.mjs","../../node_modules/framer-motion/dist/es/easing/circ.mjs","../../node_modules/framer-motion/dist/es/utils/is-zero-value-string.mjs","../../node_modules/framer-motion/dist/es/animation/utils/is-none.mjs","../../node_modules/framer-motion/dist/es/value/types/utils/sanitize.mjs","../../node_modules/framer-motion/dist/es/value/types/utils/float-regex.mjs","../../node_modules/framer-motion/dist/es/value/types/utils/single-color-regex.mjs","../../node_modules/framer-motion/dist/es/value/types/color/utils.mjs","../../node_modules/framer-motion/dist/es/value/types/utils/is-nullish.mjs","../../node_modules/framer-motion/dist/es/value/types/color/rgba.mjs","../../node_modules/framer-motion/dist/es/value/types/color/hex.mjs","../../node_modules/framer-motion/dist/es/value/types/color/hsla.mjs","../../node_modules/framer-motion/dist/es/value/types/color/index.mjs","../../node_modules/framer-motion/dist/es/value/types/utils/color-regex.mjs","../../node_modules/framer-motion/dist/es/value/types/complex/index.mjs","../../node_modules/framer-motion/dist/es/value/types/complex/filter.mjs","../../node_modules/framer-motion/dist/es/render/dom/value-types/defaults.mjs","../../node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs","../../node_modules/framer-motion/dist/es/render/html/utils/make-none-animatable.mjs","../../node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs","../../node_modules/framer-motion/dist/es/render/utils/KeyframesResolver.mjs","../../node_modules/framer-motion/dist/es/utils/is-numerical-string.mjs","../../node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs","../../node_modules/framer-motion/dist/es/render/dom/value-types/test.mjs","../../node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs","../../node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.mjs","../../node_modules/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs","../../node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs","../../node_modules/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs","../../node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs","../../node_modules/framer-motion/dist/es/animation/animators/utils/can-animate.mjs","../../node_modules/framer-motion/dist/es/utils/mix/number.mjs","../../node_modules/framer-motion/dist/es/utils/hsla-to-rgba.mjs","../../node_modules/framer-motion/dist/es/utils/mix/immediate.mjs","../../node_modules/framer-motion/dist/es/utils/mix/color.mjs","../../node_modules/framer-motion/dist/es/utils/pipe.mjs","../../node_modules/framer-motion/dist/es/utils/mix/visibility.mjs","../../node_modules/framer-motion/dist/es/utils/mix/complex.mjs","../../node_modules/framer-motion/dist/es/utils/mix/index.mjs","../../node_modules/framer-motion/dist/es/animation/generators/utils/velocity.mjs","../../node_modules/framer-motion/dist/es/animation/generators/spring/defaults.mjs","../../node_modules/framer-motion/dist/es/animation/generators/spring/find.mjs","../../node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs","../../node_modules/framer-motion/dist/es/animation/generators/inertia.mjs","../../node_modules/framer-motion/dist/es/easing/ease.mjs","../../node_modules/framer-motion/dist/es/easing/utils/map.mjs","../../node_modules/framer-motion/dist/es/utils/interpolate.mjs","../../node_modules/framer-motion/dist/es/utils/offsets/default.mjs","../../node_modules/framer-motion/dist/es/utils/offsets/fill.mjs","../../node_modules/framer-motion/dist/es/animation/generators/keyframes.mjs","../../node_modules/framer-motion/dist/es/easing/utils/is-easing-array.mjs","../../node_modules/framer-motion/dist/es/utils/offsets/time.mjs","../../node_modules/framer-motion/dist/es/animation/animators/drivers/driver-frameloop.mjs","../../node_modules/framer-motion/dist/es/animation/animators/MainThreadAnimation.mjs","../../node_modules/framer-motion/dist/es/animation/animators/utils/accelerated-values.mjs","../../node_modules/framer-motion/dist/es/animation/animators/waapi/index.mjs","../../node_modules/framer-motion/dist/es/animation/animators/waapi/utils/supports-waapi.mjs","../../node_modules/framer-motion/dist/es/animation/animators/AcceleratedAnimation.mjs","../../node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs","../../node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs","../../node_modules/framer-motion/dist/es/animation/utils/is-transition-defined.mjs","../../node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs","../../node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs","../../node_modules/framer-motion/dist/es/render/utils/get-variant-context.mjs","../../node_modules/framer-motion/dist/es/render/utils/animation-state.mjs","../../node_modules/framer-motion/dist/es/animation/interfaces/visual-element.mjs","../../node_modules/framer-motion/dist/es/motion/features/Feature.mjs","../../node_modules/framer-motion/dist/es/motion/features/animation/exit.mjs","../../node_modules/framer-motion/dist/es/motion/features/animations.mjs","../../node_modules/framer-motion/dist/es/motion/features/animation/index.mjs","../../node_modules/framer-motion/dist/es/events/add-dom-event.mjs","../../node_modules/framer-motion/dist/es/events/event-info.mjs","../../node_modules/framer-motion/dist/es/events/add-pointer-event.mjs","../../node_modules/framer-motion/dist/es/utils/distance.mjs","../../node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs","../../node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs","../../node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs","../../node_modules/framer-motion/dist/es/projection/geometry/models.mjs","../../node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs","../../node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs","../../node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs","../../node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs","../../node_modules/framer-motion/dist/es/projection/utils/measure.mjs","../../node_modules/framer-motion/dist/es/utils/get-context-window.mjs","../../node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs","../../node_modules/motion-dom/dist/es/gestures/drag/state/set-active.mjs","../../node_modules/framer-motion/dist/es/gestures/pan/index.mjs","../../node_modules/framer-motion/dist/es/projection/node/state.mjs","../../node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs","../../node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs","../../node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs","../../node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs","../../node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs","../../node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs","../../node_modules/framer-motion/dist/es/projection/geometry/copy.mjs","../../node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs","../../node_modules/framer-motion/dist/es/projection/geometry/utils.mjs","../../node_modules/framer-motion/dist/es/projection/shared/stack.mjs","../../node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs","../../node_modules/framer-motion/dist/es/render/dom/utils/is-svg-element.mjs","../../node_modules/framer-motion/dist/es/utils/delay.mjs","../../node_modules/framer-motion/dist/es/animation/animate/single-value.mjs","../../node_modules/framer-motion/dist/es/projection/styles/transform.mjs","../../node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs","../../node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs","../../node_modules/framer-motion/dist/es/motion/features/drag.mjs","../../node_modules/framer-motion/dist/es/gestures/drag/index.mjs","../../node_modules/framer-motion/dist/es/gestures/hover.mjs","../../node_modules/framer-motion/dist/es/gestures/press.mjs","../../node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs","../../node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs","../../node_modules/framer-motion/dist/es/motion/features/gestures.mjs","../../node_modules/framer-motion/dist/es/gestures/focus.mjs","../../node_modules/framer-motion/dist/es/motion/features/layout.mjs","../../node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs","../../node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs","../../node_modules/framer-motion/dist/es/render/store.mjs","../../node_modules/framer-motion/dist/es/render/VisualElement.mjs","../../node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs","../../node_modules/framer-motion/dist/es/render/utils/motion-values.mjs","../../node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs","../../node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs","../../node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs","../../node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs","../../node_modules/framer-motion/dist/es/render/components/motion/proxy.mjs","../../node_modules/framer-motion/dist/es/render/components/motion/create.mjs","../../src/components/waveform/CanvasLayerManager.js","../../src/components/waveform/ViewportManager.js","../../src/components/waveform/CanvasRenderer.js","../../src/components/waveform/PlayheadManager.js","../../src/components/waveform/WaveformVisualization.jsx"],"sourcesContent":["'use strict';\r\n\r\nif (process.env.NODE_ENV === 'production') {\r\n  module.exports = require('./cjs/react-jsx-runtime.production.js');\r\n} else {\r\n  module.exports = require('./cjs/react-jsx-runtime.development.js');\r\n}\r\n","/**\r\n * @license React\r\n * react-jsx-runtime.production.js\r\n *\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n\"use strict\";\r\nvar REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\r\n  REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\r\nfunction jsxProd(type, config, maybeKey) {\r\n  var key = null;\r\n  void 0 !== maybeKey && (key = \"\" + maybeKey);\r\n  void 0 !== config.key && (key = \"\" + config.key);\r\n  if (\"key\" in config) {\r\n    maybeKey = {};\r\n    for (var propName in config)\r\n      \"key\" !== propName && (maybeKey[propName] = config[propName]);\r\n  } else maybeKey = config;\r\n  config = maybeKey.ref;\r\n  return {\r\n    $$typeof: REACT_ELEMENT_TYPE,\r\n    type: type,\r\n    key: key,\r\n    ref: void 0 !== config ? config : null,\r\n    props: maybeKey\r\n  };\r\n}\r\nexports.Fragment = REACT_FRAGMENT_TYPE;\r\nexports.jsx = jsxProd;\r\nexports.jsxs = jsxProd;\r\n","/**\r\n * @license React\r\n * react.production.js\r\n *\r\n * Copyright (c) Meta Platforms, Inc. and affiliates.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\r\n\r\n\"use strict\";\r\nvar REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\r\n  REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\r\n  REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\r\n  REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\r\n  REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\r\n  REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\r\n  REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\r\n  REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\r\n  REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\r\n  REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\r\n  REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\r\n  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\r\nfunction getIteratorFn(maybeIterable) {\r\n  if (null === maybeIterable || \"object\" !== typeof maybeIterable) return null;\r\n  maybeIterable =\r\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\r\n    maybeIterable[\"@@iterator\"];\r\n  return \"function\" === typeof maybeIterable ? maybeIterable : null;\r\n}\r\nvar ReactNoopUpdateQueue = {\r\n    isMounted: function () {\r\n      return !1;\r\n    },\r\n    enqueueForceUpdate: function () {},\r\n    enqueueReplaceState: function () {},\r\n    enqueueSetState: function () {}\r\n  },\r\n  assign = Object.assign,\r\n  emptyObject = {};\r\nfunction Component(props, context, updater) {\r\n  this.props = props;\r\n  this.context = context;\r\n  this.refs = emptyObject;\r\n  this.updater = updater || ReactNoopUpdateQueue;\r\n}\r\nComponent.prototype.isReactComponent = {};\r\nComponent.prototype.setState = function (partialState, callback) {\r\n  if (\r\n    \"object\" !== typeof partialState &&\r\n    \"function\" !== typeof partialState &&\r\n    null != partialState\r\n  )\r\n    throw Error(\r\n      \"takes an object of state variables to update or a function which returns an object of state variables.\"\r\n    );\r\n  this.updater.enqueueSetState(this, partialState, callback, \"setState\");\r\n};\r\nComponent.prototype.forceUpdate = function (callback) {\r\n  this.updater.enqueueForceUpdate(this, callback, \"forceUpdate\");\r\n};\r\nfunction ComponentDummy() {}\r\nComponentDummy.prototype = Component.prototype;\r\nfunction PureComponent(props, context, updater) {\r\n  this.props = props;\r\n  this.context = context;\r\n  this.refs = emptyObject;\r\n  this.updater = updater || ReactNoopUpdateQueue;\r\n}\r\nvar pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());\r\npureComponentPrototype.constructor = PureComponent;\r\nassign(pureComponentPrototype, Component.prototype);\r\npureComponentPrototype.isPureReactComponent = !0;\r\nvar isArrayImpl = Array.isArray,\r\n  ReactSharedInternals = { H: null, A: null, T: null, S: null, V: null },\r\n  hasOwnProperty = Object.prototype.hasOwnProperty;\r\nfunction ReactElement(type, key, self, source, owner, props) {\r\n  self = props.ref;\r\n  return {\r\n    $$typeof: REACT_ELEMENT_TYPE,\r\n    type: type,\r\n    key: key,\r\n    ref: void 0 !== self ? self : null,\r\n    props: props\r\n  };\r\n}\r\nfunction cloneAndReplaceKey(oldElement, newKey) {\r\n  return ReactElement(\r\n    oldElement.type,\r\n    newKey,\r\n    void 0,\r\n    void 0,\r\n    void 0,\r\n    oldElement.props\r\n  );\r\n}\r\nfunction isValidElement(object) {\r\n  return (\r\n    \"object\" === typeof object &&\r\n    null !== object &&\r\n    object.$$typeof === REACT_ELEMENT_TYPE\r\n  );\r\n}\r\nfunction escape(key) {\r\n  var escaperLookup = { \"=\": \"=0\", \":\": \"=2\" };\r\n  return (\r\n    \"$\" +\r\n    key.replace(/[=:]/g, function (match) {\r\n      return escaperLookup[match];\r\n    })\r\n  );\r\n}\r\nvar userProvidedKeyEscapeRegex = /\\/+/g;\r\nfunction getElementKey(element, index) {\r\n  return \"object\" === typeof element && null !== element && null != element.key\r\n    ? escape(\"\" + element.key)\r\n    : index.toString(36);\r\n}\r\nfunction noop$1() {}\r\nfunction resolveThenable(thenable) {\r\n  switch (thenable.status) {\r\n    case \"fulfilled\":\r\n      return thenable.value;\r\n    case \"rejected\":\r\n      throw thenable.reason;\r\n    default:\r\n      switch (\r\n        (\"string\" === typeof thenable.status\r\n          ? thenable.then(noop$1, noop$1)\r\n          : ((thenable.status = \"pending\"),\r\n            thenable.then(\r\n              function (fulfilledValue) {\r\n                \"pending\" === thenable.status &&\r\n                  ((thenable.status = \"fulfilled\"),\r\n                  (thenable.value = fulfilledValue));\r\n              },\r\n              function (error) {\r\n                \"pending\" === thenable.status &&\r\n                  ((thenable.status = \"rejected\"), (thenable.reason = error));\r\n              }\r\n            )),\r\n        thenable.status)\r\n      ) {\r\n        case \"fulfilled\":\r\n          return thenable.value;\r\n        case \"rejected\":\r\n          throw thenable.reason;\r\n      }\r\n  }\r\n  throw thenable;\r\n}\r\nfunction mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\r\n  var type = typeof children;\r\n  if (\"undefined\" === type || \"boolean\" === type) children = null;\r\n  var invokeCallback = !1;\r\n  if (null === children) invokeCallback = !0;\r\n  else\r\n    switch (type) {\r\n      case \"bigint\":\r\n      case \"string\":\r\n      case \"number\":\r\n        invokeCallback = !0;\r\n        break;\r\n      case \"object\":\r\n        switch (children.$$typeof) {\r\n          case REACT_ELEMENT_TYPE:\r\n          case REACT_PORTAL_TYPE:\r\n            invokeCallback = !0;\r\n            break;\r\n          case REACT_LAZY_TYPE:\r\n            return (\r\n              (invokeCallback = children._init),\r\n              mapIntoArray(\r\n                invokeCallback(children._payload),\r\n                array,\r\n                escapedPrefix,\r\n                nameSoFar,\r\n                callback\r\n              )\r\n            );\r\n        }\r\n    }\r\n  if (invokeCallback)\r\n    return (\r\n      (callback = callback(children)),\r\n      (invokeCallback =\r\n        \"\" === nameSoFar ? \".\" + getElementKey(children, 0) : nameSoFar),\r\n      isArrayImpl(callback)\r\n        ? ((escapedPrefix = \"\"),\r\n          null != invokeCallback &&\r\n            (escapedPrefix =\r\n              invokeCallback.replace(userProvidedKeyEscapeRegex, \"$&/\") + \"/\"),\r\n          mapIntoArray(callback, array, escapedPrefix, \"\", function (c) {\r\n            return c;\r\n          }))\r\n        : null != callback &&\r\n          (isValidElement(callback) &&\r\n            (callback = cloneAndReplaceKey(\r\n              callback,\r\n              escapedPrefix +\r\n                (null == callback.key ||\r\n                (children && children.key === callback.key)\r\n                  ? \"\"\r\n                  : (\"\" + callback.key).replace(\r\n                      userProvidedKeyEscapeRegex,\r\n                      \"$&/\"\r\n                    ) + \"/\") +\r\n                invokeCallback\r\n            )),\r\n          array.push(callback)),\r\n      1\r\n    );\r\n  invokeCallback = 0;\r\n  var nextNamePrefix = \"\" === nameSoFar ? \".\" : nameSoFar + \":\";\r\n  if (isArrayImpl(children))\r\n    for (var i = 0; i < children.length; i++)\r\n      (nameSoFar = children[i]),\r\n        (type = nextNamePrefix + getElementKey(nameSoFar, i)),\r\n        (invokeCallback += mapIntoArray(\r\n          nameSoFar,\r\n          array,\r\n          escapedPrefix,\r\n          type,\r\n          callback\r\n        ));\r\n  else if (((i = getIteratorFn(children)), \"function\" === typeof i))\r\n    for (\r\n      children = i.call(children), i = 0;\r\n      !(nameSoFar = children.next()).done;\r\n\r\n    )\r\n      (nameSoFar = nameSoFar.value),\r\n        (type = nextNamePrefix + getElementKey(nameSoFar, i++)),\r\n        (invokeCallback += mapIntoArray(\r\n          nameSoFar,\r\n          array,\r\n          escapedPrefix,\r\n          type,\r\n          callback\r\n        ));\r\n  else if (\"object\" === type) {\r\n    if (\"function\" === typeof children.then)\r\n      return mapIntoArray(\r\n        resolveThenable(children),\r\n        array,\r\n        escapedPrefix,\r\n        nameSoFar,\r\n        callback\r\n      );\r\n    array = String(children);\r\n    throw Error(\r\n      \"Objects are not valid as a React child (found: \" +\r\n        (\"[object Object]\" === array\r\n          ? \"object with keys {\" + Object.keys(children).join(\", \") + \"}\"\r\n          : array) +\r\n        \"). If you meant to render a collection of children, use an array instead.\"\r\n    );\r\n  }\r\n  return invokeCallback;\r\n}\r\nfunction mapChildren(children, func, context) {\r\n  if (null == children) return children;\r\n  var result = [],\r\n    count = 0;\r\n  mapIntoArray(children, result, \"\", \"\", function (child) {\r\n    return func.call(context, child, count++);\r\n  });\r\n  return result;\r\n}\r\nfunction lazyInitializer(payload) {\r\n  if (-1 === payload._status) {\r\n    var ctor = payload._result;\r\n    ctor = ctor();\r\n    ctor.then(\r\n      function (moduleObject) {\r\n        if (0 === payload._status || -1 === payload._status)\r\n          (payload._status = 1), (payload._result = moduleObject);\r\n      },\r\n      function (error) {\r\n        if (0 === payload._status || -1 === payload._status)\r\n          (payload._status = 2), (payload._result = error);\r\n      }\r\n    );\r\n    -1 === payload._status && ((payload._status = 0), (payload._result = ctor));\r\n  }\r\n  if (1 === payload._status) return payload._result.default;\r\n  throw payload._result;\r\n}\r\nvar reportGlobalError =\r\n  \"function\" === typeof reportError\r\n    ? reportError\r\n    : function (error) {\r\n        if (\r\n          \"object\" === typeof window &&\r\n          \"function\" === typeof window.ErrorEvent\r\n        ) {\r\n          var event = new window.ErrorEvent(\"error\", {\r\n            bubbles: !0,\r\n            cancelable: !0,\r\n            message:\r\n              \"object\" === typeof error &&\r\n              null !== error &&\r\n              \"string\" === typeof error.message\r\n                ? String(error.message)\r\n                : String(error),\r\n            error: error\r\n          });\r\n          if (!window.dispatchEvent(event)) return;\r\n        } else if (\r\n          \"object\" === typeof process &&\r\n          \"function\" === typeof process.emit\r\n        ) {\r\n          process.emit(\"uncaughtException\", error);\r\n          return;\r\n        }\r\n        console.error(error);\r\n      };\r\nfunction noop() {}\r\nexports.Children = {\r\n  map: mapChildren,\r\n  forEach: function (children, forEachFunc, forEachContext) {\r\n    mapChildren(\r\n      children,\r\n      function () {\r\n        forEachFunc.apply(this, arguments);\r\n      },\r\n      forEachContext\r\n    );\r\n  },\r\n  count: function (children) {\r\n    var n = 0;\r\n    mapChildren(children, function () {\r\n      n++;\r\n    });\r\n    return n;\r\n  },\r\n  toArray: function (children) {\r\n    return (\r\n      mapChildren(children, function (child) {\r\n        return child;\r\n      }) || []\r\n    );\r\n  },\r\n  only: function (children) {\r\n    if (!isValidElement(children))\r\n      throw Error(\r\n        \"React.Children.only expected to receive a single React element child.\"\r\n      );\r\n    return children;\r\n  }\r\n};\r\nexports.Component = Component;\r\nexports.Fragment = REACT_FRAGMENT_TYPE;\r\nexports.Profiler = REACT_PROFILER_TYPE;\r\nexports.PureComponent = PureComponent;\r\nexports.StrictMode = REACT_STRICT_MODE_TYPE;\r\nexports.Suspense = REACT_SUSPENSE_TYPE;\r\nexports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =\r\n  ReactSharedInternals;\r\nexports.__COMPILER_RUNTIME = {\r\n  __proto__: null,\r\n  c: function (size) {\r\n    return ReactSharedInternals.H.useMemoCache(size);\r\n  }\r\n};\r\nexports.cache = function (fn) {\r\n  return function () {\r\n    return fn.apply(null, arguments);\r\n  };\r\n};\r\nexports.cloneElement = function (element, config, children) {\r\n  if (null === element || void 0 === element)\r\n    throw Error(\r\n      \"The argument must be a React element, but you passed \" + element + \".\"\r\n    );\r\n  var props = assign({}, element.props),\r\n    key = element.key,\r\n    owner = void 0;\r\n  if (null != config)\r\n    for (propName in (void 0 !== config.ref && (owner = void 0),\r\n    void 0 !== config.key && (key = \"\" + config.key),\r\n    config))\r\n      !hasOwnProperty.call(config, propName) ||\r\n        \"key\" === propName ||\r\n        \"__self\" === propName ||\r\n        \"__source\" === propName ||\r\n        (\"ref\" === propName && void 0 === config.ref) ||\r\n        (props[propName] = config[propName]);\r\n  var propName = arguments.length - 2;\r\n  if (1 === propName) props.children = children;\r\n  else if (1 < propName) {\r\n    for (var childArray = Array(propName), i = 0; i < propName; i++)\r\n      childArray[i] = arguments[i + 2];\r\n    props.children = childArray;\r\n  }\r\n  return ReactElement(element.type, key, void 0, void 0, owner, props);\r\n};\r\nexports.createContext = function (defaultValue) {\r\n  defaultValue = {\r\n    $$typeof: REACT_CONTEXT_TYPE,\r\n    _currentValue: defaultValue,\r\n    _currentValue2: defaultValue,\r\n    _threadCount: 0,\r\n    Provider: null,\r\n    Consumer: null\r\n  };\r\n  defaultValue.Provider = defaultValue;\r\n  defaultValue.Consumer = {\r\n    $$typeof: REACT_CONSUMER_TYPE,\r\n    _context: defaultValue\r\n  };\r\n  return defaultValue;\r\n};\r\nexports.createElement = function (type, config, children) {\r\n  var propName,\r\n    props = {},\r\n    key = null;\r\n  if (null != config)\r\n    for (propName in (void 0 !== config.key && (key = \"\" + config.key), config))\r\n      hasOwnProperty.call(config, propName) &&\r\n        \"key\" !== propName &&\r\n        \"__self\" !== propName &&\r\n        \"__source\" !== propName &&\r\n        (props[propName] = config[propName]);\r\n  var childrenLength = arguments.length - 2;\r\n  if (1 === childrenLength) props.children = children;\r\n  else if (1 < childrenLength) {\r\n    for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)\r\n      childArray[i] = arguments[i + 2];\r\n    props.children = childArray;\r\n  }\r\n  if (type && type.defaultProps)\r\n    for (propName in ((childrenLength = type.defaultProps), childrenLength))\r\n      void 0 === props[propName] &&\r\n        (props[propName] = childrenLength[propName]);\r\n  return ReactElement(type, key, void 0, void 0, null, props);\r\n};\r\nexports.createRef = function () {\r\n  return { current: null };\r\n};\r\nexports.forwardRef = function (render) {\r\n  return { $$typeof: REACT_FORWARD_REF_TYPE, render: render };\r\n};\r\nexports.isValidElement = isValidElement;\r\nexports.lazy = function (ctor) {\r\n  return {\r\n    $$typeof: REACT_LAZY_TYPE,\r\n    _payload: { _status: -1, _result: ctor },\r\n    _init: lazyInitializer\r\n  };\r\n};\r\nexports.memo = function (type, compare) {\r\n  return {\r\n    $$typeof: REACT_MEMO_TYPE,\r\n    type: type,\r\n    compare: void 0 === compare ? null : compare\r\n  };\r\n};\r\nexports.startTransition = function (scope) {\r\n  var prevTransition = ReactSharedInternals.T,\r\n    currentTransition = {};\r\n  ReactSharedInternals.T = currentTransition;\r\n  try {\r\n    var returnValue = scope(),\r\n      onStartTransitionFinish = ReactSharedInternals.S;\r\n    null !== onStartTransitionFinish &&\r\n      onStartTransitionFinish(currentTransition, returnValue);\r\n    \"object\" === typeof returnValue &&\r\n      null !== returnValue &&\r\n      \"function\" === typeof returnValue.then &&\r\n      returnValue.then(noop, reportGlobalError);\r\n  } catch (error) {\r\n    reportGlobalError(error);\r\n  } finally {\r\n    ReactSharedInternals.T = prevTransition;\r\n  }\r\n};\r\nexports.unstable_useCacheRefresh = function () {\r\n  return ReactSharedInternals.H.useCacheRefresh();\r\n};\r\nexports.use = function (usable) {\r\n  return ReactSharedInternals.H.use(usable);\r\n};\r\nexports.useActionState = function (action, initialState, permalink) {\r\n  return ReactSharedInternals.H.useActionState(action, initialState, permalink);\r\n};\r\nexports.useCallback = function (callback, deps) {\r\n  return ReactSharedInternals.H.useCallback(callback, deps);\r\n};\r\nexports.useContext = function (Context) {\r\n  return ReactSharedInternals.H.useContext(Context);\r\n};\r\nexports.useDebugValue = function () {};\r\nexports.useDeferredValue = function (value, initialValue) {\r\n  return ReactSharedInternals.H.useDeferredValue(value, initialValue);\r\n};\r\nexports.useEffect = function (create, createDeps, update) {\r\n  var dispatcher = ReactSharedInternals.H;\r\n  if (\"function\" === typeof update)\r\n    throw Error(\r\n      \"useEffect CRUD overload is not enabled in this build of React.\"\r\n    );\r\n  return dispatcher.useEffect(create, createDeps);\r\n};\r\nexports.useId = function () {\r\n  return ReactSharedInternals.H.useId();\r\n};\r\nexports.useImperativeHandle = function (ref, create, deps) {\r\n  return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);\r\n};\r\nexports.useInsertionEffect = function (create, deps) {\r\n  return ReactSharedInternals.H.useInsertionEffect(create, deps);\r\n};\r\nexports.useLayoutEffect = function (create, deps) {\r\n  return ReactSharedInternals.H.useLayoutEffect(create, deps);\r\n};\r\nexports.useMemo = function (create, deps) {\r\n  return ReactSharedInternals.H.useMemo(create, deps);\r\n};\r\nexports.useOptimistic = function (passthrough, reducer) {\r\n  return ReactSharedInternals.H.useOptimistic(passthrough, reducer);\r\n};\r\nexports.useReducer = function (reducer, initialArg, init) {\r\n  return ReactSharedInternals.H.useReducer(reducer, initialArg, init);\r\n};\r\nexports.useRef = function (initialValue) {\r\n  return ReactSharedInternals.H.useRef(initialValue);\r\n};\r\nexports.useState = function (initialState) {\r\n  return ReactSharedInternals.H.useState(initialState);\r\n};\r\nexports.useSyncExternalStore = function (\r\n  subscribe,\r\n  getSnapshot,\r\n  getServerSnapshot\r\n) {\r\n  return ReactSharedInternals.H.useSyncExternalStore(\r\n    subscribe,\r\n    getSnapshot,\r\n    getServerSnapshot\r\n  );\r\n};\r\nexports.useTransition = function () {\r\n  return ReactSharedInternals.H.useTransition();\r\n};\r\nexports.version = \"19.1.1\";\r\n","'use strict';\r\n\r\nif (process.env.NODE_ENV === 'production') {\r\n  module.exports = require('./cjs/react.production.js');\r\n} else {\r\n  module.exports = require('./cjs/react.development.js');\r\n}\r\n","\"use client\";\r\nimport { createContext } from 'react';\r\n\r\nconst LayoutGroupContext = createContext({});\r\n\r\nexport { LayoutGroupContext };\r\n","import { useRef } from 'react';\r\n\r\n/**\r\n * Creates a constant value over the lifecycle of a component.\r\n *\r\n * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer\r\n * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`\r\n * you can ensure that initialisers don't execute twice or more.\r\n */\r\nfunction useConstant(init) {\r\n    const ref = useRef(null);\r\n    if (ref.current === null) {\r\n        ref.current = init();\r\n    }\r\n    return ref.current;\r\n}\r\n\r\nexport { useConstant };\r\n","\"use client\";\r\nimport { createContext } from 'react';\r\n\r\n/**\r\n * @public\r\n */\r\nconst PresenceContext = createContext(null);\r\n\r\nexport { PresenceContext };\r\n","\"use client\";\r\nimport { createContext } from 'react';\r\n\r\n/**\r\n * @public\r\n */\r\nconst MotionConfigContext = createContext({\r\n    transformPagePoint: (p) => p,\r\n    isStatic: false,\r\n    reducedMotion: \"never\",\r\n});\r\n\r\nexport { MotionConfigContext };\r\n","\"use client\";\r\nimport { jsx } from 'react/jsx-runtime';\r\nimport * as React from 'react';\r\nimport { useId, useRef, useContext, useInsertionEffect } from 'react';\r\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\r\n\r\n/**\r\n * Measurement functionality has to be within a separate component\r\n * to leverage snapshot lifecycle.\r\n */\r\nclass PopChildMeasure extends React.Component {\r\n    getSnapshotBeforeUpdate(prevProps) {\r\n        const element = this.props.childRef.current;\r\n        if (element && prevProps.isPresent && !this.props.isPresent) {\r\n            const size = this.props.sizeRef.current;\r\n            size.height = element.offsetHeight || 0;\r\n            size.width = element.offsetWidth || 0;\r\n            size.top = element.offsetTop;\r\n            size.left = element.offsetLeft;\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Required with getSnapshotBeforeUpdate to stop React complaining.\r\n     */\r\n    componentDidUpdate() { }\r\n    render() {\r\n        return this.props.children;\r\n    }\r\n}\r\nfunction PopChild({ children, isPresent }) {\r\n    const id = useId();\r\n    const ref = useRef(null);\r\n    const size = useRef({\r\n        width: 0,\r\n        height: 0,\r\n        top: 0,\r\n        left: 0,\r\n    });\r\n    const { nonce } = useContext(MotionConfigContext);\r\n    /**\r\n     * We create and inject a style block so we can apply this explicit\r\n     * sizing in a non-destructive manner by just deleting the style block.\r\n     *\r\n     * We can't apply size via render as the measurement happens\r\n     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\r\n     * styles directly on the DOM node, we might be overwriting\r\n     * styles set via the style prop.\r\n     */\r\n    useInsertionEffect(() => {\r\n        const { width, height, top, left } = size.current;\r\n        if (isPresent || !ref.current || !width || !height)\r\n            return;\r\n        ref.current.dataset.motionPopId = id;\r\n        const style = document.createElement(\"style\");\r\n        if (nonce)\r\n            style.nonce = nonce;\r\n        document.head.appendChild(style);\r\n        if (style.sheet) {\r\n            style.sheet.insertRule(`\r\n          [data-motion-pop-id=\"${id}\"] {\r\n            position: absolute !important;\r\n            width: ${width}px !important;\r\n            height: ${height}px !important;\r\n            top: ${top}px !important;\r\n            left: ${left}px !important;\r\n          }\r\n        `);\r\n        }\r\n        return () => {\r\n            document.head.removeChild(style);\r\n        };\r\n    }, [isPresent]);\r\n    return (jsx(PopChildMeasure, { isPresent: isPresent, childRef: ref, sizeRef: size, children: React.cloneElement(children, { ref }) }));\r\n}\r\n\r\nexport { PopChild };\r\n","\"use client\";\r\nimport { jsx } from 'react/jsx-runtime';\r\nimport * as React from 'react';\r\nimport { useId, useCallback, useMemo } from 'react';\r\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\r\nimport { useConstant } from '../../utils/use-constant.mjs';\r\nimport { PopChild } from './PopChild.mjs';\r\n\r\nconst PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, }) => {\r\n    const presenceChildren = useConstant(newChildrenMap);\r\n    const id = useId();\r\n    const memoizedOnExitComplete = useCallback((childId) => {\r\n        presenceChildren.set(childId, true);\r\n        for (const isComplete of presenceChildren.values()) {\r\n            if (!isComplete)\r\n                return; // can stop searching when any is incomplete\r\n        }\r\n        onExitComplete && onExitComplete();\r\n    }, [presenceChildren, onExitComplete]);\r\n    const context = useMemo(() => ({\r\n        id,\r\n        initial,\r\n        isPresent,\r\n        custom,\r\n        onExitComplete: memoizedOnExitComplete,\r\n        register: (childId) => {\r\n            presenceChildren.set(childId, false);\r\n            return () => presenceChildren.delete(childId);\r\n        },\r\n    }), \r\n    /**\r\n     * If the presence of a child affects the layout of the components around it,\r\n     * we want to make a new context value to ensure they get re-rendered\r\n     * so they can detect that layout change.\r\n     */\r\n    presenceAffectsLayout\r\n        ? [Math.random(), memoizedOnExitComplete]\r\n        : [isPresent, memoizedOnExitComplete]);\r\n    useMemo(() => {\r\n        presenceChildren.forEach((_, key) => presenceChildren.set(key, false));\r\n    }, [isPresent]);\r\n    /**\r\n     * If there's no `motion` components to fire exit animations, we want to remove this\r\n     * component immediately.\r\n     */\r\n    React.useEffect(() => {\r\n        !isPresent &&\r\n            !presenceChildren.size &&\r\n            onExitComplete &&\r\n            onExitComplete();\r\n    }, [isPresent]);\r\n    if (mode === \"popLayout\") {\r\n        children = jsx(PopChild, { isPresent: isPresent, children: children });\r\n    }\r\n    return (jsx(PresenceContext.Provider, { value: context, children: children }));\r\n};\r\nfunction newChildrenMap() {\r\n    return new Map();\r\n}\r\n\r\nexport { PresenceChild };\r\n","import { useContext, useId, useEffect, useCallback } from 'react';\r\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\r\n\r\n/**\r\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\r\n * to access information about whether it's still present in the React tree.\r\n *\r\n * ```jsx\r\n * import { usePresence } from \"framer-motion\"\r\n *\r\n * export const Component = () => {\r\n *   const [isPresent, safeToRemove] = usePresence()\r\n *\r\n *   useEffect(() => {\r\n *     !isPresent && setTimeout(safeToRemove, 1000)\r\n *   }, [isPresent])\r\n *\r\n *   return <div />\r\n * }\r\n * ```\r\n *\r\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\r\n * `AnimatePresence` won't really remove it until `safeToRemove` has been called.\r\n *\r\n * @public\r\n */\r\nfunction usePresence(subscribe = true) {\r\n    const context = useContext(PresenceContext);\r\n    if (context === null)\r\n        return [true, null];\r\n    const { isPresent, onExitComplete, register } = context;\r\n    // It's safe to call the following hooks conditionally (after an early return) because the context will always\r\n    // either be null or non-null for the lifespan of the component.\r\n    const id = useId();\r\n    useEffect(() => {\r\n        if (subscribe)\r\n            register(id);\r\n    }, [subscribe]);\r\n    const safeToRemove = useCallback(() => subscribe && onExitComplete && onExitComplete(id), [id, onExitComplete, subscribe]);\r\n    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\r\n}\r\n/**\r\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\r\n * There is no `safeToRemove` function.\r\n *\r\n * ```jsx\r\n * import { useIsPresent } from \"framer-motion\"\r\n *\r\n * export const Component = () => {\r\n *   const isPresent = useIsPresent()\r\n *\r\n *   useEffect(() => {\r\n *     !isPresent && console.log(\"I've been removed!\")\r\n *   }, [isPresent])\r\n *\r\n *   return <div />\r\n * }\r\n * ```\r\n *\r\n * @public\r\n */\r\nfunction useIsPresent() {\r\n    return isPresent(useContext(PresenceContext));\r\n}\r\nfunction isPresent(context) {\r\n    return context === null ? true : context.isPresent;\r\n}\r\n\r\nexport { isPresent, useIsPresent, usePresence };\r\n","import { Children, isValidElement } from 'react';\r\n\r\nconst getChildKey = (child) => child.key || \"\";\r\nfunction onlyElements(children) {\r\n    const filtered = [];\r\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\r\n    Children.forEach(children, (child) => {\r\n        if (isValidElement(child))\r\n            filtered.push(child);\r\n    });\r\n    return filtered;\r\n}\r\n\r\nexport { getChildKey, onlyElements };\r\n","const isBrowser = typeof window !== \"undefined\";\r\n\r\nexport { isBrowser };\r\n","import { useLayoutEffect, useEffect } from 'react';\r\nimport { isBrowser } from './is-browser.mjs';\r\n\r\nconst useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect : useEffect;\r\n\r\nexport { useIsomorphicLayoutEffect };\r\n","\"use client\";\r\nimport { jsx, Fragment } from 'react/jsx-runtime';\r\nimport { useMemo, useRef, useState, useContext } from 'react';\r\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\r\nimport { useConstant } from '../../utils/use-constant.mjs';\r\nimport { PresenceChild } from './PresenceChild.mjs';\r\nimport { usePresence } from './use-presence.mjs';\r\nimport { onlyElements, getChildKey } from './utils.mjs';\r\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\r\n\r\n/**\r\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\r\n *\r\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\r\n *\r\n * Any `motion` components that have an `exit` property defined will animate out when removed from\r\n * the tree.\r\n *\r\n * ```jsx\r\n * import { motion, AnimatePresence } from 'framer-motion'\r\n *\r\n * export const Items = ({ items }) => (\r\n *   <AnimatePresence>\r\n *     {items.map(item => (\r\n *       <motion.div\r\n *         key={item.id}\r\n *         initial={{ opacity: 0 }}\r\n *         animate={{ opacity: 1 }}\r\n *         exit={{ opacity: 0 }}\r\n *       />\r\n *     ))}\r\n *   </AnimatePresence>\r\n * )\r\n * ```\r\n *\r\n * You can sequence exit animations throughout a tree using variants.\r\n *\r\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\r\n * once all `motion` components have finished animating out. Likewise, any components using\r\n * `usePresence` all need to call `safeToRemove`.\r\n *\r\n * @public\r\n */\r\nconst AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = \"sync\", propagate = false, }) => {\r\n    const [isParentPresent, safeToRemove] = usePresence(propagate);\r\n    /**\r\n     * Filter any children that aren't ReactElements. We can only track components\r\n     * between renders with a props.key.\r\n     */\r\n    const presentChildren = useMemo(() => onlyElements(children), [children]);\r\n    /**\r\n     * Track the keys of the currently rendered children. This is used to\r\n     * determine which children are exiting.\r\n     */\r\n    const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);\r\n    /**\r\n     * If `initial={false}` we only want to pass this to components in the first render.\r\n     */\r\n    const isInitialRender = useRef(true);\r\n    /**\r\n     * A ref containing the currently present children. When all exit animations\r\n     * are complete, we use this to re-render the component with the latest children\r\n     * *committed* rather than the latest children *rendered*.\r\n     */\r\n    const pendingPresentChildren = useRef(presentChildren);\r\n    /**\r\n     * Track which exiting children have finished animating out.\r\n     */\r\n    const exitComplete = useConstant(() => new Map());\r\n    /**\r\n     * Save children to render as React state. To ensure this component is concurrent-safe,\r\n     * we check for exiting children via an effect.\r\n     */\r\n    const [diffedChildren, setDiffedChildren] = useState(presentChildren);\r\n    const [renderedChildren, setRenderedChildren] = useState(presentChildren);\r\n    useIsomorphicLayoutEffect(() => {\r\n        isInitialRender.current = false;\r\n        pendingPresentChildren.current = presentChildren;\r\n        /**\r\n         * Update complete status of exiting children.\r\n         */\r\n        for (let i = 0; i < renderedChildren.length; i++) {\r\n            const key = getChildKey(renderedChildren[i]);\r\n            if (!presentKeys.includes(key)) {\r\n                if (exitComplete.get(key) !== true) {\r\n                    exitComplete.set(key, false);\r\n                }\r\n            }\r\n            else {\r\n                exitComplete.delete(key);\r\n            }\r\n        }\r\n    }, [renderedChildren, presentKeys.length, presentKeys.join(\"-\")]);\r\n    const exitingChildren = [];\r\n    if (presentChildren !== diffedChildren) {\r\n        let nextChildren = [...presentChildren];\r\n        /**\r\n         * Loop through all the currently rendered components and decide which\r\n         * are exiting.\r\n         */\r\n        for (let i = 0; i < renderedChildren.length; i++) {\r\n            const child = renderedChildren[i];\r\n            const key = getChildKey(child);\r\n            if (!presentKeys.includes(key)) {\r\n                nextChildren.splice(i, 0, child);\r\n                exitingChildren.push(child);\r\n            }\r\n        }\r\n        /**\r\n         * If we're in \"wait\" mode, and we have exiting children, we want to\r\n         * only render these until they've all exited.\r\n         */\r\n        if (mode === \"wait\" && exitingChildren.length) {\r\n            nextChildren = exitingChildren;\r\n        }\r\n        setRenderedChildren(onlyElements(nextChildren));\r\n        setDiffedChildren(presentChildren);\r\n        /**\r\n         * Early return to ensure once we've set state with the latest diffed\r\n         * children, we can immediately re-render.\r\n         */\r\n        return;\r\n    }\r\n    if (process.env.NODE_ENV !== \"production\" &&\r\n        mode === \"wait\" &&\r\n        renderedChildren.length > 1) {\r\n        console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\r\n    }\r\n    /**\r\n     * If we've been provided a forceRender function by the LayoutGroupContext,\r\n     * we can use it to force a re-render amongst all surrounding components once\r\n     * all components have finished animating out.\r\n     */\r\n    const { forceRender } = useContext(LayoutGroupContext);\r\n    return (jsx(Fragment, { children: renderedChildren.map((child) => {\r\n            const key = getChildKey(child);\r\n            const isPresent = propagate && !isParentPresent\r\n                ? false\r\n                : presentChildren === renderedChildren ||\r\n                    presentKeys.includes(key);\r\n            const onExit = () => {\r\n                if (exitComplete.has(key)) {\r\n                    exitComplete.set(key, true);\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n                let isEveryExitComplete = true;\r\n                exitComplete.forEach((isExitComplete) => {\r\n                    if (!isExitComplete)\r\n                        isEveryExitComplete = false;\r\n                });\r\n                if (isEveryExitComplete) {\r\n                    forceRender === null || forceRender === void 0 ? void 0 : forceRender();\r\n                    setRenderedChildren(pendingPresentChildren.current);\r\n                    propagate && (safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove());\r\n                    onExitComplete && onExitComplete();\r\n                }\r\n            };\r\n            return (jsx(PresenceChild, { isPresent: isPresent, initial: !isInitialRender.current || initial\r\n                    ? undefined\r\n                    : false, custom: isPresent ? undefined : custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode, onExitComplete: isPresent ? undefined : onExit, children: child }, key));\r\n        }) }));\r\n};\r\n\r\nexport { AnimatePresence };\r\n","/*#__NO_SIDE_EFFECTS__*/\r\nconst noop = (any) => any;\r\n\r\nexport { noop };\r\n","import { noop } from './noop.mjs';\r\n\r\nlet warning = noop;\r\nlet invariant = noop;\r\nif (process.env.NODE_ENV !== \"production\") {\r\n    warning = (check, message) => {\r\n        if (!check && typeof console !== \"undefined\") {\r\n            console.warn(message);\r\n        }\r\n    };\r\n    invariant = (check, message) => {\r\n        if (!check) {\r\n            throw new Error(message);\r\n        }\r\n    };\r\n}\r\n\r\nexport { invariant, warning };\r\n","/*#__NO_SIDE_EFFECTS__*/\r\nfunction memo(callback) {\r\n    let result;\r\n    return () => {\r\n        if (result === undefined)\r\n            result = callback();\r\n        return result;\r\n    };\r\n}\r\n\r\nexport { memo };\r\n","/*\r\n  Progress within given range\r\n\r\n  Given a lower limit and an upper limit, we return the progress\r\n  (expressed as a number 0-1) represented by the given value, and\r\n  limit that progress to within 0-1.\r\n\r\n  @param [number]: Lower limit\r\n  @param [number]: Upper limit\r\n  @param [number]: Value to find progress within given range\r\n  @return [number]: Progress of value within range as expressed 0-1\r\n*/\r\n/*#__NO_SIDE_EFFECTS__*/\r\nconst progress = (from, to, value) => {\r\n    const toFromDifference = to - from;\r\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\r\n};\r\n\r\nexport { progress };\r\n","/**\r\n * Converts seconds to milliseconds\r\n *\r\n * @param seconds - Time in seconds.\r\n * @return milliseconds - Converted time in milliseconds.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nconst secondsToMilliseconds = (seconds) => seconds * 1000;\r\n/*#__NO_SIDE_EFFECTS__*/\r\nconst millisecondsToSeconds = (milliseconds) => milliseconds / 1000;\r\n\r\nexport { millisecondsToSeconds, secondsToMilliseconds };\r\n","const MotionGlobalConfig = {\r\n    skipAnimations: false,\r\n    useManualTiming: false,\r\n};\r\n\r\nexport { MotionGlobalConfig };\r\n","import { MotionGlobalConfig } from '../utils/GlobalConfig.mjs';\r\nimport { createRenderStep } from './render-step.mjs';\r\n\r\nconst stepsOrder = [\r\n    \"read\", // Read\r\n    \"resolveKeyframes\", // Write/Read/Write/Read\r\n    \"update\", // Compute\r\n    \"preRender\", // Compute\r\n    \"render\", // Write\r\n    \"postRender\", // Compute\r\n];\r\nconst maxElapsed = 40;\r\nfunction createRenderBatcher(scheduleNextBatch, allowKeepAlive) {\r\n    let runNextFrame = false;\r\n    let useDefaultElapsed = true;\r\n    const state = {\r\n        delta: 0.0,\r\n        timestamp: 0.0,\r\n        isProcessing: false,\r\n    };\r\n    const flagRunNextFrame = () => (runNextFrame = true);\r\n    const steps = stepsOrder.reduce((acc, key) => {\r\n        acc[key] = createRenderStep(flagRunNextFrame);\r\n        return acc;\r\n    }, {});\r\n    const { read, resolveKeyframes, update, preRender, render, postRender } = steps;\r\n    const processBatch = () => {\r\n        const timestamp = MotionGlobalConfig.useManualTiming\r\n            ? state.timestamp\r\n            : performance.now();\r\n        runNextFrame = false;\r\n        state.delta = useDefaultElapsed\r\n            ? 1000 / 60\r\n            : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);\r\n        state.timestamp = timestamp;\r\n        state.isProcessing = true;\r\n        // Unrolled render loop for better per-frame performance\r\n        read.process(state);\r\n        resolveKeyframes.process(state);\r\n        update.process(state);\r\n        preRender.process(state);\r\n        render.process(state);\r\n        postRender.process(state);\r\n        state.isProcessing = false;\r\n        if (runNextFrame && allowKeepAlive) {\r\n            useDefaultElapsed = false;\r\n            scheduleNextBatch(processBatch);\r\n        }\r\n    };\r\n    const wake = () => {\r\n        runNextFrame = true;\r\n        useDefaultElapsed = true;\r\n        if (!state.isProcessing) {\r\n            scheduleNextBatch(processBatch);\r\n        }\r\n    };\r\n    const schedule = stepsOrder.reduce((acc, key) => {\r\n        const step = steps[key];\r\n        acc[key] = (process, keepAlive = false, immediate = false) => {\r\n            if (!runNextFrame)\r\n                wake();\r\n            return step.schedule(process, keepAlive, immediate);\r\n        };\r\n        return acc;\r\n    }, {});\r\n    const cancel = (process) => {\r\n        for (let i = 0; i < stepsOrder.length; i++) {\r\n            steps[stepsOrder[i]].cancel(process);\r\n        }\r\n    };\r\n    return { schedule, cancel, state, steps };\r\n}\r\n\r\nexport { createRenderBatcher, stepsOrder };\r\n","function createRenderStep(runNextFrame) {\r\n    /**\r\n     * We create and reuse two queues, one to queue jobs for the current frame\r\n     * and one for the next. We reuse to avoid triggering GC after x frames.\r\n     */\r\n    let thisFrame = new Set();\r\n    let nextFrame = new Set();\r\n    /**\r\n     * Track whether we're currently processing jobs in this step. This way\r\n     * we can decide whether to schedule new jobs for this frame or next.\r\n     */\r\n    let isProcessing = false;\r\n    let flushNextFrame = false;\r\n    /**\r\n     * A set of processes which were marked keepAlive when scheduled.\r\n     */\r\n    const toKeepAlive = new WeakSet();\r\n    let latestFrameData = {\r\n        delta: 0.0,\r\n        timestamp: 0.0,\r\n        isProcessing: false,\r\n    };\r\n    function triggerCallback(callback) {\r\n        if (toKeepAlive.has(callback)) {\r\n            step.schedule(callback);\r\n            runNextFrame();\r\n        }\r\n        callback(latestFrameData);\r\n    }\r\n    const step = {\r\n        /**\r\n         * Schedule a process to run on the next frame.\r\n         */\r\n        schedule: (callback, keepAlive = false, immediate = false) => {\r\n            const addToCurrentFrame = immediate && isProcessing;\r\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\r\n            if (keepAlive)\r\n                toKeepAlive.add(callback);\r\n            if (!queue.has(callback))\r\n                queue.add(callback);\r\n            return callback;\r\n        },\r\n        /**\r\n         * Cancel the provided callback from running on the next frame.\r\n         */\r\n        cancel: (callback) => {\r\n            nextFrame.delete(callback);\r\n            toKeepAlive.delete(callback);\r\n        },\r\n        /**\r\n         * Execute all schedule callbacks.\r\n         */\r\n        process: (frameData) => {\r\n            latestFrameData = frameData;\r\n            /**\r\n             * If we're already processing we've probably been triggered by a flushSync\r\n             * inside an existing process. Instead of executing, mark flushNextFrame\r\n             * as true and ensure we flush the following frame at the end of this one.\r\n             */\r\n            if (isProcessing) {\r\n                flushNextFrame = true;\r\n                return;\r\n            }\r\n            isProcessing = true;\r\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\r\n            // Execute this frame\r\n            thisFrame.forEach(triggerCallback);\r\n            // Clear the frame so no callbacks remain. This is to avoid\r\n            // memory leaks should this render step not run for a while.\r\n            thisFrame.clear();\r\n            isProcessing = false;\r\n            if (flushNextFrame) {\r\n                flushNextFrame = false;\r\n                step.process(frameData);\r\n            }\r\n        },\r\n    };\r\n    return step;\r\n}\r\n\r\nexport { createRenderStep };\r\n","import { noop } from 'motion-utils';\r\nimport { createRenderBatcher } from './batcher.mjs';\r\n\r\nconst { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = createRenderBatcher(typeof requestAnimationFrame !== \"undefined\" ? requestAnimationFrame : noop, true);\r\n\r\nexport { cancelFrame, frame, frameData, frameSteps };\r\n","\"use client\";\r\nimport { createContext } from 'react';\r\n\r\nconst LazyContext = createContext({ strict: false });\r\n\r\nexport { LazyContext };\r\n","const featureProps = {\r\n    animation: [\r\n        \"animate\",\r\n        \"variants\",\r\n        \"whileHover\",\r\n        \"whileTap\",\r\n        \"exit\",\r\n        \"whileInView\",\r\n        \"whileFocus\",\r\n        \"whileDrag\",\r\n    ],\r\n    exit: [\"exit\"],\r\n    drag: [\"drag\", \"dragControls\"],\r\n    focus: [\"whileFocus\"],\r\n    hover: [\"whileHover\", \"onHoverStart\", \"onHoverEnd\"],\r\n    tap: [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"],\r\n    pan: [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"],\r\n    inView: [\"whileInView\", \"onViewportEnter\", \"onViewportLeave\"],\r\n    layout: [\"layout\", \"layoutId\"],\r\n};\r\nconst featureDefinitions = {};\r\nfor (const key in featureProps) {\r\n    featureDefinitions[key] = {\r\n        isEnabled: (props) => featureProps[key].some((name) => !!props[name]),\r\n    };\r\n}\r\n\r\nexport { featureDefinitions };\r\n","/**\r\n * A list of all valid MotionProps.\r\n *\r\n * @privateRemarks\r\n * This doesn't throw if a `MotionProp` name is missing - it should.\r\n */\r\nconst validMotionProps = new Set([\r\n    \"animate\",\r\n    \"exit\",\r\n    \"variants\",\r\n    \"initial\",\r\n    \"style\",\r\n    \"values\",\r\n    \"variants\",\r\n    \"transition\",\r\n    \"transformTemplate\",\r\n    \"custom\",\r\n    \"inherit\",\r\n    \"onBeforeLayoutMeasure\",\r\n    \"onAnimationStart\",\r\n    \"onAnimationComplete\",\r\n    \"onUpdate\",\r\n    \"onDragStart\",\r\n    \"onDrag\",\r\n    \"onDragEnd\",\r\n    \"onMeasureDragConstraints\",\r\n    \"onDirectionLock\",\r\n    \"onDragTransitionEnd\",\r\n    \"_dragX\",\r\n    \"_dragY\",\r\n    \"onHoverStart\",\r\n    \"onHoverEnd\",\r\n    \"onViewportEnter\",\r\n    \"onViewportLeave\",\r\n    \"globalTapTarget\",\r\n    \"ignoreStrict\",\r\n    \"viewport\",\r\n]);\r\n/**\r\n * Check whether a prop name is a valid `MotionProp` key.\r\n *\r\n * @param key - Name of the property to check\r\n * @returns `true` is key is a valid `MotionProp`.\r\n *\r\n * @public\r\n */\r\nfunction isValidMotionProp(key) {\r\n    return (key.startsWith(\"while\") ||\r\n        (key.startsWith(\"drag\") && key !== \"draggable\") ||\r\n        key.startsWith(\"layout\") ||\r\n        key.startsWith(\"onTap\") ||\r\n        key.startsWith(\"onPan\") ||\r\n        key.startsWith(\"onLayout\") ||\r\n        validMotionProps.has(key));\r\n}\r\n\r\nexport { isValidMotionProp };\r\n","import { isValidMotionProp } from '../../../motion/utils/valid-prop.mjs';\r\n\r\nlet shouldForward = (key) => !isValidMotionProp(key);\r\nfunction loadExternalIsValidProp(isValidProp) {\r\n    if (!isValidProp)\r\n        return;\r\n    // Explicitly filter our events\r\n    shouldForward = (key) => key.startsWith(\"on\") ? !isValidMotionProp(key) : isValidProp(key);\r\n}\r\n/**\r\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\r\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\r\n * of these should be passed to the underlying DOM node.\r\n *\r\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\r\n * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\r\n * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of\r\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\r\n *\r\n * By making it an optionalDependency we can offer this functionality only in the situations where it's\r\n * actually required.\r\n */\r\ntry {\r\n    /**\r\n     * We attempt to import this package but require won't be defined in esm environments, in that case\r\n     * isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed\r\n     * in favour of explicit injection.\r\n     */\r\n    loadExternalIsValidProp(require(\"@emotion/is-prop-valid\").default);\r\n}\r\ncatch (_a) {\r\n    // We don't need to actually do anything here - the fallback is the existing `isPropValid`.\r\n}\r\nfunction filterProps(props, isDom, forwardMotionProps) {\r\n    const filteredProps = {};\r\n    for (const key in props) {\r\n        /**\r\n         * values is considered a valid prop by Emotion, so if it's present\r\n         * this will be rendered out to the DOM unless explicitly filtered.\r\n         *\r\n         * We check the type as it could be used with the `feColorMatrix`\r\n         * element, which we support.\r\n         */\r\n        if (key === \"values\" && typeof props.values === \"object\")\r\n            continue;\r\n        if (shouldForward(key) ||\r\n            (forwardMotionProps === true && isValidMotionProp(key)) ||\r\n            (!isDom && !isValidMotionProp(key)) ||\r\n            // If trying to use native HTML drag events, forward drag listeners\r\n            (props[\"draggable\"] &&\r\n                key.startsWith(\"onDrag\"))) {\r\n            filteredProps[key] =\r\n                props[key];\r\n        }\r\n    }\r\n    return filteredProps;\r\n}\r\n\r\nexport { filterProps, loadExternalIsValidProp };\r\n","import { warnOnce } from '../../utils/warn-once.mjs';\r\n\r\nfunction createDOMMotionComponentProxy(componentFactory) {\r\n    if (typeof Proxy === \"undefined\") {\r\n        return componentFactory;\r\n    }\r\n    /**\r\n     * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.\r\n     * Rather than generating them anew every render.\r\n     */\r\n    const componentCache = new Map();\r\n    const deprecatedFactoryFunction = (...args) => {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            warnOnce(false, \"motion() is deprecated. Use motion.create() instead.\");\r\n        }\r\n        return componentFactory(...args);\r\n    };\r\n    return new Proxy(deprecatedFactoryFunction, {\r\n        /**\r\n         * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\r\n         * The prop name is passed through as `key` and we can use that to generate a `motion`\r\n         * DOM component with that name.\r\n         */\r\n        get: (_target, key) => {\r\n            if (key === \"create\")\r\n                return componentFactory;\r\n            /**\r\n             * If this element doesn't exist in the component cache, create it and cache.\r\n             */\r\n            if (!componentCache.has(key)) {\r\n                componentCache.set(key, componentFactory(key));\r\n            }\r\n            return componentCache.get(key);\r\n        },\r\n    });\r\n}\r\n\r\nexport { createDOMMotionComponentProxy };\r\n","\"use client\";\r\nimport { createContext } from 'react';\r\n\r\nconst MotionContext = createContext({});\r\n\r\nexport { MotionContext };\r\n","/**\r\n * Decides if the supplied variable is variant label\r\n */\r\nfunction isVariantLabel(v) {\r\n    return typeof v === \"string\" || Array.isArray(v);\r\n}\r\n\r\nexport { isVariantLabel };\r\n","function isAnimationControls(v) {\r\n    return (v !== null &&\r\n        typeof v === \"object\" &&\r\n        typeof v.start === \"function\");\r\n}\r\n\r\nexport { isAnimationControls };\r\n","const variantPriorityOrder = [\r\n    \"animate\",\r\n    \"whileInView\",\r\n    \"whileFocus\",\r\n    \"whileHover\",\r\n    \"whileTap\",\r\n    \"whileDrag\",\r\n    \"exit\",\r\n];\r\nconst variantProps = [\"initial\", ...variantPriorityOrder];\r\n\r\nexport { variantPriorityOrder, variantProps };\r\n","import { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\r\nimport { isVariantLabel } from './is-variant-label.mjs';\r\nimport { variantProps } from './variant-props.mjs';\r\n\r\nfunction isControllingVariants(props) {\r\n    return (isAnimationControls(props.animate) ||\r\n        variantProps.some((name) => isVariantLabel(props[name])));\r\n}\r\nfunction isVariantNode(props) {\r\n    return Boolean(isControllingVariants(props) || props.variants);\r\n}\r\n\r\nexport { isControllingVariants, isVariantNode };\r\n","import { useContext, useMemo } from 'react';\r\nimport { MotionContext } from './index.mjs';\r\nimport { getCurrentTreeVariants } from './utils.mjs';\r\n\r\nfunction useCreateMotionContext(props) {\r\n    const { initial, animate } = getCurrentTreeVariants(props, useContext(MotionContext));\r\n    return useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);\r\n}\r\nfunction variantLabelsAsDependency(prop) {\r\n    return Array.isArray(prop) ? prop.join(\" \") : prop;\r\n}\r\n\r\nexport { useCreateMotionContext };\r\n","import { isVariantLabel } from '../../render/utils/is-variant-label.mjs';\r\nimport { isControllingVariants } from '../../render/utils/is-controlling-variants.mjs';\r\n\r\nfunction getCurrentTreeVariants(props, context) {\r\n    if (isControllingVariants(props)) {\r\n        const { initial, animate } = props;\r\n        return {\r\n            initial: initial === false || isVariantLabel(initial)\r\n                ? initial\r\n                : undefined,\r\n            animate: isVariantLabel(animate) ? animate : undefined,\r\n        };\r\n    }\r\n    return props.inherit !== false ? context : {};\r\n}\r\n\r\nexport { getCurrentTreeVariants };\r\n","const motionComponentSymbol = Symbol.for(\"motionComponentSymbol\");\r\n\r\nexport { motionComponentSymbol };\r\n","function isRefObject(ref) {\r\n    return (ref &&\r\n        typeof ref === \"object\" &&\r\n        Object.prototype.hasOwnProperty.call(ref, \"current\"));\r\n}\r\n\r\nexport { isRefObject };\r\n","import { useCallback } from 'react';\r\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\r\n\r\n/**\r\n * Creates a ref function that, when called, hydrates the provided\r\n * external ref and VisualElement.\r\n */\r\nfunction useMotionRef(visualState, visualElement, externalRef) {\r\n    return useCallback((instance) => {\r\n        if (instance) {\r\n            visualState.onMount && visualState.onMount(instance);\r\n        }\r\n        if (visualElement) {\r\n            if (instance) {\r\n                visualElement.mount(instance);\r\n            }\r\n            else {\r\n                visualElement.unmount();\r\n            }\r\n        }\r\n        if (externalRef) {\r\n            if (typeof externalRef === \"function\") {\r\n                externalRef(instance);\r\n            }\r\n            else if (isRefObject(externalRef)) {\r\n                externalRef.current = instance;\r\n            }\r\n        }\r\n    }, \r\n    /**\r\n     * Only pass a new ref callback to React if we've received a visual element\r\n     * factory. Otherwise we'll be mounting/remounting every time externalRef\r\n     * or other dependencies change.\r\n     */\r\n    [visualElement]);\r\n}\r\n\r\nexport { useMotionRef };\r\n","/**\r\n * Convert camelCase to dash-case properties.\r\n */\r\nconst camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, \"$1-$2\").toLowerCase();\r\n\r\nexport { camelToDash };\r\n","import { camelToDash } from '../../render/dom/utils/camel-to-dash.mjs';\r\n\r\nconst optimizedAppearDataId = \"framerAppearId\";\r\nconst optimizedAppearDataAttribute = \"data-\" + camelToDash(optimizedAppearDataId);\r\n\r\nexport { optimizedAppearDataAttribute, optimizedAppearDataId };\r\n","import { createRenderBatcher } from './batcher.mjs';\r\n\r\nconst { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, false);\r\n\r\nexport { cancelMicrotask, microtask };\r\n","\"use client\";\r\nimport { createContext } from 'react';\r\n\r\n/**\r\n * Internal, exported only for usage in Framer\r\n */\r\nconst SwitchLayoutGroupContext = createContext({});\r\n\r\nexport { SwitchLayoutGroupContext };\r\n","import { useContext, useRef, useInsertionEffect, useEffect } from 'react';\r\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\r\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\r\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\r\nimport { LazyContext } from '../../context/LazyContext.mjs';\r\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\r\nimport { optimizedAppearDataAttribute } from '../../animation/optimized-appear/data-id.mjs';\r\nimport { microtask } from '../../frameloop/microtask.mjs';\r\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\r\nimport { SwitchLayoutGroupContext } from '../../context/SwitchLayoutGroupContext.mjs';\r\n\r\nfunction useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {\r\n    var _a, _b;\r\n    const { visualElement: parent } = useContext(MotionContext);\r\n    const lazyContext = useContext(LazyContext);\r\n    const presenceContext = useContext(PresenceContext);\r\n    const reducedMotionConfig = useContext(MotionConfigContext).reducedMotion;\r\n    const visualElementRef = useRef(null);\r\n    /**\r\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\r\n     */\r\n    createVisualElement = createVisualElement || lazyContext.renderer;\r\n    if (!visualElementRef.current && createVisualElement) {\r\n        visualElementRef.current = createVisualElement(Component, {\r\n            visualState,\r\n            parent,\r\n            props,\r\n            presenceContext,\r\n            blockInitialAnimation: presenceContext\r\n                ? presenceContext.initial === false\r\n                : false,\r\n            reducedMotionConfig,\r\n        });\r\n    }\r\n    const visualElement = visualElementRef.current;\r\n    /**\r\n     * Load Motion gesture and animation features. These are rendered as renderless\r\n     * components so each feature can optionally make use of React lifecycle methods.\r\n     */\r\n    const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);\r\n    if (visualElement &&\r\n        !visualElement.projection &&\r\n        ProjectionNodeConstructor &&\r\n        (visualElement.type === \"html\" || visualElement.type === \"svg\")) {\r\n        createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);\r\n    }\r\n    const isMounted = useRef(false);\r\n    useInsertionEffect(() => {\r\n        /**\r\n         * Check the component has already mounted before calling\r\n         * `update` unnecessarily. This ensures we skip the initial update.\r\n         */\r\n        if (visualElement && isMounted.current) {\r\n            visualElement.update(props, presenceContext);\r\n        }\r\n    });\r\n    /**\r\n     * Cache this value as we want to know whether HandoffAppearAnimations\r\n     * was present on initial render - it will be deleted after this.\r\n     */\r\n    const optimisedAppearId = props[optimizedAppearDataAttribute];\r\n    const wantsHandoff = useRef(Boolean(optimisedAppearId) &&\r\n        !((_a = window.MotionHandoffIsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId)) &&\r\n        ((_b = window.MotionHasOptimisedAnimation) === null || _b === void 0 ? void 0 : _b.call(window, optimisedAppearId)));\r\n    useIsomorphicLayoutEffect(() => {\r\n        if (!visualElement)\r\n            return;\r\n        isMounted.current = true;\r\n        window.MotionIsMounted = true;\r\n        visualElement.updateFeatures();\r\n        microtask.render(visualElement.render);\r\n        /**\r\n         * Ideally this function would always run in a useEffect.\r\n         *\r\n         * However, if we have optimised appear animations to handoff from,\r\n         * it needs to happen synchronously to ensure there's no flash of\r\n         * incorrect styles in the event of a hydration error.\r\n         *\r\n         * So if we detect a situtation where optimised appear animations\r\n         * are running, we use useLayoutEffect to trigger animations.\r\n         */\r\n        if (wantsHandoff.current && visualElement.animationState) {\r\n            visualElement.animationState.animateChanges();\r\n        }\r\n    });\r\n    useEffect(() => {\r\n        if (!visualElement)\r\n            return;\r\n        if (!wantsHandoff.current && visualElement.animationState) {\r\n            visualElement.animationState.animateChanges();\r\n        }\r\n        if (wantsHandoff.current) {\r\n            // This ensures all future calls to animateChanges() in this component will run in useEffect\r\n            queueMicrotask(() => {\r\n                var _a;\r\n                (_a = window.MotionHandoffMarkAsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId);\r\n            });\r\n            wantsHandoff.current = false;\r\n        }\r\n    });\r\n    return visualElement;\r\n}\r\nfunction createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {\r\n    const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, } = props;\r\n    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props[\"data-framer-portal-id\"]\r\n        ? undefined\r\n        : getClosestProjectingNode(visualElement.parent));\r\n    visualElement.projection.setOptions({\r\n        layoutId,\r\n        layout,\r\n        alwaysMeasureLayout: Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),\r\n        visualElement,\r\n        /**\r\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\r\n         * to update by the time layout animations run.\r\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\r\n         * ensuring it gets called if there's no potential layout animations.\r\n         *\r\n         */\r\n        animationType: typeof layout === \"string\" ? layout : \"both\",\r\n        initialPromotionConfig,\r\n        layoutScroll,\r\n        layoutRoot,\r\n    });\r\n}\r\nfunction getClosestProjectingNode(visualElement) {\r\n    if (!visualElement)\r\n        return undefined;\r\n    return visualElement.options.allowProjection !== false\r\n        ? visualElement.projection\r\n        : getClosestProjectingNode(visualElement.parent);\r\n}\r\n\r\nexport { useVisualElement };\r\n","\"use client\";\r\nimport { jsxs, jsx } from 'react/jsx-runtime';\r\nimport { warning, invariant } from 'motion-utils';\r\nimport { forwardRef, useContext } from 'react';\r\nimport { LayoutGroupContext } from '../context/LayoutGroupContext.mjs';\r\nimport { LazyContext } from '../context/LazyContext.mjs';\r\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\r\nimport { MotionContext } from '../context/MotionContext/index.mjs';\r\nimport { useCreateMotionContext } from '../context/MotionContext/create.mjs';\r\nimport { isBrowser } from '../utils/is-browser.mjs';\r\nimport { featureDefinitions } from './features/definitions.mjs';\r\nimport { loadFeatures } from './features/load-features.mjs';\r\nimport { motionComponentSymbol } from './utils/symbol.mjs';\r\nimport { useMotionRef } from './utils/use-motion-ref.mjs';\r\nimport { useVisualElement } from './utils/use-visual-element.mjs';\r\n\r\n/**\r\n * Create a `motion` component.\r\n *\r\n * This function accepts a Component argument, which can be either a string (ie \"div\"\r\n * for `motion.div`), or an actual React component.\r\n *\r\n * Alongside this is a config option which provides a way of rendering the provided\r\n * component \"offline\", or outside the React render cycle.\r\n */\r\nfunction createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component, }) {\r\n    var _a, _b;\r\n    preloadedFeatures && loadFeatures(preloadedFeatures);\r\n    function MotionComponent(props, externalRef) {\r\n        /**\r\n         * If we need to measure the element we load this functionality in a\r\n         * separate class component in order to gain access to getSnapshotBeforeUpdate.\r\n         */\r\n        let MeasureLayout;\r\n        const configAndProps = {\r\n            ...useContext(MotionConfigContext),\r\n            ...props,\r\n            layoutId: useLayoutId(props),\r\n        };\r\n        const { isStatic } = configAndProps;\r\n        const context = useCreateMotionContext(props);\r\n        const visualState = useVisualState(props, isStatic);\r\n        if (!isStatic && isBrowser) {\r\n            useStrictMode(configAndProps, preloadedFeatures);\r\n            const layoutProjection = getProjectionFunctionality(configAndProps);\r\n            MeasureLayout = layoutProjection.MeasureLayout;\r\n            /**\r\n             * Create a VisualElement for this component. A VisualElement provides a common\r\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\r\n             * providing a way of rendering to these APIs outside of the React render loop\r\n             * for more performant animations and interactions\r\n             */\r\n            context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);\r\n        }\r\n        /**\r\n         * The mount order and hierarchy is specific to ensure our element ref\r\n         * is hydrated by the time features fire their effects.\r\n         */\r\n        return (jsxs(MotionContext.Provider, { value: context, children: [MeasureLayout && context.visualElement ? (jsx(MeasureLayout, { visualElement: context.visualElement, ...configAndProps })) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] }));\r\n    }\r\n    MotionComponent.displayName = `motion.${typeof Component === \"string\"\r\n        ? Component\r\n        : `create(${(_b = (_a = Component.displayName) !== null && _a !== void 0 ? _a : Component.name) !== null && _b !== void 0 ? _b : \"\"})`}`;\r\n    const ForwardRefMotionComponent = forwardRef(MotionComponent);\r\n    ForwardRefMotionComponent[motionComponentSymbol] = Component;\r\n    return ForwardRefMotionComponent;\r\n}\r\nfunction useLayoutId({ layoutId }) {\r\n    const layoutGroupId = useContext(LayoutGroupContext).id;\r\n    return layoutGroupId && layoutId !== undefined\r\n        ? layoutGroupId + \"-\" + layoutId\r\n        : layoutId;\r\n}\r\nfunction useStrictMode(configAndProps, preloadedFeatures) {\r\n    const isStrict = useContext(LazyContext).strict;\r\n    /**\r\n     * If we're in development mode, check to make sure we're not rendering a motion component\r\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\r\n     */\r\n    if (process.env.NODE_ENV !== \"production\" &&\r\n        preloadedFeatures &&\r\n        isStrict) {\r\n        const strictMessage = \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\";\r\n        configAndProps.ignoreStrict\r\n            ? warning(false, strictMessage)\r\n            : invariant(false, strictMessage);\r\n    }\r\n}\r\nfunction getProjectionFunctionality(props) {\r\n    const { drag, layout } = featureDefinitions;\r\n    if (!drag && !layout)\r\n        return {};\r\n    const combined = { ...drag, ...layout };\r\n    return {\r\n        MeasureLayout: (drag === null || drag === void 0 ? void 0 : drag.isEnabled(props)) || (layout === null || layout === void 0 ? void 0 : layout.isEnabled(props))\r\n            ? combined.MeasureLayout\r\n            : undefined,\r\n        ProjectionNode: combined.ProjectionNode,\r\n    };\r\n}\r\n\r\nexport { createRendererMotionComponent };\r\n","import { featureDefinitions } from './definitions.mjs';\r\n\r\nfunction loadFeatures(features) {\r\n    for (const key in features) {\r\n        featureDefinitions[key] = {\r\n            ...featureDefinitions[key],\r\n            ...features[key],\r\n        };\r\n    }\r\n}\r\n\r\nexport { loadFeatures };\r\n","/**\r\n * We keep these listed separately as we use the lowercase tag names as part\r\n * of the runtime bundle to detect SVG components\r\n */\r\nconst lowercaseSVGElements = [\r\n    \"animate\",\r\n    \"circle\",\r\n    \"defs\",\r\n    \"desc\",\r\n    \"ellipse\",\r\n    \"g\",\r\n    \"image\",\r\n    \"line\",\r\n    \"filter\",\r\n    \"marker\",\r\n    \"mask\",\r\n    \"metadata\",\r\n    \"path\",\r\n    \"pattern\",\r\n    \"polygon\",\r\n    \"polyline\",\r\n    \"rect\",\r\n    \"stop\",\r\n    \"switch\",\r\n    \"symbol\",\r\n    \"svg\",\r\n    \"text\",\r\n    \"tspan\",\r\n    \"use\",\r\n    \"view\",\r\n];\r\n\r\nexport { lowercaseSVGElements };\r\n","import { lowercaseSVGElements } from '../../svg/lowercase-elements.mjs';\r\n\r\nfunction isSVGComponent(Component) {\r\n    if (\r\n    /**\r\n     * If it's not a string, it's a custom React component. Currently we only support\r\n     * HTML custom React components.\r\n     */\r\n    typeof Component !== \"string\" ||\r\n        /**\r\n         * If it contains a dash, the element is a custom HTML webcomponent.\r\n         */\r\n        Component.includes(\"-\")) {\r\n        return false;\r\n    }\r\n    else if (\r\n    /**\r\n     * If it's in our list of lowercase SVG tags, it's an SVG component\r\n     */\r\n    lowercaseSVGElements.indexOf(Component) > -1 ||\r\n        /**\r\n         * If it contains a capital letter, it's an SVG component\r\n         */\r\n        /[A-Z]/u.test(Component)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nexport { isSVGComponent };\r\n","function getValueState(visualElement) {\r\n    const state = [{}, {}];\r\n    visualElement === null || visualElement === void 0 ? void 0 : visualElement.values.forEach((value, key) => {\r\n        state[0][key] = value.get();\r\n        state[1][key] = value.getVelocity();\r\n    });\r\n    return state;\r\n}\r\nfunction resolveVariantFromProps(props, definition, custom, visualElement) {\r\n    /**\r\n     * If the variant definition is a function, resolve.\r\n     */\r\n    if (typeof definition === \"function\") {\r\n        const [current, velocity] = getValueState(visualElement);\r\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\r\n    }\r\n    /**\r\n     * If the variant definition is a variant label, or\r\n     * the function returned a variant label, resolve.\r\n     */\r\n    if (typeof definition === \"string\") {\r\n        definition = props.variants && props.variants[definition];\r\n    }\r\n    /**\r\n     * At this point we've resolved both functions and variant labels,\r\n     * but the resolved variant label might itself have been a function.\r\n     * If so, resolve. This can only have returned a valid target object.\r\n     */\r\n    if (typeof definition === \"function\") {\r\n        const [current, velocity] = getValueState(visualElement);\r\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\r\n    }\r\n    return definition;\r\n}\r\n\r\nexport { resolveVariantFromProps };\r\n","const isKeyframesTarget = (v) => {\r\n    return Array.isArray(v);\r\n};\r\n\r\nexport { isKeyframesTarget };\r\n","import { isKeyframesTarget } from '../animation/utils/is-keyframes-target.mjs';\r\n\r\nconst isCustomValue = (v) => {\r\n    return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\r\n};\r\nconst resolveFinalValueInKeyframes = (v) => {\r\n    // TODO maybe throw if v.length - 1 is placeholder token?\r\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\r\n};\r\n\r\nexport { isCustomValue, resolveFinalValueInKeyframes };\r\n","const isMotionValue = (value) => Boolean(value && value.getVelocity);\r\n\r\nexport { isMotionValue };\r\n","import { isCustomValue } from '../../utils/resolve-value.mjs';\r\nimport { isMotionValue } from './is-motion-value.mjs';\r\n\r\n/**\r\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\r\n *\r\n * TODO: Remove and move to library\r\n */\r\nfunction resolveMotionValue(value) {\r\n    const unwrappedValue = isMotionValue(value) ? value.get() : value;\r\n    return isCustomValue(unwrappedValue)\r\n        ? unwrappedValue.toValue()\r\n        : unwrappedValue;\r\n}\r\n\r\nexport { resolveMotionValue };\r\n","import { useContext } from 'react';\r\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\r\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\r\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\r\nimport { isControllingVariants, isVariantNode } from '../../render/utils/is-controlling-variants.mjs';\r\nimport { resolveVariantFromProps } from '../../render/utils/resolve-variants.mjs';\r\nimport { useConstant } from '../../utils/use-constant.mjs';\r\nimport { resolveMotionValue } from '../../value/utils/resolve-motion-value.mjs';\r\n\r\nfunction makeState({ scrapeMotionValuesFromProps, createRenderState, onUpdate, }, props, context, presenceContext) {\r\n    const state = {\r\n        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\r\n        renderState: createRenderState(),\r\n    };\r\n    if (onUpdate) {\r\n        /**\r\n         * onMount works without the VisualElement because it could be\r\n         * called before the VisualElement payload has been hydrated.\r\n         * (e.g. if someone is using m components <m.circle />)\r\n         */\r\n        state.onMount = (instance) => onUpdate({ props, current: instance, ...state });\r\n        state.onUpdate = (visualElement) => onUpdate(visualElement);\r\n    }\r\n    return state;\r\n}\r\nconst makeUseVisualState = (config) => (props, isStatic) => {\r\n    const context = useContext(MotionContext);\r\n    const presenceContext = useContext(PresenceContext);\r\n    const make = () => makeState(config, props, context, presenceContext);\r\n    return isStatic ? make() : useConstant(make);\r\n};\r\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\r\n    const values = {};\r\n    const motionValues = scrapeMotionValues(props, {});\r\n    for (const key in motionValues) {\r\n        values[key] = resolveMotionValue(motionValues[key]);\r\n    }\r\n    let { initial, animate } = props;\r\n    const isControllingVariants$1 = isControllingVariants(props);\r\n    const isVariantNode$1 = isVariantNode(props);\r\n    if (context &&\r\n        isVariantNode$1 &&\r\n        !isControllingVariants$1 &&\r\n        props.inherit !== false) {\r\n        if (initial === undefined)\r\n            initial = context.initial;\r\n        if (animate === undefined)\r\n            animate = context.animate;\r\n    }\r\n    let isInitialAnimationBlocked = presenceContext\r\n        ? presenceContext.initial === false\r\n        : false;\r\n    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\r\n    const variantToSet = isInitialAnimationBlocked ? animate : initial;\r\n    if (variantToSet &&\r\n        typeof variantToSet !== \"boolean\" &&\r\n        !isAnimationControls(variantToSet)) {\r\n        const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\r\n        for (let i = 0; i < list.length; i++) {\r\n            const resolved = resolveVariantFromProps(props, list[i]);\r\n            if (resolved) {\r\n                const { transitionEnd, transition, ...target } = resolved;\r\n                for (const key in target) {\r\n                    let valueTarget = target[key];\r\n                    if (Array.isArray(valueTarget)) {\r\n                        /**\r\n                         * Take final keyframe if the initial animation is blocked because\r\n                         * we want to initialise at the end of that blocked animation.\r\n                         */\r\n                        const index = isInitialAnimationBlocked\r\n                            ? valueTarget.length - 1\r\n                            : 0;\r\n                        valueTarget = valueTarget[index];\r\n                    }\r\n                    if (valueTarget !== null) {\r\n                        values[key] = valueTarget;\r\n                    }\r\n                }\r\n                for (const key in transitionEnd) {\r\n                    values[key] = transitionEnd[key];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return values;\r\n}\r\n\r\nexport { makeUseVisualState };\r\n","/**\r\n * Generate a list of every possible transform key.\r\n */\r\nconst transformPropOrder = [\r\n    \"transformPerspective\",\r\n    \"x\",\r\n    \"y\",\r\n    \"z\",\r\n    \"translateX\",\r\n    \"translateY\",\r\n    \"translateZ\",\r\n    \"scale\",\r\n    \"scaleX\",\r\n    \"scaleY\",\r\n    \"rotate\",\r\n    \"rotateX\",\r\n    \"rotateY\",\r\n    \"rotateZ\",\r\n    \"skew\",\r\n    \"skewX\",\r\n    \"skewY\",\r\n];\r\n/**\r\n * A quick lookup for transform props.\r\n */\r\nconst transformProps = new Set(transformPropOrder);\r\n\r\nexport { transformPropOrder, transformProps };\r\n","const checkStringStartsWith = (token) => (key) => typeof key === \"string\" && key.startsWith(token);\r\nconst isCSSVariableName = \r\n/*@__PURE__*/ checkStringStartsWith(\"--\");\r\nconst startsAsVariableToken = \r\n/*@__PURE__*/ checkStringStartsWith(\"var(--\");\r\nconst isCSSVariableToken = (value) => {\r\n    const startsWithToken = startsAsVariableToken(value);\r\n    if (!startsWithToken)\r\n        return false;\r\n    // Ensure any comments are stripped from the value as this can harm performance of the regex.\r\n    return singleCssVariableRegex.test(value.split(\"/*\")[0].trim());\r\n};\r\nconst singleCssVariableRegex = /var\\(--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)$/iu;\r\n\r\nexport { isCSSVariableName, isCSSVariableToken };\r\n","/**\r\n * Provided a value and a ValueType, returns the value as that value type.\r\n */\r\nconst getValueAsType = (value, type) => {\r\n    return type && typeof value === \"number\"\r\n        ? type.transform(value)\r\n        : value;\r\n};\r\n\r\nexport { getValueAsType };\r\n","const clamp = (min, max, v) => {\r\n    if (v > max)\r\n        return max;\r\n    if (v < min)\r\n        return min;\r\n    return v;\r\n};\r\n\r\nexport { clamp };\r\n","import { clamp } from '../../../utils/clamp.mjs';\r\n\r\nconst number = {\r\n    test: (v) => typeof v === \"number\",\r\n    parse: parseFloat,\r\n    transform: (v) => v,\r\n};\r\nconst alpha = {\r\n    ...number,\r\n    transform: (v) => clamp(0, 1, v),\r\n};\r\nconst scale = {\r\n    ...number,\r\n    default: 1,\r\n};\r\n\r\nexport { alpha, number, scale };\r\n","const createUnitType = (unit) => ({\r\n    test: (v) => typeof v === \"string\" && v.endsWith(unit) && v.split(\" \").length === 1,\r\n    parse: parseFloat,\r\n    transform: (v) => `${v}${unit}`,\r\n});\r\nconst degrees = /*@__PURE__*/ createUnitType(\"deg\");\r\nconst percent = /*@__PURE__*/ createUnitType(\"%\");\r\nconst px = /*@__PURE__*/ createUnitType(\"px\");\r\nconst vh = /*@__PURE__*/ createUnitType(\"vh\");\r\nconst vw = /*@__PURE__*/ createUnitType(\"vw\");\r\nconst progressPercentage = {\r\n    ...percent,\r\n    parse: (v) => percent.parse(v) / 100,\r\n    transform: (v) => percent.transform(v * 100),\r\n};\r\n\r\nexport { degrees, percent, progressPercentage, px, vh, vw };\r\n","import { px } from '../../../value/types/numbers/units.mjs';\r\n\r\nconst browserNumberValueTypes = {\r\n    // Border props\r\n    borderWidth: px,\r\n    borderTopWidth: px,\r\n    borderRightWidth: px,\r\n    borderBottomWidth: px,\r\n    borderLeftWidth: px,\r\n    borderRadius: px,\r\n    radius: px,\r\n    borderTopLeftRadius: px,\r\n    borderTopRightRadius: px,\r\n    borderBottomRightRadius: px,\r\n    borderBottomLeftRadius: px,\r\n    // Positioning props\r\n    width: px,\r\n    maxWidth: px,\r\n    height: px,\r\n    maxHeight: px,\r\n    top: px,\r\n    right: px,\r\n    bottom: px,\r\n    left: px,\r\n    // Spacing props\r\n    padding: px,\r\n    paddingTop: px,\r\n    paddingRight: px,\r\n    paddingBottom: px,\r\n    paddingLeft: px,\r\n    margin: px,\r\n    marginTop: px,\r\n    marginRight: px,\r\n    marginBottom: px,\r\n    marginLeft: px,\r\n    // Misc\r\n    backgroundPositionX: px,\r\n    backgroundPositionY: px,\r\n};\r\n\r\nexport { browserNumberValueTypes };\r\n","import { scale, alpha } from '../../../value/types/numbers/index.mjs';\r\nimport { degrees, px, progressPercentage } from '../../../value/types/numbers/units.mjs';\r\n\r\nconst transformValueTypes = {\r\n    rotate: degrees,\r\n    rotateX: degrees,\r\n    rotateY: degrees,\r\n    rotateZ: degrees,\r\n    scale,\r\n    scaleX: scale,\r\n    scaleY: scale,\r\n    scaleZ: scale,\r\n    skew: degrees,\r\n    skewX: degrees,\r\n    skewY: degrees,\r\n    distance: px,\r\n    translateX: px,\r\n    translateY: px,\r\n    translateZ: px,\r\n    x: px,\r\n    y: px,\r\n    z: px,\r\n    perspective: px,\r\n    transformPerspective: px,\r\n    opacity: alpha,\r\n    originX: progressPercentage,\r\n    originY: progressPercentage,\r\n    originZ: px,\r\n};\r\n\r\nexport { transformValueTypes };\r\n","import { number } from '../../../value/types/numbers/index.mjs';\r\n\r\nconst int = {\r\n    ...number,\r\n    transform: Math.round,\r\n};\r\n\r\nexport { int };\r\n","import { alpha } from '../../../value/types/numbers/index.mjs';\r\nimport { px } from '../../../value/types/numbers/units.mjs';\r\nimport { browserNumberValueTypes } from './number-browser.mjs';\r\nimport { transformValueTypes } from './transform.mjs';\r\nimport { int } from './type-int.mjs';\r\n\r\nconst numberValueTypes = {\r\n    ...browserNumberValueTypes,\r\n    ...transformValueTypes,\r\n    zIndex: int,\r\n    size: px,\r\n    // SVG\r\n    fillOpacity: alpha,\r\n    strokeOpacity: alpha,\r\n    numOctaves: int,\r\n};\r\n\r\nexport { numberValueTypes };\r\n","import { getValueAsType } from '../../dom/value-types/get-as-type.mjs';\r\nimport { numberValueTypes } from '../../dom/value-types/number.mjs';\r\nimport { transformPropOrder } from './keys-transform.mjs';\r\n\r\nconst translateAlias = {\r\n    x: \"translateX\",\r\n    y: \"translateY\",\r\n    z: \"translateZ\",\r\n    transformPerspective: \"perspective\",\r\n};\r\nconst numTransforms = transformPropOrder.length;\r\n/**\r\n * Build a CSS transform style from individual x/y/scale etc properties.\r\n *\r\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\r\n * providing a transformTemplate function.\r\n */\r\nfunction buildTransform(latestValues, transform, transformTemplate) {\r\n    // The transform string we're going to build into.\r\n    let transformString = \"\";\r\n    let transformIsDefault = true;\r\n    /**\r\n     * Loop over all possible transforms in order, adding the ones that\r\n     * are present to the transform string.\r\n     */\r\n    for (let i = 0; i < numTransforms; i++) {\r\n        const key = transformPropOrder[i];\r\n        const value = latestValues[key];\r\n        if (value === undefined)\r\n            continue;\r\n        let valueIsDefault = true;\r\n        if (typeof value === \"number\") {\r\n            valueIsDefault = value === (key.startsWith(\"scale\") ? 1 : 0);\r\n        }\r\n        else {\r\n            valueIsDefault = parseFloat(value) === 0;\r\n        }\r\n        if (!valueIsDefault || transformTemplate) {\r\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\r\n            if (!valueIsDefault) {\r\n                transformIsDefault = false;\r\n                const transformName = translateAlias[key] || key;\r\n                transformString += `${transformName}(${valueAsType}) `;\r\n            }\r\n            if (transformTemplate) {\r\n                transform[key] = valueAsType;\r\n            }\r\n        }\r\n    }\r\n    transformString = transformString.trim();\r\n    // If we have a custom `transform` template, pass our transform values and\r\n    // generated transformString to that before returning\r\n    if (transformTemplate) {\r\n        transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\r\n    }\r\n    else if (transformIsDefault) {\r\n        transformString = \"none\";\r\n    }\r\n    return transformString;\r\n}\r\n\r\nexport { buildTransform };\r\n","import { isCSSVariableName } from '../../dom/utils/is-css-variable.mjs';\r\nimport { getValueAsType } from '../../dom/value-types/get-as-type.mjs';\r\nimport { numberValueTypes } from '../../dom/value-types/number.mjs';\r\nimport { buildTransform } from './build-transform.mjs';\r\nimport { transformProps } from './keys-transform.mjs';\r\n\r\nfunction buildHTMLStyles(state, latestValues, transformTemplate) {\r\n    const { style, vars, transformOrigin } = state;\r\n    // Track whether we encounter any transform or transformOrigin values.\r\n    let hasTransform = false;\r\n    let hasTransformOrigin = false;\r\n    /**\r\n     * Loop over all our latest animated values and decide whether to handle them\r\n     * as a style or CSS variable.\r\n     *\r\n     * Transforms and transform origins are kept separately for further processing.\r\n     */\r\n    for (const key in latestValues) {\r\n        const value = latestValues[key];\r\n        if (transformProps.has(key)) {\r\n            // If this is a transform, flag to enable further transform processing\r\n            hasTransform = true;\r\n            continue;\r\n        }\r\n        else if (isCSSVariableName(key)) {\r\n            vars[key] = value;\r\n            continue;\r\n        }\r\n        else {\r\n            // Convert the value to its default value type, ie 0 -> \"0px\"\r\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\r\n            if (key.startsWith(\"origin\")) {\r\n                // If this is a transform origin, flag and enable further transform-origin processing\r\n                hasTransformOrigin = true;\r\n                transformOrigin[key] =\r\n                    valueAsType;\r\n            }\r\n            else {\r\n                style[key] = valueAsType;\r\n            }\r\n        }\r\n    }\r\n    if (!latestValues.transform) {\r\n        if (hasTransform || transformTemplate) {\r\n            style.transform = buildTransform(latestValues, state.transform, transformTemplate);\r\n        }\r\n        else if (style.transform) {\r\n            /**\r\n             * If we have previously created a transform but currently don't have any,\r\n             * reset transform style to none.\r\n             */\r\n            style.transform = \"none\";\r\n        }\r\n    }\r\n    /**\r\n     * Build a transformOrigin style. Uses the same defaults as the browser for\r\n     * undefined origins.\r\n     */\r\n    if (hasTransformOrigin) {\r\n        const { originX = \"50%\", originY = \"50%\", originZ = 0, } = transformOrigin;\r\n        style.transformOrigin = `${originX} ${originY} ${originZ}`;\r\n    }\r\n}\r\n\r\nexport { buildHTMLStyles };\r\n","import { px } from '../../../value/types/numbers/units.mjs';\r\n\r\nconst dashKeys = {\r\n    offset: \"stroke-dashoffset\",\r\n    array: \"stroke-dasharray\",\r\n};\r\nconst camelKeys = {\r\n    offset: \"strokeDashoffset\",\r\n    array: \"strokeDasharray\",\r\n};\r\n/**\r\n * Build SVG path properties. Uses the path's measured length to convert\r\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\r\n * and stroke-dasharray attributes.\r\n *\r\n * This function is mutative to reduce per-frame GC.\r\n */\r\nfunction buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {\r\n    // Normalise path length by setting SVG attribute pathLength to 1\r\n    attrs.pathLength = 1;\r\n    // We use dash case when setting attributes directly to the DOM node and camel case\r\n    // when defining props on a React component.\r\n    const keys = useDashCase ? dashKeys : camelKeys;\r\n    // Build the dash offset\r\n    attrs[keys.offset] = px.transform(-offset);\r\n    // Build the dash array\r\n    const pathLength = px.transform(length);\r\n    const pathSpacing = px.transform(spacing);\r\n    attrs[keys.array] = `${pathLength} ${pathSpacing}`;\r\n}\r\n\r\nexport { buildSVGPath };\r\n","import { px } from '../../../value/types/numbers/units.mjs';\r\n\r\nfunction calcOrigin(origin, offset, size) {\r\n    return typeof origin === \"string\"\r\n        ? origin\r\n        : px.transform(offset + size * origin);\r\n}\r\n/**\r\n * The SVG transform origin defaults are different to CSS and is less intuitive,\r\n * so we use the measured dimensions of the SVG to reconcile these.\r\n */\r\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\r\n    const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);\r\n    const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);\r\n    return `${pxOriginX} ${pxOriginY}`;\r\n}\r\n\r\nexport { calcSVGTransformOrigin };\r\n","import { buildHTMLStyles } from '../../html/utils/build-styles.mjs';\r\nimport { buildSVGPath } from './path.mjs';\r\nimport { calcSVGTransformOrigin } from './transform-origin.mjs';\r\n\r\n/**\r\n * Build SVG visual attrbutes, like cx and style.transform\r\n */\r\nfunction buildSVGAttrs(state, { attrX, attrY, attrScale, originX, originY, pathLength, pathSpacing = 1, pathOffset = 0, \r\n// This is object creation, which we try to avoid per-frame.\r\n...latest }, isSVGTag, transformTemplate) {\r\n    buildHTMLStyles(state, latest, transformTemplate);\r\n    /**\r\n     * For svg tags we just want to make sure viewBox is animatable and treat all the styles\r\n     * as normal HTML tags.\r\n     */\r\n    if (isSVGTag) {\r\n        if (state.style.viewBox) {\r\n            state.attrs.viewBox = state.style.viewBox;\r\n        }\r\n        return;\r\n    }\r\n    state.attrs = state.style;\r\n    state.style = {};\r\n    const { attrs, style, dimensions } = state;\r\n    /**\r\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\r\n     * and copy it into style.\r\n     */\r\n    if (attrs.transform) {\r\n        if (dimensions)\r\n            style.transform = attrs.transform;\r\n        delete attrs.transform;\r\n    }\r\n    // Parse transformOrigin\r\n    if (dimensions &&\r\n        (originX !== undefined || originY !== undefined || style.transform)) {\r\n        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\r\n    }\r\n    // Render attrX/attrY/attrScale as attributes\r\n    if (attrX !== undefined)\r\n        attrs.x = attrX;\r\n    if (attrY !== undefined)\r\n        attrs.y = attrY;\r\n    if (attrScale !== undefined)\r\n        attrs.scale = attrScale;\r\n    // Build SVG path if one has been defined\r\n    if (pathLength !== undefined) {\r\n        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\r\n    }\r\n}\r\n\r\nexport { buildSVGAttrs };\r\n","const createHtmlRenderState = () => ({\r\n    style: {},\r\n    transform: {},\r\n    transformOrigin: {},\r\n    vars: {},\r\n});\r\n\r\nexport { createHtmlRenderState };\r\n","import { createHtmlRenderState } from '../../html/utils/create-render-state.mjs';\r\n\r\nconst createSvgRenderState = () => ({\r\n    ...createHtmlRenderState(),\r\n    attrs: {},\r\n});\r\n\r\nexport { createSvgRenderState };\r\n","const isSVGTag = (tag) => typeof tag === \"string\" && tag.toLowerCase() === \"svg\";\r\n\r\nexport { isSVGTag };\r\n","function renderHTML(element, { style, vars }, styleProp, projection) {\r\n    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));\r\n    // Loop over any CSS variables and assign those.\r\n    for (const key in vars) {\r\n        element.style.setProperty(key, vars[key]);\r\n    }\r\n}\r\n\r\nexport { renderHTML };\r\n","/**\r\n * A set of attribute names that are always read/written as camel case.\r\n */\r\nconst camelCaseAttributes = new Set([\r\n    \"baseFrequency\",\r\n    \"diffuseConstant\",\r\n    \"kernelMatrix\",\r\n    \"kernelUnitLength\",\r\n    \"keySplines\",\r\n    \"keyTimes\",\r\n    \"limitingConeAngle\",\r\n    \"markerHeight\",\r\n    \"markerWidth\",\r\n    \"numOctaves\",\r\n    \"targetX\",\r\n    \"targetY\",\r\n    \"surfaceScale\",\r\n    \"specularConstant\",\r\n    \"specularExponent\",\r\n    \"stdDeviation\",\r\n    \"tableValues\",\r\n    \"viewBox\",\r\n    \"gradientTransform\",\r\n    \"pathLength\",\r\n    \"startOffset\",\r\n    \"textLength\",\r\n    \"lengthAdjust\",\r\n]);\r\n\r\nexport { camelCaseAttributes };\r\n","import { camelToDash } from '../../dom/utils/camel-to-dash.mjs';\r\nimport { renderHTML } from '../../html/utils/render.mjs';\r\nimport { camelCaseAttributes } from './camel-case-attrs.mjs';\r\n\r\nfunction renderSVG(element, renderState, _styleProp, projection) {\r\n    renderHTML(element, renderState, undefined, projection);\r\n    for (const key in renderState.attrs) {\r\n        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\r\n    }\r\n}\r\n\r\nexport { renderSVG };\r\n","const scaleCorrectors = {};\r\nfunction addScaleCorrector(correctors) {\r\n    Object.assign(scaleCorrectors, correctors);\r\n}\r\n\r\nexport { addScaleCorrector, scaleCorrectors };\r\n","import { scaleCorrectors } from '../../projection/styles/scale-correction.mjs';\r\nimport { transformProps } from '../../render/html/utils/keys-transform.mjs';\r\n\r\nfunction isForcedMotionValue(key, { layout, layoutId }) {\r\n    return (transformProps.has(key) ||\r\n        key.startsWith(\"origin\") ||\r\n        ((layout || layoutId !== undefined) &&\r\n            (!!scaleCorrectors[key] || key === \"opacity\")));\r\n}\r\n\r\nexport { isForcedMotionValue };\r\n","import { isForcedMotionValue } from '../../../motion/utils/is-forced-motion-value.mjs';\r\nimport { isMotionValue } from '../../../value/utils/is-motion-value.mjs';\r\n\r\nfunction scrapeMotionValuesFromProps(props, prevProps, visualElement) {\r\n    var _a;\r\n    const { style } = props;\r\n    const newValues = {};\r\n    for (const key in style) {\r\n        if (isMotionValue(style[key]) ||\r\n            (prevProps.style &&\r\n                isMotionValue(prevProps.style[key])) ||\r\n            isForcedMotionValue(key, props) ||\r\n            ((_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.liveStyle) !== undefined) {\r\n            newValues[key] = style[key];\r\n        }\r\n    }\r\n    return newValues;\r\n}\r\n\r\nexport { scrapeMotionValuesFromProps };\r\n","import { isMotionValue } from '../../../value/utils/is-motion-value.mjs';\r\nimport { transformPropOrder } from '../../html/utils/keys-transform.mjs';\r\nimport { scrapeMotionValuesFromProps as scrapeMotionValuesFromProps$1 } from '../../html/utils/scrape-motion-values.mjs';\r\n\r\nfunction scrapeMotionValuesFromProps(props, prevProps, visualElement) {\r\n    const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);\r\n    for (const key in props) {\r\n        if (isMotionValue(props[key]) ||\r\n            isMotionValue(prevProps[key])) {\r\n            const targetKey = transformPropOrder.indexOf(key) !== -1\r\n                ? \"attr\" + key.charAt(0).toUpperCase() + key.substring(1)\r\n                : key;\r\n            newValues[targetKey] = props[key];\r\n        }\r\n    }\r\n    return newValues;\r\n}\r\n\r\nexport { scrapeMotionValuesFromProps };\r\n","import { frame } from '../../frameloop/frame.mjs';\r\nimport { makeUseVisualState } from '../../motion/utils/use-visual-state.mjs';\r\nimport { transformProps } from '../html/utils/keys-transform.mjs';\r\nimport { buildSVGAttrs } from './utils/build-attrs.mjs';\r\nimport { createSvgRenderState } from './utils/create-render-state.mjs';\r\nimport { isSVGTag } from './utils/is-svg-tag.mjs';\r\nimport { renderSVG } from './utils/render.mjs';\r\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\r\n\r\nfunction updateSVGDimensions(instance, renderState) {\r\n    try {\r\n        renderState.dimensions =\r\n            typeof instance.getBBox === \"function\"\r\n                ? instance.getBBox()\r\n                : instance.getBoundingClientRect();\r\n    }\r\n    catch (e) {\r\n        // Most likely trying to measure an unrendered element under Firefox\r\n        renderState.dimensions = {\r\n            x: 0,\r\n            y: 0,\r\n            width: 0,\r\n            height: 0,\r\n        };\r\n    }\r\n}\r\nconst layoutProps = [\"x\", \"y\", \"width\", \"height\", \"cx\", \"cy\", \"r\"];\r\nconst svgMotionConfig = {\r\n    useVisualState: makeUseVisualState({\r\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\r\n        createRenderState: createSvgRenderState,\r\n        onUpdate: ({ props, prevProps, current, renderState, latestValues, }) => {\r\n            if (!current)\r\n                return;\r\n            let hasTransform = !!props.drag;\r\n            if (!hasTransform) {\r\n                for (const key in latestValues) {\r\n                    if (transformProps.has(key)) {\r\n                        hasTransform = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (!hasTransform)\r\n                return;\r\n            let needsMeasure = !prevProps;\r\n            if (prevProps) {\r\n                /**\r\n                 * Check the layout props for changes, if any are found we need to\r\n                 * measure the element again.\r\n                 */\r\n                for (let i = 0; i < layoutProps.length; i++) {\r\n                    const key = layoutProps[i];\r\n                    if (props[key] !==\r\n                        prevProps[key]) {\r\n                        needsMeasure = true;\r\n                    }\r\n                }\r\n            }\r\n            if (!needsMeasure)\r\n                return;\r\n            frame.read(() => {\r\n                updateSVGDimensions(current, renderState);\r\n                frame.render(() => {\r\n                    buildSVGAttrs(renderState, latestValues, isSVGTag(current.tagName), props.transformTemplate);\r\n                    renderSVG(current, renderState);\r\n                });\r\n            });\r\n        },\r\n    }),\r\n};\r\n\r\nexport { svgMotionConfig };\r\n","import { makeUseVisualState } from '../../motion/utils/use-visual-state.mjs';\r\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\r\nimport { createHtmlRenderState } from './utils/create-render-state.mjs';\r\n\r\nconst htmlMotionConfig = {\r\n    useVisualState: makeUseVisualState({\r\n        scrapeMotionValuesFromProps,\r\n        createRenderState: createHtmlRenderState,\r\n    }),\r\n};\r\n\r\nexport { htmlMotionConfig };\r\n","import { useMemo } from 'react';\r\nimport { isForcedMotionValue } from '../../motion/utils/is-forced-motion-value.mjs';\r\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\r\nimport { buildHTMLStyles } from './utils/build-styles.mjs';\r\nimport { createHtmlRenderState } from './utils/create-render-state.mjs';\r\n\r\nfunction copyRawValuesOnly(target, source, props) {\r\n    for (const key in source) {\r\n        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\r\n            target[key] = source[key];\r\n        }\r\n    }\r\n}\r\nfunction useInitialMotionValues({ transformTemplate }, visualState) {\r\n    return useMemo(() => {\r\n        const state = createHtmlRenderState();\r\n        buildHTMLStyles(state, visualState, transformTemplate);\r\n        return Object.assign({}, state.vars, state.style);\r\n    }, [visualState]);\r\n}\r\nfunction useStyle(props, visualState) {\r\n    const styleProp = props.style || {};\r\n    const style = {};\r\n    /**\r\n     * Copy non-Motion Values straight into style\r\n     */\r\n    copyRawValuesOnly(style, styleProp, props);\r\n    Object.assign(style, useInitialMotionValues(props, visualState));\r\n    return style;\r\n}\r\nfunction useHTMLProps(props, visualState) {\r\n    // The `any` isn't ideal but it is the type of createElement props argument\r\n    const htmlProps = {};\r\n    const style = useStyle(props, visualState);\r\n    if (props.drag && props.dragListener !== false) {\r\n        // Disable the ghost element when a user drags\r\n        htmlProps.draggable = false;\r\n        // Disable text selection\r\n        style.userSelect =\r\n            style.WebkitUserSelect =\r\n                style.WebkitTouchCallout =\r\n                    \"none\";\r\n        // Disable scrolling on the draggable direction\r\n        style.touchAction =\r\n            props.drag === true\r\n                ? \"none\"\r\n                : `pan-${props.drag === \"x\" ? \"y\" : \"x\"}`;\r\n    }\r\n    if (props.tabIndex === undefined &&\r\n        (props.onTap || props.onTapStart || props.whileTap)) {\r\n        htmlProps.tabIndex = 0;\r\n    }\r\n    htmlProps.style = style;\r\n    return htmlProps;\r\n}\r\n\r\nexport { copyRawValuesOnly, useHTMLProps };\r\n","import { useMemo } from 'react';\r\nimport { copyRawValuesOnly } from '../html/use-props.mjs';\r\nimport { buildSVGAttrs } from './utils/build-attrs.mjs';\r\nimport { createSvgRenderState } from './utils/create-render-state.mjs';\r\nimport { isSVGTag } from './utils/is-svg-tag.mjs';\r\n\r\nfunction useSVGProps(props, visualState, _isStatic, Component) {\r\n    const visualProps = useMemo(() => {\r\n        const state = createSvgRenderState();\r\n        buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate);\r\n        return {\r\n            ...state.attrs,\r\n            style: { ...state.style },\r\n        };\r\n    }, [visualState]);\r\n    if (props.style) {\r\n        const rawStyles = {};\r\n        copyRawValuesOnly(rawStyles, props.style, props);\r\n        visualProps.style = { ...rawStyles, ...visualProps.style };\r\n    }\r\n    return visualProps;\r\n}\r\n\r\nexport { useSVGProps };\r\n","import { Fragment, useMemo, createElement } from 'react';\r\nimport { useHTMLProps } from '../html/use-props.mjs';\r\nimport { filterProps } from './utils/filter-props.mjs';\r\nimport { isSVGComponent } from './utils/is-svg-component.mjs';\r\nimport { useSVGProps } from '../svg/use-props.mjs';\r\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\r\n\r\nfunction createUseRender(forwardMotionProps = false) {\r\n    const useRender = (Component, props, ref, { latestValues }, isStatic) => {\r\n        const useVisualProps = isSVGComponent(Component)\r\n            ? useSVGProps\r\n            : useHTMLProps;\r\n        const visualProps = useVisualProps(props, latestValues, isStatic, Component);\r\n        const filteredProps = filterProps(props, typeof Component === \"string\", forwardMotionProps);\r\n        const elementProps = Component !== Fragment\r\n            ? { ...filteredProps, ...visualProps, ref }\r\n            : {};\r\n        /**\r\n         * If component has been handed a motion value as its child,\r\n         * memoise its initial value and render that. Subsequent updates\r\n         * will be handled by the onChange handler\r\n         */\r\n        const { children } = props;\r\n        const renderedChildren = useMemo(() => (isMotionValue(children) ? children.get() : children), [children]);\r\n        return createElement(Component, {\r\n            ...elementProps,\r\n            children: renderedChildren,\r\n        });\r\n    };\r\n    return useRender;\r\n}\r\n\r\nexport { createUseRender };\r\n","import { createRendererMotionComponent } from '../../motion/index.mjs';\r\nimport { isSVGComponent } from '../dom/utils/is-svg-component.mjs';\r\nimport { svgMotionConfig } from '../svg/config-motion.mjs';\r\nimport { htmlMotionConfig } from '../html/config-motion.mjs';\r\nimport { createUseRender } from '../dom/use-render.mjs';\r\n\r\nfunction createMotionComponentFactory(preloadedFeatures, createVisualElement) {\r\n    return function createMotionComponent(Component, { forwardMotionProps } = { forwardMotionProps: false }) {\r\n        const baseConfig = isSVGComponent(Component)\r\n            ? svgMotionConfig\r\n            : htmlMotionConfig;\r\n        const config = {\r\n            ...baseConfig,\r\n            preloadedFeatures,\r\n            useRender: createUseRender(forwardMotionProps),\r\n            createVisualElement,\r\n            Component,\r\n        };\r\n        return createRendererMotionComponent(config);\r\n    };\r\n}\r\n\r\nexport { createMotionComponentFactory };\r\n","function shallowCompare(next, prev) {\r\n    if (!Array.isArray(prev))\r\n        return false;\r\n    const prevLength = prev.length;\r\n    if (prevLength !== next.length)\r\n        return false;\r\n    for (let i = 0; i < prevLength; i++) {\r\n        if (prev[i] !== next[i])\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nexport { shallowCompare };\r\n","import { resolveVariantFromProps } from './resolve-variants.mjs';\r\n\r\nfunction resolveVariant(visualElement, definition, custom) {\r\n    const props = visualElement.getProps();\r\n    return resolveVariantFromProps(props, definition, custom !== undefined ? custom : props.custom, visualElement);\r\n}\r\n\r\nexport { resolveVariant };\r\n","import { memo } from 'motion-utils';\r\n\r\nconst supportsScrollTimeline = memo(() => window.ScrollTimeline !== undefined);\r\n\r\nexport { supportsScrollTimeline };\r\n","import { supportsScrollTimeline } from '../../utils/supports/scroll-timeline.mjs';\r\n\r\nclass BaseGroupPlaybackControls {\r\n    constructor(animations) {\r\n        // Bound to accomodate common `return animation.stop` pattern\r\n        this.stop = () => this.runAll(\"stop\");\r\n        this.animations = animations.filter(Boolean);\r\n    }\r\n    get finished() {\r\n        // Support for new finished Promise and legacy thennable API\r\n        return Promise.all(this.animations.map((animation) => \"finished\" in animation ? animation.finished : animation));\r\n    }\r\n    /**\r\n     * TODO: Filter out cancelled or stopped animations before returning\r\n     */\r\n    getAll(propName) {\r\n        return this.animations[0][propName];\r\n    }\r\n    setAll(propName, newValue) {\r\n        for (let i = 0; i < this.animations.length; i++) {\r\n            this.animations[i][propName] = newValue;\r\n        }\r\n    }\r\n    attachTimeline(timeline, fallback) {\r\n        const subscriptions = this.animations.map((animation) => {\r\n            if (supportsScrollTimeline() && animation.attachTimeline) {\r\n                return animation.attachTimeline(timeline);\r\n            }\r\n            else if (typeof fallback === \"function\") {\r\n                return fallback(animation);\r\n            }\r\n        });\r\n        return () => {\r\n            subscriptions.forEach((cancel, i) => {\r\n                cancel && cancel();\r\n                this.animations[i].stop();\r\n            });\r\n        };\r\n    }\r\n    get time() {\r\n        return this.getAll(\"time\");\r\n    }\r\n    set time(time) {\r\n        this.setAll(\"time\", time);\r\n    }\r\n    get speed() {\r\n        return this.getAll(\"speed\");\r\n    }\r\n    set speed(speed) {\r\n        this.setAll(\"speed\", speed);\r\n    }\r\n    get startTime() {\r\n        return this.getAll(\"startTime\");\r\n    }\r\n    get duration() {\r\n        let max = 0;\r\n        for (let i = 0; i < this.animations.length; i++) {\r\n            max = Math.max(max, this.animations[i].duration);\r\n        }\r\n        return max;\r\n    }\r\n    runAll(methodName) {\r\n        this.animations.forEach((controls) => controls[methodName]());\r\n    }\r\n    flatten() {\r\n        this.runAll(\"flatten\");\r\n    }\r\n    play() {\r\n        this.runAll(\"play\");\r\n    }\r\n    pause() {\r\n        this.runAll(\"pause\");\r\n    }\r\n    cancel() {\r\n        this.runAll(\"cancel\");\r\n    }\r\n    complete() {\r\n        this.runAll(\"complete\");\r\n    }\r\n}\r\n\r\nexport { BaseGroupPlaybackControls };\r\n","import { BaseGroupPlaybackControls } from './BaseGroup.mjs';\r\n\r\n/**\r\n * TODO: This is a temporary class to support the legacy\r\n * thennable API\r\n */\r\nclass GroupPlaybackControls extends BaseGroupPlaybackControls {\r\n    then(onResolve, onReject) {\r\n        return Promise.all(this.animations).then(onResolve).catch(onReject);\r\n    }\r\n}\r\n\r\nexport { GroupPlaybackControls };\r\n","function getValueTransition(transition, key) {\r\n    return transition\r\n        ? transition[key] ||\r\n            transition[\"default\"] ||\r\n            transition\r\n        : undefined;\r\n}\r\n\r\nexport { getValueTransition };\r\n","/**\r\n * Implement a practical max duration for keyframe generation\r\n * to prevent infinite loops\r\n */\r\nconst maxGeneratorDuration = 20000;\r\nfunction calcGeneratorDuration(generator) {\r\n    let duration = 0;\r\n    const timeStep = 50;\r\n    let state = generator.next(duration);\r\n    while (!state.done && duration < maxGeneratorDuration) {\r\n        duration += timeStep;\r\n        state = generator.next(duration);\r\n    }\r\n    return duration >= maxGeneratorDuration ? Infinity : duration;\r\n}\r\n\r\nexport { calcGeneratorDuration, maxGeneratorDuration };\r\n","function isGenerator(type) {\r\n    return typeof type === \"function\";\r\n}\r\n\r\nexport { isGenerator };\r\n","function attachTimeline(animation, timeline) {\r\n    animation.timeline = timeline;\r\n    animation.onfinish = null;\r\n}\r\n\r\nexport { attachTimeline };\r\n","const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === \"number\";\r\n\r\nexport { isBezierDefinition };\r\n","/**\r\n * Add the ability for test suites to manually set support flags\r\n * to better test more environments.\r\n */\r\nconst supportsFlags = {\r\n    linearEasing: undefined,\r\n};\r\n\r\nexport { supportsFlags };\r\n","import { memo } from 'motion-utils';\r\nimport { supportsFlags } from './flags.mjs';\r\n\r\nfunction memoSupports(callback, supportsFlag) {\r\n    const memoized = memo(callback);\r\n    return () => { var _a; return (_a = supportsFlags[supportsFlag]) !== null && _a !== void 0 ? _a : memoized(); };\r\n}\r\n\r\nexport { memoSupports };\r\n","import { memoSupports } from './memo.mjs';\r\n\r\nconst supportsLinearEasing = /*@__PURE__*/ memoSupports(() => {\r\n    try {\r\n        document\r\n            .createElement(\"div\")\r\n            .animate({ opacity: 0 }, { easing: \"linear(0, 1)\" });\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n    return true;\r\n}, \"linearEasing\");\r\n\r\nexport { supportsLinearEasing };\r\n","import { progress } from 'motion-utils';\r\n\r\nconst generateLinearEasing = (easing, duration, // as milliseconds\r\nresolution = 10 // as milliseconds\r\n) => {\r\n    let points = \"\";\r\n    const numPoints = Math.max(Math.round(duration / resolution), 2);\r\n    for (let i = 0; i < numPoints; i++) {\r\n        points += easing(progress(0, numPoints - 1, i)) + \", \";\r\n    }\r\n    return `linear(${points.substring(0, points.length - 2)})`;\r\n};\r\n\r\nexport { generateLinearEasing };\r\n","import { isBezierDefinition } from '../../../utils/is-bezier-definition.mjs';\r\nimport { supportsLinearEasing } from '../../../utils/supports/linear-easing.mjs';\r\nimport { generateLinearEasing } from './linear.mjs';\r\n\r\nfunction isWaapiSupportedEasing(easing) {\r\n    return Boolean((typeof easing === \"function\" && supportsLinearEasing()) ||\r\n        !easing ||\r\n        (typeof easing === \"string\" &&\r\n            (easing in supportedWaapiEasing || supportsLinearEasing())) ||\r\n        isBezierDefinition(easing) ||\r\n        (Array.isArray(easing) && easing.every(isWaapiSupportedEasing)));\r\n}\r\nconst cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\r\nconst supportedWaapiEasing = {\r\n    linear: \"linear\",\r\n    ease: \"ease\",\r\n    easeIn: \"ease-in\",\r\n    easeOut: \"ease-out\",\r\n    easeInOut: \"ease-in-out\",\r\n    circIn: /*@__PURE__*/ cubicBezierAsString([0, 0.65, 0.55, 1]),\r\n    circOut: /*@__PURE__*/ cubicBezierAsString([0.55, 0, 1, 0.45]),\r\n    backIn: /*@__PURE__*/ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),\r\n    backOut: /*@__PURE__*/ cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),\r\n};\r\nfunction mapEasingToNativeEasing(easing, duration) {\r\n    if (!easing) {\r\n        return undefined;\r\n    }\r\n    else if (typeof easing === \"function\" && supportsLinearEasing()) {\r\n        return generateLinearEasing(easing, duration);\r\n    }\r\n    else if (isBezierDefinition(easing)) {\r\n        return cubicBezierAsString(easing);\r\n    }\r\n    else if (Array.isArray(easing)) {\r\n        return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) ||\r\n            supportedWaapiEasing.easeOut);\r\n    }\r\n    else {\r\n        return supportedWaapiEasing[easing];\r\n    }\r\n}\r\n\r\nexport { cubicBezierAsString, isWaapiSupportedEasing, mapEasingToNativeEasing, supportedWaapiEasing };\r\n","const isDragging = {\r\n    x: false,\r\n    y: false,\r\n};\r\nfunction isDragActive() {\r\n    return isDragging.x || isDragging.y;\r\n}\r\n\r\nexport { isDragActive, isDragging };\r\n","import { resolveElements } from '../../utils/resolve-elements.mjs';\r\n\r\nfunction setupGesture(elementOrSelector, options) {\r\n    const elements = resolveElements(elementOrSelector);\r\n    const gestureAbortController = new AbortController();\r\n    const eventOptions = {\r\n        passive: true,\r\n        ...options,\r\n        signal: gestureAbortController.signal,\r\n    };\r\n    const cancel = () => gestureAbortController.abort();\r\n    return [elements, eventOptions, cancel];\r\n}\r\n\r\nexport { setupGesture };\r\n","function resolveElements(elementOrSelector, scope, selectorCache) {\r\n    var _a;\r\n    if (elementOrSelector instanceof Element) {\r\n        return [elementOrSelector];\r\n    }\r\n    else if (typeof elementOrSelector === \"string\") {\r\n        let root = document;\r\n        if (scope) {\r\n            // TODO: Refactor to utils package\r\n            // invariant(\r\n            //     Boolean(scope.current),\r\n            //     \"Scope provided, but no element detected.\"\r\n            // )\r\n            root = scope.current;\r\n        }\r\n        const elements = (_a = selectorCache === null || selectorCache === void 0 ? void 0 : selectorCache[elementOrSelector]) !== null && _a !== void 0 ? _a : root.querySelectorAll(elementOrSelector);\r\n        return elements ? Array.from(elements) : [];\r\n    }\r\n    return Array.from(elementOrSelector);\r\n}\r\n\r\nexport { resolveElements };\r\n","import { isDragActive } from './drag/state/is-active.mjs';\r\nimport { setupGesture } from './utils/setup.mjs';\r\n\r\n/**\r\n * Filter out events that are not pointer events, or are triggering\r\n * while a Motion gesture is active.\r\n */\r\nfunction filterEvents(callback) {\r\n    return (event) => {\r\n        if (event.pointerType === \"touch\" || isDragActive())\r\n            return;\r\n        callback(event);\r\n    };\r\n}\r\n/**\r\n * Create a hover gesture. hover() is different to .addEventListener(\"pointerenter\")\r\n * in that it has an easier syntax, filters out polyfilled touch events, interoperates\r\n * with drag gestures, and automatically removes the \"pointerennd\" event listener when the hover ends.\r\n *\r\n * @public\r\n */\r\nfunction hover(elementOrSelector, onHoverStart, options = {}) {\r\n    const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);\r\n    const onPointerEnter = filterEvents((enterEvent) => {\r\n        const { target } = enterEvent;\r\n        const onHoverEnd = onHoverStart(enterEvent);\r\n        if (typeof onHoverEnd !== \"function\" || !target)\r\n            return;\r\n        const onPointerLeave = filterEvents((leaveEvent) => {\r\n            onHoverEnd(leaveEvent);\r\n            target.removeEventListener(\"pointerleave\", onPointerLeave);\r\n        });\r\n        target.addEventListener(\"pointerleave\", onPointerLeave, eventOptions);\r\n    });\r\n    elements.forEach((element) => {\r\n        element.addEventListener(\"pointerenter\", onPointerEnter, eventOptions);\r\n    });\r\n    return cancel;\r\n}\r\n\r\nexport { hover };\r\n","/**\r\n * Recursively traverse up the tree to check whether the provided child node\r\n * is the parent or a descendant of it.\r\n *\r\n * @param parent - Element to find\r\n * @param child - Element to test against parent\r\n */\r\nconst isNodeOrChild = (parent, child) => {\r\n    if (!child) {\r\n        return false;\r\n    }\r\n    else if (parent === child) {\r\n        return true;\r\n    }\r\n    else {\r\n        return isNodeOrChild(parent, child.parentElement);\r\n    }\r\n};\r\n\r\nexport { isNodeOrChild };\r\n","const isPrimaryPointer = (event) => {\r\n    if (event.pointerType === \"mouse\") {\r\n        return typeof event.button !== \"number\" || event.button <= 0;\r\n    }\r\n    else {\r\n        /**\r\n         * isPrimary is true for all mice buttons, whereas every touch point\r\n         * is regarded as its own input. So subsequent concurrent touch points\r\n         * will be false.\r\n         *\r\n         * Specifically match against false here as incomplete versions of\r\n         * PointerEvents in very old browser might have it set as undefined.\r\n         */\r\n        return event.isPrimary !== false;\r\n    }\r\n};\r\n\r\nexport { isPrimaryPointer };\r\n","const focusableElements = new Set([\r\n    \"BUTTON\",\r\n    \"INPUT\",\r\n    \"SELECT\",\r\n    \"TEXTAREA\",\r\n    \"A\",\r\n]);\r\nfunction isElementKeyboardAccessible(element) {\r\n    return (focusableElements.has(element.tagName) ||\r\n        element.tabIndex !== -1);\r\n}\r\n\r\nexport { isElementKeyboardAccessible };\r\n","const isPressing = new WeakSet();\r\n\r\nexport { isPressing };\r\n","import { isPressing } from './state.mjs';\r\n\r\n/**\r\n * Filter out events that are not \"Enter\" keys.\r\n */\r\nfunction filterEvents(callback) {\r\n    return (event) => {\r\n        if (event.key !== \"Enter\")\r\n            return;\r\n        callback(event);\r\n    };\r\n}\r\nfunction firePointerEvent(target, type) {\r\n    target.dispatchEvent(new PointerEvent(\"pointer\" + type, { isPrimary: true, bubbles: true }));\r\n}\r\nconst enableKeyboardPress = (focusEvent, eventOptions) => {\r\n    const element = focusEvent.currentTarget;\r\n    if (!element)\r\n        return;\r\n    const handleKeydown = filterEvents(() => {\r\n        if (isPressing.has(element))\r\n            return;\r\n        firePointerEvent(element, \"down\");\r\n        const handleKeyup = filterEvents(() => {\r\n            firePointerEvent(element, \"up\");\r\n        });\r\n        const handleBlur = () => firePointerEvent(element, \"cancel\");\r\n        element.addEventListener(\"keyup\", handleKeyup, eventOptions);\r\n        element.addEventListener(\"blur\", handleBlur, eventOptions);\r\n    });\r\n    element.addEventListener(\"keydown\", handleKeydown, eventOptions);\r\n    /**\r\n     * Add an event listener that fires on blur to remove the keydown events.\r\n     */\r\n    element.addEventListener(\"blur\", () => element.removeEventListener(\"keydown\", handleKeydown), eventOptions);\r\n};\r\n\r\nexport { enableKeyboardPress };\r\n","import { isDragActive } from '../drag/state/is-active.mjs';\r\nimport { isNodeOrChild } from '../utils/is-node-or-child.mjs';\r\nimport { isPrimaryPointer } from '../utils/is-primary-pointer.mjs';\r\nimport { setupGesture } from '../utils/setup.mjs';\r\nimport { isElementKeyboardAccessible } from './utils/is-keyboard-accessible.mjs';\r\nimport { enableKeyboardPress } from './utils/keyboard.mjs';\r\nimport { isPressing } from './utils/state.mjs';\r\n\r\n/**\r\n * Filter out events that are not primary pointer events, or are triggering\r\n * while a Motion gesture is active.\r\n */\r\nfunction isValidPressEvent(event) {\r\n    return isPrimaryPointer(event) && !isDragActive();\r\n}\r\n/**\r\n * Create a press gesture.\r\n *\r\n * Press is different to `\"pointerdown\"`, `\"pointerup\"` in that it\r\n * automatically filters out secondary pointer events like right\r\n * click and multitouch.\r\n *\r\n * It also adds accessibility support for keyboards, where\r\n * an element with a press gesture will receive focus and\r\n *  trigger on Enter `\"keydown\"` and `\"keyup\"` events.\r\n *\r\n * This is different to a browser's `\"click\"` event, which does\r\n * respond to keyboards but only for the `\"click\"` itself, rather\r\n * than the press start and end/cancel. The element also needs\r\n * to be focusable for this to work, whereas a press gesture will\r\n * make an element focusable by default.\r\n *\r\n * @public\r\n */\r\nfunction press(elementOrSelector, onPressStart, options = {}) {\r\n    const [elements, eventOptions, cancelEvents] = setupGesture(elementOrSelector, options);\r\n    const startPress = (startEvent) => {\r\n        const element = startEvent.currentTarget;\r\n        if (!isValidPressEvent(startEvent) || isPressing.has(element))\r\n            return;\r\n        isPressing.add(element);\r\n        const onPressEnd = onPressStart(startEvent);\r\n        const onPointerEnd = (endEvent, success) => {\r\n            window.removeEventListener(\"pointerup\", onPointerUp);\r\n            window.removeEventListener(\"pointercancel\", onPointerCancel);\r\n            if (!isValidPressEvent(endEvent) || !isPressing.has(element)) {\r\n                return;\r\n            }\r\n            isPressing.delete(element);\r\n            if (typeof onPressEnd === \"function\") {\r\n                onPressEnd(endEvent, { success });\r\n            }\r\n        };\r\n        const onPointerUp = (upEvent) => {\r\n            onPointerEnd(upEvent, options.useGlobalTarget ||\r\n                isNodeOrChild(element, upEvent.target));\r\n        };\r\n        const onPointerCancel = (cancelEvent) => {\r\n            onPointerEnd(cancelEvent, false);\r\n        };\r\n        window.addEventListener(\"pointerup\", onPointerUp, eventOptions);\r\n        window.addEventListener(\"pointercancel\", onPointerCancel, eventOptions);\r\n    };\r\n    elements.forEach((element) => {\r\n        if (!isElementKeyboardAccessible(element) &&\r\n            element.getAttribute(\"tabindex\") === null) {\r\n            element.tabIndex = 0;\r\n        }\r\n        const target = options.useGlobalTarget ? window : element;\r\n        target.addEventListener(\"pointerdown\", startPress, eventOptions);\r\n        element.addEventListener(\"focus\", (event) => enableKeyboardPress(event, eventOptions), eventOptions);\r\n    });\r\n    return cancelEvents;\r\n}\r\n\r\nexport { press };\r\n","import { transformPropOrder } from './keys-transform.mjs';\r\n\r\nconst positionalKeys = new Set([\r\n    \"width\",\r\n    \"height\",\r\n    \"top\",\r\n    \"left\",\r\n    \"right\",\r\n    \"bottom\",\r\n    ...transformPropOrder,\r\n]);\r\n\r\nexport { positionalKeys };\r\n","import { MotionGlobalConfig } from '../utils/GlobalConfig.mjs';\r\nimport { frameData } from './frame.mjs';\r\n\r\nlet now;\r\nfunction clearTime() {\r\n    now = undefined;\r\n}\r\n/**\r\n * An eventloop-synchronous alternative to performance.now().\r\n *\r\n * Ensures that time measurements remain consistent within a synchronous context.\r\n * Usually calling performance.now() twice within the same synchronous context\r\n * will return different values which isn't useful for animations when we're usually\r\n * trying to sync animations to the same frame.\r\n */\r\nconst time = {\r\n    now: () => {\r\n        if (now === undefined) {\r\n            time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming\r\n                ? frameData.timestamp\r\n                : performance.now());\r\n        }\r\n        return now;\r\n    },\r\n    set: (newTime) => {\r\n        now = newTime;\r\n        queueMicrotask(clearTime);\r\n    },\r\n};\r\n\r\nexport { time };\r\n","function addUniqueItem(arr, item) {\r\n    if (arr.indexOf(item) === -1)\r\n        arr.push(item);\r\n}\r\nfunction removeItem(arr, item) {\r\n    const index = arr.indexOf(item);\r\n    if (index > -1)\r\n        arr.splice(index, 1);\r\n}\r\n// Adapted from array-move\r\nfunction moveItem([...arr], fromIndex, toIndex) {\r\n    const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\r\n    if (startIndex >= 0 && startIndex < arr.length) {\r\n        const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\r\n        const [item] = arr.splice(fromIndex, 1);\r\n        arr.splice(endIndex, 0, item);\r\n    }\r\n    return arr;\r\n}\r\n\r\nexport { addUniqueItem, moveItem, removeItem };\r\n","import { addUniqueItem, removeItem } from './array.mjs';\r\n\r\nclass SubscriptionManager {\r\n    constructor() {\r\n        this.subscriptions = [];\r\n    }\r\n    add(handler) {\r\n        addUniqueItem(this.subscriptions, handler);\r\n        return () => removeItem(this.subscriptions, handler);\r\n    }\r\n    notify(a, b, c) {\r\n        const numSubscriptions = this.subscriptions.length;\r\n        if (!numSubscriptions)\r\n            return;\r\n        if (numSubscriptions === 1) {\r\n            /**\r\n             * If there's only a single handler we can just call it without invoking a loop.\r\n             */\r\n            this.subscriptions[0](a, b, c);\r\n        }\r\n        else {\r\n            for (let i = 0; i < numSubscriptions; i++) {\r\n                /**\r\n                 * Check whether the handler exists before firing as it's possible\r\n                 * the subscriptions were modified during this loop running.\r\n                 */\r\n                const handler = this.subscriptions[i];\r\n                handler && handler(a, b, c);\r\n            }\r\n        }\r\n    }\r\n    getSize() {\r\n        return this.subscriptions.length;\r\n    }\r\n    clear() {\r\n        this.subscriptions.length = 0;\r\n    }\r\n}\r\n\r\nexport { SubscriptionManager };\r\n","/*\r\n  Convert velocity into velocity per second\r\n\r\n  @param [number]: Unit per frame\r\n  @param [number]: Frame duration in ms\r\n*/\r\nfunction velocityPerSecond(velocity, frameDuration) {\r\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\r\n}\r\n\r\nexport { velocityPerSecond };\r\n","import { time } from '../frameloop/sync-time.mjs';\r\nimport { SubscriptionManager } from '../utils/subscription-manager.mjs';\r\nimport { velocityPerSecond } from '../utils/velocity-per-second.mjs';\r\nimport { warnOnce } from '../utils/warn-once.mjs';\r\nimport { frame } from '../frameloop/frame.mjs';\r\n\r\n/**\r\n * Maximum time between the value of two frames, beyond which we\r\n * assume the velocity has since been 0.\r\n */\r\nconst MAX_VELOCITY_DELTA = 30;\r\nconst isFloat = (value) => {\r\n    return !isNaN(parseFloat(value));\r\n};\r\nconst collectMotionValues = {\r\n    current: undefined,\r\n};\r\n/**\r\n * `MotionValue` is used to track the state and velocity of motion values.\r\n *\r\n * @public\r\n */\r\nclass MotionValue {\r\n    /**\r\n     * @param init - The initiating value\r\n     * @param config - Optional configuration options\r\n     *\r\n     * -  `transformer`: A function to transform incoming values with.\r\n     *\r\n     * @internal\r\n     */\r\n    constructor(init, options = {}) {\r\n        /**\r\n         * This will be replaced by the build step with the latest version number.\r\n         * When MotionValues are provided to motion components, warn if versions are mixed.\r\n         */\r\n        this.version = \"11.18.2\";\r\n        /**\r\n         * Tracks whether this value can output a velocity. Currently this is only true\r\n         * if the value is numerical, but we might be able to widen the scope here and support\r\n         * other value types.\r\n         *\r\n         * @internal\r\n         */\r\n        this.canTrackVelocity = null;\r\n        /**\r\n         * An object containing a SubscriptionManager for each active event.\r\n         */\r\n        this.events = {};\r\n        this.updateAndNotify = (v, render = true) => {\r\n            const currentTime = time.now();\r\n            /**\r\n             * If we're updating the value during another frame or eventloop\r\n             * than the previous frame, then the we set the previous frame value\r\n             * to current.\r\n             */\r\n            if (this.updatedAt !== currentTime) {\r\n                this.setPrevFrameValue();\r\n            }\r\n            this.prev = this.current;\r\n            this.setCurrent(v);\r\n            // Update update subscribers\r\n            if (this.current !== this.prev && this.events.change) {\r\n                this.events.change.notify(this.current);\r\n            }\r\n            // Update render subscribers\r\n            if (render && this.events.renderRequest) {\r\n                this.events.renderRequest.notify(this.current);\r\n            }\r\n        };\r\n        this.hasAnimated = false;\r\n        this.setCurrent(init);\r\n        this.owner = options.owner;\r\n    }\r\n    setCurrent(current) {\r\n        this.current = current;\r\n        this.updatedAt = time.now();\r\n        if (this.canTrackVelocity === null && current !== undefined) {\r\n            this.canTrackVelocity = isFloat(this.current);\r\n        }\r\n    }\r\n    setPrevFrameValue(prevFrameValue = this.current) {\r\n        this.prevFrameValue = prevFrameValue;\r\n        this.prevUpdatedAt = this.updatedAt;\r\n    }\r\n    /**\r\n     * Adds a function that will be notified when the `MotionValue` is updated.\r\n     *\r\n     * It returns a function that, when called, will cancel the subscription.\r\n     *\r\n     * When calling `onChange` inside a React component, it should be wrapped with the\r\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\r\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\r\n     *\r\n     * ```jsx\r\n     * export const MyComponent = () => {\r\n     *   const x = useMotionValue(0)\r\n     *   const y = useMotionValue(0)\r\n     *   const opacity = useMotionValue(1)\r\n     *\r\n     *   useEffect(() => {\r\n     *     function updateOpacity() {\r\n     *       const maxXY = Math.max(x.get(), y.get())\r\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\r\n     *       opacity.set(newOpacity)\r\n     *     }\r\n     *\r\n     *     const unsubscribeX = x.on(\"change\", updateOpacity)\r\n     *     const unsubscribeY = y.on(\"change\", updateOpacity)\r\n     *\r\n     *     return () => {\r\n     *       unsubscribeX()\r\n     *       unsubscribeY()\r\n     *     }\r\n     *   }, [])\r\n     *\r\n     *   return <motion.div style={{ x }} />\r\n     * }\r\n     * ```\r\n     *\r\n     * @param subscriber - A function that receives the latest value.\r\n     * @returns A function that, when called, will cancel this subscription.\r\n     *\r\n     * @deprecated\r\n     */\r\n    onChange(subscription) {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on(\"change\", callback).`);\r\n        }\r\n        return this.on(\"change\", subscription);\r\n    }\r\n    on(eventName, callback) {\r\n        if (!this.events[eventName]) {\r\n            this.events[eventName] = new SubscriptionManager();\r\n        }\r\n        const unsubscribe = this.events[eventName].add(callback);\r\n        if (eventName === \"change\") {\r\n            return () => {\r\n                unsubscribe();\r\n                /**\r\n                 * If we have no more change listeners by the start\r\n                 * of the next frame, stop active animations.\r\n                 */\r\n                frame.read(() => {\r\n                    if (!this.events.change.getSize()) {\r\n                        this.stop();\r\n                    }\r\n                });\r\n            };\r\n        }\r\n        return unsubscribe;\r\n    }\r\n    clearListeners() {\r\n        for (const eventManagers in this.events) {\r\n            this.events[eventManagers].clear();\r\n        }\r\n    }\r\n    /**\r\n     * Attaches a passive effect to the `MotionValue`.\r\n     *\r\n     * @internal\r\n     */\r\n    attach(passiveEffect, stopPassiveEffect) {\r\n        this.passiveEffect = passiveEffect;\r\n        this.stopPassiveEffect = stopPassiveEffect;\r\n    }\r\n    /**\r\n     * Sets the state of the `MotionValue`.\r\n     *\r\n     * @remarks\r\n     *\r\n     * ```jsx\r\n     * const x = useMotionValue(0)\r\n     * x.set(10)\r\n     * ```\r\n     *\r\n     * @param latest - Latest value to set.\r\n     * @param render - Whether to notify render subscribers. Defaults to `true`\r\n     *\r\n     * @public\r\n     */\r\n    set(v, render = true) {\r\n        if (!render || !this.passiveEffect) {\r\n            this.updateAndNotify(v, render);\r\n        }\r\n        else {\r\n            this.passiveEffect(v, this.updateAndNotify);\r\n        }\r\n    }\r\n    setWithVelocity(prev, current, delta) {\r\n        this.set(current);\r\n        this.prev = undefined;\r\n        this.prevFrameValue = prev;\r\n        this.prevUpdatedAt = this.updatedAt - delta;\r\n    }\r\n    /**\r\n     * Set the state of the `MotionValue`, stopping any active animations,\r\n     * effects, and resets velocity to `0`.\r\n     */\r\n    jump(v, endAnimation = true) {\r\n        this.updateAndNotify(v);\r\n        this.prev = v;\r\n        this.prevUpdatedAt = this.prevFrameValue = undefined;\r\n        endAnimation && this.stop();\r\n        if (this.stopPassiveEffect)\r\n            this.stopPassiveEffect();\r\n    }\r\n    /**\r\n     * Returns the latest state of `MotionValue`\r\n     *\r\n     * @returns - The latest state of `MotionValue`\r\n     *\r\n     * @public\r\n     */\r\n    get() {\r\n        if (collectMotionValues.current) {\r\n            collectMotionValues.current.push(this);\r\n        }\r\n        return this.current;\r\n    }\r\n    /**\r\n     * @public\r\n     */\r\n    getPrevious() {\r\n        return this.prev;\r\n    }\r\n    /**\r\n     * Returns the latest velocity of `MotionValue`\r\n     *\r\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\r\n     *\r\n     * @public\r\n     */\r\n    getVelocity() {\r\n        const currentTime = time.now();\r\n        if (!this.canTrackVelocity ||\r\n            this.prevFrameValue === undefined ||\r\n            currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {\r\n            return 0;\r\n        }\r\n        const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);\r\n        // Casts because of parseFloat's poor typing\r\n        return velocityPerSecond(parseFloat(this.current) -\r\n            parseFloat(this.prevFrameValue), delta);\r\n    }\r\n    /**\r\n     * Registers a new animation to control this `MotionValue`. Only one\r\n     * animation can drive a `MotionValue` at one time.\r\n     *\r\n     * ```jsx\r\n     * value.start()\r\n     * ```\r\n     *\r\n     * @param animation - A function that starts the provided animation\r\n     *\r\n     * @internal\r\n     */\r\n    start(startAnimation) {\r\n        this.stop();\r\n        return new Promise((resolve) => {\r\n            this.hasAnimated = true;\r\n            this.animation = startAnimation(resolve);\r\n            if (this.events.animationStart) {\r\n                this.events.animationStart.notify();\r\n            }\r\n        }).then(() => {\r\n            if (this.events.animationComplete) {\r\n                this.events.animationComplete.notify();\r\n            }\r\n            this.clearAnimation();\r\n        });\r\n    }\r\n    /**\r\n     * Stop the currently active animation.\r\n     *\r\n     * @public\r\n     */\r\n    stop() {\r\n        if (this.animation) {\r\n            this.animation.stop();\r\n            if (this.events.animationCancel) {\r\n                this.events.animationCancel.notify();\r\n            }\r\n        }\r\n        this.clearAnimation();\r\n    }\r\n    /**\r\n     * Returns `true` if this value is currently animating.\r\n     *\r\n     * @public\r\n     */\r\n    isAnimating() {\r\n        return !!this.animation;\r\n    }\r\n    clearAnimation() {\r\n        delete this.animation;\r\n    }\r\n    /**\r\n     * Destroy and clean up subscribers to this `MotionValue`.\r\n     *\r\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\r\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\r\n     * created a `MotionValue` via the `motionValue` function.\r\n     *\r\n     * @public\r\n     */\r\n    destroy() {\r\n        this.clearListeners();\r\n        this.stop();\r\n        if (this.stopPassiveEffect) {\r\n            this.stopPassiveEffect();\r\n        }\r\n    }\r\n}\r\nfunction motionValue(init, options) {\r\n    return new MotionValue(init, options);\r\n}\r\n\r\nexport { MotionValue, collectMotionValues, motionValue };\r\n","import { resolveFinalValueInKeyframes } from '../../utils/resolve-value.mjs';\r\nimport { motionValue } from '../../value/index.mjs';\r\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\r\n\r\n/**\r\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\r\n * it doesn't exist.\r\n */\r\nfunction setMotionValue(visualElement, key, value) {\r\n    if (visualElement.hasValue(key)) {\r\n        visualElement.getValue(key).set(value);\r\n    }\r\n    else {\r\n        visualElement.addValue(key, motionValue(value));\r\n    }\r\n}\r\nfunction setTarget(visualElement, definition) {\r\n    const resolved = resolveVariant(visualElement, definition);\r\n    let { transitionEnd = {}, transition = {}, ...target } = resolved || {};\r\n    target = { ...target, ...transitionEnd };\r\n    for (const key in target) {\r\n        const value = resolveFinalValueInKeyframes(target[key]);\r\n        setMotionValue(visualElement, key, value);\r\n    }\r\n}\r\n\r\nexport { setTarget };\r\n","import { isWillChangeMotionValue } from './is.mjs';\r\n\r\nfunction addValueToWillChange(visualElement, key) {\r\n    const willChange = visualElement.getValue(\"willChange\");\r\n    /**\r\n     * It could be that a user has set willChange to a regular MotionValue,\r\n     * in which case we can't add the value to it.\r\n     */\r\n    if (isWillChangeMotionValue(willChange)) {\r\n        return willChange.add(key);\r\n    }\r\n}\r\n\r\nexport { addValueToWillChange };\r\n","import { isMotionValue } from '../utils/is-motion-value.mjs';\r\n\r\nfunction isWillChangeMotionValue(value) {\r\n    return Boolean(isMotionValue(value) && value.add);\r\n}\r\n\r\nexport { isWillChangeMotionValue };\r\n","import { optimizedAppearDataAttribute } from './data-id.mjs';\r\n\r\nfunction getOptimisedAppearId(visualElement) {\r\n    return visualElement.props[optimizedAppearDataAttribute];\r\n}\r\n\r\nexport { getOptimisedAppearId };\r\n","import { noop } from 'motion-utils';\r\n\r\n/*\r\n  Bezier function generator\r\n  This has been modified from Gatan Renaudeau's BezierEasing\r\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\r\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\r\n  \r\n  I've removed the newtonRaphsonIterate algo because in benchmarking it\r\n  wasn't noticiably faster than binarySubdivision, indeed removing it\r\n  usually improved times, depending on the curve.\r\n  I also removed the lookup table, as for the added bundle size and loop we're\r\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\r\n  to 12 to compensate and this still tended to be faster for no perceivable\r\n  loss in accuracy.\r\n  Usage\r\n    const easeOut = cubicBezier(.17,.67,.83,.67);\r\n    const x = easeOut(0.5); // returns 0.627...\r\n*/\r\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\r\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) *\r\n    t;\r\nconst subdivisionPrecision = 0.0000001;\r\nconst subdivisionMaxIterations = 12;\r\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\r\n    let currentX;\r\n    let currentT;\r\n    let i = 0;\r\n    do {\r\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\r\n        currentX = calcBezier(currentT, mX1, mX2) - x;\r\n        if (currentX > 0.0) {\r\n            upperBound = currentT;\r\n        }\r\n        else {\r\n            lowerBound = currentT;\r\n        }\r\n    } while (Math.abs(currentX) > subdivisionPrecision &&\r\n        ++i < subdivisionMaxIterations);\r\n    return currentT;\r\n}\r\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\r\n    // If this is a linear gradient, return linear easing\r\n    if (mX1 === mY1 && mX2 === mY2)\r\n        return noop;\r\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\r\n    // If animation is at start/end, return t without easing\r\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\r\n}\r\n\r\nexport { cubicBezier };\r\n","// Accepts an easing function and returns a new one that outputs mirrored values for\r\n// the second half of the animation. Turns easeIn into easeInOut.\r\nconst mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\r\n\r\nexport { mirrorEasing };\r\n","// Accepts an easing function and returns a new one that outputs reversed values.\r\n// Turns easeIn into easeOut.\r\nconst reverseEasing = (easing) => (p) => 1 - easing(1 - p);\r\n\r\nexport { reverseEasing };\r\n","import { cubicBezier } from './cubic-bezier.mjs';\r\nimport { mirrorEasing } from './modifiers/mirror.mjs';\r\nimport { reverseEasing } from './modifiers/reverse.mjs';\r\n\r\nconst backOut = /*@__PURE__*/ cubicBezier(0.33, 1.53, 0.69, 0.99);\r\nconst backIn = /*@__PURE__*/ reverseEasing(backOut);\r\nconst backInOut = /*@__PURE__*/ mirrorEasing(backIn);\r\n\r\nexport { backIn, backInOut, backOut };\r\n","import { backIn } from './back.mjs';\r\n\r\nconst anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\r\n\r\nexport { anticipate };\r\n","import { mirrorEasing } from './modifiers/mirror.mjs';\r\nimport { reverseEasing } from './modifiers/reverse.mjs';\r\n\r\nconst circIn = (p) => 1 - Math.sin(Math.acos(p));\r\nconst circOut = reverseEasing(circIn);\r\nconst circInOut = mirrorEasing(circIn);\r\n\r\nexport { circIn, circInOut, circOut };\r\n","/**\r\n * Check if the value is a zero value string like \"0px\" or \"0%\"\r\n */\r\nconst isZeroValueString = (v) => /^0[^.\\s]+$/u.test(v);\r\n\r\nexport { isZeroValueString };\r\n","import { isZeroValueString } from '../../utils/is-zero-value-string.mjs';\r\n\r\nfunction isNone(value) {\r\n    if (typeof value === \"number\") {\r\n        return value === 0;\r\n    }\r\n    else if (value !== null) {\r\n        return value === \"none\" || value === \"0\" || isZeroValueString(value);\r\n    }\r\n    else {\r\n        return true;\r\n    }\r\n}\r\n\r\nexport { isNone };\r\n","// If this number is a decimal, make it just five decimal places\r\n// to avoid exponents\r\nconst sanitize = (v) => Math.round(v * 100000) / 100000;\r\n\r\nexport { sanitize };\r\n","const floatRegex = /-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/gu;\r\n\r\nexport { floatRegex };\r\n","const singleColorRegex = /^(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))$/iu;\r\n\r\nexport { singleColorRegex };\r\n","import { floatRegex } from '../utils/float-regex.mjs';\r\nimport { isNullish } from '../utils/is-nullish.mjs';\r\nimport { singleColorRegex } from '../utils/single-color-regex.mjs';\r\n\r\n/**\r\n * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,\r\n * but false if a number or multiple colors\r\n */\r\nconst isColorString = (type, testProp) => (v) => {\r\n    return Boolean((typeof v === \"string\" &&\r\n        singleColorRegex.test(v) &&\r\n        v.startsWith(type)) ||\r\n        (testProp &&\r\n            !isNullish(v) &&\r\n            Object.prototype.hasOwnProperty.call(v, testProp)));\r\n};\r\nconst splitColor = (aName, bName, cName) => (v) => {\r\n    if (typeof v !== \"string\")\r\n        return v;\r\n    const [a, b, c, alpha] = v.match(floatRegex);\r\n    return {\r\n        [aName]: parseFloat(a),\r\n        [bName]: parseFloat(b),\r\n        [cName]: parseFloat(c),\r\n        alpha: alpha !== undefined ? parseFloat(alpha) : 1,\r\n    };\r\n};\r\n\r\nexport { isColorString, splitColor };\r\n","function isNullish(v) {\r\n    return v == null;\r\n}\r\n\r\nexport { isNullish };\r\n","import { clamp } from '../../../utils/clamp.mjs';\r\nimport { alpha, number } from '../numbers/index.mjs';\r\nimport { sanitize } from '../utils/sanitize.mjs';\r\nimport { isColorString, splitColor } from './utils.mjs';\r\n\r\nconst clampRgbUnit = (v) => clamp(0, 255, v);\r\nconst rgbUnit = {\r\n    ...number,\r\n    transform: (v) => Math.round(clampRgbUnit(v)),\r\n};\r\nconst rgba = {\r\n    test: /*@__PURE__*/ isColorString(\"rgb\", \"red\"),\r\n    parse: /*@__PURE__*/ splitColor(\"red\", \"green\", \"blue\"),\r\n    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => \"rgba(\" +\r\n        rgbUnit.transform(red) +\r\n        \", \" +\r\n        rgbUnit.transform(green) +\r\n        \", \" +\r\n        rgbUnit.transform(blue) +\r\n        \", \" +\r\n        sanitize(alpha.transform(alpha$1)) +\r\n        \")\",\r\n};\r\n\r\nexport { rgbUnit, rgba };\r\n","import { rgba } from './rgba.mjs';\r\nimport { isColorString } from './utils.mjs';\r\n\r\nfunction parseHex(v) {\r\n    let r = \"\";\r\n    let g = \"\";\r\n    let b = \"\";\r\n    let a = \"\";\r\n    // If we have 6 characters, ie #FF0000\r\n    if (v.length > 5) {\r\n        r = v.substring(1, 3);\r\n        g = v.substring(3, 5);\r\n        b = v.substring(5, 7);\r\n        a = v.substring(7, 9);\r\n        // Or we have 3 characters, ie #F00\r\n    }\r\n    else {\r\n        r = v.substring(1, 2);\r\n        g = v.substring(2, 3);\r\n        b = v.substring(3, 4);\r\n        a = v.substring(4, 5);\r\n        r += r;\r\n        g += g;\r\n        b += b;\r\n        a += a;\r\n    }\r\n    return {\r\n        red: parseInt(r, 16),\r\n        green: parseInt(g, 16),\r\n        blue: parseInt(b, 16),\r\n        alpha: a ? parseInt(a, 16) / 255 : 1,\r\n    };\r\n}\r\nconst hex = {\r\n    test: /*@__PURE__*/ isColorString(\"#\"),\r\n    parse: parseHex,\r\n    transform: rgba.transform,\r\n};\r\n\r\nexport { hex };\r\n","import { alpha } from '../numbers/index.mjs';\r\nimport { percent } from '../numbers/units.mjs';\r\nimport { sanitize } from '../utils/sanitize.mjs';\r\nimport { isColorString, splitColor } from './utils.mjs';\r\n\r\nconst hsla = {\r\n    test: /*@__PURE__*/ isColorString(\"hsl\", \"hue\"),\r\n    parse: /*@__PURE__*/ splitColor(\"hue\", \"saturation\", \"lightness\"),\r\n    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {\r\n        return (\"hsla(\" +\r\n            Math.round(hue) +\r\n            \", \" +\r\n            percent.transform(sanitize(saturation)) +\r\n            \", \" +\r\n            percent.transform(sanitize(lightness)) +\r\n            \", \" +\r\n            sanitize(alpha.transform(alpha$1)) +\r\n            \")\");\r\n    },\r\n};\r\n\r\nexport { hsla };\r\n","import { hex } from './hex.mjs';\r\nimport { hsla } from './hsla.mjs';\r\nimport { rgba } from './rgba.mjs';\r\n\r\nconst color = {\r\n    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),\r\n    parse: (v) => {\r\n        if (rgba.test(v)) {\r\n            return rgba.parse(v);\r\n        }\r\n        else if (hsla.test(v)) {\r\n            return hsla.parse(v);\r\n        }\r\n        else {\r\n            return hex.parse(v);\r\n        }\r\n    },\r\n    transform: (v) => {\r\n        return typeof v === \"string\"\r\n            ? v\r\n            : v.hasOwnProperty(\"red\")\r\n                ? rgba.transform(v)\r\n                : hsla.transform(v);\r\n    },\r\n};\r\n\r\nexport { color };\r\n","const colorRegex = /(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))/giu;\r\n\r\nexport { colorRegex };\r\n","import { color } from '../color/index.mjs';\r\nimport { colorRegex } from '../utils/color-regex.mjs';\r\nimport { floatRegex } from '../utils/float-regex.mjs';\r\nimport { sanitize } from '../utils/sanitize.mjs';\r\n\r\nfunction test(v) {\r\n    var _a, _b;\r\n    return (isNaN(v) &&\r\n        typeof v === \"string\" &&\r\n        (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) +\r\n            (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) >\r\n            0);\r\n}\r\nconst NUMBER_TOKEN = \"number\";\r\nconst COLOR_TOKEN = \"color\";\r\nconst VAR_TOKEN = \"var\";\r\nconst VAR_FUNCTION_TOKEN = \"var(\";\r\nconst SPLIT_TOKEN = \"${}\";\r\n// this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`\r\nconst complexRegex = /var\\s*\\(\\s*--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)|#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\)|-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/giu;\r\nfunction analyseComplexValue(value) {\r\n    const originalValue = value.toString();\r\n    const values = [];\r\n    const indexes = {\r\n        color: [],\r\n        number: [],\r\n        var: [],\r\n    };\r\n    const types = [];\r\n    let i = 0;\r\n    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {\r\n        if (color.test(parsedValue)) {\r\n            indexes.color.push(i);\r\n            types.push(COLOR_TOKEN);\r\n            values.push(color.parse(parsedValue));\r\n        }\r\n        else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {\r\n            indexes.var.push(i);\r\n            types.push(VAR_TOKEN);\r\n            values.push(parsedValue);\r\n        }\r\n        else {\r\n            indexes.number.push(i);\r\n            types.push(NUMBER_TOKEN);\r\n            values.push(parseFloat(parsedValue));\r\n        }\r\n        ++i;\r\n        return SPLIT_TOKEN;\r\n    });\r\n    const split = tokenised.split(SPLIT_TOKEN);\r\n    return { values, split, indexes, types };\r\n}\r\nfunction parseComplexValue(v) {\r\n    return analyseComplexValue(v).values;\r\n}\r\nfunction createTransformer(source) {\r\n    const { split, types } = analyseComplexValue(source);\r\n    const numSections = split.length;\r\n    return (v) => {\r\n        let output = \"\";\r\n        for (let i = 0; i < numSections; i++) {\r\n            output += split[i];\r\n            if (v[i] !== undefined) {\r\n                const type = types[i];\r\n                if (type === NUMBER_TOKEN) {\r\n                    output += sanitize(v[i]);\r\n                }\r\n                else if (type === COLOR_TOKEN) {\r\n                    output += color.transform(v[i]);\r\n                }\r\n                else {\r\n                    output += v[i];\r\n                }\r\n            }\r\n        }\r\n        return output;\r\n    };\r\n}\r\nconst convertNumbersToZero = (v) => typeof v === \"number\" ? 0 : v;\r\nfunction getAnimatableNone(v) {\r\n    const parsed = parseComplexValue(v);\r\n    const transformer = createTransformer(v);\r\n    return transformer(parsed.map(convertNumbersToZero));\r\n}\r\nconst complex = {\r\n    test,\r\n    parse: parseComplexValue,\r\n    createTransformer,\r\n    getAnimatableNone,\r\n};\r\n\r\nexport { analyseComplexValue, complex };\r\n","import { complex } from './index.mjs';\r\nimport { floatRegex } from '../utils/float-regex.mjs';\r\n\r\n/**\r\n * Properties that should default to 1 or 100%\r\n */\r\nconst maxDefaults = new Set([\"brightness\", \"contrast\", \"saturate\", \"opacity\"]);\r\nfunction applyDefaultFilter(v) {\r\n    const [name, value] = v.slice(0, -1).split(\"(\");\r\n    if (name === \"drop-shadow\")\r\n        return v;\r\n    const [number] = value.match(floatRegex) || [];\r\n    if (!number)\r\n        return v;\r\n    const unit = value.replace(number, \"\");\r\n    let defaultValue = maxDefaults.has(name) ? 1 : 0;\r\n    if (number !== value)\r\n        defaultValue *= 100;\r\n    return name + \"(\" + defaultValue + unit + \")\";\r\n}\r\nconst functionRegex = /\\b([a-z-]*)\\(.*?\\)/gu;\r\nconst filter = {\r\n    ...complex,\r\n    getAnimatableNone: (v) => {\r\n        const functions = v.match(functionRegex);\r\n        return functions ? functions.map(applyDefaultFilter).join(\" \") : v;\r\n    },\r\n};\r\n\r\nexport { filter };\r\n","import { color } from '../../../value/types/color/index.mjs';\r\nimport { filter } from '../../../value/types/complex/filter.mjs';\r\nimport { numberValueTypes } from './number.mjs';\r\n\r\n/**\r\n * A map of default value types for common values\r\n */\r\nconst defaultValueTypes = {\r\n    ...numberValueTypes,\r\n    // Color props\r\n    color,\r\n    backgroundColor: color,\r\n    outlineColor: color,\r\n    fill: color,\r\n    stroke: color,\r\n    // Border props\r\n    borderColor: color,\r\n    borderTopColor: color,\r\n    borderRightColor: color,\r\n    borderBottomColor: color,\r\n    borderLeftColor: color,\r\n    filter,\r\n    WebkitFilter: filter,\r\n};\r\n/**\r\n * Gets the default ValueType for the provided value key\r\n */\r\nconst getDefaultValueType = (key) => defaultValueTypes[key];\r\n\r\nexport { defaultValueTypes, getDefaultValueType };\r\n","import { complex } from '../../../value/types/complex/index.mjs';\r\nimport { filter } from '../../../value/types/complex/filter.mjs';\r\nimport { getDefaultValueType } from './defaults.mjs';\r\n\r\nfunction getAnimatableNone(key, value) {\r\n    let defaultValueType = getDefaultValueType(key);\r\n    if (defaultValueType !== filter)\r\n        defaultValueType = complex;\r\n    // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\r\n    return defaultValueType.getAnimatableNone\r\n        ? defaultValueType.getAnimatableNone(value)\r\n        : undefined;\r\n}\r\n\r\nexport { getAnimatableNone };\r\n","import { analyseComplexValue } from '../../../value/types/complex/index.mjs';\r\nimport { getAnimatableNone } from '../../dom/value-types/animatable-none.mjs';\r\n\r\n/**\r\n * If we encounter keyframes like \"none\" or \"0\" and we also have keyframes like\r\n * \"#fff\" or \"200px 200px\" we want to find a keyframe to serve as a template for\r\n * the \"none\" keyframes. In this case \"#fff\" or \"200px 200px\" - then these get turned into\r\n * zero equivalents, i.e. \"#fff0\" or \"0px 0px\".\r\n */\r\nconst invalidTemplates = new Set([\"auto\", \"none\", \"0\"]);\r\nfunction makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {\r\n    let i = 0;\r\n    let animatableTemplate = undefined;\r\n    while (i < unresolvedKeyframes.length && !animatableTemplate) {\r\n        const keyframe = unresolvedKeyframes[i];\r\n        if (typeof keyframe === \"string\" &&\r\n            !invalidTemplates.has(keyframe) &&\r\n            analyseComplexValue(keyframe).values.length) {\r\n            animatableTemplate = unresolvedKeyframes[i];\r\n        }\r\n        i++;\r\n    }\r\n    if (animatableTemplate && name) {\r\n        for (const noneIndex of noneKeyframeIndexes) {\r\n            unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);\r\n        }\r\n    }\r\n}\r\n\r\nexport { makeNoneKeyframesAnimatable };\r\n","import { number } from '../../../value/types/numbers/index.mjs';\r\nimport { px } from '../../../value/types/numbers/units.mjs';\r\nimport { transformPropOrder } from '../../html/utils/keys-transform.mjs';\r\n\r\nconst isNumOrPxType = (v) => v === number || v === px;\r\nconst getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(\", \")[pos]);\r\nconst getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {\r\n    if (transform === \"none\" || !transform)\r\n        return 0;\r\n    const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/u);\r\n    if (matrix3d) {\r\n        return getPosFromMatrix(matrix3d[1], pos3);\r\n    }\r\n    else {\r\n        const matrix = transform.match(/^matrix\\((.+)\\)$/u);\r\n        if (matrix) {\r\n            return getPosFromMatrix(matrix[1], pos2);\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n};\r\nconst transformKeys = new Set([\"x\", \"y\", \"z\"]);\r\nconst nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\r\nfunction removeNonTranslationalTransform(visualElement) {\r\n    const removedTransforms = [];\r\n    nonTranslationalTransformKeys.forEach((key) => {\r\n        const value = visualElement.getValue(key);\r\n        if (value !== undefined) {\r\n            removedTransforms.push([key, value.get()]);\r\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\r\n        }\r\n    });\r\n    return removedTransforms;\r\n}\r\nconst positionalValues = {\r\n    // Dimensions\r\n    width: ({ x }, { paddingLeft = \"0\", paddingRight = \"0\" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\r\n    height: ({ y }, { paddingTop = \"0\", paddingBottom = \"0\" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\r\n    top: (_bbox, { top }) => parseFloat(top),\r\n    left: (_bbox, { left }) => parseFloat(left),\r\n    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\r\n    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\r\n    // Transform\r\n    x: getTranslateFromMatrix(4, 13),\r\n    y: getTranslateFromMatrix(5, 14),\r\n};\r\n// Alias translate longform names\r\npositionalValues.translateX = positionalValues.x;\r\npositionalValues.translateY = positionalValues.y;\r\n\r\nexport { isNumOrPxType, positionalValues, removeNonTranslationalTransform };\r\n","import { removeNonTranslationalTransform } from '../dom/utils/unit-conversion.mjs';\r\nimport { frame } from '../../frameloop/frame.mjs';\r\n\r\nconst toResolve = new Set();\r\nlet isScheduled = false;\r\nlet anyNeedsMeasurement = false;\r\nfunction measureAllKeyframes() {\r\n    if (anyNeedsMeasurement) {\r\n        const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);\r\n        const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));\r\n        const transformsToRestore = new Map();\r\n        /**\r\n         * Write pass\r\n         * If we're measuring elements we want to remove bounding box-changing transforms.\r\n         */\r\n        elementsToMeasure.forEach((element) => {\r\n            const removedTransforms = removeNonTranslationalTransform(element);\r\n            if (!removedTransforms.length)\r\n                return;\r\n            transformsToRestore.set(element, removedTransforms);\r\n            element.render();\r\n        });\r\n        // Read\r\n        resolversToMeasure.forEach((resolver) => resolver.measureInitialState());\r\n        // Write\r\n        elementsToMeasure.forEach((element) => {\r\n            element.render();\r\n            const restore = transformsToRestore.get(element);\r\n            if (restore) {\r\n                restore.forEach(([key, value]) => {\r\n                    var _a;\r\n                    (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);\r\n                });\r\n            }\r\n        });\r\n        // Read\r\n        resolversToMeasure.forEach((resolver) => resolver.measureEndState());\r\n        // Write\r\n        resolversToMeasure.forEach((resolver) => {\r\n            if (resolver.suspendedScrollY !== undefined) {\r\n                window.scrollTo(0, resolver.suspendedScrollY);\r\n            }\r\n        });\r\n    }\r\n    anyNeedsMeasurement = false;\r\n    isScheduled = false;\r\n    toResolve.forEach((resolver) => resolver.complete());\r\n    toResolve.clear();\r\n}\r\nfunction readAllKeyframes() {\r\n    toResolve.forEach((resolver) => {\r\n        resolver.readKeyframes();\r\n        if (resolver.needsMeasurement) {\r\n            anyNeedsMeasurement = true;\r\n        }\r\n    });\r\n}\r\nfunction flushKeyframeResolvers() {\r\n    readAllKeyframes();\r\n    measureAllKeyframes();\r\n}\r\nclass KeyframeResolver {\r\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {\r\n        /**\r\n         * Track whether this resolver has completed. Once complete, it never\r\n         * needs to attempt keyframe resolution again.\r\n         */\r\n        this.isComplete = false;\r\n        /**\r\n         * Track whether this resolver is async. If it is, it'll be added to the\r\n         * resolver queue and flushed in the next frame. Resolvers that aren't going\r\n         * to trigger read/write thrashing don't need to be async.\r\n         */\r\n        this.isAsync = false;\r\n        /**\r\n         * Track whether this resolver needs to perform a measurement\r\n         * to resolve its keyframes.\r\n         */\r\n        this.needsMeasurement = false;\r\n        /**\r\n         * Track whether this resolver is currently scheduled to resolve\r\n         * to allow it to be cancelled and resumed externally.\r\n         */\r\n        this.isScheduled = false;\r\n        this.unresolvedKeyframes = [...unresolvedKeyframes];\r\n        this.onComplete = onComplete;\r\n        this.name = name;\r\n        this.motionValue = motionValue;\r\n        this.element = element;\r\n        this.isAsync = isAsync;\r\n    }\r\n    scheduleResolve() {\r\n        this.isScheduled = true;\r\n        if (this.isAsync) {\r\n            toResolve.add(this);\r\n            if (!isScheduled) {\r\n                isScheduled = true;\r\n                frame.read(readAllKeyframes);\r\n                frame.resolveKeyframes(measureAllKeyframes);\r\n            }\r\n        }\r\n        else {\r\n            this.readKeyframes();\r\n            this.complete();\r\n        }\r\n    }\r\n    readKeyframes() {\r\n        const { unresolvedKeyframes, name, element, motionValue } = this;\r\n        /**\r\n         * If a keyframe is null, we hydrate it either by reading it from\r\n         * the instance, or propagating from previous keyframes.\r\n         */\r\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\r\n            if (unresolvedKeyframes[i] === null) {\r\n                /**\r\n                 * If the first keyframe is null, we need to find its value by sampling the element\r\n                 */\r\n                if (i === 0) {\r\n                    const currentValue = motionValue === null || motionValue === void 0 ? void 0 : motionValue.get();\r\n                    const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\r\n                    if (currentValue !== undefined) {\r\n                        unresolvedKeyframes[0] = currentValue;\r\n                    }\r\n                    else if (element && name) {\r\n                        const valueAsRead = element.readValue(name, finalKeyframe);\r\n                        if (valueAsRead !== undefined && valueAsRead !== null) {\r\n                            unresolvedKeyframes[0] = valueAsRead;\r\n                        }\r\n                    }\r\n                    if (unresolvedKeyframes[0] === undefined) {\r\n                        unresolvedKeyframes[0] = finalKeyframe;\r\n                    }\r\n                    if (motionValue && currentValue === undefined) {\r\n                        motionValue.set(unresolvedKeyframes[0]);\r\n                    }\r\n                }\r\n                else {\r\n                    unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    setFinalKeyframe() { }\r\n    measureInitialState() { }\r\n    renderEndStyles() { }\r\n    measureEndState() { }\r\n    complete() {\r\n        this.isComplete = true;\r\n        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);\r\n        toResolve.delete(this);\r\n    }\r\n    cancel() {\r\n        if (!this.isComplete) {\r\n            this.isScheduled = false;\r\n            toResolve.delete(this);\r\n        }\r\n    }\r\n    resume() {\r\n        if (!this.isComplete)\r\n            this.scheduleResolve();\r\n    }\r\n}\r\n\r\nexport { KeyframeResolver, flushKeyframeResolvers };\r\n","/**\r\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\r\n */\r\nconst isNumericalString = (v) => /^-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)$/u.test(v);\r\n\r\nexport { isNumericalString };\r\n","import { invariant } from 'motion-utils';\r\nimport { isNumericalString } from '../../../utils/is-numerical-string.mjs';\r\nimport { isCSSVariableToken } from './is-css-variable.mjs';\r\n\r\n/**\r\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\r\n *\r\n * ```\r\n * `var(--foo, #fff)` => [`--foo`, '#fff']\r\n * ```\r\n *\r\n * @param current\r\n */\r\nconst splitCSSVariableRegex = \r\n// eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words\r\n/^var\\(--(?:([\\w-]+)|([\\w-]+), ?([a-zA-Z\\d ()%#.,-]+))\\)/u;\r\nfunction parseCSSVariable(current) {\r\n    const match = splitCSSVariableRegex.exec(current);\r\n    if (!match)\r\n        return [,];\r\n    const [, token1, token2, fallback] = match;\r\n    return [`--${token1 !== null && token1 !== void 0 ? token1 : token2}`, fallback];\r\n}\r\nconst maxDepth = 4;\r\nfunction getVariableValue(current, element, depth = 1) {\r\n    invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`);\r\n    const [token, fallback] = parseCSSVariable(current);\r\n    // No CSS variable detected\r\n    if (!token)\r\n        return;\r\n    // Attempt to read this CSS variable off the element\r\n    const resolved = window.getComputedStyle(element).getPropertyValue(token);\r\n    if (resolved) {\r\n        const trimmed = resolved.trim();\r\n        return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;\r\n    }\r\n    return isCSSVariableToken(fallback)\r\n        ? getVariableValue(fallback, element, depth + 1)\r\n        : fallback;\r\n}\r\n\r\nexport { getVariableValue, parseCSSVariable };\r\n","/**\r\n * Tests a provided value against a ValueType\r\n */\r\nconst testValueType = (v) => (type) => type.test(v);\r\n\r\nexport { testValueType };\r\n","import { number } from '../../../value/types/numbers/index.mjs';\r\nimport { px, percent, degrees, vw, vh } from '../../../value/types/numbers/units.mjs';\r\nimport { testValueType } from './test.mjs';\r\nimport { auto } from './type-auto.mjs';\r\n\r\n/**\r\n * A list of value types commonly used for dimensions\r\n */\r\nconst dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\r\n/**\r\n * Tests a dimensional value against the list of dimension ValueTypes\r\n */\r\nconst findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));\r\n\r\nexport { dimensionValueTypes, findDimensionValueType };\r\n","/**\r\n * ValueType for \"auto\"\r\n */\r\nconst auto = {\r\n    test: (v) => v === \"auto\",\r\n    parse: (v) => v,\r\n};\r\n\r\nexport { auto };\r\n","import { isNone } from '../../animation/utils/is-none.mjs';\r\nimport { positionalKeys } from '../html/utils/keys-position.mjs';\r\nimport { makeNoneKeyframesAnimatable } from '../html/utils/make-none-animatable.mjs';\r\nimport { KeyframeResolver } from '../utils/KeyframesResolver.mjs';\r\nimport { getVariableValue } from './utils/css-variables-conversion.mjs';\r\nimport { isCSSVariableToken } from './utils/is-css-variable.mjs';\r\nimport { isNumOrPxType, positionalValues } from './utils/unit-conversion.mjs';\r\nimport { findDimensionValueType } from './value-types/dimensions.mjs';\r\n\r\nclass DOMKeyframesResolver extends KeyframeResolver {\r\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\r\n        super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\r\n    }\r\n    readKeyframes() {\r\n        const { unresolvedKeyframes, element, name } = this;\r\n        if (!element || !element.current)\r\n            return;\r\n        super.readKeyframes();\r\n        /**\r\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\r\n         */\r\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\r\n            let keyframe = unresolvedKeyframes[i];\r\n            if (typeof keyframe === \"string\") {\r\n                keyframe = keyframe.trim();\r\n                if (isCSSVariableToken(keyframe)) {\r\n                    const resolved = getVariableValue(keyframe, element.current);\r\n                    if (resolved !== undefined) {\r\n                        unresolvedKeyframes[i] = resolved;\r\n                    }\r\n                    if (i === unresolvedKeyframes.length - 1) {\r\n                        this.finalKeyframe = keyframe;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\r\n         * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\r\n         * have a far bigger performance impact.\r\n         */\r\n        this.resolveNoneKeyframes();\r\n        /**\r\n         * Check to see if unit type has changed. If so schedule jobs that will\r\n         * temporarily set styles to the destination keyframes.\r\n         * Skip if we have more than two keyframes or this isn't a positional value.\r\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\r\n         */\r\n        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\r\n            return;\r\n        }\r\n        const [origin, target] = unresolvedKeyframes;\r\n        const originType = findDimensionValueType(origin);\r\n        const targetType = findDimensionValueType(target);\r\n        /**\r\n         * Either we don't recognise these value types or we can animate between them.\r\n         */\r\n        if (originType === targetType)\r\n            return;\r\n        /**\r\n         * If both values are numbers or pixels, we can animate between them by\r\n         * converting them to numbers.\r\n         */\r\n        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\r\n            for (let i = 0; i < unresolvedKeyframes.length; i++) {\r\n                const value = unresolvedKeyframes[i];\r\n                if (typeof value === \"string\") {\r\n                    unresolvedKeyframes[i] = parseFloat(value);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            /**\r\n             * Else, the only way to resolve this is by measuring the element.\r\n             */\r\n            this.needsMeasurement = true;\r\n        }\r\n    }\r\n    resolveNoneKeyframes() {\r\n        const { unresolvedKeyframes, name } = this;\r\n        const noneKeyframeIndexes = [];\r\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\r\n            if (isNone(unresolvedKeyframes[i])) {\r\n                noneKeyframeIndexes.push(i);\r\n            }\r\n        }\r\n        if (noneKeyframeIndexes.length) {\r\n            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\r\n        }\r\n    }\r\n    measureInitialState() {\r\n        const { element, unresolvedKeyframes, name } = this;\r\n        if (!element || !element.current)\r\n            return;\r\n        if (name === \"height\") {\r\n            this.suspendedScrollY = window.pageYOffset;\r\n        }\r\n        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\r\n        unresolvedKeyframes[0] = this.measuredOrigin;\r\n        // Set final key frame to measure after next render\r\n        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\r\n        if (measureKeyframe !== undefined) {\r\n            element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\r\n        }\r\n    }\r\n    measureEndState() {\r\n        var _a;\r\n        const { element, name, unresolvedKeyframes } = this;\r\n        if (!element || !element.current)\r\n            return;\r\n        const value = element.getValue(name);\r\n        value && value.jump(this.measuredOrigin, false);\r\n        const finalKeyframeIndex = unresolvedKeyframes.length - 1;\r\n        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\r\n        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\r\n        if (finalKeyframe !== null && this.finalKeyframe === undefined) {\r\n            this.finalKeyframe = finalKeyframe;\r\n        }\r\n        // If we removed transform values, reapply them before the next render\r\n        if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\r\n            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\r\n                element\r\n                    .getValue(unsetTransformName)\r\n                    .set(unsetTransformValue);\r\n            });\r\n        }\r\n        this.resolveNoneKeyframes();\r\n    }\r\n}\r\n\r\nexport { DOMKeyframesResolver };\r\n","import { complex } from '../../value/types/complex/index.mjs';\r\n\r\n/**\r\n * Check if a value is animatable. Examples:\r\n *\r\n * : 100, \"100px\", \"#fff\"\r\n * : \"block\", \"url(2.jpg)\"\r\n * @param value\r\n *\r\n * @internal\r\n */\r\nconst isAnimatable = (value, name) => {\r\n    // If the list of keys tat might be non-animatable grows, replace with Set\r\n    if (name === \"zIndex\")\r\n        return false;\r\n    // If it's a number or a keyframes array, we can animate it. We might at some point\r\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\r\n    // but for now lets leave it like this for performance reasons\r\n    if (typeof value === \"number\" || Array.isArray(value))\r\n        return true;\r\n    if (typeof value === \"string\" && // It's animatable if we have a string\r\n        (complex.test(value) || value === \"0\") && // And it contains numbers and/or colors\r\n        !value.startsWith(\"url(\") // Unless it starts with \"url(\"\r\n    ) {\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n\r\nexport { isAnimatable };\r\n","const isNotNull = (value) => value !== null;\r\nfunction getFinalKeyframe(keyframes, { repeat, repeatType = \"loop\" }, finalKeyframe) {\r\n    const resolvedKeyframes = keyframes.filter(isNotNull);\r\n    const index = repeat && repeatType !== \"loop\" && repeat % 2 === 1\r\n        ? 0\r\n        : resolvedKeyframes.length - 1;\r\n    return !index || finalKeyframe === undefined\r\n        ? resolvedKeyframes[index]\r\n        : finalKeyframe;\r\n}\r\n\r\nexport { getFinalKeyframe };\r\n","import { time } from '../../frameloop/sync-time.mjs';\r\nimport { flushKeyframeResolvers } from '../../render/utils/KeyframesResolver.mjs';\r\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\r\nimport { canAnimate } from './utils/can-animate.mjs';\r\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\r\n\r\n/**\r\n * Maximum time allowed between an animation being created and it being\r\n * resolved for us to use the latter as the start time.\r\n *\r\n * This is to ensure that while we prefer to \"start\" an animation as soon\r\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\r\n * between these two moments.\r\n */\r\nconst MAX_RESOLVE_DELAY = 40;\r\nclass BaseAnimation {\r\n    constructor({ autoplay = true, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", ...options }) {\r\n        // Track whether the animation has been stopped. Stopped animations won't restart.\r\n        this.isStopped = false;\r\n        this.hasAttemptedResolve = false;\r\n        this.createdAt = time.now();\r\n        this.options = {\r\n            autoplay,\r\n            delay,\r\n            type,\r\n            repeat,\r\n            repeatDelay,\r\n            repeatType,\r\n            ...options,\r\n        };\r\n        this.updateFinishedPromise();\r\n    }\r\n    /**\r\n     * This method uses the createdAt and resolvedAt to calculate the\r\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\r\n     * as the following frame would then be the first frame of the animation in\r\n     * progress, which would feel snappier.\r\n     *\r\n     * However, if there's a delay (main thread work) between the creation of\r\n     * the animation and the first commited frame, we prefer to use resolvedAt\r\n     * to avoid a sudden jump into the animation.\r\n     */\r\n    calcStartTime() {\r\n        if (!this.resolvedAt)\r\n            return this.createdAt;\r\n        return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\r\n            ? this.resolvedAt\r\n            : this.createdAt;\r\n    }\r\n    /**\r\n     * A getter for resolved data. If keyframes are not yet resolved, accessing\r\n     * this.resolved will synchronously flush all pending keyframe resolvers.\r\n     * This is a deoptimisation, but at its worst still batches read/writes.\r\n     */\r\n    get resolved() {\r\n        if (!this._resolved && !this.hasAttemptedResolve) {\r\n            flushKeyframeResolvers();\r\n        }\r\n        return this._resolved;\r\n    }\r\n    /**\r\n     * A method to be called when the keyframes resolver completes. This method\r\n     * will check if its possible to run the animation and, if not, skip it.\r\n     * Otherwise, it will call initPlayback on the implementing class.\r\n     */\r\n    onKeyframesResolved(keyframes, finalKeyframe) {\r\n        this.resolvedAt = time.now();\r\n        this.hasAttemptedResolve = true;\r\n        const { name, type, velocity, delay, onComplete, onUpdate, isGenerator, } = this.options;\r\n        /**\r\n         * If we can't animate this value with the resolved keyframes\r\n         * then we should complete it immediately.\r\n         */\r\n        if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\r\n            // Finish immediately\r\n            if (instantAnimationState.current || !delay) {\r\n                onUpdate &&\r\n                    onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\r\n                onComplete && onComplete();\r\n                this.resolveFinishedPromise();\r\n                return;\r\n            }\r\n            // Finish after a delay\r\n            else {\r\n                this.options.duration = 0;\r\n            }\r\n        }\r\n        const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\r\n        if (resolvedAnimation === false)\r\n            return;\r\n        this._resolved = {\r\n            keyframes,\r\n            finalKeyframe,\r\n            ...resolvedAnimation,\r\n        };\r\n        this.onPostResolved();\r\n    }\r\n    onPostResolved() { }\r\n    /**\r\n     * Allows the returned animation to be awaited or promise-chained. Currently\r\n     * resolves when the animation finishes at all but in a future update could/should\r\n     * reject if its cancels.\r\n     */\r\n    then(resolve, reject) {\r\n        return this.currentFinishedPromise.then(resolve, reject);\r\n    }\r\n    flatten() {\r\n        this.options.type = \"keyframes\";\r\n        this.options.ease = \"linear\";\r\n    }\r\n    updateFinishedPromise() {\r\n        this.currentFinishedPromise = new Promise((resolve) => {\r\n            this.resolveFinishedPromise = resolve;\r\n        });\r\n    }\r\n}\r\n\r\nexport { BaseAnimation };\r\n","import { isGenerator } from 'motion-dom';\r\nimport { warning } from 'motion-utils';\r\nimport { isAnimatable } from '../../utils/is-animatable.mjs';\r\n\r\nfunction hasKeyframesChanged(keyframes) {\r\n    const current = keyframes[0];\r\n    if (keyframes.length === 1)\r\n        return true;\r\n    for (let i = 0; i < keyframes.length; i++) {\r\n        if (keyframes[i] !== current)\r\n            return true;\r\n    }\r\n}\r\nfunction canAnimate(keyframes, name, type, velocity) {\r\n    /**\r\n     * Check if we're able to animate between the start and end keyframes,\r\n     * and throw a warning if we're attempting to animate between one that's\r\n     * animatable and another that isn't.\r\n     */\r\n    const originKeyframe = keyframes[0];\r\n    if (originKeyframe === null)\r\n        return false;\r\n    /**\r\n     * These aren't traditionally animatable but we do support them.\r\n     * In future we could look into making this more generic or replacing\r\n     * this function with mix() === mixImmediate\r\n     */\r\n    if (name === \"display\" || name === \"visibility\")\r\n        return true;\r\n    const targetKeyframe = keyframes[keyframes.length - 1];\r\n    const isOriginAnimatable = isAnimatable(originKeyframe, name);\r\n    const isTargetAnimatable = isAnimatable(targetKeyframe, name);\r\n    warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from \"${originKeyframe}\" to \"${targetKeyframe}\". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \\`style\\` property.`);\r\n    // Always skip if any of these are true\r\n    if (!isOriginAnimatable || !isTargetAnimatable) {\r\n        return false;\r\n    }\r\n    return (hasKeyframesChanged(keyframes) ||\r\n        ((type === \"spring\" || isGenerator(type)) && velocity));\r\n}\r\n\r\nexport { canAnimate };\r\n","/*\r\n  Value in range from progress\r\n\r\n  Given a lower limit and an upper limit, we return the value within\r\n  that range as expressed by progress (usually a number from 0 to 1)\r\n\r\n  So progress = 0.5 would change\r\n\r\n  from -------- to\r\n\r\n  to\r\n\r\n  from ---- to\r\n\r\n  E.g. from = 10, to = 20, progress = 0.5 => 15\r\n\r\n  @param [number]: Lower limit of range\r\n  @param [number]: Upper limit of range\r\n  @param [number]: The progress between lower and upper limits expressed 0-1\r\n  @return [number]: Value as calculated from progress within range (not limited within range)\r\n*/\r\nconst mixNumber = (from, to, progress) => {\r\n    return from + (to - from) * progress;\r\n};\r\n\r\nexport { mixNumber };\r\n","// Adapted from https://gist.github.com/mjackson/5311256\r\nfunction hueToRgb(p, q, t) {\r\n    if (t < 0)\r\n        t += 1;\r\n    if (t > 1)\r\n        t -= 1;\r\n    if (t < 1 / 6)\r\n        return p + (q - p) * 6 * t;\r\n    if (t < 1 / 2)\r\n        return q;\r\n    if (t < 2 / 3)\r\n        return p + (q - p) * (2 / 3 - t) * 6;\r\n    return p;\r\n}\r\nfunction hslaToRgba({ hue, saturation, lightness, alpha }) {\r\n    hue /= 360;\r\n    saturation /= 100;\r\n    lightness /= 100;\r\n    let red = 0;\r\n    let green = 0;\r\n    let blue = 0;\r\n    if (!saturation) {\r\n        red = green = blue = lightness;\r\n    }\r\n    else {\r\n        const q = lightness < 0.5\r\n            ? lightness * (1 + saturation)\r\n            : lightness + saturation - lightness * saturation;\r\n        const p = 2 * lightness - q;\r\n        red = hueToRgb(p, q, hue + 1 / 3);\r\n        green = hueToRgb(p, q, hue);\r\n        blue = hueToRgb(p, q, hue - 1 / 3);\r\n    }\r\n    return {\r\n        red: Math.round(red * 255),\r\n        green: Math.round(green * 255),\r\n        blue: Math.round(blue * 255),\r\n        alpha,\r\n    };\r\n}\r\n\r\nexport { hslaToRgba };\r\n","function mixImmediate(a, b) {\r\n    return (p) => (p > 0 ? b : a);\r\n}\r\n\r\nexport { mixImmediate };\r\n","import { mixNumber } from './number.mjs';\r\nimport { warning } from 'motion-utils';\r\nimport { hslaToRgba } from '../hsla-to-rgba.mjs';\r\nimport { hex } from '../../value/types/color/hex.mjs';\r\nimport { rgba } from '../../value/types/color/rgba.mjs';\r\nimport { hsla } from '../../value/types/color/hsla.mjs';\r\nimport { mixImmediate } from './immediate.mjs';\r\n\r\n// Linear color space blending\r\n// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw\r\n// Demonstrated http://codepen.io/osublake/pen/xGVVaN\r\nconst mixLinearColor = (from, to, v) => {\r\n    const fromExpo = from * from;\r\n    const expo = v * (to * to - fromExpo) + fromExpo;\r\n    return expo < 0 ? 0 : Math.sqrt(expo);\r\n};\r\nconst colorTypes = [hex, rgba, hsla];\r\nconst getColorType = (v) => colorTypes.find((type) => type.test(v));\r\nfunction asRGBA(color) {\r\n    const type = getColorType(color);\r\n    warning(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);\r\n    if (!Boolean(type))\r\n        return false;\r\n    let model = type.parse(color);\r\n    if (type === hsla) {\r\n        // TODO Remove this cast - needed since Motion's stricter typing\r\n        model = hslaToRgba(model);\r\n    }\r\n    return model;\r\n}\r\nconst mixColor = (from, to) => {\r\n    const fromRGBA = asRGBA(from);\r\n    const toRGBA = asRGBA(to);\r\n    if (!fromRGBA || !toRGBA) {\r\n        return mixImmediate(from, to);\r\n    }\r\n    const blended = { ...fromRGBA };\r\n    return (v) => {\r\n        blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);\r\n        blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);\r\n        blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);\r\n        blended.alpha = mixNumber(fromRGBA.alpha, toRGBA.alpha, v);\r\n        return rgba.transform(blended);\r\n    };\r\n};\r\n\r\nexport { mixColor, mixLinearColor };\r\n","/**\r\n * Pipe\r\n * Compose other transformers to run linearily\r\n * pipe(min(20), max(40))\r\n * @param  {...functions} transformers\r\n * @return {function}\r\n */\r\nconst combineFunctions = (a, b) => (v) => b(a(v));\r\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\r\n\r\nexport { pipe };\r\n","const invisibleValues = new Set([\"none\", \"hidden\"]);\r\n/**\r\n * Returns a function that, when provided a progress value between 0 and 1,\r\n * will return the \"none\" or \"hidden\" string only when the progress is that of\r\n * the origin or target.\r\n */\r\nfunction mixVisibility(origin, target) {\r\n    if (invisibleValues.has(origin)) {\r\n        return (p) => (p <= 0 ? origin : target);\r\n    }\r\n    else {\r\n        return (p) => (p >= 1 ? target : origin);\r\n    }\r\n}\r\n\r\nexport { invisibleValues, mixVisibility };\r\n","import { mixNumber as mixNumber$1 } from './number.mjs';\r\nimport { mixColor } from './color.mjs';\r\nimport { pipe } from '../pipe.mjs';\r\nimport { warning } from 'motion-utils';\r\nimport { color } from '../../value/types/color/index.mjs';\r\nimport { complex, analyseComplexValue } from '../../value/types/complex/index.mjs';\r\nimport { isCSSVariableToken } from '../../render/dom/utils/is-css-variable.mjs';\r\nimport { invisibleValues, mixVisibility } from './visibility.mjs';\r\nimport { mixImmediate } from './immediate.mjs';\r\n\r\nfunction mixNumber(a, b) {\r\n    return (p) => mixNumber$1(a, b, p);\r\n}\r\nfunction getMixer(a) {\r\n    if (typeof a === \"number\") {\r\n        return mixNumber;\r\n    }\r\n    else if (typeof a === \"string\") {\r\n        return isCSSVariableToken(a)\r\n            ? mixImmediate\r\n            : color.test(a)\r\n                ? mixColor\r\n                : mixComplex;\r\n    }\r\n    else if (Array.isArray(a)) {\r\n        return mixArray;\r\n    }\r\n    else if (typeof a === \"object\") {\r\n        return color.test(a) ? mixColor : mixObject;\r\n    }\r\n    return mixImmediate;\r\n}\r\nfunction mixArray(a, b) {\r\n    const output = [...a];\r\n    const numValues = output.length;\r\n    const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));\r\n    return (p) => {\r\n        for (let i = 0; i < numValues; i++) {\r\n            output[i] = blendValue[i](p);\r\n        }\r\n        return output;\r\n    };\r\n}\r\nfunction mixObject(a, b) {\r\n    const output = { ...a, ...b };\r\n    const blendValue = {};\r\n    for (const key in output) {\r\n        if (a[key] !== undefined && b[key] !== undefined) {\r\n            blendValue[key] = getMixer(a[key])(a[key], b[key]);\r\n        }\r\n    }\r\n    return (v) => {\r\n        for (const key in blendValue) {\r\n            output[key] = blendValue[key](v);\r\n        }\r\n        return output;\r\n    };\r\n}\r\nfunction matchOrder(origin, target) {\r\n    var _a;\r\n    const orderedOrigin = [];\r\n    const pointers = { color: 0, var: 0, number: 0 };\r\n    for (let i = 0; i < target.values.length; i++) {\r\n        const type = target.types[i];\r\n        const originIndex = origin.indexes[type][pointers[type]];\r\n        const originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;\r\n        orderedOrigin[i] = originValue;\r\n        pointers[type]++;\r\n    }\r\n    return orderedOrigin;\r\n}\r\nconst mixComplex = (origin, target) => {\r\n    const template = complex.createTransformer(target);\r\n    const originStats = analyseComplexValue(origin);\r\n    const targetStats = analyseComplexValue(target);\r\n    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length &&\r\n        originStats.indexes.color.length === targetStats.indexes.color.length &&\r\n        originStats.indexes.number.length >= targetStats.indexes.number.length;\r\n    if (canInterpolate) {\r\n        if ((invisibleValues.has(origin) &&\r\n            !targetStats.values.length) ||\r\n            (invisibleValues.has(target) &&\r\n                !originStats.values.length)) {\r\n            return mixVisibility(origin, target);\r\n        }\r\n        return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);\r\n    }\r\n    else {\r\n        warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\r\n        return mixImmediate(origin, target);\r\n    }\r\n};\r\n\r\nexport { getMixer, mixArray, mixComplex, mixObject };\r\n","import { getMixer } from './complex.mjs';\r\nimport { mixNumber } from './number.mjs';\r\n\r\nfunction mix(from, to, p) {\r\n    if (typeof from === \"number\" &&\r\n        typeof to === \"number\" &&\r\n        typeof p === \"number\") {\r\n        return mixNumber(from, to, p);\r\n    }\r\n    const mixer = getMixer(from);\r\n    return mixer(from, to);\r\n}\r\n\r\nexport { mix };\r\n","import { velocityPerSecond } from '../../../utils/velocity-per-second.mjs';\r\n\r\nconst velocitySampleDuration = 5; // ms\r\nfunction calcGeneratorVelocity(resolveValue, t, current) {\r\n    const prevT = Math.max(t - velocitySampleDuration, 0);\r\n    return velocityPerSecond(current - resolveValue(prevT), t - prevT);\r\n}\r\n\r\nexport { calcGeneratorVelocity };\r\n","const springDefaults = {\r\n    // Default spring physics\r\n    stiffness: 100,\r\n    damping: 10,\r\n    mass: 1.0,\r\n    velocity: 0.0,\r\n    // Default duration/bounce-based options\r\n    duration: 800, // in ms\r\n    bounce: 0.3,\r\n    visualDuration: 0.3, // in seconds\r\n    // Rest thresholds\r\n    restSpeed: {\r\n        granular: 0.01,\r\n        default: 2,\r\n    },\r\n    restDelta: {\r\n        granular: 0.005,\r\n        default: 0.5,\r\n    },\r\n    // Limits\r\n    minDuration: 0.01, // in seconds\r\n    maxDuration: 10.0, // in seconds\r\n    minDamping: 0.05,\r\n    maxDamping: 1,\r\n};\r\n\r\nexport { springDefaults };\r\n","import { warning, secondsToMilliseconds, millisecondsToSeconds } from 'motion-utils';\r\nimport { clamp } from '../../../utils/clamp.mjs';\r\nimport { springDefaults } from './defaults.mjs';\r\n\r\nconst safeMin = 0.001;\r\nfunction findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass, }) {\r\n    let envelope;\r\n    let derivative;\r\n    warning(duration <= secondsToMilliseconds(springDefaults.maxDuration), \"Spring duration must be 10 seconds or less\");\r\n    let dampingRatio = 1 - bounce;\r\n    /**\r\n     * Restrict dampingRatio and duration to within acceptable ranges.\r\n     */\r\n    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);\r\n    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));\r\n    if (dampingRatio < 1) {\r\n        /**\r\n         * Underdamped spring\r\n         */\r\n        envelope = (undampedFreq) => {\r\n            const exponentialDecay = undampedFreq * dampingRatio;\r\n            const delta = exponentialDecay * duration;\r\n            const a = exponentialDecay - velocity;\r\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\r\n            const c = Math.exp(-delta);\r\n            return safeMin - (a / b) * c;\r\n        };\r\n        derivative = (undampedFreq) => {\r\n            const exponentialDecay = undampedFreq * dampingRatio;\r\n            const delta = exponentialDecay * duration;\r\n            const d = delta * velocity + velocity;\r\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\r\n            const f = Math.exp(-delta);\r\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\r\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\r\n            return (factor * ((d - e) * f)) / g;\r\n        };\r\n    }\r\n    else {\r\n        /**\r\n         * Critically-damped spring\r\n         */\r\n        envelope = (undampedFreq) => {\r\n            const a = Math.exp(-undampedFreq * duration);\r\n            const b = (undampedFreq - velocity) * duration + 1;\r\n            return -safeMin + a * b;\r\n        };\r\n        derivative = (undampedFreq) => {\r\n            const a = Math.exp(-undampedFreq * duration);\r\n            const b = (velocity - undampedFreq) * (duration * duration);\r\n            return a * b;\r\n        };\r\n    }\r\n    const initialGuess = 5 / duration;\r\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\r\n    duration = secondsToMilliseconds(duration);\r\n    if (isNaN(undampedFreq)) {\r\n        return {\r\n            stiffness: springDefaults.stiffness,\r\n            damping: springDefaults.damping,\r\n            duration,\r\n        };\r\n    }\r\n    else {\r\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\r\n        return {\r\n            stiffness,\r\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\r\n            duration,\r\n        };\r\n    }\r\n}\r\nconst rootIterations = 12;\r\nfunction approximateRoot(envelope, derivative, initialGuess) {\r\n    let result = initialGuess;\r\n    for (let i = 1; i < rootIterations; i++) {\r\n        result = result - envelope(result) / derivative(result);\r\n    }\r\n    return result;\r\n}\r\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\r\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\r\n}\r\n\r\nexport { calcAngularFreq, findSpring };\r\n","import { calcGeneratorDuration, maxGeneratorDuration, generateLinearEasing } from 'motion-dom';\r\nimport { millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\r\nimport { clamp } from '../../../utils/clamp.mjs';\r\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\r\nimport { springDefaults } from './defaults.mjs';\r\nimport { findSpring, calcAngularFreq } from './find.mjs';\r\n\r\nconst durationKeys = [\"duration\", \"bounce\"];\r\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\r\nfunction isSpringType(options, keys) {\r\n    return keys.some((key) => options[key] !== undefined);\r\n}\r\nfunction getSpringOptions(options) {\r\n    let springOptions = {\r\n        velocity: springDefaults.velocity,\r\n        stiffness: springDefaults.stiffness,\r\n        damping: springDefaults.damping,\r\n        mass: springDefaults.mass,\r\n        isResolvedFromDuration: false,\r\n        ...options,\r\n    };\r\n    // stiffness/damping/mass overrides duration/bounce\r\n    if (!isSpringType(options, physicsKeys) &&\r\n        isSpringType(options, durationKeys)) {\r\n        if (options.visualDuration) {\r\n            const visualDuration = options.visualDuration;\r\n            const root = (2 * Math.PI) / (visualDuration * 1.2);\r\n            const stiffness = root * root;\r\n            const damping = 2 *\r\n                clamp(0.05, 1, 1 - (options.bounce || 0)) *\r\n                Math.sqrt(stiffness);\r\n            springOptions = {\r\n                ...springOptions,\r\n                mass: springDefaults.mass,\r\n                stiffness,\r\n                damping,\r\n            };\r\n        }\r\n        else {\r\n            const derived = findSpring(options);\r\n            springOptions = {\r\n                ...springOptions,\r\n                ...derived,\r\n                mass: springDefaults.mass,\r\n            };\r\n            springOptions.isResolvedFromDuration = true;\r\n        }\r\n    }\r\n    return springOptions;\r\n}\r\nfunction spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {\r\n    const options = typeof optionsOrVisualDuration !== \"object\"\r\n        ? {\r\n            visualDuration: optionsOrVisualDuration,\r\n            keyframes: [0, 1],\r\n            bounce,\r\n        }\r\n        : optionsOrVisualDuration;\r\n    let { restSpeed, restDelta } = options;\r\n    const origin = options.keyframes[0];\r\n    const target = options.keyframes[options.keyframes.length - 1];\r\n    /**\r\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\r\n     * to reduce GC during animation.\r\n     */\r\n    const state = { done: false, value: origin };\r\n    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({\r\n        ...options,\r\n        velocity: -millisecondsToSeconds(options.velocity || 0),\r\n    });\r\n    const initialVelocity = velocity || 0.0;\r\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\r\n    const initialDelta = target - origin;\r\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\r\n    /**\r\n     * If we're working on a granular scale, use smaller defaults for determining\r\n     * when the spring is finished.\r\n     *\r\n     * These defaults have been selected emprically based on what strikes a good\r\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\r\n     */\r\n    const isGranularScale = Math.abs(initialDelta) < 5;\r\n    restSpeed || (restSpeed = isGranularScale\r\n        ? springDefaults.restSpeed.granular\r\n        : springDefaults.restSpeed.default);\r\n    restDelta || (restDelta = isGranularScale\r\n        ? springDefaults.restDelta.granular\r\n        : springDefaults.restDelta.default);\r\n    let resolveSpring;\r\n    if (dampingRatio < 1) {\r\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\r\n        // Underdamped spring\r\n        resolveSpring = (t) => {\r\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\r\n            return (target -\r\n                envelope *\r\n                    (((initialVelocity +\r\n                        dampingRatio * undampedAngularFreq * initialDelta) /\r\n                        angularFreq) *\r\n                        Math.sin(angularFreq * t) +\r\n                        initialDelta * Math.cos(angularFreq * t)));\r\n        };\r\n    }\r\n    else if (dampingRatio === 1) {\r\n        // Critically damped spring\r\n        resolveSpring = (t) => target -\r\n            Math.exp(-undampedAngularFreq * t) *\r\n                (initialDelta +\r\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\r\n    }\r\n    else {\r\n        // Overdamped spring\r\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\r\n        resolveSpring = (t) => {\r\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\r\n            // When performing sinh or cosh values can hit Infinity so we cap them here\r\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\r\n            return (target -\r\n                (envelope *\r\n                    ((initialVelocity +\r\n                        dampingRatio * undampedAngularFreq * initialDelta) *\r\n                        Math.sinh(freqForT) +\r\n                        dampedAngularFreq *\r\n                            initialDelta *\r\n                            Math.cosh(freqForT))) /\r\n                    dampedAngularFreq);\r\n        };\r\n    }\r\n    const generator = {\r\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\r\n        next: (t) => {\r\n            const current = resolveSpring(t);\r\n            if (!isResolvedFromDuration) {\r\n                let currentVelocity = 0.0;\r\n                /**\r\n                 * We only need to calculate velocity for under-damped springs\r\n                 * as over- and critically-damped springs can't overshoot, so\r\n                 * checking only for displacement is enough.\r\n                 */\r\n                if (dampingRatio < 1) {\r\n                    currentVelocity =\r\n                        t === 0\r\n                            ? secondsToMilliseconds(initialVelocity)\r\n                            : calcGeneratorVelocity(resolveSpring, t, current);\r\n                }\r\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\r\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\r\n                state.done =\r\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\r\n            }\r\n            else {\r\n                state.done = t >= duration;\r\n            }\r\n            state.value = state.done ? target : current;\r\n            return state;\r\n        },\r\n        toString: () => {\r\n            const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\r\n            const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);\r\n            return calculatedDuration + \"ms \" + easing;\r\n        },\r\n    };\r\n    return generator;\r\n}\r\n\r\nexport { spring };\r\n","import { spring } from './spring/index.mjs';\r\nimport { calcGeneratorVelocity } from './utils/velocity.mjs';\r\n\r\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {\r\n    const origin = keyframes[0];\r\n    const state = {\r\n        done: false,\r\n        value: origin,\r\n    };\r\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\r\n    const nearestBoundary = (v) => {\r\n        if (min === undefined)\r\n            return max;\r\n        if (max === undefined)\r\n            return min;\r\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\r\n    };\r\n    let amplitude = power * velocity;\r\n    const ideal = origin + amplitude;\r\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\r\n    /**\r\n     * If the target has changed we need to re-calculate the amplitude, otherwise\r\n     * the animation will start from the wrong position.\r\n     */\r\n    if (target !== ideal)\r\n        amplitude = target - origin;\r\n    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\r\n    const calcLatest = (t) => target + calcDelta(t);\r\n    const applyFriction = (t) => {\r\n        const delta = calcDelta(t);\r\n        const latest = calcLatest(t);\r\n        state.done = Math.abs(delta) <= restDelta;\r\n        state.value = state.done ? target : latest;\r\n    };\r\n    /**\r\n     * Ideally this would resolve for t in a stateless way, we could\r\n     * do that by always precalculating the animation but as we know\r\n     * this will be done anyway we can assume that spring will\r\n     * be discovered during that.\r\n     */\r\n    let timeReachedBoundary;\r\n    let spring$1;\r\n    const checkCatchBoundary = (t) => {\r\n        if (!isOutOfBounds(state.value))\r\n            return;\r\n        timeReachedBoundary = t;\r\n        spring$1 = spring({\r\n            keyframes: [state.value, nearestBoundary(state.value)],\r\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value), // TODO: This should be passing * 1000\r\n            damping: bounceDamping,\r\n            stiffness: bounceStiffness,\r\n            restDelta,\r\n            restSpeed,\r\n        });\r\n    };\r\n    checkCatchBoundary(0);\r\n    return {\r\n        calculatedDuration: null,\r\n        next: (t) => {\r\n            /**\r\n             * We need to resolve the friction to figure out if we need a\r\n             * spring but we don't want to do this twice per frame. So here\r\n             * we flag if we updated for this frame and later if we did\r\n             * we can skip doing it again.\r\n             */\r\n            let hasUpdatedFrame = false;\r\n            if (!spring$1 && timeReachedBoundary === undefined) {\r\n                hasUpdatedFrame = true;\r\n                applyFriction(t);\r\n                checkCatchBoundary(t);\r\n            }\r\n            /**\r\n             * If we have a spring and the provided t is beyond the moment the friction\r\n             * animation crossed the min/max boundary, use the spring.\r\n             */\r\n            if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {\r\n                return spring$1.next(t - timeReachedBoundary);\r\n            }\r\n            else {\r\n                !hasUpdatedFrame && applyFriction(t);\r\n                return state;\r\n            }\r\n        },\r\n    };\r\n}\r\n\r\nexport { inertia };\r\n","import { cubicBezier } from './cubic-bezier.mjs';\r\n\r\nconst easeIn = /*@__PURE__*/ cubicBezier(0.42, 0, 1, 1);\r\nconst easeOut = /*@__PURE__*/ cubicBezier(0, 0, 0.58, 1);\r\nconst easeInOut = /*@__PURE__*/ cubicBezier(0.42, 0, 0.58, 1);\r\n\r\nexport { easeIn, easeInOut, easeOut };\r\n","import { isBezierDefinition } from 'motion-dom';\r\nimport { invariant, noop } from 'motion-utils';\r\nimport { anticipate } from '../anticipate.mjs';\r\nimport { backIn, backInOut, backOut } from '../back.mjs';\r\nimport { circIn, circInOut, circOut } from '../circ.mjs';\r\nimport { cubicBezier } from '../cubic-bezier.mjs';\r\nimport { easeIn, easeInOut, easeOut } from '../ease.mjs';\r\n\r\nconst easingLookup = {\r\n    linear: noop,\r\n    easeIn,\r\n    easeInOut,\r\n    easeOut,\r\n    circIn,\r\n    circInOut,\r\n    circOut,\r\n    backIn,\r\n    backInOut,\r\n    backOut,\r\n    anticipate,\r\n};\r\nconst easingDefinitionToFunction = (definition) => {\r\n    if (isBezierDefinition(definition)) {\r\n        // If cubic bezier definition, create bezier curve\r\n        invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\r\n        const [x1, y1, x2, y2] = definition;\r\n        return cubicBezier(x1, y1, x2, y2);\r\n    }\r\n    else if (typeof definition === \"string\") {\r\n        // Else lookup from table\r\n        invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);\r\n        return easingLookup[definition];\r\n    }\r\n    return definition;\r\n};\r\n\r\nexport { easingDefinitionToFunction };\r\n","import { invariant, noop, progress } from 'motion-utils';\r\nimport { clamp } from './clamp.mjs';\r\nimport { mix } from './mix/index.mjs';\r\nimport { pipe } from './pipe.mjs';\r\n\r\nfunction createMixers(output, ease, customMixer) {\r\n    const mixers = [];\r\n    const mixerFactory = customMixer || mix;\r\n    const numMixers = output.length - 1;\r\n    for (let i = 0; i < numMixers; i++) {\r\n        let mixer = mixerFactory(output[i], output[i + 1]);\r\n        if (ease) {\r\n            const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\r\n            mixer = pipe(easingFunction, mixer);\r\n        }\r\n        mixers.push(mixer);\r\n    }\r\n    return mixers;\r\n}\r\n/**\r\n * Create a function that maps from a numerical input array to a generic output array.\r\n *\r\n * Accepts:\r\n *   - Numbers\r\n *   - Colors (hex, hsl, hsla, rgb, rgba)\r\n *   - Complex (combinations of one or more numbers or strings)\r\n *\r\n * ```jsx\r\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\r\n *\r\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\r\n * ```\r\n *\r\n * TODO Revist this approach once we've moved to data models for values,\r\n * probably not needed to pregenerate mixer functions.\r\n *\r\n * @public\r\n */\r\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\r\n    const inputLength = input.length;\r\n    invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\r\n    /**\r\n     * If we're only provided a single input, we can just make a function\r\n     * that returns the output.\r\n     */\r\n    if (inputLength === 1)\r\n        return () => output[0];\r\n    if (inputLength === 2 && output[0] === output[1])\r\n        return () => output[1];\r\n    const isZeroDeltaRange = input[0] === input[1];\r\n    // If input runs highest -> lowest, reverse both arrays\r\n    if (input[0] > input[inputLength - 1]) {\r\n        input = [...input].reverse();\r\n        output = [...output].reverse();\r\n    }\r\n    const mixers = createMixers(output, ease, mixer);\r\n    const numMixers = mixers.length;\r\n    const interpolator = (v) => {\r\n        if (isZeroDeltaRange && v < input[0])\r\n            return output[0];\r\n        let i = 0;\r\n        if (numMixers > 1) {\r\n            for (; i < input.length - 2; i++) {\r\n                if (v < input[i + 1])\r\n                    break;\r\n            }\r\n        }\r\n        const progressInRange = progress(input[i], input[i + 1], v);\r\n        return mixers[i](progressInRange);\r\n    };\r\n    return isClamp\r\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\r\n        : interpolator;\r\n}\r\n\r\nexport { interpolate };\r\n","import { fillOffset } from './fill.mjs';\r\n\r\nfunction defaultOffset(arr) {\r\n    const offset = [0];\r\n    fillOffset(offset, arr.length - 1);\r\n    return offset;\r\n}\r\n\r\nexport { defaultOffset };\r\n","import { progress } from 'motion-utils';\r\nimport { mixNumber } from '../mix/number.mjs';\r\n\r\nfunction fillOffset(offset, remaining) {\r\n    const min = offset[offset.length - 1];\r\n    for (let i = 1; i <= remaining; i++) {\r\n        const offsetProgress = progress(0, remaining, i);\r\n        offset.push(mixNumber(min, 1, offsetProgress));\r\n    }\r\n}\r\n\r\nexport { fillOffset };\r\n","import { easeInOut } from '../../easing/ease.mjs';\r\nimport { isEasingArray } from '../../easing/utils/is-easing-array.mjs';\r\nimport { easingDefinitionToFunction } from '../../easing/utils/map.mjs';\r\nimport { interpolate } from '../../utils/interpolate.mjs';\r\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\r\nimport { convertOffsetToTimes } from '../../utils/offsets/time.mjs';\r\n\r\nfunction defaultEasing(values, easing) {\r\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\r\n}\r\nfunction keyframes({ duration = 300, keyframes: keyframeValues, times, ease = \"easeInOut\", }) {\r\n    /**\r\n     * Easing functions can be externally defined as strings. Here we convert them\r\n     * into actual functions.\r\n     */\r\n    const easingFunctions = isEasingArray(ease)\r\n        ? ease.map(easingDefinitionToFunction)\r\n        : easingDefinitionToFunction(ease);\r\n    /**\r\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\r\n     * to reduce GC during animation.\r\n     */\r\n    const state = {\r\n        done: false,\r\n        value: keyframeValues[0],\r\n    };\r\n    /**\r\n     * Create a times array based on the provided 0-1 offsets\r\n     */\r\n    const absoluteTimes = convertOffsetToTimes(\r\n    // Only use the provided offsets if they're the correct length\r\n    // TODO Maybe we should warn here if there's a length mismatch\r\n    times && times.length === keyframeValues.length\r\n        ? times\r\n        : defaultOffset(keyframeValues), duration);\r\n    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {\r\n        ease: Array.isArray(easingFunctions)\r\n            ? easingFunctions\r\n            : defaultEasing(keyframeValues, easingFunctions),\r\n    });\r\n    return {\r\n        calculatedDuration: duration,\r\n        next: (t) => {\r\n            state.value = mapTimeToKeyframe(t);\r\n            state.done = t >= duration;\r\n            return state;\r\n        },\r\n    };\r\n}\r\n\r\nexport { defaultEasing, keyframes };\r\n","const isEasingArray = (ease) => {\r\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\r\n};\r\n\r\nexport { isEasingArray };\r\n","function convertOffsetToTimes(offset, duration) {\r\n    return offset.map((o) => o * duration);\r\n}\r\n\r\nexport { convertOffsetToTimes };\r\n","import { time } from '../../../frameloop/sync-time.mjs';\r\nimport { frame, cancelFrame, frameData } from '../../../frameloop/frame.mjs';\r\n\r\nconst frameloopDriver = (update) => {\r\n    const passTimestamp = ({ timestamp }) => update(timestamp);\r\n    return {\r\n        start: () => frame.update(passTimestamp, true),\r\n        stop: () => cancelFrame(passTimestamp),\r\n        /**\r\n         * If we're processing this frame we can use the\r\n         * framelocked timestamp to keep things in sync.\r\n         */\r\n        now: () => (frameData.isProcessing ? frameData.timestamp : time.now()),\r\n    };\r\n};\r\n\r\nexport { frameloopDriver };\r\n","import { isGenerator, calcGeneratorDuration } from 'motion-dom';\r\nimport { invariant, millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\r\nimport { KeyframeResolver } from '../../render/utils/KeyframesResolver.mjs';\r\nimport { clamp } from '../../utils/clamp.mjs';\r\nimport { mix } from '../../utils/mix/index.mjs';\r\nimport { pipe } from '../../utils/pipe.mjs';\r\nimport { inertia } from '../generators/inertia.mjs';\r\nimport { keyframes } from '../generators/keyframes.mjs';\r\nimport { spring } from '../generators/spring/index.mjs';\r\nimport { BaseAnimation } from './BaseAnimation.mjs';\r\nimport { frameloopDriver } from './drivers/driver-frameloop.mjs';\r\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\r\n\r\nconst generators = {\r\n    decay: inertia,\r\n    inertia,\r\n    tween: keyframes,\r\n    keyframes: keyframes,\r\n    spring,\r\n};\r\nconst percentToProgress = (percent) => percent / 100;\r\n/**\r\n * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of\r\n * features we expose publically. Mostly the compatibility is to ensure visual identity\r\n * between both WAAPI and main thread animations.\r\n */\r\nclass MainThreadAnimation extends BaseAnimation {\r\n    constructor(options) {\r\n        super(options);\r\n        /**\r\n         * The time at which the animation was paused.\r\n         */\r\n        this.holdTime = null;\r\n        /**\r\n         * The time at which the animation was cancelled.\r\n         */\r\n        this.cancelTime = null;\r\n        /**\r\n         * The current time of the animation.\r\n         */\r\n        this.currentTime = 0;\r\n        /**\r\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\r\n         */\r\n        this.playbackSpeed = 1;\r\n        /**\r\n         * The state of the animation to apply when the animation is resolved. This\r\n         * allows calls to the public API to control the animation before it is resolved,\r\n         * without us having to resolve it first.\r\n         */\r\n        this.pendingPlayState = \"running\";\r\n        /**\r\n         * The time at which the animation was started.\r\n         */\r\n        this.startTime = null;\r\n        this.state = \"idle\";\r\n        /**\r\n         * This method is bound to the instance to fix a pattern where\r\n         * animation.stop is returned as a reference from a useEffect.\r\n         */\r\n        this.stop = () => {\r\n            this.resolver.cancel();\r\n            this.isStopped = true;\r\n            if (this.state === \"idle\")\r\n                return;\r\n            this.teardown();\r\n            const { onStop } = this.options;\r\n            onStop && onStop();\r\n        };\r\n        const { name, motionValue, element, keyframes } = this.options;\r\n        const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;\r\n        const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\r\n        this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);\r\n        this.resolver.scheduleResolve();\r\n    }\r\n    flatten() {\r\n        super.flatten();\r\n        // If we've already resolved the animation, re-initialise it\r\n        if (this._resolved) {\r\n            Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));\r\n        }\r\n    }\r\n    initPlayback(keyframes$1) {\r\n        const { type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = this.options;\r\n        const generatorFactory = isGenerator(type)\r\n            ? type\r\n            : generators[type] || keyframes;\r\n        /**\r\n         * If our generator doesn't support mixing numbers, we need to replace keyframes with\r\n         * [0, 100] and then make a function that maps that to the actual keyframes.\r\n         *\r\n         * 100 is chosen instead of 1 as it works nicer with spring animations.\r\n         */\r\n        let mapPercentToKeyframes;\r\n        let mirroredGenerator;\r\n        if (generatorFactory !== keyframes &&\r\n            typeof keyframes$1[0] !== \"number\") {\r\n            if (process.env.NODE_ENV !== \"production\") {\r\n                invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\r\n            }\r\n            mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\r\n            keyframes$1 = [0, 100];\r\n        }\r\n        const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });\r\n        /**\r\n         * If we have a mirror repeat type we need to create a second generator that outputs the\r\n         * mirrored (not reversed) animation and later ping pong between the two generators.\r\n         */\r\n        if (repeatType === \"mirror\") {\r\n            mirroredGenerator = generatorFactory({\r\n                ...this.options,\r\n                keyframes: [...keyframes$1].reverse(),\r\n                velocity: -velocity,\r\n            });\r\n        }\r\n        /**\r\n         * If duration is undefined and we have repeat options,\r\n         * we need to calculate a duration from the generator.\r\n         *\r\n         * We set it to the generator itself to cache the duration.\r\n         * Any timeline resolver will need to have already precalculated\r\n         * the duration by this step.\r\n         */\r\n        if (generator.calculatedDuration === null) {\r\n            generator.calculatedDuration = calcGeneratorDuration(generator);\r\n        }\r\n        const { calculatedDuration } = generator;\r\n        const resolvedDuration = calculatedDuration + repeatDelay;\r\n        const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\r\n        return {\r\n            generator,\r\n            mirroredGenerator,\r\n            mapPercentToKeyframes,\r\n            calculatedDuration,\r\n            resolvedDuration,\r\n            totalDuration,\r\n        };\r\n    }\r\n    onPostResolved() {\r\n        const { autoplay = true } = this.options;\r\n        this.play();\r\n        if (this.pendingPlayState === \"paused\" || !autoplay) {\r\n            this.pause();\r\n        }\r\n        else {\r\n            this.state = this.pendingPlayState;\r\n        }\r\n    }\r\n    tick(timestamp, sample = false) {\r\n        const { resolved } = this;\r\n        // If the animations has failed to resolve, return the final keyframe.\r\n        if (!resolved) {\r\n            const { keyframes } = this.options;\r\n            return { done: true, value: keyframes[keyframes.length - 1] };\r\n        }\r\n        const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes, calculatedDuration, totalDuration, resolvedDuration, } = resolved;\r\n        if (this.startTime === null)\r\n            return generator.next(0);\r\n        const { delay, repeat, repeatType, repeatDelay, onUpdate } = this.options;\r\n        /**\r\n         * requestAnimationFrame timestamps can come through as lower than\r\n         * the startTime as set by performance.now(). Here we prevent this,\r\n         * though in the future it could be possible to make setting startTime\r\n         * a pending operation that gets resolved here.\r\n         */\r\n        if (this.speed > 0) {\r\n            this.startTime = Math.min(this.startTime, timestamp);\r\n        }\r\n        else if (this.speed < 0) {\r\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\r\n        }\r\n        // Update currentTime\r\n        if (sample) {\r\n            this.currentTime = timestamp;\r\n        }\r\n        else if (this.holdTime !== null) {\r\n            this.currentTime = this.holdTime;\r\n        }\r\n        else {\r\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\r\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\r\n            // example.\r\n            this.currentTime =\r\n                Math.round(timestamp - this.startTime) * this.speed;\r\n        }\r\n        // Rebase on delay\r\n        const timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);\r\n        const isInDelayPhase = this.speed >= 0\r\n            ? timeWithoutDelay < 0\r\n            : timeWithoutDelay > totalDuration;\r\n        this.currentTime = Math.max(timeWithoutDelay, 0);\r\n        // If this animation has finished, set the current time  to the total duration.\r\n        if (this.state === \"finished\" && this.holdTime === null) {\r\n            this.currentTime = totalDuration;\r\n        }\r\n        let elapsed = this.currentTime;\r\n        let frameGenerator = generator;\r\n        if (repeat) {\r\n            /**\r\n             * Get the current progress (0-1) of the animation. If t is >\r\n             * than duration we'll get values like 2.5 (midway through the\r\n             * third iteration)\r\n             */\r\n            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\r\n            /**\r\n             * Get the current iteration (0 indexed). For instance the floor of\r\n             * 2.5 is 2.\r\n             */\r\n            let currentIteration = Math.floor(progress);\r\n            /**\r\n             * Get the current progress of the iteration by taking the remainder\r\n             * so 2.5 is 0.5 through iteration 2\r\n             */\r\n            let iterationProgress = progress % 1.0;\r\n            /**\r\n             * If iteration progress is 1 we count that as the end\r\n             * of the previous iteration.\r\n             */\r\n            if (!iterationProgress && progress >= 1) {\r\n                iterationProgress = 1;\r\n            }\r\n            iterationProgress === 1 && currentIteration--;\r\n            currentIteration = Math.min(currentIteration, repeat + 1);\r\n            /**\r\n             * Reverse progress if we're not running in \"normal\" direction\r\n             */\r\n            const isOddIteration = Boolean(currentIteration % 2);\r\n            if (isOddIteration) {\r\n                if (repeatType === \"reverse\") {\r\n                    iterationProgress = 1 - iterationProgress;\r\n                    if (repeatDelay) {\r\n                        iterationProgress -= repeatDelay / resolvedDuration;\r\n                    }\r\n                }\r\n                else if (repeatType === \"mirror\") {\r\n                    frameGenerator = mirroredGenerator;\r\n                }\r\n            }\r\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\r\n        }\r\n        /**\r\n         * If we're in negative time, set state as the initial keyframe.\r\n         * This prevents delay: x, duration: 0 animations from finishing\r\n         * instantly.\r\n         */\r\n        const state = isInDelayPhase\r\n            ? { done: false, value: keyframes[0] }\r\n            : frameGenerator.next(elapsed);\r\n        if (mapPercentToKeyframes) {\r\n            state.value = mapPercentToKeyframes(state.value);\r\n        }\r\n        let { done } = state;\r\n        if (!isInDelayPhase && calculatedDuration !== null) {\r\n            done =\r\n                this.speed >= 0\r\n                    ? this.currentTime >= totalDuration\r\n                    : this.currentTime <= 0;\r\n        }\r\n        const isAnimationFinished = this.holdTime === null &&\r\n            (this.state === \"finished\" || (this.state === \"running\" && done));\r\n        if (isAnimationFinished && finalKeyframe !== undefined) {\r\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);\r\n        }\r\n        if (onUpdate) {\r\n            onUpdate(state.value);\r\n        }\r\n        if (isAnimationFinished) {\r\n            this.finish();\r\n        }\r\n        return state;\r\n    }\r\n    get duration() {\r\n        const { resolved } = this;\r\n        return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;\r\n    }\r\n    get time() {\r\n        return millisecondsToSeconds(this.currentTime);\r\n    }\r\n    set time(newTime) {\r\n        newTime = secondsToMilliseconds(newTime);\r\n        this.currentTime = newTime;\r\n        if (this.holdTime !== null || this.speed === 0) {\r\n            this.holdTime = newTime;\r\n        }\r\n        else if (this.driver) {\r\n            this.startTime = this.driver.now() - newTime / this.speed;\r\n        }\r\n    }\r\n    get speed() {\r\n        return this.playbackSpeed;\r\n    }\r\n    set speed(newSpeed) {\r\n        const hasChanged = this.playbackSpeed !== newSpeed;\r\n        this.playbackSpeed = newSpeed;\r\n        if (hasChanged) {\r\n            this.time = millisecondsToSeconds(this.currentTime);\r\n        }\r\n    }\r\n    play() {\r\n        if (!this.resolver.isScheduled) {\r\n            this.resolver.resume();\r\n        }\r\n        if (!this._resolved) {\r\n            this.pendingPlayState = \"running\";\r\n            return;\r\n        }\r\n        if (this.isStopped)\r\n            return;\r\n        const { driver = frameloopDriver, onPlay, startTime } = this.options;\r\n        if (!this.driver) {\r\n            this.driver = driver((timestamp) => this.tick(timestamp));\r\n        }\r\n        onPlay && onPlay();\r\n        const now = this.driver.now();\r\n        if (this.holdTime !== null) {\r\n            this.startTime = now - this.holdTime;\r\n        }\r\n        else if (!this.startTime) {\r\n            this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\r\n        }\r\n        else if (this.state === \"finished\") {\r\n            this.startTime = now;\r\n        }\r\n        if (this.state === \"finished\") {\r\n            this.updateFinishedPromise();\r\n        }\r\n        this.cancelTime = this.startTime;\r\n        this.holdTime = null;\r\n        /**\r\n         * Set playState to running only after we've used it in\r\n         * the previous logic.\r\n         */\r\n        this.state = \"running\";\r\n        this.driver.start();\r\n    }\r\n    pause() {\r\n        var _a;\r\n        if (!this._resolved) {\r\n            this.pendingPlayState = \"paused\";\r\n            return;\r\n        }\r\n        this.state = \"paused\";\r\n        this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\r\n    }\r\n    complete() {\r\n        if (this.state !== \"running\") {\r\n            this.play();\r\n        }\r\n        this.pendingPlayState = this.state = \"finished\";\r\n        this.holdTime = null;\r\n    }\r\n    finish() {\r\n        this.teardown();\r\n        this.state = \"finished\";\r\n        const { onComplete } = this.options;\r\n        onComplete && onComplete();\r\n    }\r\n    cancel() {\r\n        if (this.cancelTime !== null) {\r\n            this.tick(this.cancelTime);\r\n        }\r\n        this.teardown();\r\n        this.updateFinishedPromise();\r\n    }\r\n    teardown() {\r\n        this.state = \"idle\";\r\n        this.stopDriver();\r\n        this.resolveFinishedPromise();\r\n        this.updateFinishedPromise();\r\n        this.startTime = this.cancelTime = null;\r\n        this.resolver.cancel();\r\n    }\r\n    stopDriver() {\r\n        if (!this.driver)\r\n            return;\r\n        this.driver.stop();\r\n        this.driver = undefined;\r\n    }\r\n    sample(time) {\r\n        this.startTime = 0;\r\n        return this.tick(time, true);\r\n    }\r\n}\r\n// Legacy interface\r\nfunction animateValue(options) {\r\n    return new MainThreadAnimation(options);\r\n}\r\n\r\nexport { MainThreadAnimation, animateValue };\r\n","/**\r\n * A list of values that can be hardware-accelerated.\r\n */\r\nconst acceleratedValues = new Set([\r\n    \"opacity\",\r\n    \"clipPath\",\r\n    \"filter\",\r\n    \"transform\",\r\n    // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved\r\n    // or until we implement support for linear() easing.\r\n    // \"background-color\"\r\n]);\r\n\r\nexport { acceleratedValues };\r\n","import { mapEasingToNativeEasing } from 'motion-dom';\r\n\r\nfunction startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = \"loop\", ease = \"easeInOut\", times, } = {}) {\r\n    const keyframeOptions = { [valueName]: keyframes };\r\n    if (times)\r\n        keyframeOptions.offset = times;\r\n    const easing = mapEasingToNativeEasing(ease, duration);\r\n    /**\r\n     * If this is an easing array, apply to keyframes, not animation as a whole\r\n     */\r\n    if (Array.isArray(easing))\r\n        keyframeOptions.easing = easing;\r\n    return element.animate(keyframeOptions, {\r\n        delay,\r\n        duration,\r\n        easing: !Array.isArray(easing) ? easing : \"linear\",\r\n        fill: \"both\",\r\n        iterations: repeat + 1,\r\n        direction: repeatType === \"reverse\" ? \"alternate\" : \"normal\",\r\n    });\r\n}\r\n\r\nexport { startWaapiAnimation };\r\n","import { memo } from 'motion-utils';\r\n\r\nconst supportsWaapi = /*@__PURE__*/ memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\r\n\r\nexport { supportsWaapi };\r\n","import { supportsLinearEasing, attachTimeline, isGenerator, isWaapiSupportedEasing } from 'motion-dom';\r\nimport { millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\r\nimport { anticipate } from '../../easing/anticipate.mjs';\r\nimport { backInOut } from '../../easing/back.mjs';\r\nimport { circInOut } from '../../easing/circ.mjs';\r\nimport { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\r\nimport { BaseAnimation } from './BaseAnimation.mjs';\r\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\r\nimport { acceleratedValues } from './utils/accelerated-values.mjs';\r\nimport { startWaapiAnimation } from './waapi/index.mjs';\r\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\r\nimport { supportsWaapi } from './waapi/utils/supports-waapi.mjs';\r\n\r\n/**\r\n * 10ms is chosen here as it strikes a balance between smooth\r\n * results (more than one keyframe per frame at 60fps) and\r\n * keyframe quantity.\r\n */\r\nconst sampleDelta = 10; //ms\r\n/**\r\n * Implement a practical max duration for keyframe generation\r\n * to prevent infinite loops\r\n */\r\nconst maxDuration = 20000;\r\n/**\r\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\r\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\r\n * handing off.\r\n */\r\nfunction requiresPregeneratedKeyframes(options) {\r\n    return (isGenerator(options.type) ||\r\n        options.type === \"spring\" ||\r\n        !isWaapiSupportedEasing(options.ease));\r\n}\r\nfunction pregenerateKeyframes(keyframes, options) {\r\n    /**\r\n     * Create a main-thread animation to pregenerate keyframes.\r\n     * We sample this at regular intervals to generate keyframes that we then\r\n     * linearly interpolate between.\r\n     */\r\n    const sampleAnimation = new MainThreadAnimation({\r\n        ...options,\r\n        keyframes,\r\n        repeat: 0,\r\n        delay: 0,\r\n        isGenerator: true,\r\n    });\r\n    let state = { done: false, value: keyframes[0] };\r\n    const pregeneratedKeyframes = [];\r\n    /**\r\n     * Bail after 20 seconds of pre-generated keyframes as it's likely\r\n     * we're heading for an infinite loop.\r\n     */\r\n    let t = 0;\r\n    while (!state.done && t < maxDuration) {\r\n        state = sampleAnimation.sample(t);\r\n        pregeneratedKeyframes.push(state.value);\r\n        t += sampleDelta;\r\n    }\r\n    return {\r\n        times: undefined,\r\n        keyframes: pregeneratedKeyframes,\r\n        duration: t - sampleDelta,\r\n        ease: \"linear\",\r\n    };\r\n}\r\nconst unsupportedEasingFunctions = {\r\n    anticipate,\r\n    backInOut,\r\n    circInOut,\r\n};\r\nfunction isUnsupportedEase(key) {\r\n    return key in unsupportedEasingFunctions;\r\n}\r\nclass AcceleratedAnimation extends BaseAnimation {\r\n    constructor(options) {\r\n        super(options);\r\n        const { name, motionValue, element, keyframes } = this.options;\r\n        this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);\r\n        this.resolver.scheduleResolve();\r\n    }\r\n    initPlayback(keyframes, finalKeyframe) {\r\n        let { duration = 300, times, ease, type, motionValue, name, startTime, } = this.options;\r\n        /**\r\n         * If element has since been unmounted, return false to indicate\r\n         * the animation failed to initialised.\r\n         */\r\n        if (!motionValue.owner || !motionValue.owner.current) {\r\n            return false;\r\n        }\r\n        /**\r\n         * If the user has provided an easing function name that isn't supported\r\n         * by WAAPI (like \"anticipate\"), we need to provide the corressponding\r\n         * function. This will later get converted to a linear() easing function.\r\n         */\r\n        if (typeof ease === \"string\" &&\r\n            supportsLinearEasing() &&\r\n            isUnsupportedEase(ease)) {\r\n            ease = unsupportedEasingFunctions[ease];\r\n        }\r\n        /**\r\n         * If this animation needs pre-generated keyframes then generate.\r\n         */\r\n        if (requiresPregeneratedKeyframes(this.options)) {\r\n            const { onComplete, onUpdate, motionValue, element, ...options } = this.options;\r\n            const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\r\n            keyframes = pregeneratedAnimation.keyframes;\r\n            // If this is a very short animation, ensure we have\r\n            // at least two keyframes to animate between as older browsers\r\n            // can't animate between a single keyframe.\r\n            if (keyframes.length === 1) {\r\n                keyframes[1] = keyframes[0];\r\n            }\r\n            duration = pregeneratedAnimation.duration;\r\n            times = pregeneratedAnimation.times;\r\n            ease = pregeneratedAnimation.ease;\r\n            type = \"keyframes\";\r\n        }\r\n        const animation = startWaapiAnimation(motionValue.owner.current, name, keyframes, { ...this.options, duration, times, ease });\r\n        // Override the browser calculated startTime with one synchronised to other JS\r\n        // and WAAPI animations starting this event loop.\r\n        animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\r\n        if (this.pendingTimeline) {\r\n            attachTimeline(animation, this.pendingTimeline);\r\n            this.pendingTimeline = undefined;\r\n        }\r\n        else {\r\n            /**\r\n             * Prefer the `onfinish` prop as it's more widely supported than\r\n             * the `finished` promise.\r\n             *\r\n             * Here, we synchronously set the provided MotionValue to the end\r\n             * keyframe. If we didn't, when the WAAPI animation is finished it would\r\n             * be removed from the element which would then revert to its old styles.\r\n             */\r\n            animation.onfinish = () => {\r\n                const { onComplete } = this.options;\r\n                motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));\r\n                onComplete && onComplete();\r\n                this.cancel();\r\n                this.resolveFinishedPromise();\r\n            };\r\n        }\r\n        return {\r\n            animation,\r\n            duration,\r\n            times,\r\n            type,\r\n            ease,\r\n            keyframes: keyframes,\r\n        };\r\n    }\r\n    get duration() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return 0;\r\n        const { duration } = resolved;\r\n        return millisecondsToSeconds(duration);\r\n    }\r\n    get time() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return 0;\r\n        const { animation } = resolved;\r\n        return millisecondsToSeconds(animation.currentTime || 0);\r\n    }\r\n    set time(newTime) {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        const { animation } = resolved;\r\n        animation.currentTime = secondsToMilliseconds(newTime);\r\n    }\r\n    get speed() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return 1;\r\n        const { animation } = resolved;\r\n        return animation.playbackRate;\r\n    }\r\n    set speed(newSpeed) {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        const { animation } = resolved;\r\n        animation.playbackRate = newSpeed;\r\n    }\r\n    get state() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return \"idle\";\r\n        const { animation } = resolved;\r\n        return animation.playState;\r\n    }\r\n    get startTime() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return null;\r\n        const { animation } = resolved;\r\n        // Coerce to number as TypeScript incorrectly types this\r\n        // as CSSNumberish\r\n        return animation.startTime;\r\n    }\r\n    /**\r\n     * Replace the default DocumentTimeline with another AnimationTimeline.\r\n     * Currently used for scroll animations.\r\n     */\r\n    attachTimeline(timeline) {\r\n        if (!this._resolved) {\r\n            this.pendingTimeline = timeline;\r\n        }\r\n        else {\r\n            const { resolved } = this;\r\n            if (!resolved)\r\n                return noop;\r\n            const { animation } = resolved;\r\n            attachTimeline(animation, timeline);\r\n        }\r\n        return noop;\r\n    }\r\n    play() {\r\n        if (this.isStopped)\r\n            return;\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        const { animation } = resolved;\r\n        if (animation.playState === \"finished\") {\r\n            this.updateFinishedPromise();\r\n        }\r\n        animation.play();\r\n    }\r\n    pause() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        const { animation } = resolved;\r\n        animation.pause();\r\n    }\r\n    stop() {\r\n        this.resolver.cancel();\r\n        this.isStopped = true;\r\n        if (this.state === \"idle\")\r\n            return;\r\n        this.resolveFinishedPromise();\r\n        this.updateFinishedPromise();\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        const { animation, keyframes, duration, type, ease, times } = resolved;\r\n        if (animation.playState === \"idle\" ||\r\n            animation.playState === \"finished\") {\r\n            return;\r\n        }\r\n        /**\r\n         * WAAPI doesn't natively have any interruption capabilities.\r\n         *\r\n         * Rather than read commited styles back out of the DOM, we can\r\n         * create a renderless JS animation and sample it twice to calculate\r\n         * its current value, \"previous\" value, and therefore allow\r\n         * Motion to calculate velocity for any subsequent animation.\r\n         */\r\n        if (this.time) {\r\n            const { motionValue, onUpdate, onComplete, element, ...options } = this.options;\r\n            const sampleAnimation = new MainThreadAnimation({\r\n                ...options,\r\n                keyframes,\r\n                duration,\r\n                type,\r\n                ease,\r\n                times,\r\n                isGenerator: true,\r\n            });\r\n            const sampleTime = secondsToMilliseconds(this.time);\r\n            motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\r\n        }\r\n        const { onStop } = this.options;\r\n        onStop && onStop();\r\n        this.cancel();\r\n    }\r\n    complete() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        resolved.animation.finish();\r\n    }\r\n    cancel() {\r\n        const { resolved } = this;\r\n        if (!resolved)\r\n            return;\r\n        resolved.animation.cancel();\r\n    }\r\n    static supports(options) {\r\n        const { motionValue, name, repeatDelay, repeatType, damping, type } = options;\r\n        if (!motionValue ||\r\n            !motionValue.owner ||\r\n            !(motionValue.owner.current instanceof HTMLElement)) {\r\n            return false;\r\n        }\r\n        const { onUpdate, transformTemplate } = motionValue.owner.getProps();\r\n        return (supportsWaapi() &&\r\n            name &&\r\n            acceleratedValues.has(name) &&\r\n            /**\r\n             * If we're outputting values to onUpdate then we can't use WAAPI as there's\r\n             * no way to read the value from WAAPI every frame.\r\n             */\r\n            !onUpdate &&\r\n            !transformTemplate &&\r\n            !repeatDelay &&\r\n            repeatType !== \"mirror\" &&\r\n            damping !== 0 &&\r\n            type !== \"inertia\");\r\n    }\r\n}\r\n\r\nexport { AcceleratedAnimation };\r\n","import { transformProps } from '../../render/html/utils/keys-transform.mjs';\r\n\r\nconst underDampedSpring = {\r\n    type: \"spring\",\r\n    stiffness: 500,\r\n    damping: 25,\r\n    restSpeed: 10,\r\n};\r\nconst criticallyDampedSpring = (target) => ({\r\n    type: \"spring\",\r\n    stiffness: 550,\r\n    damping: target === 0 ? 2 * Math.sqrt(550) : 30,\r\n    restSpeed: 10,\r\n});\r\nconst keyframesTransition = {\r\n    type: \"keyframes\",\r\n    duration: 0.8,\r\n};\r\n/**\r\n * Default easing curve is a slightly shallower version of\r\n * the default browser easing curve.\r\n */\r\nconst ease = {\r\n    type: \"keyframes\",\r\n    ease: [0.25, 0.1, 0.35, 1],\r\n    duration: 0.3,\r\n};\r\nconst getDefaultTransition = (valueKey, { keyframes }) => {\r\n    if (keyframes.length > 2) {\r\n        return keyframesTransition;\r\n    }\r\n    else if (transformProps.has(valueKey)) {\r\n        return valueKey.startsWith(\"scale\")\r\n            ? criticallyDampedSpring(keyframes[1])\r\n            : underDampedSpring;\r\n    }\r\n    return ease;\r\n};\r\n\r\nexport { getDefaultTransition };\r\n","import { getValueTransition, GroupPlaybackControls } from 'motion-dom';\r\nimport { secondsToMilliseconds } from 'motion-utils';\r\nimport { frame } from '../../frameloop/frame.mjs';\r\nimport { MotionGlobalConfig } from '../../utils/GlobalConfig.mjs';\r\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\r\nimport { AcceleratedAnimation } from '../animators/AcceleratedAnimation.mjs';\r\nimport { MainThreadAnimation } from '../animators/MainThreadAnimation.mjs';\r\nimport { getFinalKeyframe } from '../animators/waapi/utils/get-final-keyframe.mjs';\r\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\r\nimport { isTransitionDefined } from '../utils/is-transition-defined.mjs';\r\n\r\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {\r\n    const valueTransition = getValueTransition(transition, name) || {};\r\n    /**\r\n     * Most transition values are currently completely overwritten by value-specific\r\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\r\n     * delay actually does inherit from the root transition if not value-specific.\r\n     */\r\n    const delay = valueTransition.delay || transition.delay || 0;\r\n    /**\r\n     * Elapsed isn't a public transition option but can be passed through from\r\n     * optimized appear effects in milliseconds.\r\n     */\r\n    let { elapsed = 0 } = transition;\r\n    elapsed = elapsed - secondsToMilliseconds(delay);\r\n    let options = {\r\n        keyframes: Array.isArray(target) ? target : [null, target],\r\n        ease: \"easeOut\",\r\n        velocity: value.getVelocity(),\r\n        ...valueTransition,\r\n        delay: -elapsed,\r\n        onUpdate: (v) => {\r\n            value.set(v);\r\n            valueTransition.onUpdate && valueTransition.onUpdate(v);\r\n        },\r\n        onComplete: () => {\r\n            onComplete();\r\n            valueTransition.onComplete && valueTransition.onComplete();\r\n        },\r\n        name,\r\n        motionValue: value,\r\n        element: isHandoff ? undefined : element,\r\n    };\r\n    /**\r\n     * If there's no transition defined for this value, we can generate\r\n     * unqiue transition settings for this value.\r\n     */\r\n    if (!isTransitionDefined(valueTransition)) {\r\n        options = {\r\n            ...options,\r\n            ...getDefaultTransition(name, options),\r\n        };\r\n    }\r\n    /**\r\n     * Both WAAPI and our internal animation functions use durations\r\n     * as defined by milliseconds, while our external API defines them\r\n     * as seconds.\r\n     */\r\n    if (options.duration) {\r\n        options.duration = secondsToMilliseconds(options.duration);\r\n    }\r\n    if (options.repeatDelay) {\r\n        options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\r\n    }\r\n    if (options.from !== undefined) {\r\n        options.keyframes[0] = options.from;\r\n    }\r\n    let shouldSkip = false;\r\n    if (options.type === false ||\r\n        (options.duration === 0 && !options.repeatDelay)) {\r\n        options.duration = 0;\r\n        if (options.delay === 0) {\r\n            shouldSkip = true;\r\n        }\r\n    }\r\n    if (instantAnimationState.current ||\r\n        MotionGlobalConfig.skipAnimations) {\r\n        shouldSkip = true;\r\n        options.duration = 0;\r\n        options.delay = 0;\r\n    }\r\n    /**\r\n     * If we can or must skip creating the animation, and apply only\r\n     * the final keyframe, do so. We also check once keyframes are resolved but\r\n     * this early check prevents the need to create an animation at all.\r\n     */\r\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\r\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\r\n        if (finalKeyframe !== undefined) {\r\n            frame.update(() => {\r\n                options.onUpdate(finalKeyframe);\r\n                options.onComplete();\r\n            });\r\n            // We still want to return some animation controls here rather\r\n            // than returning undefined\r\n            return new GroupPlaybackControls([]);\r\n        }\r\n    }\r\n    /**\r\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\r\n     * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\r\n     * optimised animation.\r\n     */\r\n    if (!isHandoff && AcceleratedAnimation.supports(options)) {\r\n        return new AcceleratedAnimation(options);\r\n    }\r\n    else {\r\n        return new MainThreadAnimation(options);\r\n    }\r\n};\r\n\r\nexport { animateMotionValue };\r\n","/**\r\n * Decide whether a transition is defined on a given Transition.\r\n * This filters out orchestration options and returns true\r\n * if any options are left.\r\n */\r\nfunction isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {\r\n    return !!Object.keys(transition).length;\r\n}\r\n\r\nexport { isTransitionDefined };\r\n","import { getValueTransition } from 'motion-dom';\r\nimport { positionalKeys } from '../../render/html/utils/keys-position.mjs';\r\nimport { setTarget } from '../../render/utils/setters.mjs';\r\nimport { addValueToWillChange } from '../../value/use-will-change/add-will-change.mjs';\r\nimport { getOptimisedAppearId } from '../optimized-appear/get-appear-id.mjs';\r\nimport { animateMotionValue } from './motion-value.mjs';\r\nimport { frame } from '../../frameloop/frame.mjs';\r\n\r\n/**\r\n * Decide whether we should block this animation. Previously, we achieved this\r\n * just by checking whether the key was listed in protectedKeys, but this\r\n * posed problems if an animation was triggered by afterChildren and protectedKeys\r\n * had been set to true in the meantime.\r\n */\r\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\r\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\r\n    needsAnimating[key] = false;\r\n    return shouldBlock;\r\n}\r\nfunction animateTarget(visualElement, targetAndTransition, { delay = 0, transitionOverride, type } = {}) {\r\n    var _a;\r\n    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;\r\n    if (transitionOverride)\r\n        transition = transitionOverride;\r\n    const animations = [];\r\n    const animationTypeState = type &&\r\n        visualElement.animationState &&\r\n        visualElement.animationState.getState()[type];\r\n    for (const key in target) {\r\n        const value = visualElement.getValue(key, (_a = visualElement.latestValues[key]) !== null && _a !== void 0 ? _a : null);\r\n        const valueTarget = target[key];\r\n        if (valueTarget === undefined ||\r\n            (animationTypeState &&\r\n                shouldBlockAnimation(animationTypeState, key))) {\r\n            continue;\r\n        }\r\n        const valueTransition = {\r\n            delay,\r\n            ...getValueTransition(transition || {}, key),\r\n        };\r\n        /**\r\n         * If this is the first time a value is being animated, check\r\n         * to see if we're handling off from an existing animation.\r\n         */\r\n        let isHandoff = false;\r\n        if (window.MotionHandoffAnimation) {\r\n            const appearId = getOptimisedAppearId(visualElement);\r\n            if (appearId) {\r\n                const startTime = window.MotionHandoffAnimation(appearId, key, frame);\r\n                if (startTime !== null) {\r\n                    valueTransition.startTime = startTime;\r\n                    isHandoff = true;\r\n                }\r\n            }\r\n        }\r\n        addValueToWillChange(visualElement, key);\r\n        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key)\r\n            ? { type: false }\r\n            : valueTransition, visualElement, isHandoff));\r\n        const animation = value.animation;\r\n        if (animation) {\r\n            animations.push(animation);\r\n        }\r\n    }\r\n    if (transitionEnd) {\r\n        Promise.all(animations).then(() => {\r\n            frame.update(() => {\r\n                transitionEnd && setTarget(visualElement, transitionEnd);\r\n            });\r\n        });\r\n    }\r\n    return animations;\r\n}\r\n\r\nexport { animateTarget };\r\n","import { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';\r\nimport { animateTarget } from './visual-element-target.mjs';\r\n\r\nfunction animateVariant(visualElement, variant, options = {}) {\r\n    var _a;\r\n    const resolved = resolveVariant(visualElement, variant, options.type === \"exit\"\r\n        ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom\r\n        : undefined);\r\n    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\r\n    if (options.transitionOverride) {\r\n        transition = options.transitionOverride;\r\n    }\r\n    /**\r\n     * If we have a variant, create a callback that runs it as an animation.\r\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\r\n     */\r\n    const getAnimation = resolved\r\n        ? () => Promise.all(animateTarget(visualElement, resolved, options))\r\n        : () => Promise.resolve();\r\n    /**\r\n     * If we have children, create a callback that runs all their animations.\r\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\r\n     */\r\n    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size\r\n        ? (forwardDelay = 0) => {\r\n            const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;\r\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\r\n        }\r\n        : () => Promise.resolve();\r\n    /**\r\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\r\n     * this animation or all children animations before playing the other.\r\n     */\r\n    const { when } = transition;\r\n    if (when) {\r\n        const [first, last] = when === \"beforeChildren\"\r\n            ? [getAnimation, getChildAnimations]\r\n            : [getChildAnimations, getAnimation];\r\n        return first().then(() => last());\r\n    }\r\n    else {\r\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\r\n    }\r\n}\r\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\r\n    const animations = [];\r\n    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\r\n    const generateStaggerDuration = staggerDirection === 1\r\n        ? (i = 0) => i * staggerChildren\r\n        : (i = 0) => maxStaggerDuration - i * staggerChildren;\r\n    Array.from(visualElement.variantChildren)\r\n        .sort(sortByTreeOrder)\r\n        .forEach((child, i) => {\r\n        child.notify(\"AnimationStart\", variant);\r\n        animations.push(animateVariant(child, variant, {\r\n            ...options,\r\n            delay: delayChildren + generateStaggerDuration(i),\r\n        }).then(() => child.notify(\"AnimationComplete\", variant)));\r\n    });\r\n    return Promise.all(animations);\r\n}\r\nfunction sortByTreeOrder(a, b) {\r\n    return a.sortNodePosition(b);\r\n}\r\n\r\nexport { animateVariant, sortByTreeOrder };\r\n","import { isVariantLabel } from './is-variant-label.mjs';\r\nimport { variantProps } from './variant-props.mjs';\r\n\r\nconst numVariantProps = variantProps.length;\r\nfunction getVariantContext(visualElement) {\r\n    if (!visualElement)\r\n        return undefined;\r\n    if (!visualElement.isControllingVariants) {\r\n        const context = visualElement.parent\r\n            ? getVariantContext(visualElement.parent) || {}\r\n            : {};\r\n        if (visualElement.props.initial !== undefined) {\r\n            context.initial = visualElement.props.initial;\r\n        }\r\n        return context;\r\n    }\r\n    const context = {};\r\n    for (let i = 0; i < numVariantProps; i++) {\r\n        const name = variantProps[i];\r\n        const prop = visualElement.props[name];\r\n        if (isVariantLabel(prop) || prop === false) {\r\n            context[name] = prop;\r\n        }\r\n    }\r\n    return context;\r\n}\r\n\r\nexport { getVariantContext };\r\n","import { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\r\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';\r\nimport { shallowCompare } from '../../utils/shallow-compare.mjs';\r\nimport { isVariantLabel } from './is-variant-label.mjs';\r\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\r\nimport { variantPriorityOrder } from './variant-props.mjs';\r\nimport { animateVisualElement } from '../../animation/interfaces/visual-element.mjs';\r\nimport { getVariantContext } from './get-variant-context.mjs';\r\n\r\nconst reversePriorityOrder = [...variantPriorityOrder].reverse();\r\nconst numAnimationTypes = variantPriorityOrder.length;\r\nfunction animateList(visualElement) {\r\n    return (animations) => Promise.all(animations.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\r\n}\r\nfunction createAnimationState(visualElement) {\r\n    let animate = animateList(visualElement);\r\n    let state = createState();\r\n    let isInitialRender = true;\r\n    /**\r\n     * This function will be used to reduce the animation definitions for\r\n     * each active animation type into an object of resolved values for it.\r\n     */\r\n    const buildResolvedTypeValues = (type) => (acc, definition) => {\r\n        var _a;\r\n        const resolved = resolveVariant(visualElement, definition, type === \"exit\"\r\n            ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom\r\n            : undefined);\r\n        if (resolved) {\r\n            const { transition, transitionEnd, ...target } = resolved;\r\n            acc = { ...acc, ...target, ...transitionEnd };\r\n        }\r\n        return acc;\r\n    };\r\n    /**\r\n     * This just allows us to inject mocked animation functions\r\n     * @internal\r\n     */\r\n    function setAnimateFunction(makeAnimator) {\r\n        animate = makeAnimator(visualElement);\r\n    }\r\n    /**\r\n     * When we receive new props, we need to:\r\n     * 1. Create a list of protected keys for each type. This is a directory of\r\n     *    value keys that are currently being \"handled\" by types of a higher priority\r\n     *    so that whenever an animation is played of a given type, these values are\r\n     *    protected from being animated.\r\n     * 2. Determine if an animation type needs animating.\r\n     * 3. Determine if any values have been removed from a type and figure out\r\n     *    what to animate those to.\r\n     */\r\n    function animateChanges(changedActiveType) {\r\n        const { props } = visualElement;\r\n        const context = getVariantContext(visualElement.parent) || {};\r\n        /**\r\n         * A list of animations that we'll build into as we iterate through the animation\r\n         * types. This will get executed at the end of the function.\r\n         */\r\n        const animations = [];\r\n        /**\r\n         * Keep track of which values have been removed. Then, as we hit lower priority\r\n         * animation types, we can check if they contain removed values and animate to that.\r\n         */\r\n        const removedKeys = new Set();\r\n        /**\r\n         * A dictionary of all encountered keys. This is an object to let us build into and\r\n         * copy it without iteration. Each time we hit an animation type we set its protected\r\n         * keys - the keys its not allowed to animate - to the latest version of this object.\r\n         */\r\n        let encounteredKeys = {};\r\n        /**\r\n         * If a variant has been removed at a given index, and this component is controlling\r\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\r\n         */\r\n        let removedVariantIndex = Infinity;\r\n        /**\r\n         * Iterate through all animation types in reverse priority order. For each, we want to\r\n         * detect which values it's handling and whether or not they've changed (and therefore\r\n         * need to be animated). If any values have been removed, we want to detect those in\r\n         * lower priority props and flag for animation.\r\n         */\r\n        for (let i = 0; i < numAnimationTypes; i++) {\r\n            const type = reversePriorityOrder[i];\r\n            const typeState = state[type];\r\n            const prop = props[type] !== undefined\r\n                ? props[type]\r\n                : context[type];\r\n            const propIsVariant = isVariantLabel(prop);\r\n            /**\r\n             * If this type has *just* changed isActive status, set activeDelta\r\n             * to that status. Otherwise set to null.\r\n             */\r\n            const activeDelta = type === changedActiveType ? typeState.isActive : null;\r\n            if (activeDelta === false)\r\n                removedVariantIndex = i;\r\n            /**\r\n             * If this prop is an inherited variant, rather than been set directly on the\r\n             * component itself, we want to make sure we allow the parent to trigger animations.\r\n             *\r\n             * TODO: Can probably change this to a !isControllingVariants check\r\n             */\r\n            let isInherited = prop === context[type] &&\r\n                prop !== props[type] &&\r\n                propIsVariant;\r\n            /**\r\n             *\r\n             */\r\n            if (isInherited &&\r\n                isInitialRender &&\r\n                visualElement.manuallyAnimateOnMount) {\r\n                isInherited = false;\r\n            }\r\n            /**\r\n             * Set all encountered keys so far as the protected keys for this type. This will\r\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\r\n             */\r\n            typeState.protectedKeys = { ...encounteredKeys };\r\n            // Check if we can skip analysing this prop early\r\n            if (\r\n            // If it isn't active and hasn't *just* been set as inactive\r\n            (!typeState.isActive && activeDelta === null) ||\r\n                // If we didn't and don't have any defined prop for this animation type\r\n                (!prop && !typeState.prevProp) ||\r\n                // Or if the prop doesn't define an animation\r\n                isAnimationControls(prop) ||\r\n                typeof prop === \"boolean\") {\r\n                continue;\r\n            }\r\n            /**\r\n             * As we go look through the values defined on this type, if we detect\r\n             * a changed value or a value that was removed in a higher priority, we set\r\n             * this to true and add this prop to the animation list.\r\n             */\r\n            const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\r\n            let shouldAnimateType = variantDidChange ||\r\n                // If we're making this variant active, we want to always make it active\r\n                (type === changedActiveType &&\r\n                    typeState.isActive &&\r\n                    !isInherited &&\r\n                    propIsVariant) ||\r\n                // If we removed a higher-priority variant (i is in reverse order)\r\n                (i > removedVariantIndex && propIsVariant);\r\n            let handledRemovedValues = false;\r\n            /**\r\n             * As animations can be set as variant lists, variants or target objects, we\r\n             * coerce everything to an array if it isn't one already\r\n             */\r\n            const definitionList = Array.isArray(prop) ? prop : [prop];\r\n            /**\r\n             * Build an object of all the resolved values. We'll use this in the subsequent\r\n             * animateChanges calls to determine whether a value has changed.\r\n             */\r\n            let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});\r\n            if (activeDelta === false)\r\n                resolvedValues = {};\r\n            /**\r\n             * Now we need to loop through all the keys in the prev prop and this prop,\r\n             * and decide:\r\n             * 1. If the value has changed, and needs animating\r\n             * 2. If it has been removed, and needs adding to the removedKeys set\r\n             * 3. If it has been removed in a higher priority type and needs animating\r\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\r\n             *    needs adding to the type's protectedKeys list.\r\n             */\r\n            const { prevResolvedValues = {} } = typeState;\r\n            const allKeys = {\r\n                ...prevResolvedValues,\r\n                ...resolvedValues,\r\n            };\r\n            const markToAnimate = (key) => {\r\n                shouldAnimateType = true;\r\n                if (removedKeys.has(key)) {\r\n                    handledRemovedValues = true;\r\n                    removedKeys.delete(key);\r\n                }\r\n                typeState.needsAnimating[key] = true;\r\n                const motionValue = visualElement.getValue(key);\r\n                if (motionValue)\r\n                    motionValue.liveStyle = false;\r\n            };\r\n            for (const key in allKeys) {\r\n                const next = resolvedValues[key];\r\n                const prev = prevResolvedValues[key];\r\n                // If we've already handled this we can just skip ahead\r\n                if (encounteredKeys.hasOwnProperty(key))\r\n                    continue;\r\n                /**\r\n                 * If the value has changed, we probably want to animate it.\r\n                 */\r\n                let valueHasChanged = false;\r\n                if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\r\n                    valueHasChanged = !shallowCompare(next, prev);\r\n                }\r\n                else {\r\n                    valueHasChanged = next !== prev;\r\n                }\r\n                if (valueHasChanged) {\r\n                    if (next !== undefined && next !== null) {\r\n                        // If next is defined and doesn't equal prev, it needs animating\r\n                        markToAnimate(key);\r\n                    }\r\n                    else {\r\n                        // If it's undefined, it's been removed.\r\n                        removedKeys.add(key);\r\n                    }\r\n                }\r\n                else if (next !== undefined && removedKeys.has(key)) {\r\n                    /**\r\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\r\n                     * been removed by a higher priority\r\n                     */\r\n                    markToAnimate(key);\r\n                }\r\n                else {\r\n                    /**\r\n                     * If it hasn't changed, we add it to the list of protected values\r\n                     * to ensure it doesn't get animated.\r\n                     */\r\n                    typeState.protectedKeys[key] = true;\r\n                }\r\n            }\r\n            /**\r\n             * Update the typeState so next time animateChanges is called we can compare the\r\n             * latest prop and resolvedValues to these.\r\n             */\r\n            typeState.prevProp = prop;\r\n            typeState.prevResolvedValues = resolvedValues;\r\n            /**\r\n             *\r\n             */\r\n            if (typeState.isActive) {\r\n                encounteredKeys = { ...encounteredKeys, ...resolvedValues };\r\n            }\r\n            if (isInitialRender && visualElement.blockInitialAnimation) {\r\n                shouldAnimateType = false;\r\n            }\r\n            /**\r\n             * If this is an inherited prop we want to skip this animation\r\n             * unless the inherited variants haven't changed on this render.\r\n             */\r\n            const willAnimateViaParent = isInherited && variantDidChange;\r\n            const needsAnimating = !willAnimateViaParent || handledRemovedValues;\r\n            if (shouldAnimateType && needsAnimating) {\r\n                animations.push(...definitionList.map((animation) => ({\r\n                    animation: animation,\r\n                    options: { type },\r\n                })));\r\n            }\r\n        }\r\n        /**\r\n         * If there are some removed value that haven't been dealt with,\r\n         * we need to create a new animation that falls back either to the value\r\n         * defined in the style prop, or the last read value.\r\n         */\r\n        if (removedKeys.size) {\r\n            const fallbackAnimation = {};\r\n            removedKeys.forEach((key) => {\r\n                const fallbackTarget = visualElement.getBaseTarget(key);\r\n                const motionValue = visualElement.getValue(key);\r\n                if (motionValue)\r\n                    motionValue.liveStyle = true;\r\n                // @ts-expect-error - @mattgperry to figure if we should do something here\r\n                fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;\r\n            });\r\n            animations.push({ animation: fallbackAnimation });\r\n        }\r\n        let shouldAnimate = Boolean(animations.length);\r\n        if (isInitialRender &&\r\n            (props.initial === false || props.initial === props.animate) &&\r\n            !visualElement.manuallyAnimateOnMount) {\r\n            shouldAnimate = false;\r\n        }\r\n        isInitialRender = false;\r\n        return shouldAnimate ? animate(animations) : Promise.resolve();\r\n    }\r\n    /**\r\n     * Change whether a certain animation type is active.\r\n     */\r\n    function setActive(type, isActive) {\r\n        var _a;\r\n        // If the active state hasn't changed, we can safely do nothing here\r\n        if (state[type].isActive === isActive)\r\n            return Promise.resolve();\r\n        // Propagate active change to children\r\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\r\n        state[type].isActive = isActive;\r\n        const animations = animateChanges(type);\r\n        for (const key in state) {\r\n            state[key].protectedKeys = {};\r\n        }\r\n        return animations;\r\n    }\r\n    return {\r\n        animateChanges,\r\n        setActive,\r\n        setAnimateFunction,\r\n        getState: () => state,\r\n        reset: () => {\r\n            state = createState();\r\n            isInitialRender = true;\r\n        },\r\n    };\r\n}\r\nfunction checkVariantsDidChange(prev, next) {\r\n    if (typeof next === \"string\") {\r\n        return next !== prev;\r\n    }\r\n    else if (Array.isArray(next)) {\r\n        return !shallowCompare(next, prev);\r\n    }\r\n    return false;\r\n}\r\nfunction createTypeState(isActive = false) {\r\n    return {\r\n        isActive,\r\n        protectedKeys: {},\r\n        needsAnimating: {},\r\n        prevResolvedValues: {},\r\n    };\r\n}\r\nfunction createState() {\r\n    return {\r\n        animate: createTypeState(true),\r\n        whileInView: createTypeState(),\r\n        whileHover: createTypeState(),\r\n        whileTap: createTypeState(),\r\n        whileDrag: createTypeState(),\r\n        whileFocus: createTypeState(),\r\n        exit: createTypeState(),\r\n    };\r\n}\r\n\r\nexport { checkVariantsDidChange, createAnimationState };\r\n","import { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';\r\nimport { animateTarget } from './visual-element-target.mjs';\r\nimport { animateVariant } from './visual-element-variant.mjs';\r\n\r\nfunction animateVisualElement(visualElement, definition, options = {}) {\r\n    visualElement.notify(\"AnimationStart\", definition);\r\n    let animation;\r\n    if (Array.isArray(definition)) {\r\n        const animations = definition.map((variant) => animateVariant(visualElement, variant, options));\r\n        animation = Promise.all(animations);\r\n    }\r\n    else if (typeof definition === \"string\") {\r\n        animation = animateVariant(visualElement, definition, options);\r\n    }\r\n    else {\r\n        const resolvedDefinition = typeof definition === \"function\"\r\n            ? resolveVariant(visualElement, definition, options.custom)\r\n            : definition;\r\n        animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));\r\n    }\r\n    return animation.then(() => {\r\n        visualElement.notify(\"AnimationComplete\", definition);\r\n    });\r\n}\r\n\r\nexport { animateVisualElement };\r\n","class Feature {\r\n    constructor(node) {\r\n        this.isMounted = false;\r\n        this.node = node;\r\n    }\r\n    update() { }\r\n}\r\n\r\nexport { Feature };\r\n","import { Feature } from '../Feature.mjs';\r\n\r\nlet id = 0;\r\nclass ExitAnimationFeature extends Feature {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.id = id++;\r\n    }\r\n    update() {\r\n        if (!this.node.presenceContext)\r\n            return;\r\n        const { isPresent, onExitComplete } = this.node.presenceContext;\r\n        const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};\r\n        if (!this.node.animationState || isPresent === prevIsPresent) {\r\n            return;\r\n        }\r\n        const exitAnimation = this.node.animationState.setActive(\"exit\", !isPresent);\r\n        if (onExitComplete && !isPresent) {\r\n            exitAnimation.then(() => onExitComplete(this.id));\r\n        }\r\n    }\r\n    mount() {\r\n        const { register } = this.node.presenceContext || {};\r\n        if (register) {\r\n            this.unmount = register(this.id);\r\n        }\r\n    }\r\n    unmount() { }\r\n}\r\n\r\nexport { ExitAnimationFeature };\r\n","import { AnimationFeature } from './animation/index.mjs';\r\nimport { ExitAnimationFeature } from './animation/exit.mjs';\r\n\r\nconst animations = {\r\n    animation: {\r\n        Feature: AnimationFeature,\r\n    },\r\n    exit: {\r\n        Feature: ExitAnimationFeature,\r\n    },\r\n};\r\n\r\nexport { animations };\r\n","import { isAnimationControls } from '../../../animation/utils/is-animation-controls.mjs';\r\nimport { createAnimationState } from '../../../render/utils/animation-state.mjs';\r\nimport { Feature } from '../Feature.mjs';\r\n\r\nclass AnimationFeature extends Feature {\r\n    /**\r\n     * We dynamically generate the AnimationState manager as it contains a reference\r\n     * to the underlying animation library. We only want to load that if we load this,\r\n     * so people can optionally code split it out using the `m` component.\r\n     */\r\n    constructor(node) {\r\n        super(node);\r\n        node.animationState || (node.animationState = createAnimationState(node));\r\n    }\r\n    updateAnimationControlsSubscription() {\r\n        const { animate } = this.node.getProps();\r\n        if (isAnimationControls(animate)) {\r\n            this.unmountControls = animate.subscribe(this.node);\r\n        }\r\n    }\r\n    /**\r\n     * Subscribe any provided AnimationControls to the component's VisualElement\r\n     */\r\n    mount() {\r\n        this.updateAnimationControlsSubscription();\r\n    }\r\n    update() {\r\n        const { animate } = this.node.getProps();\r\n        const { animate: prevAnimate } = this.node.prevProps || {};\r\n        if (animate !== prevAnimate) {\r\n            this.updateAnimationControlsSubscription();\r\n        }\r\n    }\r\n    unmount() {\r\n        var _a;\r\n        this.node.animationState.reset();\r\n        (_a = this.unmountControls) === null || _a === void 0 ? void 0 : _a.call(this);\r\n    }\r\n}\r\n\r\nexport { AnimationFeature };\r\n","function addDomEvent(target, eventName, handler, options = { passive: true }) {\r\n    target.addEventListener(eventName, handler, options);\r\n    return () => target.removeEventListener(eventName, handler);\r\n}\r\n\r\nexport { addDomEvent };\r\n","import { isPrimaryPointer } from 'motion-dom';\r\n\r\nfunction extractEventInfo(event) {\r\n    return {\r\n        point: {\r\n            x: event.pageX,\r\n            y: event.pageY,\r\n        },\r\n    };\r\n}\r\nconst addPointerInfo = (handler) => {\r\n    return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));\r\n};\r\n\r\nexport { addPointerInfo, extractEventInfo };\r\n","import { addDomEvent } from './add-dom-event.mjs';\r\nimport { addPointerInfo } from './event-info.mjs';\r\n\r\nfunction addPointerEvent(target, eventName, handler, options) {\r\n    return addDomEvent(target, eventName, addPointerInfo(handler), options);\r\n}\r\n\r\nexport { addPointerEvent };\r\n","const distance = (a, b) => Math.abs(a - b);\r\nfunction distance2D(a, b) {\r\n    // Multi-dimensional\r\n    const xDelta = distance(a.x, b.x);\r\n    const yDelta = distance(a.y, b.y);\r\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2);\r\n}\r\n\r\nexport { distance, distance2D };\r\n","import { isPrimaryPointer } from 'motion-dom';\r\nimport { secondsToMilliseconds, millisecondsToSeconds } from 'motion-utils';\r\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\r\nimport { extractEventInfo } from '../../events/event-info.mjs';\r\nimport { distance2D } from '../../utils/distance.mjs';\r\nimport { pipe } from '../../utils/pipe.mjs';\r\nimport { frame, cancelFrame, frameData } from '../../frameloop/frame.mjs';\r\n\r\n/**\r\n * @internal\r\n */\r\nclass PanSession {\r\n    constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false, } = {}) {\r\n        /**\r\n         * @internal\r\n         */\r\n        this.startEvent = null;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.lastMoveEvent = null;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.lastMoveEventInfo = null;\r\n        /**\r\n         * @internal\r\n         */\r\n        this.handlers = {};\r\n        /**\r\n         * @internal\r\n         */\r\n        this.contextWindow = window;\r\n        this.updatePoint = () => {\r\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\r\n                return;\r\n            const info = getPanInfo(this.lastMoveEventInfo, this.history);\r\n            const isPanStarted = this.startEvent !== null;\r\n            // Only start panning if the offset is larger than 3 pixels. If we make it\r\n            // any larger than this we'll want to reset the pointer history\r\n            // on the first update to avoid visual snapping to the cursoe.\r\n            const isDistancePastThreshold = distance2D(info.offset, { x: 0, y: 0 }) >= 3;\r\n            if (!isPanStarted && !isDistancePastThreshold)\r\n                return;\r\n            const { point } = info;\r\n            const { timestamp } = frameData;\r\n            this.history.push({ ...point, timestamp });\r\n            const { onStart, onMove } = this.handlers;\r\n            if (!isPanStarted) {\r\n                onStart && onStart(this.lastMoveEvent, info);\r\n                this.startEvent = this.lastMoveEvent;\r\n            }\r\n            onMove && onMove(this.lastMoveEvent, info);\r\n        };\r\n        this.handlePointerMove = (event, info) => {\r\n            this.lastMoveEvent = event;\r\n            this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\r\n            // Throttle mouse move event to once per frame\r\n            frame.update(this.updatePoint, true);\r\n        };\r\n        this.handlePointerUp = (event, info) => {\r\n            this.end();\r\n            const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;\r\n            if (this.dragSnapToOrigin)\r\n                resumeAnimation && resumeAnimation();\r\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\r\n                return;\r\n            const panInfo = getPanInfo(event.type === \"pointercancel\"\r\n                ? this.lastMoveEventInfo\r\n                : transformPoint(info, this.transformPagePoint), this.history);\r\n            if (this.startEvent && onEnd) {\r\n                onEnd(event, panInfo);\r\n            }\r\n            onSessionEnd && onSessionEnd(event, panInfo);\r\n        };\r\n        // If we have more than one touch, don't start detecting this gesture\r\n        if (!isPrimaryPointer(event))\r\n            return;\r\n        this.dragSnapToOrigin = dragSnapToOrigin;\r\n        this.handlers = handlers;\r\n        this.transformPagePoint = transformPagePoint;\r\n        this.contextWindow = contextWindow || window;\r\n        const info = extractEventInfo(event);\r\n        const initialInfo = transformPoint(info, this.transformPagePoint);\r\n        const { point } = initialInfo;\r\n        const { timestamp } = frameData;\r\n        this.history = [{ ...point, timestamp }];\r\n        const { onSessionStart } = handlers;\r\n        onSessionStart &&\r\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\r\n        this.removeListeners = pipe(addPointerEvent(this.contextWindow, \"pointermove\", this.handlePointerMove), addPointerEvent(this.contextWindow, \"pointerup\", this.handlePointerUp), addPointerEvent(this.contextWindow, \"pointercancel\", this.handlePointerUp));\r\n    }\r\n    updateHandlers(handlers) {\r\n        this.handlers = handlers;\r\n    }\r\n    end() {\r\n        this.removeListeners && this.removeListeners();\r\n        cancelFrame(this.updatePoint);\r\n    }\r\n}\r\nfunction transformPoint(info, transformPagePoint) {\r\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\r\n}\r\nfunction subtractPoint(a, b) {\r\n    return { x: a.x - b.x, y: a.y - b.y };\r\n}\r\nfunction getPanInfo({ point }, history) {\r\n    return {\r\n        point,\r\n        delta: subtractPoint(point, lastDevicePoint(history)),\r\n        offset: subtractPoint(point, startDevicePoint(history)),\r\n        velocity: getVelocity(history, 0.1),\r\n    };\r\n}\r\nfunction startDevicePoint(history) {\r\n    return history[0];\r\n}\r\nfunction lastDevicePoint(history) {\r\n    return history[history.length - 1];\r\n}\r\nfunction getVelocity(history, timeDelta) {\r\n    if (history.length < 2) {\r\n        return { x: 0, y: 0 };\r\n    }\r\n    let i = history.length - 1;\r\n    let timestampedPoint = null;\r\n    const lastPoint = lastDevicePoint(history);\r\n    while (i >= 0) {\r\n        timestampedPoint = history[i];\r\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\r\n            secondsToMilliseconds(timeDelta)) {\r\n            break;\r\n        }\r\n        i--;\r\n    }\r\n    if (!timestampedPoint) {\r\n        return { x: 0, y: 0 };\r\n    }\r\n    const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\r\n    if (time === 0) {\r\n        return { x: 0, y: 0 };\r\n    }\r\n    const currentVelocity = {\r\n        x: (lastPoint.x - timestampedPoint.x) / time,\r\n        y: (lastPoint.y - timestampedPoint.y) / time,\r\n    };\r\n    if (currentVelocity.x === Infinity) {\r\n        currentVelocity.x = 0;\r\n    }\r\n    if (currentVelocity.y === Infinity) {\r\n        currentVelocity.y = 0;\r\n    }\r\n    return currentVelocity;\r\n}\r\n\r\nexport { PanSession };\r\n","import { mixNumber } from '../../utils/mix/number.mjs';\r\n\r\nconst SCALE_PRECISION = 0.0001;\r\nconst SCALE_MIN = 1 - SCALE_PRECISION;\r\nconst SCALE_MAX = 1 + SCALE_PRECISION;\r\nconst TRANSLATE_PRECISION = 0.01;\r\nconst TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;\r\nconst TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;\r\nfunction calcLength(axis) {\r\n    return axis.max - axis.min;\r\n}\r\nfunction isNear(value, target, maxDistance) {\r\n    return Math.abs(value - target) <= maxDistance;\r\n}\r\nfunction calcAxisDelta(delta, source, target, origin = 0.5) {\r\n    delta.origin = origin;\r\n    delta.originPoint = mixNumber(source.min, source.max, delta.origin);\r\n    delta.scale = calcLength(target) / calcLength(source);\r\n    delta.translate =\r\n        mixNumber(target.min, target.max, delta.origin) - delta.originPoint;\r\n    if ((delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX) ||\r\n        isNaN(delta.scale)) {\r\n        delta.scale = 1.0;\r\n    }\r\n    if ((delta.translate >= TRANSLATE_MIN &&\r\n        delta.translate <= TRANSLATE_MAX) ||\r\n        isNaN(delta.translate)) {\r\n        delta.translate = 0.0;\r\n    }\r\n}\r\nfunction calcBoxDelta(delta, source, target, origin) {\r\n    calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : undefined);\r\n    calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : undefined);\r\n}\r\nfunction calcRelativeAxis(target, relative, parent) {\r\n    target.min = parent.min + relative.min;\r\n    target.max = target.min + calcLength(relative);\r\n}\r\nfunction calcRelativeBox(target, relative, parent) {\r\n    calcRelativeAxis(target.x, relative.x, parent.x);\r\n    calcRelativeAxis(target.y, relative.y, parent.y);\r\n}\r\nfunction calcRelativeAxisPosition(target, layout, parent) {\r\n    target.min = layout.min - parent.min;\r\n    target.max = target.min + calcLength(layout);\r\n}\r\nfunction calcRelativePosition(target, layout, parent) {\r\n    calcRelativeAxisPosition(target.x, layout.x, parent.x);\r\n    calcRelativeAxisPosition(target.y, layout.y, parent.y);\r\n}\r\n\r\nexport { calcAxisDelta, calcBoxDelta, calcLength, calcRelativeAxis, calcRelativeAxisPosition, calcRelativeBox, calcRelativePosition, isNear };\r\n","import { progress } from 'motion-utils';\r\nimport { calcLength } from '../../../projection/geometry/delta-calc.mjs';\r\nimport { clamp } from '../../../utils/clamp.mjs';\r\nimport { mixNumber } from '../../../utils/mix/number.mjs';\r\n\r\n/**\r\n * Apply constraints to a point. These constraints are both physical along an\r\n * axis, and an elastic factor that determines how much to constrain the point\r\n * by if it does lie outside the defined parameters.\r\n */\r\nfunction applyConstraints(point, { min, max }, elastic) {\r\n    if (min !== undefined && point < min) {\r\n        // If we have a min point defined, and this is outside of that, constrain\r\n        point = elastic\r\n            ? mixNumber(min, point, elastic.min)\r\n            : Math.max(point, min);\r\n    }\r\n    else if (max !== undefined && point > max) {\r\n        // If we have a max point defined, and this is outside of that, constrain\r\n        point = elastic\r\n            ? mixNumber(max, point, elastic.max)\r\n            : Math.min(point, max);\r\n    }\r\n    return point;\r\n}\r\n/**\r\n * Calculate constraints in terms of the viewport when defined relatively to the\r\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\r\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\r\n */\r\nfunction calcRelativeAxisConstraints(axis, min, max) {\r\n    return {\r\n        min: min !== undefined ? axis.min + min : undefined,\r\n        max: max !== undefined\r\n            ? axis.max + max - (axis.max - axis.min)\r\n            : undefined,\r\n    };\r\n}\r\n/**\r\n * Calculate constraints in terms of the viewport when\r\n * defined relatively to the measured bounding box.\r\n */\r\nfunction calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {\r\n    return {\r\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\r\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\r\n    };\r\n}\r\n/**\r\n * Calculate viewport constraints when defined as another viewport-relative axis\r\n */\r\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\r\n    let min = constraintsAxis.min - layoutAxis.min;\r\n    let max = constraintsAxis.max - layoutAxis.max;\r\n    // If the constraints axis is actually smaller than the layout axis then we can\r\n    // flip the constraints\r\n    if (constraintsAxis.max - constraintsAxis.min <\r\n        layoutAxis.max - layoutAxis.min) {\r\n        [min, max] = [max, min];\r\n    }\r\n    return { min, max };\r\n}\r\n/**\r\n * Calculate viewport constraints when defined as another viewport-relative box\r\n */\r\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\r\n    return {\r\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\r\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\r\n    };\r\n}\r\n/**\r\n * Calculate a transform origin relative to the source axis, between 0-1, that results\r\n * in an asthetically pleasing scale/transform needed to project from source to target.\r\n */\r\nfunction calcOrigin(source, target) {\r\n    let origin = 0.5;\r\n    const sourceLength = calcLength(source);\r\n    const targetLength = calcLength(target);\r\n    if (targetLength > sourceLength) {\r\n        origin = progress(target.min, target.max - sourceLength, source.min);\r\n    }\r\n    else if (sourceLength > targetLength) {\r\n        origin = progress(source.min, source.max - targetLength, target.min);\r\n    }\r\n    return clamp(0, 1, origin);\r\n}\r\n/**\r\n * Rebase the calculated viewport constraints relative to the layout.min point.\r\n */\r\nfunction rebaseAxisConstraints(layout, constraints) {\r\n    const relativeConstraints = {};\r\n    if (constraints.min !== undefined) {\r\n        relativeConstraints.min = constraints.min - layout.min;\r\n    }\r\n    if (constraints.max !== undefined) {\r\n        relativeConstraints.max = constraints.max - layout.min;\r\n    }\r\n    return relativeConstraints;\r\n}\r\nconst defaultElastic = 0.35;\r\n/**\r\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\r\n */\r\nfunction resolveDragElastic(dragElastic = defaultElastic) {\r\n    if (dragElastic === false) {\r\n        dragElastic = 0;\r\n    }\r\n    else if (dragElastic === true) {\r\n        dragElastic = defaultElastic;\r\n    }\r\n    return {\r\n        x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\r\n        y: resolveAxisElastic(dragElastic, \"top\", \"bottom\"),\r\n    };\r\n}\r\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\r\n    return {\r\n        min: resolvePointElastic(dragElastic, minLabel),\r\n        max: resolvePointElastic(dragElastic, maxLabel),\r\n    };\r\n}\r\nfunction resolvePointElastic(dragElastic, label) {\r\n    return typeof dragElastic === \"number\"\r\n        ? dragElastic\r\n        : dragElastic[label] || 0;\r\n}\r\n\r\nexport { applyConstraints, calcOrigin, calcRelativeAxisConstraints, calcRelativeConstraints, calcViewportAxisConstraints, calcViewportConstraints, defaultElastic, rebaseAxisConstraints, resolveAxisElastic, resolveDragElastic, resolvePointElastic };\r\n","const createAxisDelta = () => ({\r\n    translate: 0,\r\n    scale: 1,\r\n    origin: 0,\r\n    originPoint: 0,\r\n});\r\nconst createDelta = () => ({\r\n    x: createAxisDelta(),\r\n    y: createAxisDelta(),\r\n});\r\nconst createAxis = () => ({ min: 0, max: 0 });\r\nconst createBox = () => ({\r\n    x: createAxis(),\r\n    y: createAxis(),\r\n});\r\n\r\nexport { createAxis, createAxisDelta, createBox, createDelta };\r\n","function eachAxis(callback) {\r\n    return [callback(\"x\"), callback(\"y\")];\r\n}\r\n\r\nexport { eachAxis };\r\n","/**\r\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\r\n * it's easier to consider each axis individually. This function returns a bounding box\r\n * as a map of single-axis min/max values.\r\n */\r\nfunction convertBoundingBoxToBox({ top, left, right, bottom, }) {\r\n    return {\r\n        x: { min: left, max: right },\r\n        y: { min: top, max: bottom },\r\n    };\r\n}\r\nfunction convertBoxToBoundingBox({ x, y }) {\r\n    return { top: y.min, right: x.max, bottom: y.max, left: x.min };\r\n}\r\n/**\r\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\r\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\r\n * when measuring DOM elements and DOM event points.\r\n */\r\nfunction transformBoxPoints(point, transformPoint) {\r\n    if (!transformPoint)\r\n        return point;\r\n    const topLeft = transformPoint({ x: point.left, y: point.top });\r\n    const bottomRight = transformPoint({ x: point.right, y: point.bottom });\r\n    return {\r\n        top: topLeft.y,\r\n        left: topLeft.x,\r\n        bottom: bottomRight.y,\r\n        right: bottomRight.x,\r\n    };\r\n}\r\n\r\nexport { convertBoundingBoxToBox, convertBoxToBoundingBox, transformBoxPoints };\r\n","function isIdentityScale(scale) {\r\n    return scale === undefined || scale === 1;\r\n}\r\nfunction hasScale({ scale, scaleX, scaleY }) {\r\n    return (!isIdentityScale(scale) ||\r\n        !isIdentityScale(scaleX) ||\r\n        !isIdentityScale(scaleY));\r\n}\r\nfunction hasTransform(values) {\r\n    return (hasScale(values) ||\r\n        has2DTranslate(values) ||\r\n        values.z ||\r\n        values.rotate ||\r\n        values.rotateX ||\r\n        values.rotateY ||\r\n        values.skewX ||\r\n        values.skewY);\r\n}\r\nfunction has2DTranslate(values) {\r\n    return is2DTranslate(values.x) || is2DTranslate(values.y);\r\n}\r\nfunction is2DTranslate(value) {\r\n    return value && value !== \"0%\";\r\n}\r\n\r\nexport { has2DTranslate, hasScale, hasTransform };\r\n","import { mixNumber } from '../../utils/mix/number.mjs';\r\nimport { hasTransform } from '../utils/has-transform.mjs';\r\n\r\n/**\r\n * Scales a point based on a factor and an originPoint\r\n */\r\nfunction scalePoint(point, scale, originPoint) {\r\n    const distanceFromOrigin = point - originPoint;\r\n    const scaled = scale * distanceFromOrigin;\r\n    return originPoint + scaled;\r\n}\r\n/**\r\n * Applies a translate/scale delta to a point\r\n */\r\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\r\n    if (boxScale !== undefined) {\r\n        point = scalePoint(point, boxScale, originPoint);\r\n    }\r\n    return scalePoint(point, scale, originPoint) + translate;\r\n}\r\n/**\r\n * Applies a translate/scale delta to an axis\r\n */\r\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\r\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\r\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\r\n}\r\n/**\r\n * Applies a translate/scale delta to a box\r\n */\r\nfunction applyBoxDelta(box, { x, y }) {\r\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\r\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\r\n}\r\nconst TREE_SCALE_SNAP_MIN = 0.999999999999;\r\nconst TREE_SCALE_SNAP_MAX = 1.0000000000001;\r\n/**\r\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\r\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\r\n *\r\n * This is the final nested loop within updateLayoutDelta for future refactoring\r\n */\r\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\r\n    const treeLength = treePath.length;\r\n    if (!treeLength)\r\n        return;\r\n    // Reset the treeScale\r\n    treeScale.x = treeScale.y = 1;\r\n    let node;\r\n    let delta;\r\n    for (let i = 0; i < treeLength; i++) {\r\n        node = treePath[i];\r\n        delta = node.projectionDelta;\r\n        /**\r\n         * TODO: Prefer to remove this, but currently we have motion components with\r\n         * display: contents in Framer.\r\n         */\r\n        const { visualElement } = node.options;\r\n        if (visualElement &&\r\n            visualElement.props.style &&\r\n            visualElement.props.style.display === \"contents\") {\r\n            continue;\r\n        }\r\n        if (isSharedTransition &&\r\n            node.options.layoutScroll &&\r\n            node.scroll &&\r\n            node !== node.root) {\r\n            transformBox(box, {\r\n                x: -node.scroll.offset.x,\r\n                y: -node.scroll.offset.y,\r\n            });\r\n        }\r\n        if (delta) {\r\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\r\n            treeScale.x *= delta.x.scale;\r\n            treeScale.y *= delta.y.scale;\r\n            // Apply each ancestor's calculated delta into this component's recorded layout box\r\n            applyBoxDelta(box, delta);\r\n        }\r\n        if (isSharedTransition && hasTransform(node.latestValues)) {\r\n            transformBox(box, node.latestValues);\r\n        }\r\n    }\r\n    /**\r\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\r\n     * This will help reduce useless scales getting rendered.\r\n     */\r\n    if (treeScale.x < TREE_SCALE_SNAP_MAX &&\r\n        treeScale.x > TREE_SCALE_SNAP_MIN) {\r\n        treeScale.x = 1.0;\r\n    }\r\n    if (treeScale.y < TREE_SCALE_SNAP_MAX &&\r\n        treeScale.y > TREE_SCALE_SNAP_MIN) {\r\n        treeScale.y = 1.0;\r\n    }\r\n}\r\nfunction translateAxis(axis, distance) {\r\n    axis.min = axis.min + distance;\r\n    axis.max = axis.max + distance;\r\n}\r\n/**\r\n * Apply a transform to an axis from the latest resolved motion values.\r\n * This function basically acts as a bridge between a flat motion value map\r\n * and applyAxisDelta\r\n */\r\nfunction transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {\r\n    const originPoint = mixNumber(axis.min, axis.max, axisOrigin);\r\n    // Apply the axis delta to the final axis\r\n    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);\r\n}\r\n/**\r\n * Apply a transform to a box from the latest resolved motion values.\r\n */\r\nfunction transformBox(box, transform) {\r\n    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\r\n    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\r\n}\r\n\r\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };\r\n","import { convertBoundingBoxToBox, transformBoxPoints } from '../geometry/conversion.mjs';\r\nimport { translateAxis } from '../geometry/delta-apply.mjs';\r\n\r\nfunction measureViewportBox(instance, transformPoint) {\r\n    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));\r\n}\r\nfunction measurePageBox(element, rootProjectionNode, transformPagePoint) {\r\n    const viewportBox = measureViewportBox(element, transformPagePoint);\r\n    const { scroll } = rootProjectionNode;\r\n    if (scroll) {\r\n        translateAxis(viewportBox.x, scroll.offset.x);\r\n        translateAxis(viewportBox.y, scroll.offset.y);\r\n    }\r\n    return viewportBox;\r\n}\r\n\r\nexport { measurePageBox, measureViewportBox };\r\n","// Fixes https://github.com/motiondivision/motion/issues/2270\r\nconst getContextWindow = ({ current }) => {\r\n    return current ? current.ownerDocument.defaultView : null;\r\n};\r\n\r\nexport { getContextWindow };\r\n","import { invariant } from 'motion-utils';\r\nimport { setDragLock } from 'motion-dom';\r\nimport { PanSession } from '../pan/PanSession.mjs';\r\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\r\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\r\nimport { applyConstraints, calcRelativeConstraints, resolveDragElastic, rebaseAxisConstraints, calcViewportConstraints, calcOrigin, defaultElastic } from './utils/constraints.mjs';\r\nimport { createBox } from '../../projection/geometry/models.mjs';\r\nimport { eachAxis } from '../../projection/utils/each-axis.mjs';\r\nimport { measurePageBox } from '../../projection/utils/measure.mjs';\r\nimport { extractEventInfo } from '../../events/event-info.mjs';\r\nimport { convertBoxToBoundingBox, convertBoundingBoxToBox } from '../../projection/geometry/conversion.mjs';\r\nimport { addDomEvent } from '../../events/add-dom-event.mjs';\r\nimport { calcLength } from '../../projection/geometry/delta-calc.mjs';\r\nimport { mixNumber } from '../../utils/mix/number.mjs';\r\nimport { percent } from '../../value/types/numbers/units.mjs';\r\nimport { animateMotionValue } from '../../animation/interfaces/motion-value.mjs';\r\nimport { getContextWindow } from '../../utils/get-context-window.mjs';\r\nimport { addValueToWillChange } from '../../value/use-will-change/add-will-change.mjs';\r\nimport { frame } from '../../frameloop/frame.mjs';\r\n\r\nconst elementDragControls = new WeakMap();\r\n/**\r\n *\r\n */\r\n// let latestPointerEvent: PointerEvent\r\nclass VisualElementDragControls {\r\n    constructor(visualElement) {\r\n        this.openDragLock = null;\r\n        this.isDragging = false;\r\n        this.currentDirection = null;\r\n        this.originPoint = { x: 0, y: 0 };\r\n        /**\r\n         * The permitted boundaries of travel, in pixels.\r\n         */\r\n        this.constraints = false;\r\n        this.hasMutatedConstraints = false;\r\n        /**\r\n         * The per-axis resolved elastic values.\r\n         */\r\n        this.elastic = createBox();\r\n        this.visualElement = visualElement;\r\n    }\r\n    start(originEvent, { snapToCursor = false } = {}) {\r\n        /**\r\n         * Don't start dragging if this component is exiting\r\n         */\r\n        const { presenceContext } = this.visualElement;\r\n        if (presenceContext && presenceContext.isPresent === false)\r\n            return;\r\n        const onSessionStart = (event) => {\r\n            const { dragSnapToOrigin } = this.getProps();\r\n            // Stop or pause any animations on both axis values immediately. This allows the user to throw and catch\r\n            // the component.\r\n            dragSnapToOrigin ? this.pauseAnimation() : this.stopAnimation();\r\n            if (snapToCursor) {\r\n                this.snapToCursor(extractEventInfo(event).point);\r\n            }\r\n        };\r\n        const onStart = (event, info) => {\r\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\r\n            const { drag, dragPropagation, onDragStart } = this.getProps();\r\n            if (drag && !dragPropagation) {\r\n                if (this.openDragLock)\r\n                    this.openDragLock();\r\n                this.openDragLock = setDragLock(drag);\r\n                // If we don 't have the lock, don't start dragging\r\n                if (!this.openDragLock)\r\n                    return;\r\n            }\r\n            this.isDragging = true;\r\n            this.currentDirection = null;\r\n            this.resolveConstraints();\r\n            if (this.visualElement.projection) {\r\n                this.visualElement.projection.isAnimationBlocked = true;\r\n                this.visualElement.projection.target = undefined;\r\n            }\r\n            /**\r\n             * Record gesture origin\r\n             */\r\n            eachAxis((axis) => {\r\n                let current = this.getAxisMotionValue(axis).get() || 0;\r\n                /**\r\n                 * If the MotionValue is a percentage value convert to px\r\n                 */\r\n                if (percent.test(current)) {\r\n                    const { projection } = this.visualElement;\r\n                    if (projection && projection.layout) {\r\n                        const measuredAxis = projection.layout.layoutBox[axis];\r\n                        if (measuredAxis) {\r\n                            const length = calcLength(measuredAxis);\r\n                            current = length * (parseFloat(current) / 100);\r\n                        }\r\n                    }\r\n                }\r\n                this.originPoint[axis] = current;\r\n            });\r\n            // Fire onDragStart event\r\n            if (onDragStart) {\r\n                frame.postRender(() => onDragStart(event, info));\r\n            }\r\n            addValueToWillChange(this.visualElement, \"transform\");\r\n            const { animationState } = this.visualElement;\r\n            animationState && animationState.setActive(\"whileDrag\", true);\r\n        };\r\n        const onMove = (event, info) => {\r\n            // latestPointerEvent = event\r\n            const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag, } = this.getProps();\r\n            // If we didn't successfully receive the gesture lock, early return.\r\n            if (!dragPropagation && !this.openDragLock)\r\n                return;\r\n            const { offset } = info;\r\n            // Attempt to detect drag direction if directionLock is true\r\n            if (dragDirectionLock && this.currentDirection === null) {\r\n                this.currentDirection = getCurrentDirection(offset);\r\n                // If we've successfully set a direction, notify listener\r\n                if (this.currentDirection !== null) {\r\n                    onDirectionLock && onDirectionLock(this.currentDirection);\r\n                }\r\n                return;\r\n            }\r\n            // Update each point with the latest position\r\n            this.updateAxis(\"x\", info.point, offset);\r\n            this.updateAxis(\"y\", info.point, offset);\r\n            /**\r\n             * Ideally we would leave the renderer to fire naturally at the end of\r\n             * this frame but if the element is about to change layout as the result\r\n             * of a re-render we want to ensure the browser can read the latest\r\n             * bounding box to ensure the pointer and element don't fall out of sync.\r\n             */\r\n            this.visualElement.render();\r\n            /**\r\n             * This must fire after the render call as it might trigger a state\r\n             * change which itself might trigger a layout update.\r\n             */\r\n            onDrag && onDrag(event, info);\r\n        };\r\n        const onSessionEnd = (event, info) => this.stop(event, info);\r\n        const resumeAnimation = () => eachAxis((axis) => {\r\n            var _a;\r\n            return this.getAnimationState(axis) === \"paused\" &&\r\n                ((_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.play());\r\n        });\r\n        const { dragSnapToOrigin } = this.getProps();\r\n        this.panSession = new PanSession(originEvent, {\r\n            onSessionStart,\r\n            onStart,\r\n            onMove,\r\n            onSessionEnd,\r\n            resumeAnimation,\r\n        }, {\r\n            transformPagePoint: this.visualElement.getTransformPagePoint(),\r\n            dragSnapToOrigin,\r\n            contextWindow: getContextWindow(this.visualElement),\r\n        });\r\n    }\r\n    stop(event, info) {\r\n        const isDragging = this.isDragging;\r\n        this.cancel();\r\n        if (!isDragging)\r\n            return;\r\n        const { velocity } = info;\r\n        this.startAnimation(velocity);\r\n        const { onDragEnd } = this.getProps();\r\n        if (onDragEnd) {\r\n            frame.postRender(() => onDragEnd(event, info));\r\n        }\r\n    }\r\n    cancel() {\r\n        this.isDragging = false;\r\n        const { projection, animationState } = this.visualElement;\r\n        if (projection) {\r\n            projection.isAnimationBlocked = false;\r\n        }\r\n        this.panSession && this.panSession.end();\r\n        this.panSession = undefined;\r\n        const { dragPropagation } = this.getProps();\r\n        if (!dragPropagation && this.openDragLock) {\r\n            this.openDragLock();\r\n            this.openDragLock = null;\r\n        }\r\n        animationState && animationState.setActive(\"whileDrag\", false);\r\n    }\r\n    updateAxis(axis, _point, offset) {\r\n        const { drag } = this.getProps();\r\n        // If we're not dragging this axis, do an early return.\r\n        if (!offset || !shouldDrag(axis, drag, this.currentDirection))\r\n            return;\r\n        const axisValue = this.getAxisMotionValue(axis);\r\n        let next = this.originPoint[axis] + offset[axis];\r\n        // Apply constraints\r\n        if (this.constraints && this.constraints[axis]) {\r\n            next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);\r\n        }\r\n        axisValue.set(next);\r\n    }\r\n    resolveConstraints() {\r\n        var _a;\r\n        const { dragConstraints, dragElastic } = this.getProps();\r\n        const layout = this.visualElement.projection &&\r\n            !this.visualElement.projection.layout\r\n            ? this.visualElement.projection.measure(false)\r\n            : (_a = this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout;\r\n        const prevConstraints = this.constraints;\r\n        if (dragConstraints && isRefObject(dragConstraints)) {\r\n            if (!this.constraints) {\r\n                this.constraints = this.resolveRefConstraints();\r\n            }\r\n        }\r\n        else {\r\n            if (dragConstraints && layout) {\r\n                this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);\r\n            }\r\n            else {\r\n                this.constraints = false;\r\n            }\r\n        }\r\n        this.elastic = resolveDragElastic(dragElastic);\r\n        /**\r\n         * If we're outputting to external MotionValues, we want to rebase the measured constraints\r\n         * from viewport-relative to component-relative.\r\n         */\r\n        if (prevConstraints !== this.constraints &&\r\n            layout &&\r\n            this.constraints &&\r\n            !this.hasMutatedConstraints) {\r\n            eachAxis((axis) => {\r\n                if (this.constraints !== false &&\r\n                    this.getAxisMotionValue(axis)) {\r\n                    this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    resolveRefConstraints() {\r\n        const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();\r\n        if (!constraints || !isRefObject(constraints))\r\n            return false;\r\n        const constraintsElement = constraints.current;\r\n        invariant(constraintsElement !== null, \"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.\");\r\n        const { projection } = this.visualElement;\r\n        // TODO\r\n        if (!projection || !projection.layout)\r\n            return false;\r\n        const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());\r\n        let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);\r\n        /**\r\n         * If there's an onMeasureDragConstraints listener we call it and\r\n         * if different constraints are returned, set constraints to that\r\n         */\r\n        if (onMeasureDragConstraints) {\r\n            const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));\r\n            this.hasMutatedConstraints = !!userConstraints;\r\n            if (userConstraints) {\r\n                measuredConstraints = convertBoundingBoxToBox(userConstraints);\r\n            }\r\n        }\r\n        return measuredConstraints;\r\n    }\r\n    startAnimation(velocity) {\r\n        const { drag, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd, } = this.getProps();\r\n        const constraints = this.constraints || {};\r\n        const momentumAnimations = eachAxis((axis) => {\r\n            if (!shouldDrag(axis, drag, this.currentDirection)) {\r\n                return;\r\n            }\r\n            let transition = (constraints && constraints[axis]) || {};\r\n            if (dragSnapToOrigin)\r\n                transition = { min: 0, max: 0 };\r\n            /**\r\n             * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame\r\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\r\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\r\n             * using the value of `dragElastic`.\r\n             */\r\n            const bounceStiffness = dragElastic ? 200 : 1000000;\r\n            const bounceDamping = dragElastic ? 40 : 10000000;\r\n            const inertia = {\r\n                type: \"inertia\",\r\n                velocity: dragMomentum ? velocity[axis] : 0,\r\n                bounceStiffness,\r\n                bounceDamping,\r\n                timeConstant: 750,\r\n                restDelta: 1,\r\n                restSpeed: 10,\r\n                ...dragTransition,\r\n                ...transition,\r\n            };\r\n            // If we're not animating on an externally-provided `MotionValue` we can use the\r\n            // component's animation controls which will handle interactions with whileHover (etc),\r\n            // otherwise we just have to animate the `MotionValue` itself.\r\n            return this.startAxisValueAnimation(axis, inertia);\r\n        });\r\n        // Run all animations and then resolve the new drag constraints.\r\n        return Promise.all(momentumAnimations).then(onDragTransitionEnd);\r\n    }\r\n    startAxisValueAnimation(axis, transition) {\r\n        const axisValue = this.getAxisMotionValue(axis);\r\n        addValueToWillChange(this.visualElement, axis);\r\n        return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));\r\n    }\r\n    stopAnimation() {\r\n        eachAxis((axis) => this.getAxisMotionValue(axis).stop());\r\n    }\r\n    pauseAnimation() {\r\n        eachAxis((axis) => { var _a; return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.pause(); });\r\n    }\r\n    getAnimationState(axis) {\r\n        var _a;\r\n        return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.state;\r\n    }\r\n    /**\r\n     * Drag works differently depending on which props are provided.\r\n     *\r\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\r\n     * - Otherwise, we apply the delta to the x/y motion values.\r\n     */\r\n    getAxisMotionValue(axis) {\r\n        const dragKey = `_drag${axis.toUpperCase()}`;\r\n        const props = this.visualElement.getProps();\r\n        const externalMotionValue = props[dragKey];\r\n        return externalMotionValue\r\n            ? externalMotionValue\r\n            : this.visualElement.getValue(axis, (props.initial\r\n                ? props.initial[axis]\r\n                : undefined) || 0);\r\n    }\r\n    snapToCursor(point) {\r\n        eachAxis((axis) => {\r\n            const { drag } = this.getProps();\r\n            // If we're not dragging this axis, do an early return.\r\n            if (!shouldDrag(axis, drag, this.currentDirection))\r\n                return;\r\n            const { projection } = this.visualElement;\r\n            const axisValue = this.getAxisMotionValue(axis);\r\n            if (projection && projection.layout) {\r\n                const { min, max } = projection.layout.layoutBox[axis];\r\n                axisValue.set(point[axis] - mixNumber(min, max, 0.5));\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * When the viewport resizes we want to check if the measured constraints\r\n     * have changed and, if so, reposition the element within those new constraints\r\n     * relative to where it was before the resize.\r\n     */\r\n    scalePositionWithinConstraints() {\r\n        if (!this.visualElement.current)\r\n            return;\r\n        const { drag, dragConstraints } = this.getProps();\r\n        const { projection } = this.visualElement;\r\n        if (!isRefObject(dragConstraints) || !projection || !this.constraints)\r\n            return;\r\n        /**\r\n         * Stop current animations as there can be visual glitching if we try to do\r\n         * this mid-animation\r\n         */\r\n        this.stopAnimation();\r\n        /**\r\n         * Record the relative position of the dragged element relative to the\r\n         * constraints box and save as a progress value.\r\n         */\r\n        const boxProgress = { x: 0, y: 0 };\r\n        eachAxis((axis) => {\r\n            const axisValue = this.getAxisMotionValue(axis);\r\n            if (axisValue && this.constraints !== false) {\r\n                const latest = axisValue.get();\r\n                boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);\r\n            }\r\n        });\r\n        /**\r\n         * Update the layout of this element and resolve the latest drag constraints\r\n         */\r\n        const { transformTemplate } = this.visualElement.getProps();\r\n        this.visualElement.current.style.transform = transformTemplate\r\n            ? transformTemplate({}, \"\")\r\n            : \"none\";\r\n        projection.root && projection.root.updateScroll();\r\n        projection.updateLayout();\r\n        this.resolveConstraints();\r\n        /**\r\n         * For each axis, calculate the current progress of the layout axis\r\n         * within the new constraints.\r\n         */\r\n        eachAxis((axis) => {\r\n            if (!shouldDrag(axis, drag, null))\r\n                return;\r\n            /**\r\n             * Calculate a new transform based on the previous box progress\r\n             */\r\n            const axisValue = this.getAxisMotionValue(axis);\r\n            const { min, max } = this.constraints[axis];\r\n            axisValue.set(mixNumber(min, max, boxProgress[axis]));\r\n        });\r\n    }\r\n    addListeners() {\r\n        if (!this.visualElement.current)\r\n            return;\r\n        elementDragControls.set(this.visualElement, this);\r\n        const element = this.visualElement.current;\r\n        /**\r\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\r\n         */\r\n        const stopPointerListener = addPointerEvent(element, \"pointerdown\", (event) => {\r\n            const { drag, dragListener = true } = this.getProps();\r\n            drag && dragListener && this.start(event);\r\n        });\r\n        const measureDragConstraints = () => {\r\n            const { dragConstraints } = this.getProps();\r\n            if (isRefObject(dragConstraints) && dragConstraints.current) {\r\n                this.constraints = this.resolveRefConstraints();\r\n            }\r\n        };\r\n        const { projection } = this.visualElement;\r\n        const stopMeasureLayoutListener = projection.addEventListener(\"measure\", measureDragConstraints);\r\n        if (projection && !projection.layout) {\r\n            projection.root && projection.root.updateScroll();\r\n            projection.updateLayout();\r\n        }\r\n        frame.read(measureDragConstraints);\r\n        /**\r\n         * Attach a window resize listener to scale the draggable target within its defined\r\n         * constraints as the window resizes.\r\n         */\r\n        const stopResizeListener = addDomEvent(window, \"resize\", () => this.scalePositionWithinConstraints());\r\n        /**\r\n         * If the element's layout changes, calculate the delta and apply that to\r\n         * the drag gesture's origin point.\r\n         */\r\n        const stopLayoutUpdateListener = projection.addEventListener(\"didUpdate\", (({ delta, hasLayoutChanged }) => {\r\n            if (this.isDragging && hasLayoutChanged) {\r\n                eachAxis((axis) => {\r\n                    const motionValue = this.getAxisMotionValue(axis);\r\n                    if (!motionValue)\r\n                        return;\r\n                    this.originPoint[axis] += delta[axis].translate;\r\n                    motionValue.set(motionValue.get() + delta[axis].translate);\r\n                });\r\n                this.visualElement.render();\r\n            }\r\n        }));\r\n        return () => {\r\n            stopResizeListener();\r\n            stopPointerListener();\r\n            stopMeasureLayoutListener();\r\n            stopLayoutUpdateListener && stopLayoutUpdateListener();\r\n        };\r\n    }\r\n    getProps() {\r\n        const props = this.visualElement.getProps();\r\n        const { drag = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true, } = props;\r\n        return {\r\n            ...props,\r\n            drag,\r\n            dragDirectionLock,\r\n            dragPropagation,\r\n            dragConstraints,\r\n            dragElastic,\r\n            dragMomentum,\r\n        };\r\n    }\r\n}\r\nfunction shouldDrag(direction, drag, currentDirection) {\r\n    return ((drag === true || drag === direction) &&\r\n        (currentDirection === null || currentDirection === direction));\r\n}\r\n/**\r\n * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower\r\n * than the provided threshold, return `null`.\r\n *\r\n * @param offset - The x/y offset from origin.\r\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\r\n */\r\nfunction getCurrentDirection(offset, lockThreshold = 10) {\r\n    let direction = null;\r\n    if (Math.abs(offset.y) > lockThreshold) {\r\n        direction = \"y\";\r\n    }\r\n    else if (Math.abs(offset.x) > lockThreshold) {\r\n        direction = \"x\";\r\n    }\r\n    return direction;\r\n}\r\n\r\nexport { VisualElementDragControls, elementDragControls };\r\n","import { isDragging } from './is-active.mjs';\r\n\r\nfunction setDragLock(axis) {\r\n    if (axis === \"x\" || axis === \"y\") {\r\n        if (isDragging[axis]) {\r\n            return null;\r\n        }\r\n        else {\r\n            isDragging[axis] = true;\r\n            return () => {\r\n                isDragging[axis] = false;\r\n            };\r\n        }\r\n    }\r\n    else {\r\n        if (isDragging.x || isDragging.y) {\r\n            return null;\r\n        }\r\n        else {\r\n            isDragging.x = isDragging.y = true;\r\n            return () => {\r\n                isDragging.x = isDragging.y = false;\r\n            };\r\n        }\r\n    }\r\n}\r\n\r\nexport { setDragLock };\r\n","import { PanSession } from './PanSession.mjs';\r\nimport { addPointerEvent } from '../../events/add-pointer-event.mjs';\r\nimport { Feature } from '../../motion/features/Feature.mjs';\r\nimport { noop } from 'motion-utils';\r\nimport { getContextWindow } from '../../utils/get-context-window.mjs';\r\nimport { frame } from '../../frameloop/frame.mjs';\r\n\r\nconst asyncHandler = (handler) => (event, info) => {\r\n    if (handler) {\r\n        frame.postRender(() => handler(event, info));\r\n    }\r\n};\r\nclass PanGesture extends Feature {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.removePointerDownListener = noop;\r\n    }\r\n    onPointerDown(pointerDownEvent) {\r\n        this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {\r\n            transformPagePoint: this.node.getTransformPagePoint(),\r\n            contextWindow: getContextWindow(this.node),\r\n        });\r\n    }\r\n    createPanHandlers() {\r\n        const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();\r\n        return {\r\n            onSessionStart: asyncHandler(onPanSessionStart),\r\n            onStart: asyncHandler(onPanStart),\r\n            onMove: onPan,\r\n            onEnd: (event, info) => {\r\n                delete this.session;\r\n                if (onPanEnd) {\r\n                    frame.postRender(() => onPanEnd(event, info));\r\n                }\r\n            },\r\n        };\r\n    }\r\n    mount() {\r\n        this.removePointerDownListener = addPointerEvent(this.node.current, \"pointerdown\", (event) => this.onPointerDown(event));\r\n    }\r\n    update() {\r\n        this.session && this.session.updateHandlers(this.createPanHandlers());\r\n    }\r\n    unmount() {\r\n        this.removePointerDownListener();\r\n        this.session && this.session.end();\r\n    }\r\n}\r\n\r\nexport { PanGesture };\r\n","/**\r\n * This should only ever be modified on the client otherwise it'll\r\n * persist through server requests. If we need instanced states we\r\n * could lazy-init via root.\r\n */\r\nconst globalProjectionState = {\r\n    /**\r\n     * Global flag as to whether the tree has animated since the last time\r\n     * we resized the window\r\n     */\r\n    hasAnimatedSinceResize: true,\r\n    /**\r\n     * We set this to true once, on the first update. Any nodes added to the tree beyond that\r\n     * update will be given a `data-projection-id` attribute.\r\n     */\r\n    hasEverUpdated: false,\r\n};\r\n\r\nexport { globalProjectionState };\r\n","import { px } from '../../value/types/numbers/units.mjs';\r\n\r\nfunction pixelsToPercent(pixels, axis) {\r\n    if (axis.max === axis.min)\r\n        return 0;\r\n    return (pixels / (axis.max - axis.min)) * 100;\r\n}\r\n/**\r\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\r\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\r\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\r\n * borderRadius in both states. If we animate between the two in pixels that will trigger\r\n * a paint each time. If we animate between the two in percentage we'll avoid a paint.\r\n */\r\nconst correctBorderRadius = {\r\n    correct: (latest, node) => {\r\n        if (!node.target)\r\n            return latest;\r\n        /**\r\n         * If latest is a string, if it's a percentage we can return immediately as it's\r\n         * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.\r\n         */\r\n        if (typeof latest === \"string\") {\r\n            if (px.test(latest)) {\r\n                latest = parseFloat(latest);\r\n            }\r\n            else {\r\n                return latest;\r\n            }\r\n        }\r\n        /**\r\n         * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that\r\n         * pixel value as a percentage of each axis\r\n         */\r\n        const x = pixelsToPercent(latest, node.target.x);\r\n        const y = pixelsToPercent(latest, node.target.y);\r\n        return `${x}% ${y}%`;\r\n    },\r\n};\r\n\r\nexport { correctBorderRadius, pixelsToPercent };\r\n","import { mixNumber } from '../../utils/mix/number.mjs';\r\nimport { complex } from '../../value/types/complex/index.mjs';\r\n\r\nconst correctBoxShadow = {\r\n    correct: (latest, { treeScale, projectionDelta }) => {\r\n        const original = latest;\r\n        const shadow = complex.parse(latest);\r\n        // TODO: Doesn't support multiple shadows\r\n        if (shadow.length > 5)\r\n            return original;\r\n        const template = complex.createTransformer(latest);\r\n        const offset = typeof shadow[0] !== \"number\" ? 1 : 0;\r\n        // Calculate the overall context scale\r\n        const xScale = projectionDelta.x.scale * treeScale.x;\r\n        const yScale = projectionDelta.y.scale * treeScale.y;\r\n        shadow[0 + offset] /= xScale;\r\n        shadow[1 + offset] /= yScale;\r\n        /**\r\n         * Ideally we'd correct x and y scales individually, but because blur and\r\n         * spread apply to both we have to take a scale average and apply that instead.\r\n         * We could potentially improve the outcome of this by incorporating the ratio between\r\n         * the two scales.\r\n         */\r\n        const averageScale = mixNumber(xScale, yScale, 0.5);\r\n        // Blur\r\n        if (typeof shadow[2 + offset] === \"number\")\r\n            shadow[2 + offset] /= averageScale;\r\n        // Spread\r\n        if (typeof shadow[3 + offset] === \"number\")\r\n            shadow[3 + offset] /= averageScale;\r\n        return template(shadow);\r\n    },\r\n};\r\n\r\nexport { correctBoxShadow };\r\n","\"use client\";\r\nimport { jsx } from 'react/jsx-runtime';\r\nimport { useContext, Component } from 'react';\r\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.mjs';\r\nimport { LayoutGroupContext } from '../../../context/LayoutGroupContext.mjs';\r\nimport { SwitchLayoutGroupContext } from '../../../context/SwitchLayoutGroupContext.mjs';\r\nimport { globalProjectionState } from '../../../projection/node/state.mjs';\r\nimport { correctBorderRadius } from '../../../projection/styles/scale-border-radius.mjs';\r\nimport { correctBoxShadow } from '../../../projection/styles/scale-box-shadow.mjs';\r\nimport { addScaleCorrector } from '../../../projection/styles/scale-correction.mjs';\r\nimport { microtask } from '../../../frameloop/microtask.mjs';\r\nimport { frame } from '../../../frameloop/frame.mjs';\r\n\r\nclass MeasureLayoutWithContext extends Component {\r\n    /**\r\n     * This only mounts projection nodes for components that\r\n     * need measuring, we might want to do it for all components\r\n     * in order to incorporate transforms\r\n     */\r\n    componentDidMount() {\r\n        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;\r\n        const { projection } = visualElement;\r\n        addScaleCorrector(defaultScaleCorrectors);\r\n        if (projection) {\r\n            if (layoutGroup.group)\r\n                layoutGroup.group.add(projection);\r\n            if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\r\n                switchLayoutGroup.register(projection);\r\n            }\r\n            projection.root.didUpdate();\r\n            projection.addEventListener(\"animationComplete\", () => {\r\n                this.safeToRemove();\r\n            });\r\n            projection.setOptions({\r\n                ...projection.options,\r\n                onExitComplete: () => this.safeToRemove(),\r\n            });\r\n        }\r\n        globalProjectionState.hasEverUpdated = true;\r\n    }\r\n    getSnapshotBeforeUpdate(prevProps) {\r\n        const { layoutDependency, visualElement, drag, isPresent } = this.props;\r\n        const projection = visualElement.projection;\r\n        if (!projection)\r\n            return null;\r\n        /**\r\n         * TODO: We use this data in relegate to determine whether to\r\n         * promote a previous element. There's no guarantee its presence data\r\n         * will have updated by this point - if a bug like this arises it will\r\n         * have to be that we markForRelegation and then find a new lead some other way,\r\n         * perhaps in didUpdate\r\n         */\r\n        projection.isPresent = isPresent;\r\n        if (drag ||\r\n            prevProps.layoutDependency !== layoutDependency ||\r\n            layoutDependency === undefined) {\r\n            projection.willUpdate();\r\n        }\r\n        else {\r\n            this.safeToRemove();\r\n        }\r\n        if (prevProps.isPresent !== isPresent) {\r\n            if (isPresent) {\r\n                projection.promote();\r\n            }\r\n            else if (!projection.relegate()) {\r\n                /**\r\n                 * If there's another stack member taking over from this one,\r\n                 * it's in charge of the exit animation and therefore should\r\n                 * be in charge of the safe to remove. Otherwise we call it here.\r\n                 */\r\n                frame.postRender(() => {\r\n                    const stack = projection.getStack();\r\n                    if (!stack || !stack.members.length) {\r\n                        this.safeToRemove();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    componentDidUpdate() {\r\n        const { projection } = this.props.visualElement;\r\n        if (projection) {\r\n            projection.root.didUpdate();\r\n            microtask.postRender(() => {\r\n                if (!projection.currentAnimation && projection.isLead()) {\r\n                    this.safeToRemove();\r\n                }\r\n            });\r\n        }\r\n    }\r\n    componentWillUnmount() {\r\n        const { visualElement, layoutGroup, switchLayoutGroup: promoteContext, } = this.props;\r\n        const { projection } = visualElement;\r\n        if (projection) {\r\n            projection.scheduleCheckAfterUnmount();\r\n            if (layoutGroup && layoutGroup.group)\r\n                layoutGroup.group.remove(projection);\r\n            if (promoteContext && promoteContext.deregister)\r\n                promoteContext.deregister(projection);\r\n        }\r\n    }\r\n    safeToRemove() {\r\n        const { safeToRemove } = this.props;\r\n        safeToRemove && safeToRemove();\r\n    }\r\n    render() {\r\n        return null;\r\n    }\r\n}\r\nfunction MeasureLayout(props) {\r\n    const [isPresent, safeToRemove] = usePresence();\r\n    const layoutGroup = useContext(LayoutGroupContext);\r\n    return (jsx(MeasureLayoutWithContext, { ...props, layoutGroup: layoutGroup, switchLayoutGroup: useContext(SwitchLayoutGroupContext), isPresent: isPresent, safeToRemove: safeToRemove }));\r\n}\r\nconst defaultScaleCorrectors = {\r\n    borderRadius: {\r\n        ...correctBorderRadius,\r\n        applyTo: [\r\n            \"borderTopLeftRadius\",\r\n            \"borderTopRightRadius\",\r\n            \"borderBottomLeftRadius\",\r\n            \"borderBottomRightRadius\",\r\n        ],\r\n    },\r\n    borderTopLeftRadius: correctBorderRadius,\r\n    borderTopRightRadius: correctBorderRadius,\r\n    borderBottomLeftRadius: correctBorderRadius,\r\n    borderBottomRightRadius: correctBorderRadius,\r\n    boxShadow: correctBoxShadow,\r\n};\r\n\r\nexport { MeasureLayout };\r\n","const compareByDepth = (a, b) => a.depth - b.depth;\r\n\r\nexport { compareByDepth };\r\n","import { addUniqueItem, removeItem } from '../../utils/array.mjs';\r\nimport { compareByDepth } from './compare-by-depth.mjs';\r\n\r\nclass FlatTree {\r\n    constructor() {\r\n        this.children = [];\r\n        this.isDirty = false;\r\n    }\r\n    add(child) {\r\n        addUniqueItem(this.children, child);\r\n        this.isDirty = true;\r\n    }\r\n    remove(child) {\r\n        removeItem(this.children, child);\r\n        this.isDirty = true;\r\n    }\r\n    forEach(callback) {\r\n        this.isDirty && this.children.sort(compareByDepth);\r\n        this.isDirty = false;\r\n        this.children.forEach(callback);\r\n    }\r\n}\r\n\r\nexport { FlatTree };\r\n","import { progress, noop } from 'motion-utils';\r\nimport { circOut } from '../../easing/circ.mjs';\r\nimport { mixNumber } from '../../utils/mix/number.mjs';\r\nimport { percent, px } from '../../value/types/numbers/units.mjs';\r\n\r\nconst borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\r\nconst numBorders = borders.length;\r\nconst asNumber = (value) => typeof value === \"string\" ? parseFloat(value) : value;\r\nconst isPx = (value) => typeof value === \"number\" || px.test(value);\r\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\r\n    if (shouldCrossfadeOpacity) {\r\n        target.opacity = mixNumber(0, \r\n        // TODO Reinstate this if only child\r\n        lead.opacity !== undefined ? lead.opacity : 1, easeCrossfadeIn(progress));\r\n        target.opacityExit = mixNumber(follow.opacity !== undefined ? follow.opacity : 1, 0, easeCrossfadeOut(progress));\r\n    }\r\n    else if (isOnlyMember) {\r\n        target.opacity = mixNumber(follow.opacity !== undefined ? follow.opacity : 1, lead.opacity !== undefined ? lead.opacity : 1, progress);\r\n    }\r\n    /**\r\n     * Mix border radius\r\n     */\r\n    for (let i = 0; i < numBorders; i++) {\r\n        const borderLabel = `border${borders[i]}Radius`;\r\n        let followRadius = getRadius(follow, borderLabel);\r\n        let leadRadius = getRadius(lead, borderLabel);\r\n        if (followRadius === undefined && leadRadius === undefined)\r\n            continue;\r\n        followRadius || (followRadius = 0);\r\n        leadRadius || (leadRadius = 0);\r\n        const canMix = followRadius === 0 ||\r\n            leadRadius === 0 ||\r\n            isPx(followRadius) === isPx(leadRadius);\r\n        if (canMix) {\r\n            target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress), 0);\r\n            if (percent.test(leadRadius) || percent.test(followRadius)) {\r\n                target[borderLabel] += \"%\";\r\n            }\r\n        }\r\n        else {\r\n            target[borderLabel] = leadRadius;\r\n        }\r\n    }\r\n    /**\r\n     * Mix rotation\r\n     */\r\n    if (follow.rotate || lead.rotate) {\r\n        target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress);\r\n    }\r\n}\r\nfunction getRadius(values, radiusName) {\r\n    return values[radiusName] !== undefined\r\n        ? values[radiusName]\r\n        : values.borderRadius;\r\n}\r\n// /**\r\n//  * We only want to mix the background color if there's a follow element\r\n//  * that we're not crossfading opacity between. For instance with switch\r\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\r\n//  * element being animated but also cuts down on the number of paints triggered\r\n//  * for elements where opacity is doing that work for us.\r\n//  */\r\n// if (\r\n//     !hasFollowElement &&\r\n//     latestLeadValues.backgroundColor &&\r\n//     latestFollowValues.backgroundColor\r\n// ) {\r\n//     /**\r\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\r\n//      * We could probably create a mixer that runs at the start of the animation but\r\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\r\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\r\n//      */\r\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\r\n//         latestFollowValues.backgroundColor as string,\r\n//         latestLeadValues.backgroundColor as string\r\n//     )(p)\r\n// }\r\nconst easeCrossfadeIn = /*@__PURE__*/ compress(0, 0.5, circOut);\r\nconst easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, noop);\r\nfunction compress(min, max, easing) {\r\n    return (p) => {\r\n        // Could replace ifs with clamp\r\n        if (p < min)\r\n            return 0;\r\n        if (p > max)\r\n            return 1;\r\n        return easing(progress(min, max, p));\r\n    };\r\n}\r\n\r\nexport { mixValues };\r\n","/**\r\n * Reset an axis to the provided origin box.\r\n *\r\n * This is a mutative operation.\r\n */\r\nfunction copyAxisInto(axis, originAxis) {\r\n    axis.min = originAxis.min;\r\n    axis.max = originAxis.max;\r\n}\r\n/**\r\n * Reset a box to the provided origin box.\r\n *\r\n * This is a mutative operation.\r\n */\r\nfunction copyBoxInto(box, originBox) {\r\n    copyAxisInto(box.x, originBox.x);\r\n    copyAxisInto(box.y, originBox.y);\r\n}\r\n/**\r\n * Reset a delta to the provided origin box.\r\n *\r\n * This is a mutative operation.\r\n */\r\nfunction copyAxisDeltaInto(delta, originDelta) {\r\n    delta.translate = originDelta.translate;\r\n    delta.scale = originDelta.scale;\r\n    delta.originPoint = originDelta.originPoint;\r\n    delta.origin = originDelta.origin;\r\n}\r\n\r\nexport { copyAxisDeltaInto, copyAxisInto, copyBoxInto };\r\n","import { mixNumber } from '../../utils/mix/number.mjs';\r\nimport { percent } from '../../value/types/numbers/units.mjs';\r\nimport { scalePoint } from './delta-apply.mjs';\r\n\r\n/**\r\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\r\n */\r\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\r\n    point -= translate;\r\n    point = scalePoint(point, 1 / scale, originPoint);\r\n    if (boxScale !== undefined) {\r\n        point = scalePoint(point, 1 / boxScale, originPoint);\r\n    }\r\n    return point;\r\n}\r\n/**\r\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\r\n */\r\nfunction removeAxisDelta(axis, translate = 0, scale = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {\r\n    if (percent.test(translate)) {\r\n        translate = parseFloat(translate);\r\n        const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);\r\n        translate = relativeProgress - sourceAxis.min;\r\n    }\r\n    if (typeof translate !== \"number\")\r\n        return;\r\n    let originPoint = mixNumber(originAxis.min, originAxis.max, origin);\r\n    if (axis === originAxis)\r\n        originPoint -= translate;\r\n    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\r\n    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\r\n}\r\n/**\r\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\r\n * and acts as a bridge between motion values and removeAxisDelta\r\n */\r\nfunction removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {\r\n    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);\r\n}\r\n/**\r\n * The names of the motion values we want to apply as translation, scale and origin.\r\n */\r\nconst xKeys = [\"x\", \"scaleX\", \"originX\"];\r\nconst yKeys = [\"y\", \"scaleY\", \"originY\"];\r\n/**\r\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\r\n * and acts as a bridge between motion values and removeAxisDelta\r\n */\r\nfunction removeBoxTransforms(box, transforms, originBox, sourceBox) {\r\n    removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : undefined, sourceBox ? sourceBox.x : undefined);\r\n    removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : undefined, sourceBox ? sourceBox.y : undefined);\r\n}\r\n\r\nexport { removeAxisDelta, removeAxisTransforms, removeBoxTransforms, removePointDelta };\r\n","import { calcLength } from './delta-calc.mjs';\r\n\r\nfunction isAxisDeltaZero(delta) {\r\n    return delta.translate === 0 && delta.scale === 1;\r\n}\r\nfunction isDeltaZero(delta) {\r\n    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);\r\n}\r\nfunction axisEquals(a, b) {\r\n    return a.min === b.min && a.max === b.max;\r\n}\r\nfunction boxEquals(a, b) {\r\n    return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);\r\n}\r\nfunction axisEqualsRounded(a, b) {\r\n    return (Math.round(a.min) === Math.round(b.min) &&\r\n        Math.round(a.max) === Math.round(b.max));\r\n}\r\nfunction boxEqualsRounded(a, b) {\r\n    return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);\r\n}\r\nfunction aspectRatio(box) {\r\n    return calcLength(box.x) / calcLength(box.y);\r\n}\r\nfunction axisDeltaEquals(a, b) {\r\n    return (a.translate === b.translate &&\r\n        a.scale === b.scale &&\r\n        a.originPoint === b.originPoint);\r\n}\r\n\r\nexport { aspectRatio, axisDeltaEquals, axisEquals, axisEqualsRounded, boxEquals, boxEqualsRounded, isDeltaZero };\r\n","import { addUniqueItem, removeItem } from '../../utils/array.mjs';\r\n\r\nclass NodeStack {\r\n    constructor() {\r\n        this.members = [];\r\n    }\r\n    add(node) {\r\n        addUniqueItem(this.members, node);\r\n        node.scheduleRender();\r\n    }\r\n    remove(node) {\r\n        removeItem(this.members, node);\r\n        if (node === this.prevLead) {\r\n            this.prevLead = undefined;\r\n        }\r\n        if (node === this.lead) {\r\n            const prevLead = this.members[this.members.length - 1];\r\n            if (prevLead) {\r\n                this.promote(prevLead);\r\n            }\r\n        }\r\n    }\r\n    relegate(node) {\r\n        const indexOfNode = this.members.findIndex((member) => node === member);\r\n        if (indexOfNode === 0)\r\n            return false;\r\n        /**\r\n         * Find the next projection node that is present\r\n         */\r\n        let prevLead;\r\n        for (let i = indexOfNode; i >= 0; i--) {\r\n            const member = this.members[i];\r\n            if (member.isPresent !== false) {\r\n                prevLead = member;\r\n                break;\r\n            }\r\n        }\r\n        if (prevLead) {\r\n            this.promote(prevLead);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    promote(node, preserveFollowOpacity) {\r\n        const prevLead = this.lead;\r\n        if (node === prevLead)\r\n            return;\r\n        this.prevLead = prevLead;\r\n        this.lead = node;\r\n        node.show();\r\n        if (prevLead) {\r\n            prevLead.instance && prevLead.scheduleRender();\r\n            node.scheduleRender();\r\n            node.resumeFrom = prevLead;\r\n            if (preserveFollowOpacity) {\r\n                node.resumeFrom.preserveOpacity = true;\r\n            }\r\n            if (prevLead.snapshot) {\r\n                node.snapshot = prevLead.snapshot;\r\n                node.snapshot.latestValues =\r\n                    prevLead.animationValues || prevLead.latestValues;\r\n            }\r\n            if (node.root && node.root.isUpdating) {\r\n                node.isLayoutDirty = true;\r\n            }\r\n            const { crossfade } = node.options;\r\n            if (crossfade === false) {\r\n                prevLead.hide();\r\n            }\r\n            /**\r\n             * TODO:\r\n             *   - Test border radius when previous node was deleted\r\n             *   - boxShadow mixing\r\n             *   - Shared between element A in scrolled container and element B (scroll stays the same or changes)\r\n             *   - Shared between element A in transformed container and element B (transform stays the same or changes)\r\n             *   - Shared between element A in scrolled page and element B (scroll stays the same or changes)\r\n             * ---\r\n             *   - Crossfade opacity of root nodes\r\n             *   - layoutId changes after animation\r\n             *   - layoutId changes mid animation\r\n             */\r\n        }\r\n    }\r\n    exitAnimationComplete() {\r\n        this.members.forEach((node) => {\r\n            const { options, resumingFrom } = node;\r\n            options.onExitComplete && options.onExitComplete();\r\n            if (resumingFrom) {\r\n                resumingFrom.options.onExitComplete &&\r\n                    resumingFrom.options.onExitComplete();\r\n            }\r\n        });\r\n    }\r\n    scheduleRender() {\r\n        this.members.forEach((node) => {\r\n            node.instance && node.scheduleRender(false);\r\n        });\r\n    }\r\n    /**\r\n     * Clear any leads that have been removed this render to prevent them from being\r\n     * used in future animations and to prevent memory leaks\r\n     */\r\n    removeLeadSnapshot() {\r\n        if (this.lead && this.lead.snapshot) {\r\n            this.lead.snapshot = undefined;\r\n        }\r\n    }\r\n}\r\n\r\nexport { NodeStack };\r\n","import { getValueTransition } from 'motion-dom';\r\nimport { noop } from 'motion-utils';\r\nimport { animateSingleValue } from '../../animation/animate/single-value.mjs';\r\nimport { getOptimisedAppearId } from '../../animation/optimized-appear/get-appear-id.mjs';\r\nimport { cancelFrame, frameData, frameSteps, frame } from '../../frameloop/frame.mjs';\r\nimport { microtask } from '../../frameloop/microtask.mjs';\r\nimport { time } from '../../frameloop/sync-time.mjs';\r\nimport { isSVGElement } from '../../render/dom/utils/is-svg-element.mjs';\r\nimport { FlatTree } from '../../render/utils/flat-tree.mjs';\r\nimport { clamp } from '../../utils/clamp.mjs';\r\nimport { delay } from '../../utils/delay.mjs';\r\nimport { mixNumber } from '../../utils/mix/number.mjs';\r\nimport { SubscriptionManager } from '../../utils/subscription-manager.mjs';\r\nimport { resolveMotionValue } from '../../value/utils/resolve-motion-value.mjs';\r\nimport { mixValues } from '../animation/mix-values.mjs';\r\nimport { copyBoxInto, copyAxisDeltaInto } from '../geometry/copy.mjs';\r\nimport { translateAxis, transformBox, applyBoxDelta, applyTreeDeltas } from '../geometry/delta-apply.mjs';\r\nimport { calcRelativePosition, calcRelativeBox, calcBoxDelta, calcLength, isNear } from '../geometry/delta-calc.mjs';\r\nimport { removeBoxTransforms } from '../geometry/delta-remove.mjs';\r\nimport { createBox, createDelta } from '../geometry/models.mjs';\r\nimport { boxEqualsRounded, isDeltaZero, axisDeltaEquals, aspectRatio, boxEquals } from '../geometry/utils.mjs';\r\nimport { NodeStack } from '../shared/stack.mjs';\r\nimport { scaleCorrectors } from '../styles/scale-correction.mjs';\r\nimport { buildProjectionTransform } from '../styles/transform.mjs';\r\nimport { eachAxis } from '../utils/each-axis.mjs';\r\nimport { hasTransform, hasScale, has2DTranslate } from '../utils/has-transform.mjs';\r\nimport { globalProjectionState } from './state.mjs';\r\n\r\nconst metrics = {\r\n    type: \"projectionFrame\",\r\n    totalNodes: 0,\r\n    resolvedTargetDeltas: 0,\r\n    recalculatedProjection: 0,\r\n};\r\nconst isDebug = typeof window !== \"undefined\" && window.MotionDebug !== undefined;\r\nconst transformAxes = [\"\", \"X\", \"Y\", \"Z\"];\r\nconst hiddenVisibility = { visibility: \"hidden\" };\r\n/**\r\n * We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1\r\n * which has a noticeable difference in spring animations\r\n */\r\nconst animationTarget = 1000;\r\nlet id = 0;\r\nfunction resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {\r\n    const { latestValues } = visualElement;\r\n    // Record the distorting transform and then temporarily set it to 0\r\n    if (latestValues[key]) {\r\n        values[key] = latestValues[key];\r\n        visualElement.setStaticValue(key, 0);\r\n        if (sharedAnimationValues) {\r\n            sharedAnimationValues[key] = 0;\r\n        }\r\n    }\r\n}\r\nfunction cancelTreeOptimisedTransformAnimations(projectionNode) {\r\n    projectionNode.hasCheckedOptimisedAppear = true;\r\n    if (projectionNode.root === projectionNode)\r\n        return;\r\n    const { visualElement } = projectionNode.options;\r\n    if (!visualElement)\r\n        return;\r\n    const appearId = getOptimisedAppearId(visualElement);\r\n    if (window.MotionHasOptimisedAnimation(appearId, \"transform\")) {\r\n        const { layout, layoutId } = projectionNode.options;\r\n        window.MotionCancelOptimisedAnimation(appearId, \"transform\", frame, !(layout || layoutId));\r\n    }\r\n    const { parent } = projectionNode;\r\n    if (parent && !parent.hasCheckedOptimisedAppear) {\r\n        cancelTreeOptimisedTransformAnimations(parent);\r\n    }\r\n}\r\nfunction createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform, }) {\r\n    return class ProjectionNode {\r\n        constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {\r\n            /**\r\n             * A unique ID generated for every projection node.\r\n             */\r\n            this.id = id++;\r\n            /**\r\n             * An id that represents a unique session instigated by startUpdate.\r\n             */\r\n            this.animationId = 0;\r\n            /**\r\n             * A Set containing all this component's children. This is used to iterate\r\n             * through the children.\r\n             *\r\n             * TODO: This could be faster to iterate as a flat array stored on the root node.\r\n             */\r\n            this.children = new Set();\r\n            /**\r\n             * Options for the node. We use this to configure what kind of layout animations\r\n             * we should perform (if any).\r\n             */\r\n            this.options = {};\r\n            /**\r\n             * We use this to detect when its safe to shut down part of a projection tree.\r\n             * We have to keep projecting children for scale correction and relative projection\r\n             * until all their parents stop performing layout animations.\r\n             */\r\n            this.isTreeAnimating = false;\r\n            this.isAnimationBlocked = false;\r\n            /**\r\n             * Flag to true if we think this layout has been changed. We can't always know this,\r\n             * currently we set it to true every time a component renders, or if it has a layoutDependency\r\n             * if that has changed between renders. Additionally, components can be grouped by LayoutGroup\r\n             * and if one node is dirtied, they all are.\r\n             */\r\n            this.isLayoutDirty = false;\r\n            /**\r\n             * Flag to true if we think the projection calculations for this node needs\r\n             * recalculating as a result of an updated transform or layout animation.\r\n             */\r\n            this.isProjectionDirty = false;\r\n            /**\r\n             * Flag to true if the layout *or* transform has changed. This then gets propagated\r\n             * throughout the projection tree, forcing any element below to recalculate on the next frame.\r\n             */\r\n            this.isSharedProjectionDirty = false;\r\n            /**\r\n             * Flag transform dirty. This gets propagated throughout the whole tree but is only\r\n             * respected by shared nodes.\r\n             */\r\n            this.isTransformDirty = false;\r\n            /**\r\n             * Block layout updates for instant layout transitions throughout the tree.\r\n             */\r\n            this.updateManuallyBlocked = false;\r\n            this.updateBlockedByResize = false;\r\n            /**\r\n             * Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`\r\n             * call.\r\n             */\r\n            this.isUpdating = false;\r\n            /**\r\n             * If this is an SVG element we currently disable projection transforms\r\n             */\r\n            this.isSVG = false;\r\n            /**\r\n             * Flag to true (during promotion) if a node doing an instant layout transition needs to reset\r\n             * its projection styles.\r\n             */\r\n            this.needsReset = false;\r\n            /**\r\n             * Flags whether this node should have its transform reset prior to measuring.\r\n             */\r\n            this.shouldResetTransform = false;\r\n            /**\r\n             * Store whether this node has been checked for optimised appear animations. As\r\n             * effects fire bottom-up, and we want to look up the tree for appear animations,\r\n             * this makes sure we only check each path once, stopping at nodes that\r\n             * have already been checked.\r\n             */\r\n            this.hasCheckedOptimisedAppear = false;\r\n            /**\r\n             * An object representing the calculated contextual/accumulated/tree scale.\r\n             * This will be used to scale calculcated projection transforms, as these are\r\n             * calculated in screen-space but need to be scaled for elements to layoutly\r\n             * make it to their calculated destinations.\r\n             *\r\n             * TODO: Lazy-init\r\n             */\r\n            this.treeScale = { x: 1, y: 1 };\r\n            /**\r\n             *\r\n             */\r\n            this.eventHandlers = new Map();\r\n            this.hasTreeAnimated = false;\r\n            // Note: Currently only running on root node\r\n            this.updateScheduled = false;\r\n            this.scheduleUpdate = () => this.update();\r\n            this.projectionUpdateScheduled = false;\r\n            this.checkUpdateFailed = () => {\r\n                if (this.isUpdating) {\r\n                    this.isUpdating = false;\r\n                    this.clearAllSnapshots();\r\n                }\r\n            };\r\n            /**\r\n             * This is a multi-step process as shared nodes might be of different depths. Nodes\r\n             * are sorted by depth order, so we need to resolve the entire tree before moving to\r\n             * the next step.\r\n             */\r\n            this.updateProjection = () => {\r\n                this.projectionUpdateScheduled = false;\r\n                /**\r\n                 * Reset debug counts. Manually resetting rather than creating a new\r\n                 * object each frame.\r\n                 */\r\n                if (isDebug) {\r\n                    metrics.totalNodes =\r\n                        metrics.resolvedTargetDeltas =\r\n                            metrics.recalculatedProjection =\r\n                                0;\r\n                }\r\n                this.nodes.forEach(propagateDirtyNodes);\r\n                this.nodes.forEach(resolveTargetDelta);\r\n                this.nodes.forEach(calcProjection);\r\n                this.nodes.forEach(cleanDirtyNodes);\r\n                if (isDebug) {\r\n                    window.MotionDebug.record(metrics);\r\n                }\r\n            };\r\n            /**\r\n             * Frame calculations\r\n             */\r\n            this.resolvedRelativeTargetAt = 0.0;\r\n            this.hasProjected = false;\r\n            this.isVisible = true;\r\n            this.animationProgress = 0;\r\n            /**\r\n             * Shared layout\r\n             */\r\n            // TODO Only running on root node\r\n            this.sharedNodes = new Map();\r\n            this.latestValues = latestValues;\r\n            this.root = parent ? parent.root || parent : this;\r\n            this.path = parent ? [...parent.path, parent] : [];\r\n            this.parent = parent;\r\n            this.depth = parent ? parent.depth + 1 : 0;\r\n            for (let i = 0; i < this.path.length; i++) {\r\n                this.path[i].shouldResetTransform = true;\r\n            }\r\n            if (this.root === this)\r\n                this.nodes = new FlatTree();\r\n        }\r\n        addEventListener(name, handler) {\r\n            if (!this.eventHandlers.has(name)) {\r\n                this.eventHandlers.set(name, new SubscriptionManager());\r\n            }\r\n            return this.eventHandlers.get(name).add(handler);\r\n        }\r\n        notifyListeners(name, ...args) {\r\n            const subscriptionManager = this.eventHandlers.get(name);\r\n            subscriptionManager && subscriptionManager.notify(...args);\r\n        }\r\n        hasListeners(name) {\r\n            return this.eventHandlers.has(name);\r\n        }\r\n        /**\r\n         * Lifecycles\r\n         */\r\n        mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {\r\n            if (this.instance)\r\n                return;\r\n            this.isSVG = isSVGElement(instance);\r\n            this.instance = instance;\r\n            const { layoutId, layout, visualElement } = this.options;\r\n            if (visualElement && !visualElement.current) {\r\n                visualElement.mount(instance);\r\n            }\r\n            this.root.nodes.add(this);\r\n            this.parent && this.parent.children.add(this);\r\n            if (isLayoutDirty && (layout || layoutId)) {\r\n                this.isLayoutDirty = true;\r\n            }\r\n            if (attachResizeListener) {\r\n                let cancelDelay;\r\n                const resizeUnblockUpdate = () => (this.root.updateBlockedByResize = false);\r\n                attachResizeListener(instance, () => {\r\n                    this.root.updateBlockedByResize = true;\r\n                    cancelDelay && cancelDelay();\r\n                    cancelDelay = delay(resizeUnblockUpdate, 250);\r\n                    if (globalProjectionState.hasAnimatedSinceResize) {\r\n                        globalProjectionState.hasAnimatedSinceResize = false;\r\n                        this.nodes.forEach(finishAnimation);\r\n                    }\r\n                });\r\n            }\r\n            if (layoutId) {\r\n                this.root.registerSharedNode(layoutId, this);\r\n            }\r\n            // Only register the handler if it requires layout animation\r\n            if (this.options.animate !== false &&\r\n                visualElement &&\r\n                (layoutId || layout)) {\r\n                this.addEventListener(\"didUpdate\", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout, }) => {\r\n                    if (this.isTreeAnimationBlocked()) {\r\n                        this.target = undefined;\r\n                        this.relativeTarget = undefined;\r\n                        return;\r\n                    }\r\n                    // TODO: Check here if an animation exists\r\n                    const layoutTransition = this.options.transition ||\r\n                        visualElement.getDefaultTransition() ||\r\n                        defaultLayoutTransition;\r\n                    const { onLayoutAnimationStart, onLayoutAnimationComplete, } = visualElement.getProps();\r\n                    /**\r\n                     * The target layout of the element might stay the same,\r\n                     * but its position relative to its parent has changed.\r\n                     */\r\n                    const targetChanged = !this.targetLayout ||\r\n                        !boxEqualsRounded(this.targetLayout, newLayout) ||\r\n                        hasRelativeTargetChanged;\r\n                    /**\r\n                     * If the layout hasn't seemed to have changed, it might be that the\r\n                     * element is visually in the same place in the document but its position\r\n                     * relative to its parent has indeed changed. So here we check for that.\r\n                     */\r\n                    const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;\r\n                    if (this.options.layoutRoot ||\r\n                        (this.resumeFrom && this.resumeFrom.instance) ||\r\n                        hasOnlyRelativeTargetChanged ||\r\n                        (hasLayoutChanged &&\r\n                            (targetChanged || !this.currentAnimation))) {\r\n                        if (this.resumeFrom) {\r\n                            this.resumingFrom = this.resumeFrom;\r\n                            this.resumingFrom.resumingFrom = undefined;\r\n                        }\r\n                        this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);\r\n                        const animationOptions = {\r\n                            ...getValueTransition(layoutTransition, \"layout\"),\r\n                            onPlay: onLayoutAnimationStart,\r\n                            onComplete: onLayoutAnimationComplete,\r\n                        };\r\n                        if (visualElement.shouldReduceMotion ||\r\n                            this.options.layoutRoot) {\r\n                            animationOptions.delay = 0;\r\n                            animationOptions.type = false;\r\n                        }\r\n                        this.startAnimation(animationOptions);\r\n                    }\r\n                    else {\r\n                        /**\r\n                         * If the layout hasn't changed and we have an animation that hasn't started yet,\r\n                         * finish it immediately. Otherwise it will be animating from a location\r\n                         * that was probably never commited to screen and look like a jumpy box.\r\n                         */\r\n                        if (!hasLayoutChanged) {\r\n                            finishAnimation(this);\r\n                        }\r\n                        if (this.isLead() && this.options.onExitComplete) {\r\n                            this.options.onExitComplete();\r\n                        }\r\n                    }\r\n                    this.targetLayout = newLayout;\r\n                });\r\n            }\r\n        }\r\n        unmount() {\r\n            this.options.layoutId && this.willUpdate();\r\n            this.root.nodes.remove(this);\r\n            const stack = this.getStack();\r\n            stack && stack.remove(this);\r\n            this.parent && this.parent.children.delete(this);\r\n            this.instance = undefined;\r\n            cancelFrame(this.updateProjection);\r\n        }\r\n        // only on the root\r\n        blockUpdate() {\r\n            this.updateManuallyBlocked = true;\r\n        }\r\n        unblockUpdate() {\r\n            this.updateManuallyBlocked = false;\r\n        }\r\n        isUpdateBlocked() {\r\n            return this.updateManuallyBlocked || this.updateBlockedByResize;\r\n        }\r\n        isTreeAnimationBlocked() {\r\n            return (this.isAnimationBlocked ||\r\n                (this.parent && this.parent.isTreeAnimationBlocked()) ||\r\n                false);\r\n        }\r\n        // Note: currently only running on root node\r\n        startUpdate() {\r\n            if (this.isUpdateBlocked())\r\n                return;\r\n            this.isUpdating = true;\r\n            this.nodes && this.nodes.forEach(resetSkewAndRotation);\r\n            this.animationId++;\r\n        }\r\n        getTransformTemplate() {\r\n            const { visualElement } = this.options;\r\n            return visualElement && visualElement.getProps().transformTemplate;\r\n        }\r\n        willUpdate(shouldNotifyListeners = true) {\r\n            this.root.hasTreeAnimated = true;\r\n            if (this.root.isUpdateBlocked()) {\r\n                this.options.onExitComplete && this.options.onExitComplete();\r\n                return;\r\n            }\r\n            /**\r\n             * If we're running optimised appear animations then these must be\r\n             * cancelled before measuring the DOM. This is so we can measure\r\n             * the true layout of the element rather than the WAAPI animation\r\n             * which will be unaffected by the resetSkewAndRotate step.\r\n             *\r\n             * Note: This is a DOM write. Worst case scenario is this is sandwiched\r\n             * between other snapshot reads which will cause unnecessary style recalculations.\r\n             * This has to happen here though, as we don't yet know which nodes will need\r\n             * snapshots in startUpdate(), but we only want to cancel optimised animations\r\n             * if a layout animation measurement is actually going to be affected by them.\r\n             */\r\n            if (window.MotionCancelOptimisedAnimation &&\r\n                !this.hasCheckedOptimisedAppear) {\r\n                cancelTreeOptimisedTransformAnimations(this);\r\n            }\r\n            !this.root.isUpdating && this.root.startUpdate();\r\n            if (this.isLayoutDirty)\r\n                return;\r\n            this.isLayoutDirty = true;\r\n            for (let i = 0; i < this.path.length; i++) {\r\n                const node = this.path[i];\r\n                node.shouldResetTransform = true;\r\n                node.updateScroll(\"snapshot\");\r\n                if (node.options.layoutRoot) {\r\n                    node.willUpdate(false);\r\n                }\r\n            }\r\n            const { layoutId, layout } = this.options;\r\n            if (layoutId === undefined && !layout)\r\n                return;\r\n            const transformTemplate = this.getTransformTemplate();\r\n            this.prevTransformTemplateValue = transformTemplate\r\n                ? transformTemplate(this.latestValues, \"\")\r\n                : undefined;\r\n            this.updateSnapshot();\r\n            shouldNotifyListeners && this.notifyListeners(\"willUpdate\");\r\n        }\r\n        update() {\r\n            this.updateScheduled = false;\r\n            const updateWasBlocked = this.isUpdateBlocked();\r\n            // When doing an instant transition, we skip the layout update,\r\n            // but should still clean up the measurements so that the next\r\n            // snapshot could be taken correctly.\r\n            if (updateWasBlocked) {\r\n                this.unblockUpdate();\r\n                this.clearAllSnapshots();\r\n                this.nodes.forEach(clearMeasurements);\r\n                return;\r\n            }\r\n            if (!this.isUpdating) {\r\n                this.nodes.forEach(clearIsLayoutDirty);\r\n            }\r\n            this.isUpdating = false;\r\n            /**\r\n             * Write\r\n             */\r\n            this.nodes.forEach(resetTransformStyle);\r\n            /**\r\n             * Read ==================\r\n             */\r\n            // Update layout measurements of updated children\r\n            this.nodes.forEach(updateLayout);\r\n            /**\r\n             * Write\r\n             */\r\n            // Notify listeners that the layout is updated\r\n            this.nodes.forEach(notifyLayoutUpdate);\r\n            this.clearAllSnapshots();\r\n            /**\r\n             * Manually flush any pending updates. Ideally\r\n             * we could leave this to the following requestAnimationFrame but this seems\r\n             * to leave a flash of incorrectly styled content.\r\n             */\r\n            const now = time.now();\r\n            frameData.delta = clamp(0, 1000 / 60, now - frameData.timestamp);\r\n            frameData.timestamp = now;\r\n            frameData.isProcessing = true;\r\n            frameSteps.update.process(frameData);\r\n            frameSteps.preRender.process(frameData);\r\n            frameSteps.render.process(frameData);\r\n            frameData.isProcessing = false;\r\n        }\r\n        didUpdate() {\r\n            if (!this.updateScheduled) {\r\n                this.updateScheduled = true;\r\n                microtask.read(this.scheduleUpdate);\r\n            }\r\n        }\r\n        clearAllSnapshots() {\r\n            this.nodes.forEach(clearSnapshot);\r\n            this.sharedNodes.forEach(removeLeadSnapshots);\r\n        }\r\n        scheduleUpdateProjection() {\r\n            if (!this.projectionUpdateScheduled) {\r\n                this.projectionUpdateScheduled = true;\r\n                frame.preRender(this.updateProjection, false, true);\r\n            }\r\n        }\r\n        scheduleCheckAfterUnmount() {\r\n            /**\r\n             * If the unmounting node is in a layoutGroup and did trigger a willUpdate,\r\n             * we manually call didUpdate to give a chance to the siblings to animate.\r\n             * Otherwise, cleanup all snapshots to prevents future nodes from reusing them.\r\n             */\r\n            frame.postRender(() => {\r\n                if (this.isLayoutDirty) {\r\n                    this.root.didUpdate();\r\n                }\r\n                else {\r\n                    this.root.checkUpdateFailed();\r\n                }\r\n            });\r\n        }\r\n        /**\r\n         * Update measurements\r\n         */\r\n        updateSnapshot() {\r\n            if (this.snapshot || !this.instance)\r\n                return;\r\n            this.snapshot = this.measure();\r\n        }\r\n        updateLayout() {\r\n            if (!this.instance)\r\n                return;\r\n            // TODO: Incorporate into a forwarded scroll offset\r\n            this.updateScroll();\r\n            if (!(this.options.alwaysMeasureLayout && this.isLead()) &&\r\n                !this.isLayoutDirty) {\r\n                return;\r\n            }\r\n            /**\r\n             * When a node is mounted, it simply resumes from the prevLead's\r\n             * snapshot instead of taking a new one, but the ancestors scroll\r\n             * might have updated while the prevLead is unmounted. We need to\r\n             * update the scroll again to make sure the layout we measure is\r\n             * up to date.\r\n             */\r\n            if (this.resumeFrom && !this.resumeFrom.instance) {\r\n                for (let i = 0; i < this.path.length; i++) {\r\n                    const node = this.path[i];\r\n                    node.updateScroll();\r\n                }\r\n            }\r\n            const prevLayout = this.layout;\r\n            this.layout = this.measure(false);\r\n            this.layoutCorrected = createBox();\r\n            this.isLayoutDirty = false;\r\n            this.projectionDelta = undefined;\r\n            this.notifyListeners(\"measure\", this.layout.layoutBox);\r\n            const { visualElement } = this.options;\r\n            visualElement &&\r\n                visualElement.notify(\"LayoutMeasure\", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : undefined);\r\n        }\r\n        updateScroll(phase = \"measure\") {\r\n            let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);\r\n            if (this.scroll &&\r\n                this.scroll.animationId === this.root.animationId &&\r\n                this.scroll.phase === phase) {\r\n                needsMeasurement = false;\r\n            }\r\n            if (needsMeasurement) {\r\n                const isRoot = checkIsScrollRoot(this.instance);\r\n                this.scroll = {\r\n                    animationId: this.root.animationId,\r\n                    phase,\r\n                    isRoot,\r\n                    offset: measureScroll(this.instance),\r\n                    wasRoot: this.scroll ? this.scroll.isRoot : isRoot,\r\n                };\r\n            }\r\n        }\r\n        resetTransform() {\r\n            if (!resetTransform)\r\n                return;\r\n            const isResetRequested = this.isLayoutDirty ||\r\n                this.shouldResetTransform ||\r\n                this.options.alwaysMeasureLayout;\r\n            const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);\r\n            const transformTemplate = this.getTransformTemplate();\r\n            const transformTemplateValue = transformTemplate\r\n                ? transformTemplate(this.latestValues, \"\")\r\n                : undefined;\r\n            const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;\r\n            if (isResetRequested &&\r\n                (hasProjection ||\r\n                    hasTransform(this.latestValues) ||\r\n                    transformTemplateHasChanged)) {\r\n                resetTransform(this.instance, transformTemplateValue);\r\n                this.shouldResetTransform = false;\r\n                this.scheduleRender();\r\n            }\r\n        }\r\n        measure(removeTransform = true) {\r\n            const pageBox = this.measurePageBox();\r\n            let layoutBox = this.removeElementScroll(pageBox);\r\n            /**\r\n             * Measurements taken during the pre-render stage\r\n             * still have transforms applied so we remove them\r\n             * via calculation.\r\n             */\r\n            if (removeTransform) {\r\n                layoutBox = this.removeTransform(layoutBox);\r\n            }\r\n            roundBox(layoutBox);\r\n            return {\r\n                animationId: this.root.animationId,\r\n                measuredBox: pageBox,\r\n                layoutBox,\r\n                latestValues: {},\r\n                source: this.id,\r\n            };\r\n        }\r\n        measurePageBox() {\r\n            var _a;\r\n            const { visualElement } = this.options;\r\n            if (!visualElement)\r\n                return createBox();\r\n            const box = visualElement.measureViewportBox();\r\n            const wasInScrollRoot = ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) || this.path.some(checkNodeWasScrollRoot);\r\n            if (!wasInScrollRoot) {\r\n                // Remove viewport scroll to give page-relative coordinates\r\n                const { scroll } = this.root;\r\n                if (scroll) {\r\n                    translateAxis(box.x, scroll.offset.x);\r\n                    translateAxis(box.y, scroll.offset.y);\r\n                }\r\n            }\r\n            return box;\r\n        }\r\n        removeElementScroll(box) {\r\n            var _a;\r\n            const boxWithoutScroll = createBox();\r\n            copyBoxInto(boxWithoutScroll, box);\r\n            if ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) {\r\n                return boxWithoutScroll;\r\n            }\r\n            /**\r\n             * Performance TODO: Keep a cumulative scroll offset down the tree\r\n             * rather than loop back up the path.\r\n             */\r\n            for (let i = 0; i < this.path.length; i++) {\r\n                const node = this.path[i];\r\n                const { scroll, options } = node;\r\n                if (node !== this.root && scroll && options.layoutScroll) {\r\n                    /**\r\n                     * If this is a new scroll root, we want to remove all previous scrolls\r\n                     * from the viewport box.\r\n                     */\r\n                    if (scroll.wasRoot) {\r\n                        copyBoxInto(boxWithoutScroll, box);\r\n                    }\r\n                    translateAxis(boxWithoutScroll.x, scroll.offset.x);\r\n                    translateAxis(boxWithoutScroll.y, scroll.offset.y);\r\n                }\r\n            }\r\n            return boxWithoutScroll;\r\n        }\r\n        applyTransform(box, transformOnly = false) {\r\n            const withTransforms = createBox();\r\n            copyBoxInto(withTransforms, box);\r\n            for (let i = 0; i < this.path.length; i++) {\r\n                const node = this.path[i];\r\n                if (!transformOnly &&\r\n                    node.options.layoutScroll &&\r\n                    node.scroll &&\r\n                    node !== node.root) {\r\n                    transformBox(withTransforms, {\r\n                        x: -node.scroll.offset.x,\r\n                        y: -node.scroll.offset.y,\r\n                    });\r\n                }\r\n                if (!hasTransform(node.latestValues))\r\n                    continue;\r\n                transformBox(withTransforms, node.latestValues);\r\n            }\r\n            if (hasTransform(this.latestValues)) {\r\n                transformBox(withTransforms, this.latestValues);\r\n            }\r\n            return withTransforms;\r\n        }\r\n        removeTransform(box) {\r\n            const boxWithoutTransform = createBox();\r\n            copyBoxInto(boxWithoutTransform, box);\r\n            for (let i = 0; i < this.path.length; i++) {\r\n                const node = this.path[i];\r\n                if (!node.instance)\r\n                    continue;\r\n                if (!hasTransform(node.latestValues))\r\n                    continue;\r\n                hasScale(node.latestValues) && node.updateSnapshot();\r\n                const sourceBox = createBox();\r\n                const nodeBox = node.measurePageBox();\r\n                copyBoxInto(sourceBox, nodeBox);\r\n                removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : undefined, sourceBox);\r\n            }\r\n            if (hasTransform(this.latestValues)) {\r\n                removeBoxTransforms(boxWithoutTransform, this.latestValues);\r\n            }\r\n            return boxWithoutTransform;\r\n        }\r\n        setTargetDelta(delta) {\r\n            this.targetDelta = delta;\r\n            this.root.scheduleUpdateProjection();\r\n            this.isProjectionDirty = true;\r\n        }\r\n        setOptions(options) {\r\n            this.options = {\r\n                ...this.options,\r\n                ...options,\r\n                crossfade: options.crossfade !== undefined ? options.crossfade : true,\r\n            };\r\n        }\r\n        clearMeasurements() {\r\n            this.scroll = undefined;\r\n            this.layout = undefined;\r\n            this.snapshot = undefined;\r\n            this.prevTransformTemplateValue = undefined;\r\n            this.targetDelta = undefined;\r\n            this.target = undefined;\r\n            this.isLayoutDirty = false;\r\n        }\r\n        forceRelativeParentToResolveTarget() {\r\n            if (!this.relativeParent)\r\n                return;\r\n            /**\r\n             * If the parent target isn't up-to-date, force it to update.\r\n             * This is an unfortunate de-optimisation as it means any updating relative\r\n             * projection will cause all the relative parents to recalculate back\r\n             * up the tree.\r\n             */\r\n            if (this.relativeParent.resolvedRelativeTargetAt !==\r\n                frameData.timestamp) {\r\n                this.relativeParent.resolveTargetDelta(true);\r\n            }\r\n        }\r\n        resolveTargetDelta(forceRecalculation = false) {\r\n            var _a;\r\n            /**\r\n             * Once the dirty status of nodes has been spread through the tree, we also\r\n             * need to check if we have a shared node of a different depth that has itself\r\n             * been dirtied.\r\n             */\r\n            const lead = this.getLead();\r\n            this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);\r\n            this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);\r\n            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);\r\n            const isShared = Boolean(this.resumingFrom) || this !== lead;\r\n            /**\r\n             * We don't use transform for this step of processing so we don't\r\n             * need to check whether any nodes have changed transform.\r\n             */\r\n            const canSkip = !(forceRecalculation ||\r\n                (isShared && this.isSharedProjectionDirty) ||\r\n                this.isProjectionDirty ||\r\n                ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) ||\r\n                this.attemptToResolveRelativeTarget ||\r\n                this.root.updateBlockedByResize);\r\n            if (canSkip)\r\n                return;\r\n            const { layout, layoutId } = this.options;\r\n            /**\r\n             * If we have no layout, we can't perform projection, so early return\r\n             */\r\n            if (!this.layout || !(layout || layoutId))\r\n                return;\r\n            this.resolvedRelativeTargetAt = frameData.timestamp;\r\n            /**\r\n             * If we don't have a targetDelta but do have a layout, we can attempt to resolve\r\n             * a relativeParent. This will allow a component to perform scale correction\r\n             * even if no animation has started.\r\n             */\r\n            if (!this.targetDelta && !this.relativeTarget) {\r\n                const relativeParent = this.getClosestProjectingParent();\r\n                if (relativeParent &&\r\n                    relativeParent.layout &&\r\n                    this.animationProgress !== 1) {\r\n                    this.relativeParent = relativeParent;\r\n                    this.forceRelativeParentToResolveTarget();\r\n                    this.relativeTarget = createBox();\r\n                    this.relativeTargetOrigin = createBox();\r\n                    calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);\r\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\r\n                }\r\n                else {\r\n                    this.relativeParent = this.relativeTarget = undefined;\r\n                }\r\n            }\r\n            /**\r\n             * If we have no relative target or no target delta our target isn't valid\r\n             * for this frame.\r\n             */\r\n            if (!this.relativeTarget && !this.targetDelta)\r\n                return;\r\n            /**\r\n             * Lazy-init target data structure\r\n             */\r\n            if (!this.target) {\r\n                this.target = createBox();\r\n                this.targetWithTransforms = createBox();\r\n            }\r\n            /**\r\n             * If we've got a relative box for this component, resolve it into a target relative to the parent.\r\n             */\r\n            if (this.relativeTarget &&\r\n                this.relativeTargetOrigin &&\r\n                this.relativeParent &&\r\n                this.relativeParent.target) {\r\n                this.forceRelativeParentToResolveTarget();\r\n                calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);\r\n                /**\r\n                 * If we've only got a targetDelta, resolve it into a target\r\n                 */\r\n            }\r\n            else if (this.targetDelta) {\r\n                if (Boolean(this.resumingFrom)) {\r\n                    // TODO: This is creating a new object every frame\r\n                    this.target = this.applyTransform(this.layout.layoutBox);\r\n                }\r\n                else {\r\n                    copyBoxInto(this.target, this.layout.layoutBox);\r\n                }\r\n                applyBoxDelta(this.target, this.targetDelta);\r\n            }\r\n            else {\r\n                /**\r\n                 * If no target, use own layout as target\r\n                 */\r\n                copyBoxInto(this.target, this.layout.layoutBox);\r\n            }\r\n            /**\r\n             * If we've been told to attempt to resolve a relative target, do so.\r\n             */\r\n            if (this.attemptToResolveRelativeTarget) {\r\n                this.attemptToResolveRelativeTarget = false;\r\n                const relativeParent = this.getClosestProjectingParent();\r\n                if (relativeParent &&\r\n                    Boolean(relativeParent.resumingFrom) ===\r\n                        Boolean(this.resumingFrom) &&\r\n                    !relativeParent.options.layoutScroll &&\r\n                    relativeParent.target &&\r\n                    this.animationProgress !== 1) {\r\n                    this.relativeParent = relativeParent;\r\n                    this.forceRelativeParentToResolveTarget();\r\n                    this.relativeTarget = createBox();\r\n                    this.relativeTargetOrigin = createBox();\r\n                    calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);\r\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\r\n                }\r\n                else {\r\n                    this.relativeParent = this.relativeTarget = undefined;\r\n                }\r\n            }\r\n            /**\r\n             * Increase debug counter for resolved target deltas\r\n             */\r\n            if (isDebug) {\r\n                metrics.resolvedTargetDeltas++;\r\n            }\r\n        }\r\n        getClosestProjectingParent() {\r\n            if (!this.parent ||\r\n                hasScale(this.parent.latestValues) ||\r\n                has2DTranslate(this.parent.latestValues)) {\r\n                return undefined;\r\n            }\r\n            if (this.parent.isProjecting()) {\r\n                return this.parent;\r\n            }\r\n            else {\r\n                return this.parent.getClosestProjectingParent();\r\n            }\r\n        }\r\n        isProjecting() {\r\n            return Boolean((this.relativeTarget ||\r\n                this.targetDelta ||\r\n                this.options.layoutRoot) &&\r\n                this.layout);\r\n        }\r\n        calcProjection() {\r\n            var _a;\r\n            const lead = this.getLead();\r\n            const isShared = Boolean(this.resumingFrom) || this !== lead;\r\n            let canSkip = true;\r\n            /**\r\n             * If this is a normal layout animation and neither this node nor its nearest projecting\r\n             * is dirty then we can't skip.\r\n             */\r\n            if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) {\r\n                canSkip = false;\r\n            }\r\n            /**\r\n             * If this is a shared layout animation and this node's shared projection is dirty then\r\n             * we can't skip.\r\n             */\r\n            if (isShared &&\r\n                (this.isSharedProjectionDirty || this.isTransformDirty)) {\r\n                canSkip = false;\r\n            }\r\n            /**\r\n             * If we have resolved the target this frame we must recalculate the\r\n             * projection to ensure it visually represents the internal calculations.\r\n             */\r\n            if (this.resolvedRelativeTargetAt === frameData.timestamp) {\r\n                canSkip = false;\r\n            }\r\n            if (canSkip)\r\n                return;\r\n            const { layout, layoutId } = this.options;\r\n            /**\r\n             * If this section of the tree isn't animating we can\r\n             * delete our target sources for the following frame.\r\n             */\r\n            this.isTreeAnimating = Boolean((this.parent && this.parent.isTreeAnimating) ||\r\n                this.currentAnimation ||\r\n                this.pendingAnimation);\r\n            if (!this.isTreeAnimating) {\r\n                this.targetDelta = this.relativeTarget = undefined;\r\n            }\r\n            if (!this.layout || !(layout || layoutId))\r\n                return;\r\n            /**\r\n             * Reset the corrected box with the latest values from box, as we're then going\r\n             * to perform mutative operations on it.\r\n             */\r\n            copyBoxInto(this.layoutCorrected, this.layout.layoutBox);\r\n            /**\r\n             * Record previous tree scales before updating.\r\n             */\r\n            const prevTreeScaleX = this.treeScale.x;\r\n            const prevTreeScaleY = this.treeScale.y;\r\n            /**\r\n             * Apply all the parent deltas to this box to produce the corrected box. This\r\n             * is the layout box, as it will appear on screen as a result of the transforms of its parents.\r\n             */\r\n            applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);\r\n            /**\r\n             * If this layer needs to perform scale correction but doesn't have a target,\r\n             * use the layout as the target.\r\n             */\r\n            if (lead.layout &&\r\n                !lead.target &&\r\n                (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {\r\n                lead.target = lead.layout.layoutBox;\r\n                lead.targetWithTransforms = createBox();\r\n            }\r\n            const { target } = lead;\r\n            if (!target) {\r\n                /**\r\n                 * If we don't have a target to project into, but we were previously\r\n                 * projecting, we want to remove the stored transform and schedule\r\n                 * a render to ensure the elements reflect the removed transform.\r\n                 */\r\n                if (this.prevProjectionDelta) {\r\n                    this.createProjectionDeltas();\r\n                    this.scheduleRender();\r\n                }\r\n                return;\r\n            }\r\n            if (!this.projectionDelta || !this.prevProjectionDelta) {\r\n                this.createProjectionDeltas();\r\n            }\r\n            else {\r\n                copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);\r\n                copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);\r\n            }\r\n            /**\r\n             * Update the delta between the corrected box and the target box before user-set transforms were applied.\r\n             * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\r\n             * for our layout reprojection, but still allow them to be scaled correctly by the user.\r\n             * It might be that to simplify this we may want to accept that user-set scale is also corrected\r\n             * and we wouldn't have to keep and calc both deltas, OR we could support a user setting\r\n             * to allow people to choose whether these styles are corrected based on just the\r\n             * layout reprojection or the final bounding box.\r\n             */\r\n            calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);\r\n            if (this.treeScale.x !== prevTreeScaleX ||\r\n                this.treeScale.y !== prevTreeScaleY ||\r\n                !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) ||\r\n                !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {\r\n                this.hasProjected = true;\r\n                this.scheduleRender();\r\n                this.notifyListeners(\"projectionUpdate\", target);\r\n            }\r\n            /**\r\n             * Increase debug counter for recalculated projections\r\n             */\r\n            if (isDebug) {\r\n                metrics.recalculatedProjection++;\r\n            }\r\n        }\r\n        hide() {\r\n            this.isVisible = false;\r\n            // TODO: Schedule render\r\n        }\r\n        show() {\r\n            this.isVisible = true;\r\n            // TODO: Schedule render\r\n        }\r\n        scheduleRender(notifyAll = true) {\r\n            var _a;\r\n            (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.scheduleRender();\r\n            if (notifyAll) {\r\n                const stack = this.getStack();\r\n                stack && stack.scheduleRender();\r\n            }\r\n            if (this.resumingFrom && !this.resumingFrom.instance) {\r\n                this.resumingFrom = undefined;\r\n            }\r\n        }\r\n        createProjectionDeltas() {\r\n            this.prevProjectionDelta = createDelta();\r\n            this.projectionDelta = createDelta();\r\n            this.projectionDeltaWithTransform = createDelta();\r\n        }\r\n        setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {\r\n            const snapshot = this.snapshot;\r\n            const snapshotLatestValues = snapshot\r\n                ? snapshot.latestValues\r\n                : {};\r\n            const mixedValues = { ...this.latestValues };\r\n            const targetDelta = createDelta();\r\n            if (!this.relativeParent ||\r\n                !this.relativeParent.options.layoutRoot) {\r\n                this.relativeTarget = this.relativeTargetOrigin = undefined;\r\n            }\r\n            this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;\r\n            const relativeLayout = createBox();\r\n            const snapshotSource = snapshot ? snapshot.source : undefined;\r\n            const layoutSource = this.layout ? this.layout.source : undefined;\r\n            const isSharedLayoutAnimation = snapshotSource !== layoutSource;\r\n            const stack = this.getStack();\r\n            const isOnlyMember = !stack || stack.members.length <= 1;\r\n            const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation &&\r\n                !isOnlyMember &&\r\n                this.options.crossfade === true &&\r\n                !this.path.some(hasOpacityCrossfade));\r\n            this.animationProgress = 0;\r\n            let prevRelativeTarget;\r\n            this.mixTargetDelta = (latest) => {\r\n                const progress = latest / 1000;\r\n                mixAxisDelta(targetDelta.x, delta.x, progress);\r\n                mixAxisDelta(targetDelta.y, delta.y, progress);\r\n                this.setTargetDelta(targetDelta);\r\n                if (this.relativeTarget &&\r\n                    this.relativeTargetOrigin &&\r\n                    this.layout &&\r\n                    this.relativeParent &&\r\n                    this.relativeParent.layout) {\r\n                    calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);\r\n                    mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress);\r\n                    /**\r\n                     * If this is an unchanged relative target we can consider the\r\n                     * projection not dirty.\r\n                     */\r\n                    if (prevRelativeTarget &&\r\n                        boxEquals(this.relativeTarget, prevRelativeTarget)) {\r\n                        this.isProjectionDirty = false;\r\n                    }\r\n                    if (!prevRelativeTarget)\r\n                        prevRelativeTarget = createBox();\r\n                    copyBoxInto(prevRelativeTarget, this.relativeTarget);\r\n                }\r\n                if (isSharedLayoutAnimation) {\r\n                    this.animationValues = mixedValues;\r\n                    mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);\r\n                }\r\n                this.root.scheduleUpdateProjection();\r\n                this.scheduleRender();\r\n                this.animationProgress = progress;\r\n            };\r\n            this.mixTargetDelta(this.options.layoutRoot ? 1000 : 0);\r\n        }\r\n        startAnimation(options) {\r\n            this.notifyListeners(\"animationStart\");\r\n            this.currentAnimation && this.currentAnimation.stop();\r\n            if (this.resumingFrom && this.resumingFrom.currentAnimation) {\r\n                this.resumingFrom.currentAnimation.stop();\r\n            }\r\n            if (this.pendingAnimation) {\r\n                cancelFrame(this.pendingAnimation);\r\n                this.pendingAnimation = undefined;\r\n            }\r\n            /**\r\n             * Start the animation in the next frame to have a frame with progress 0,\r\n             * where the target is the same as when the animation started, so we can\r\n             * calculate the relative positions correctly for instant transitions.\r\n             */\r\n            this.pendingAnimation = frame.update(() => {\r\n                globalProjectionState.hasAnimatedSinceResize = true;\r\n                this.currentAnimation = animateSingleValue(0, animationTarget, {\r\n                    ...options,\r\n                    onUpdate: (latest) => {\r\n                        this.mixTargetDelta(latest);\r\n                        options.onUpdate && options.onUpdate(latest);\r\n                    },\r\n                    onComplete: () => {\r\n                        options.onComplete && options.onComplete();\r\n                        this.completeAnimation();\r\n                    },\r\n                });\r\n                if (this.resumingFrom) {\r\n                    this.resumingFrom.currentAnimation = this.currentAnimation;\r\n                }\r\n                this.pendingAnimation = undefined;\r\n            });\r\n        }\r\n        completeAnimation() {\r\n            if (this.resumingFrom) {\r\n                this.resumingFrom.currentAnimation = undefined;\r\n                this.resumingFrom.preserveOpacity = undefined;\r\n            }\r\n            const stack = this.getStack();\r\n            stack && stack.exitAnimationComplete();\r\n            this.resumingFrom =\r\n                this.currentAnimation =\r\n                    this.animationValues =\r\n                        undefined;\r\n            this.notifyListeners(\"animationComplete\");\r\n        }\r\n        finishAnimation() {\r\n            if (this.currentAnimation) {\r\n                this.mixTargetDelta && this.mixTargetDelta(animationTarget);\r\n                this.currentAnimation.stop();\r\n            }\r\n            this.completeAnimation();\r\n        }\r\n        applyTransformsToTarget() {\r\n            const lead = this.getLead();\r\n            let { targetWithTransforms, target, layout, latestValues } = lead;\r\n            if (!targetWithTransforms || !target || !layout)\r\n                return;\r\n            /**\r\n             * If we're only animating position, and this element isn't the lead element,\r\n             * then instead of projecting into the lead box we instead want to calculate\r\n             * a new target that aligns the two boxes but maintains the layout shape.\r\n             */\r\n            if (this !== lead &&\r\n                this.layout &&\r\n                layout &&\r\n                shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {\r\n                target = this.target || createBox();\r\n                const xLength = calcLength(this.layout.layoutBox.x);\r\n                target.x.min = lead.target.x.min;\r\n                target.x.max = target.x.min + xLength;\r\n                const yLength = calcLength(this.layout.layoutBox.y);\r\n                target.y.min = lead.target.y.min;\r\n                target.y.max = target.y.min + yLength;\r\n            }\r\n            copyBoxInto(targetWithTransforms, target);\r\n            /**\r\n             * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\r\n             * This is the final box that we will then project into by calculating a transform delta and\r\n             * applying it to the corrected box.\r\n             */\r\n            transformBox(targetWithTransforms, latestValues);\r\n            /**\r\n             * Update the delta between the corrected box and the final target box, after\r\n             * user-set transforms are applied to it. This will be used by the renderer to\r\n             * create a transform style that will reproject the element from its layout layout\r\n             * into the desired bounding box.\r\n             */\r\n            calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);\r\n        }\r\n        registerSharedNode(layoutId, node) {\r\n            if (!this.sharedNodes.has(layoutId)) {\r\n                this.sharedNodes.set(layoutId, new NodeStack());\r\n            }\r\n            const stack = this.sharedNodes.get(layoutId);\r\n            stack.add(node);\r\n            const config = node.options.initialPromotionConfig;\r\n            node.promote({\r\n                transition: config ? config.transition : undefined,\r\n                preserveFollowOpacity: config && config.shouldPreserveFollowOpacity\r\n                    ? config.shouldPreserveFollowOpacity(node)\r\n                    : undefined,\r\n            });\r\n        }\r\n        isLead() {\r\n            const stack = this.getStack();\r\n            return stack ? stack.lead === this : true;\r\n        }\r\n        getLead() {\r\n            var _a;\r\n            const { layoutId } = this.options;\r\n            return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;\r\n        }\r\n        getPrevLead() {\r\n            var _a;\r\n            const { layoutId } = this.options;\r\n            return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : undefined;\r\n        }\r\n        getStack() {\r\n            const { layoutId } = this.options;\r\n            if (layoutId)\r\n                return this.root.sharedNodes.get(layoutId);\r\n        }\r\n        promote({ needsReset, transition, preserveFollowOpacity, } = {}) {\r\n            const stack = this.getStack();\r\n            if (stack)\r\n                stack.promote(this, preserveFollowOpacity);\r\n            if (needsReset) {\r\n                this.projectionDelta = undefined;\r\n                this.needsReset = true;\r\n            }\r\n            if (transition)\r\n                this.setOptions({ transition });\r\n        }\r\n        relegate() {\r\n            const stack = this.getStack();\r\n            if (stack) {\r\n                return stack.relegate(this);\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        }\r\n        resetSkewAndRotation() {\r\n            const { visualElement } = this.options;\r\n            if (!visualElement)\r\n                return;\r\n            // If there's no detected skew or rotation values, we can early return without a forced render.\r\n            let hasDistortingTransform = false;\r\n            /**\r\n             * An unrolled check for rotation values. Most elements don't have any rotation and\r\n             * skipping the nested loop and new object creation is 50% faster.\r\n             */\r\n            const { latestValues } = visualElement;\r\n            if (latestValues.z ||\r\n                latestValues.rotate ||\r\n                latestValues.rotateX ||\r\n                latestValues.rotateY ||\r\n                latestValues.rotateZ ||\r\n                latestValues.skewX ||\r\n                latestValues.skewY) {\r\n                hasDistortingTransform = true;\r\n            }\r\n            // If there's no distorting values, we don't need to do any more.\r\n            if (!hasDistortingTransform)\r\n                return;\r\n            const resetValues = {};\r\n            if (latestValues.z) {\r\n                resetDistortingTransform(\"z\", visualElement, resetValues, this.animationValues);\r\n            }\r\n            // Check the skew and rotate value of all axes and reset to 0\r\n            for (let i = 0; i < transformAxes.length; i++) {\r\n                resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);\r\n                resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);\r\n            }\r\n            // Force a render of this element to apply the transform with all skews and rotations\r\n            // set to 0.\r\n            visualElement.render();\r\n            // Put back all the values we reset\r\n            for (const key in resetValues) {\r\n                visualElement.setStaticValue(key, resetValues[key]);\r\n                if (this.animationValues) {\r\n                    this.animationValues[key] = resetValues[key];\r\n                }\r\n            }\r\n            // Schedule a render for the next frame. This ensures we won't visually\r\n            // see the element with the reset rotate value applied.\r\n            visualElement.scheduleRender();\r\n        }\r\n        getProjectionStyles(styleProp) {\r\n            var _a, _b;\r\n            if (!this.instance || this.isSVG)\r\n                return undefined;\r\n            if (!this.isVisible) {\r\n                return hiddenVisibility;\r\n            }\r\n            const styles = {\r\n                visibility: \"\",\r\n            };\r\n            const transformTemplate = this.getTransformTemplate();\r\n            if (this.needsReset) {\r\n                this.needsReset = false;\r\n                styles.opacity = \"\";\r\n                styles.pointerEvents =\r\n                    resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || \"\";\r\n                styles.transform = transformTemplate\r\n                    ? transformTemplate(this.latestValues, \"\")\r\n                    : \"none\";\r\n                return styles;\r\n            }\r\n            const lead = this.getLead();\r\n            if (!this.projectionDelta || !this.layout || !lead.target) {\r\n                const emptyStyles = {};\r\n                if (this.options.layoutId) {\r\n                    emptyStyles.opacity =\r\n                        this.latestValues.opacity !== undefined\r\n                            ? this.latestValues.opacity\r\n                            : 1;\r\n                    emptyStyles.pointerEvents =\r\n                        resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || \"\";\r\n                }\r\n                if (this.hasProjected && !hasTransform(this.latestValues)) {\r\n                    emptyStyles.transform = transformTemplate\r\n                        ? transformTemplate({}, \"\")\r\n                        : \"none\";\r\n                    this.hasProjected = false;\r\n                }\r\n                return emptyStyles;\r\n            }\r\n            const valuesToRender = lead.animationValues || lead.latestValues;\r\n            this.applyTransformsToTarget();\r\n            styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);\r\n            if (transformTemplate) {\r\n                styles.transform = transformTemplate(valuesToRender, styles.transform);\r\n            }\r\n            const { x, y } = this.projectionDelta;\r\n            styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;\r\n            if (lead.animationValues) {\r\n                /**\r\n                 * If the lead component is animating, assign this either the entering/leaving\r\n                 * opacity\r\n                 */\r\n                styles.opacity =\r\n                    lead === this\r\n                        ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1\r\n                        : this.preserveOpacity\r\n                            ? this.latestValues.opacity\r\n                            : valuesToRender.opacityExit;\r\n            }\r\n            else {\r\n                /**\r\n                 * Or we're not animating at all, set the lead component to its layout\r\n                 * opacity and other components to hidden.\r\n                 */\r\n                styles.opacity =\r\n                    lead === this\r\n                        ? valuesToRender.opacity !== undefined\r\n                            ? valuesToRender.opacity\r\n                            : \"\"\r\n                        : valuesToRender.opacityExit !== undefined\r\n                            ? valuesToRender.opacityExit\r\n                            : 0;\r\n            }\r\n            /**\r\n             * Apply scale correction\r\n             */\r\n            for (const key in scaleCorrectors) {\r\n                if (valuesToRender[key] === undefined)\r\n                    continue;\r\n                const { correct, applyTo } = scaleCorrectors[key];\r\n                /**\r\n                 * Only apply scale correction to the value if we have an\r\n                 * active projection transform. Otherwise these values become\r\n                 * vulnerable to distortion if the element changes size without\r\n                 * a corresponding layout animation.\r\n                 */\r\n                const corrected = styles.transform === \"none\"\r\n                    ? valuesToRender[key]\r\n                    : correct(valuesToRender[key], lead);\r\n                if (applyTo) {\r\n                    const num = applyTo.length;\r\n                    for (let i = 0; i < num; i++) {\r\n                        styles[applyTo[i]] = corrected;\r\n                    }\r\n                }\r\n                else {\r\n                    styles[key] = corrected;\r\n                }\r\n            }\r\n            /**\r\n             * Disable pointer events on follow components. This is to ensure\r\n             * that if a follow component covers a lead component it doesn't block\r\n             * pointer events on the lead.\r\n             */\r\n            if (this.options.layoutId) {\r\n                styles.pointerEvents =\r\n                    lead === this\r\n                        ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || \"\"\r\n                        : \"none\";\r\n            }\r\n            return styles;\r\n        }\r\n        clearSnapshot() {\r\n            this.resumeFrom = this.snapshot = undefined;\r\n        }\r\n        // Only run on root\r\n        resetTree() {\r\n            this.root.nodes.forEach((node) => { var _a; return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop(); });\r\n            this.root.nodes.forEach(clearMeasurements);\r\n            this.root.sharedNodes.clear();\r\n        }\r\n    };\r\n}\r\nfunction updateLayout(node) {\r\n    node.updateLayout();\r\n}\r\nfunction notifyLayoutUpdate(node) {\r\n    var _a;\r\n    const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;\r\n    if (node.isLead() &&\r\n        node.layout &&\r\n        snapshot &&\r\n        node.hasListeners(\"didUpdate\")) {\r\n        const { layoutBox: layout, measuredBox: measuredLayout } = node.layout;\r\n        const { animationType } = node.options;\r\n        const isShared = snapshot.source !== node.layout.source;\r\n        // TODO Maybe we want to also resize the layout snapshot so we don't trigger\r\n        // animations for instance if layout=\"size\" and an element has only changed position\r\n        if (animationType === \"size\") {\r\n            eachAxis((axis) => {\r\n                const axisSnapshot = isShared\r\n                    ? snapshot.measuredBox[axis]\r\n                    : snapshot.layoutBox[axis];\r\n                const length = calcLength(axisSnapshot);\r\n                axisSnapshot.min = layout[axis].min;\r\n                axisSnapshot.max = axisSnapshot.min + length;\r\n            });\r\n        }\r\n        else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {\r\n            eachAxis((axis) => {\r\n                const axisSnapshot = isShared\r\n                    ? snapshot.measuredBox[axis]\r\n                    : snapshot.layoutBox[axis];\r\n                const length = calcLength(layout[axis]);\r\n                axisSnapshot.max = axisSnapshot.min + length;\r\n                /**\r\n                 * Ensure relative target gets resized and rerendererd\r\n                 */\r\n                if (node.relativeTarget && !node.currentAnimation) {\r\n                    node.isProjectionDirty = true;\r\n                    node.relativeTarget[axis].max =\r\n                        node.relativeTarget[axis].min + length;\r\n                }\r\n            });\r\n        }\r\n        const layoutDelta = createDelta();\r\n        calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);\r\n        const visualDelta = createDelta();\r\n        if (isShared) {\r\n            calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);\r\n        }\r\n        else {\r\n            calcBoxDelta(visualDelta, layout, snapshot.layoutBox);\r\n        }\r\n        const hasLayoutChanged = !isDeltaZero(layoutDelta);\r\n        let hasRelativeTargetChanged = false;\r\n        if (!node.resumeFrom) {\r\n            const relativeParent = node.getClosestProjectingParent();\r\n            /**\r\n             * If the relativeParent is itself resuming from a different element then\r\n             * the relative snapshot is not relavent\r\n             */\r\n            if (relativeParent && !relativeParent.resumeFrom) {\r\n                const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;\r\n                if (parentSnapshot && parentLayout) {\r\n                    const relativeSnapshot = createBox();\r\n                    calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);\r\n                    const relativeLayout = createBox();\r\n                    calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);\r\n                    if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {\r\n                        hasRelativeTargetChanged = true;\r\n                    }\r\n                    if (relativeParent.options.layoutRoot) {\r\n                        node.relativeTarget = relativeLayout;\r\n                        node.relativeTargetOrigin = relativeSnapshot;\r\n                        node.relativeParent = relativeParent;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        node.notifyListeners(\"didUpdate\", {\r\n            layout,\r\n            snapshot,\r\n            delta: visualDelta,\r\n            layoutDelta,\r\n            hasLayoutChanged,\r\n            hasRelativeTargetChanged,\r\n        });\r\n    }\r\n    else if (node.isLead()) {\r\n        const { onExitComplete } = node.options;\r\n        onExitComplete && onExitComplete();\r\n    }\r\n    /**\r\n     * Clearing transition\r\n     * TODO: Investigate why this transition is being passed in as {type: false } from Framer\r\n     * and why we need it at all\r\n     */\r\n    node.options.transition = undefined;\r\n}\r\nfunction propagateDirtyNodes(node) {\r\n    /**\r\n     * Increase debug counter for nodes encountered this frame\r\n     */\r\n    if (isDebug) {\r\n        metrics.totalNodes++;\r\n    }\r\n    if (!node.parent)\r\n        return;\r\n    /**\r\n     * If this node isn't projecting, propagate isProjectionDirty. It will have\r\n     * no performance impact but it will allow the next child that *is* projecting\r\n     * but *isn't* dirty to just check its parent to see if *any* ancestor needs\r\n     * correcting.\r\n     */\r\n    if (!node.isProjecting()) {\r\n        node.isProjectionDirty = node.parent.isProjectionDirty;\r\n    }\r\n    /**\r\n     * Propagate isSharedProjectionDirty and isTransformDirty\r\n     * throughout the whole tree. A future revision can take another look at\r\n     * this but for safety we still recalcualte shared nodes.\r\n     */\r\n    node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty ||\r\n        node.parent.isProjectionDirty ||\r\n        node.parent.isSharedProjectionDirty));\r\n    node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);\r\n}\r\nfunction cleanDirtyNodes(node) {\r\n    node.isProjectionDirty =\r\n        node.isSharedProjectionDirty =\r\n            node.isTransformDirty =\r\n                false;\r\n}\r\nfunction clearSnapshot(node) {\r\n    node.clearSnapshot();\r\n}\r\nfunction clearMeasurements(node) {\r\n    node.clearMeasurements();\r\n}\r\nfunction clearIsLayoutDirty(node) {\r\n    node.isLayoutDirty = false;\r\n}\r\nfunction resetTransformStyle(node) {\r\n    const { visualElement } = node.options;\r\n    if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {\r\n        visualElement.notify(\"BeforeLayoutMeasure\");\r\n    }\r\n    node.resetTransform();\r\n}\r\nfunction finishAnimation(node) {\r\n    node.finishAnimation();\r\n    node.targetDelta = node.relativeTarget = node.target = undefined;\r\n    node.isProjectionDirty = true;\r\n}\r\nfunction resolveTargetDelta(node) {\r\n    node.resolveTargetDelta();\r\n}\r\nfunction calcProjection(node) {\r\n    node.calcProjection();\r\n}\r\nfunction resetSkewAndRotation(node) {\r\n    node.resetSkewAndRotation();\r\n}\r\nfunction removeLeadSnapshots(stack) {\r\n    stack.removeLeadSnapshot();\r\n}\r\nfunction mixAxisDelta(output, delta, p) {\r\n    output.translate = mixNumber(delta.translate, 0, p);\r\n    output.scale = mixNumber(delta.scale, 1, p);\r\n    output.origin = delta.origin;\r\n    output.originPoint = delta.originPoint;\r\n}\r\nfunction mixAxis(output, from, to, p) {\r\n    output.min = mixNumber(from.min, to.min, p);\r\n    output.max = mixNumber(from.max, to.max, p);\r\n}\r\nfunction mixBox(output, from, to, p) {\r\n    mixAxis(output.x, from.x, to.x, p);\r\n    mixAxis(output.y, from.y, to.y, p);\r\n}\r\nfunction hasOpacityCrossfade(node) {\r\n    return (node.animationValues && node.animationValues.opacityExit !== undefined);\r\n}\r\nconst defaultLayoutTransition = {\r\n    duration: 0.45,\r\n    ease: [0.4, 0, 0.1, 1],\r\n};\r\nconst userAgentContains = (string) => typeof navigator !== \"undefined\" &&\r\n    navigator.userAgent &&\r\n    navigator.userAgent.toLowerCase().includes(string);\r\n/**\r\n * Measured bounding boxes must be rounded in Safari and\r\n * left untouched in Chrome, otherwise non-integer layouts within scaled-up elements\r\n * can appear to jump.\r\n */\r\nconst roundPoint = userAgentContains(\"applewebkit/\") && !userAgentContains(\"chrome/\")\r\n    ? Math.round\r\n    : noop;\r\nfunction roundAxis(axis) {\r\n    // Round to the nearest .5 pixels to support subpixel layouts\r\n    axis.min = roundPoint(axis.min);\r\n    axis.max = roundPoint(axis.max);\r\n}\r\nfunction roundBox(box) {\r\n    roundAxis(box.x);\r\n    roundAxis(box.y);\r\n}\r\nfunction shouldAnimatePositionOnly(animationType, snapshot, layout) {\r\n    return (animationType === \"position\" ||\r\n        (animationType === \"preserve-aspect\" &&\r\n            !isNear(aspectRatio(snapshot), aspectRatio(layout), 0.2)));\r\n}\r\nfunction checkNodeWasScrollRoot(node) {\r\n    var _a;\r\n    return node !== node.root && ((_a = node.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot);\r\n}\r\n\r\nexport { cleanDirtyNodes, createProjectionNode, mixAxis, mixAxisDelta, mixBox, propagateDirtyNodes };\r\n","function isSVGElement(element) {\r\n    return element instanceof SVGElement && element.tagName !== \"svg\";\r\n}\r\n\r\nexport { isSVGElement };\r\n","import { secondsToMilliseconds } from 'motion-utils';\r\nimport { time } from '../frameloop/sync-time.mjs';\r\nimport { frame, cancelFrame } from '../frameloop/frame.mjs';\r\n\r\n/**\r\n * Timeout defined in ms\r\n */\r\nfunction delay(callback, timeout) {\r\n    const start = time.now();\r\n    const checkElapsed = ({ timestamp }) => {\r\n        const elapsed = timestamp - start;\r\n        if (elapsed >= timeout) {\r\n            cancelFrame(checkElapsed);\r\n            callback(elapsed - timeout);\r\n        }\r\n    };\r\n    frame.read(checkElapsed, true);\r\n    return () => cancelFrame(checkElapsed);\r\n}\r\nfunction delayInSeconds(callback, timeout) {\r\n    return delay(callback, secondsToMilliseconds(timeout));\r\n}\r\n\r\nexport { delay, delayInSeconds };\r\n","import { motionValue } from '../../value/index.mjs';\r\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\r\nimport { animateMotionValue } from '../interfaces/motion-value.mjs';\r\n\r\nfunction animateSingleValue(value, keyframes, options) {\r\n    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);\r\n    motionValue$1.start(animateMotionValue(\"\", motionValue$1, keyframes, options));\r\n    return motionValue$1.animation;\r\n}\r\n\r\nexport { animateSingleValue };\r\n","function buildProjectionTransform(delta, treeScale, latestTransform) {\r\n    let transform = \"\";\r\n    /**\r\n     * The translations we use to calculate are always relative to the viewport coordinate space.\r\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\r\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\r\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\r\n     */\r\n    const xTranslate = delta.x.translate / treeScale.x;\r\n    const yTranslate = delta.y.translate / treeScale.y;\r\n    const zTranslate = (latestTransform === null || latestTransform === void 0 ? void 0 : latestTransform.z) || 0;\r\n    if (xTranslate || yTranslate || zTranslate) {\r\n        transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;\r\n    }\r\n    /**\r\n     * Apply scale correction for the tree transform.\r\n     * This will apply scale to the screen-orientated axes.\r\n     */\r\n    if (treeScale.x !== 1 || treeScale.y !== 1) {\r\n        transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\r\n    }\r\n    if (latestTransform) {\r\n        const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;\r\n        if (transformPerspective)\r\n            transform = `perspective(${transformPerspective}px) ${transform}`;\r\n        if (rotate)\r\n            transform += `rotate(${rotate}deg) `;\r\n        if (rotateX)\r\n            transform += `rotateX(${rotateX}deg) `;\r\n        if (rotateY)\r\n            transform += `rotateY(${rotateY}deg) `;\r\n        if (skewX)\r\n            transform += `skewX(${skewX}deg) `;\r\n        if (skewY)\r\n            transform += `skewY(${skewY}deg) `;\r\n    }\r\n    /**\r\n     * Apply scale to match the size of the element to the size we want it.\r\n     * This will apply scale to the element-orientated axes.\r\n     */\r\n    const elementScaleX = delta.x.scale * treeScale.x;\r\n    const elementScaleY = delta.y.scale * treeScale.y;\r\n    if (elementScaleX !== 1 || elementScaleY !== 1) {\r\n        transform += `scale(${elementScaleX}, ${elementScaleY})`;\r\n    }\r\n    return transform || \"none\";\r\n}\r\n\r\nexport { buildProjectionTransform };\r\n","import { createProjectionNode } from './create-projection-node.mjs';\r\nimport { addDomEvent } from '../../events/add-dom-event.mjs';\r\n\r\nconst DocumentProjectionNode = createProjectionNode({\r\n    attachResizeListener: (ref, notify) => addDomEvent(ref, \"resize\", notify),\r\n    measureScroll: () => ({\r\n        x: document.documentElement.scrollLeft || document.body.scrollLeft,\r\n        y: document.documentElement.scrollTop || document.body.scrollTop,\r\n    }),\r\n    checkIsScrollRoot: () => true,\r\n});\r\n\r\nexport { DocumentProjectionNode };\r\n","import { createProjectionNode } from './create-projection-node.mjs';\r\nimport { DocumentProjectionNode } from './DocumentProjectionNode.mjs';\r\n\r\nconst rootProjectionNode = {\r\n    current: undefined,\r\n};\r\nconst HTMLProjectionNode = createProjectionNode({\r\n    measureScroll: (instance) => ({\r\n        x: instance.scrollLeft,\r\n        y: instance.scrollTop,\r\n    }),\r\n    defaultParent: () => {\r\n        if (!rootProjectionNode.current) {\r\n            const documentNode = new DocumentProjectionNode({});\r\n            documentNode.mount(window);\r\n            documentNode.setOptions({ layoutScroll: true });\r\n            rootProjectionNode.current = documentNode;\r\n        }\r\n        return rootProjectionNode.current;\r\n    },\r\n    resetTransform: (instance, value) => {\r\n        instance.style.transform = value !== undefined ? value : \"none\";\r\n    },\r\n    checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === \"fixed\"),\r\n});\r\n\r\nexport { HTMLProjectionNode, rootProjectionNode };\r\n","import { DragGesture } from '../../gestures/drag/index.mjs';\r\nimport { PanGesture } from '../../gestures/pan/index.mjs';\r\nimport { MeasureLayout } from './layout/MeasureLayout.mjs';\r\nimport { HTMLProjectionNode } from '../../projection/node/HTMLProjectionNode.mjs';\r\n\r\nconst drag = {\r\n    pan: {\r\n        Feature: PanGesture,\r\n    },\r\n    drag: {\r\n        Feature: DragGesture,\r\n        ProjectionNode: HTMLProjectionNode,\r\n        MeasureLayout,\r\n    },\r\n};\r\n\r\nexport { drag };\r\n","import { Feature } from '../../motion/features/Feature.mjs';\r\nimport { noop } from 'motion-utils';\r\nimport { VisualElementDragControls } from './VisualElementDragControls.mjs';\r\n\r\nclass DragGesture extends Feature {\r\n    constructor(node) {\r\n        super(node);\r\n        this.removeGroupControls = noop;\r\n        this.removeListeners = noop;\r\n        this.controls = new VisualElementDragControls(node);\r\n    }\r\n    mount() {\r\n        // If we've been provided a DragControls for manual control over the drag gesture,\r\n        // subscribe this component to it on mount.\r\n        const { dragControls } = this.node.getProps();\r\n        if (dragControls) {\r\n            this.removeGroupControls = dragControls.subscribe(this.controls);\r\n        }\r\n        this.removeListeners = this.controls.addListeners() || noop;\r\n    }\r\n    unmount() {\r\n        this.removeGroupControls();\r\n        this.removeListeners();\r\n    }\r\n}\r\n\r\nexport { DragGesture };\r\n","import { Feature } from '../motion/features/Feature.mjs';\r\nimport { hover } from 'motion-dom';\r\nimport { extractEventInfo } from '../events/event-info.mjs';\r\nimport { frame } from '../frameloop/frame.mjs';\r\n\r\nfunction handleHoverEvent(node, event, lifecycle) {\r\n    const { props } = node;\r\n    if (node.animationState && props.whileHover) {\r\n        node.animationState.setActive(\"whileHover\", lifecycle === \"Start\");\r\n    }\r\n    const eventName = (\"onHover\" + lifecycle);\r\n    const callback = props[eventName];\r\n    if (callback) {\r\n        frame.postRender(() => callback(event, extractEventInfo(event)));\r\n    }\r\n}\r\nclass HoverGesture extends Feature {\r\n    mount() {\r\n        const { current } = this.node;\r\n        if (!current)\r\n            return;\r\n        this.unmount = hover(current, (startEvent) => {\r\n            handleHoverEvent(this.node, startEvent, \"Start\");\r\n            return (endEvent) => handleHoverEvent(this.node, endEvent, \"End\");\r\n        });\r\n    }\r\n    unmount() { }\r\n}\r\n\r\nexport { HoverGesture };\r\n","import { Feature } from '../motion/features/Feature.mjs';\r\nimport { press } from 'motion-dom';\r\nimport { extractEventInfo } from '../events/event-info.mjs';\r\nimport { frame } from '../frameloop/frame.mjs';\r\n\r\nfunction handlePressEvent(node, event, lifecycle) {\r\n    const { props } = node;\r\n    if (node.animationState && props.whileTap) {\r\n        node.animationState.setActive(\"whileTap\", lifecycle === \"Start\");\r\n    }\r\n    const eventName = (\"onTap\" + (lifecycle === \"End\" ? \"\" : lifecycle));\r\n    const callback = props[eventName];\r\n    if (callback) {\r\n        frame.postRender(() => callback(event, extractEventInfo(event)));\r\n    }\r\n}\r\nclass PressGesture extends Feature {\r\n    mount() {\r\n        const { current } = this.node;\r\n        if (!current)\r\n            return;\r\n        this.unmount = press(current, (startEvent) => {\r\n            handlePressEvent(this.node, startEvent, \"Start\");\r\n            return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? \"End\" : \"Cancel\");\r\n        }, { useGlobalTarget: this.node.props.globalTapTarget });\r\n    }\r\n    unmount() { }\r\n}\r\n\r\nexport { PressGesture };\r\n","/**\r\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\r\n * element, so even though these handlers might all be triggered by different\r\n * observers, we can keep them in the same map.\r\n */\r\nconst observerCallbacks = new WeakMap();\r\n/**\r\n * Multiple observers can be created for multiple element/document roots. Each with\r\n * different settings. So here we store dictionaries of observers to each root,\r\n * using serialised settings (threshold/margin) as lookup keys.\r\n */\r\nconst observers = new WeakMap();\r\nconst fireObserverCallback = (entry) => {\r\n    const callback = observerCallbacks.get(entry.target);\r\n    callback && callback(entry);\r\n};\r\nconst fireAllObserverCallbacks = (entries) => {\r\n    entries.forEach(fireObserverCallback);\r\n};\r\nfunction initIntersectionObserver({ root, ...options }) {\r\n    const lookupRoot = root || document;\r\n    /**\r\n     * If we don't have an observer lookup map for this root, create one.\r\n     */\r\n    if (!observers.has(lookupRoot)) {\r\n        observers.set(lookupRoot, {});\r\n    }\r\n    const rootObservers = observers.get(lookupRoot);\r\n    const key = JSON.stringify(options);\r\n    /**\r\n     * If we don't have an observer for this combination of root and settings,\r\n     * create one.\r\n     */\r\n    if (!rootObservers[key]) {\r\n        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });\r\n    }\r\n    return rootObservers[key];\r\n}\r\nfunction observeIntersection(element, options, callback) {\r\n    const rootInteresectionObserver = initIntersectionObserver(options);\r\n    observerCallbacks.set(element, callback);\r\n    rootInteresectionObserver.observe(element);\r\n    return () => {\r\n        observerCallbacks.delete(element);\r\n        rootInteresectionObserver.unobserve(element);\r\n    };\r\n}\r\n\r\nexport { observeIntersection };\r\n","import { Feature } from '../Feature.mjs';\r\nimport { observeIntersection } from './observers.mjs';\r\n\r\nconst thresholdNames = {\r\n    some: 0,\r\n    all: 1,\r\n};\r\nclass InViewFeature extends Feature {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.hasEnteredView = false;\r\n        this.isInView = false;\r\n    }\r\n    startObserver() {\r\n        this.unmount();\r\n        const { viewport = {} } = this.node.getProps();\r\n        const { root, margin: rootMargin, amount = \"some\", once } = viewport;\r\n        const options = {\r\n            root: root ? root.current : undefined,\r\n            rootMargin,\r\n            threshold: typeof amount === \"number\" ? amount : thresholdNames[amount],\r\n        };\r\n        const onIntersectionUpdate = (entry) => {\r\n            const { isIntersecting } = entry;\r\n            /**\r\n             * If there's been no change in the viewport state, early return.\r\n             */\r\n            if (this.isInView === isIntersecting)\r\n                return;\r\n            this.isInView = isIntersecting;\r\n            /**\r\n             * Handle hasEnteredView. If this is only meant to run once, and\r\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\r\n             */\r\n            if (once && !isIntersecting && this.hasEnteredView) {\r\n                return;\r\n            }\r\n            else if (isIntersecting) {\r\n                this.hasEnteredView = true;\r\n            }\r\n            if (this.node.animationState) {\r\n                this.node.animationState.setActive(\"whileInView\", isIntersecting);\r\n            }\r\n            /**\r\n             * Use the latest committed props rather than the ones in scope\r\n             * when this observer is created\r\n             */\r\n            const { onViewportEnter, onViewportLeave } = this.node.getProps();\r\n            const callback = isIntersecting ? onViewportEnter : onViewportLeave;\r\n            callback && callback(entry);\r\n        };\r\n        return observeIntersection(this.node.current, options, onIntersectionUpdate);\r\n    }\r\n    mount() {\r\n        this.startObserver();\r\n    }\r\n    update() {\r\n        if (typeof IntersectionObserver === \"undefined\")\r\n            return;\r\n        const { props, prevProps } = this.node;\r\n        const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(hasViewportOptionChanged(props, prevProps));\r\n        if (hasOptionsChanged) {\r\n            this.startObserver();\r\n        }\r\n    }\r\n    unmount() { }\r\n}\r\nfunction hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {\r\n    return (name) => viewport[name] !== prevViewport[name];\r\n}\r\n\r\nexport { InViewFeature };\r\n","import { HoverGesture } from '../../gestures/hover.mjs';\r\nimport { FocusGesture } from '../../gestures/focus.mjs';\r\nimport { PressGesture } from '../../gestures/press.mjs';\r\nimport { InViewFeature } from './viewport/index.mjs';\r\n\r\nconst gestureAnimations = {\r\n    inView: {\r\n        Feature: InViewFeature,\r\n    },\r\n    tap: {\r\n        Feature: PressGesture,\r\n    },\r\n    focus: {\r\n        Feature: FocusGesture,\r\n    },\r\n    hover: {\r\n        Feature: HoverGesture,\r\n    },\r\n};\r\n\r\nexport { gestureAnimations };\r\n","import { addDomEvent } from '../events/add-dom-event.mjs';\r\nimport { Feature } from '../motion/features/Feature.mjs';\r\nimport { pipe } from '../utils/pipe.mjs';\r\n\r\nclass FocusGesture extends Feature {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.isActive = false;\r\n    }\r\n    onFocus() {\r\n        let isFocusVisible = false;\r\n        /**\r\n         * If this element doesn't match focus-visible then don't\r\n         * apply whileHover. But, if matches throws that focus-visible\r\n         * is not a valid selector then in that browser outline styles will be applied\r\n         * to the element by default and we want to match that behaviour with whileFocus.\r\n         */\r\n        try {\r\n            isFocusVisible = this.node.current.matches(\":focus-visible\");\r\n        }\r\n        catch (e) {\r\n            isFocusVisible = true;\r\n        }\r\n        if (!isFocusVisible || !this.node.animationState)\r\n            return;\r\n        this.node.animationState.setActive(\"whileFocus\", true);\r\n        this.isActive = true;\r\n    }\r\n    onBlur() {\r\n        if (!this.isActive || !this.node.animationState)\r\n            return;\r\n        this.node.animationState.setActive(\"whileFocus\", false);\r\n        this.isActive = false;\r\n    }\r\n    mount() {\r\n        this.unmount = pipe(addDomEvent(this.node.current, \"focus\", () => this.onFocus()), addDomEvent(this.node.current, \"blur\", () => this.onBlur()));\r\n    }\r\n    unmount() { }\r\n}\r\n\r\nexport { FocusGesture };\r\n","import { HTMLProjectionNode } from '../../projection/node/HTMLProjectionNode.mjs';\r\nimport { MeasureLayout } from './layout/MeasureLayout.mjs';\r\n\r\nconst layout = {\r\n    layout: {\r\n        ProjectionNode: HTMLProjectionNode,\r\n        MeasureLayout,\r\n    },\r\n};\r\n\r\nexport { layout };\r\n","// Does this device prefer reduced motion? Returns `null` server-side.\r\nconst prefersReducedMotion = { current: null };\r\nconst hasReducedMotionListener = { current: false };\r\n\r\nexport { hasReducedMotionListener, prefersReducedMotion };\r\n","import { color } from '../../../value/types/color/index.mjs';\r\nimport { complex } from '../../../value/types/complex/index.mjs';\r\nimport { dimensionValueTypes } from './dimensions.mjs';\r\nimport { testValueType } from './test.mjs';\r\n\r\n/**\r\n * A list of all ValueTypes\r\n */\r\nconst valueTypes = [...dimensionValueTypes, color, complex];\r\n/**\r\n * Tests a value against the list of ValueTypes\r\n */\r\nconst findValueType = (v) => valueTypes.find(testValueType(v));\r\n\r\nexport { findValueType };\r\n","const visualElementStore = new WeakMap();\r\n\r\nexport { visualElementStore };\r\n","import { time } from '../frameloop/sync-time.mjs';\r\nimport { featureDefinitions } from '../motion/features/definitions.mjs';\r\nimport { createBox } from '../projection/geometry/models.mjs';\r\nimport { isNumericalString } from '../utils/is-numerical-string.mjs';\r\nimport { isZeroValueString } from '../utils/is-zero-value-string.mjs';\r\nimport { initPrefersReducedMotion } from '../utils/reduced-motion/index.mjs';\r\nimport { hasReducedMotionListener, prefersReducedMotion } from '../utils/reduced-motion/state.mjs';\r\nimport { SubscriptionManager } from '../utils/subscription-manager.mjs';\r\nimport { warnOnce } from '../utils/warn-once.mjs';\r\nimport { motionValue } from '../value/index.mjs';\r\nimport { complex } from '../value/types/complex/index.mjs';\r\nimport { isMotionValue } from '../value/utils/is-motion-value.mjs';\r\nimport { getAnimatableNone } from './dom/value-types/animatable-none.mjs';\r\nimport { findValueType } from './dom/value-types/find.mjs';\r\nimport { transformProps } from './html/utils/keys-transform.mjs';\r\nimport { visualElementStore } from './store.mjs';\r\nimport { isControllingVariants, isVariantNode } from './utils/is-controlling-variants.mjs';\r\nimport { KeyframeResolver } from './utils/KeyframesResolver.mjs';\r\nimport { updateMotionValuesFromProps } from './utils/motion-values.mjs';\r\nimport { resolveVariantFromProps } from './utils/resolve-variants.mjs';\r\nimport { frame, cancelFrame } from '../frameloop/frame.mjs';\r\n\r\nconst propEventHandlers = [\r\n    \"AnimationStart\",\r\n    \"AnimationComplete\",\r\n    \"Update\",\r\n    \"BeforeLayoutMeasure\",\r\n    \"LayoutMeasure\",\r\n    \"LayoutAnimationStart\",\r\n    \"LayoutAnimationComplete\",\r\n];\r\n/**\r\n * A VisualElement is an imperative abstraction around UI elements such as\r\n * HTMLElement, SVGElement, Three.Object3D etc.\r\n */\r\nclass VisualElement {\r\n    /**\r\n     * This method takes React props and returns found MotionValues. For example, HTML\r\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\r\n     *\r\n     * This isn't an abstract method as it needs calling in the constructor, but it is\r\n     * intended to be one.\r\n     */\r\n    scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {\r\n        return {};\r\n    }\r\n    constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState, }, options = {}) {\r\n        /**\r\n         * A reference to the current underlying Instance, e.g. a HTMLElement\r\n         * or Three.Mesh etc.\r\n         */\r\n        this.current = null;\r\n        /**\r\n         * A set containing references to this VisualElement's children.\r\n         */\r\n        this.children = new Set();\r\n        /**\r\n         * Determine what role this visual element should take in the variant tree.\r\n         */\r\n        this.isVariantNode = false;\r\n        this.isControllingVariants = false;\r\n        /**\r\n         * Decides whether this VisualElement should animate in reduced motion\r\n         * mode.\r\n         *\r\n         * TODO: This is currently set on every individual VisualElement but feels\r\n         * like it could be set globally.\r\n         */\r\n        this.shouldReduceMotion = null;\r\n        /**\r\n         * A map of all motion values attached to this visual element. Motion\r\n         * values are source of truth for any given animated value. A motion\r\n         * value might be provided externally by the component via props.\r\n         */\r\n        this.values = new Map();\r\n        this.KeyframeResolver = KeyframeResolver;\r\n        /**\r\n         * Cleanup functions for active features (hover/tap/exit etc)\r\n         */\r\n        this.features = {};\r\n        /**\r\n         * A map of every subscription that binds the provided or generated\r\n         * motion values onChange listeners to this visual element.\r\n         */\r\n        this.valueSubscriptions = new Map();\r\n        /**\r\n         * A reference to the previously-provided motion values as returned\r\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\r\n         * if any motion values need to be removed after props are updated.\r\n         */\r\n        this.prevMotionValues = {};\r\n        /**\r\n         * An object containing a SubscriptionManager for each active event.\r\n         */\r\n        this.events = {};\r\n        /**\r\n         * An object containing an unsubscribe function for each prop event subscription.\r\n         * For example, every \"Update\" event can have multiple subscribers via\r\n         * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\r\n         */\r\n        this.propEventSubscriptions = {};\r\n        this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\r\n        this.render = () => {\r\n            if (!this.current)\r\n                return;\r\n            this.triggerBuild();\r\n            this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\r\n        };\r\n        this.renderScheduledAt = 0.0;\r\n        this.scheduleRender = () => {\r\n            const now = time.now();\r\n            if (this.renderScheduledAt < now) {\r\n                this.renderScheduledAt = now;\r\n                frame.render(this.render, false, true);\r\n            }\r\n        };\r\n        const { latestValues, renderState, onUpdate } = visualState;\r\n        this.onUpdate = onUpdate;\r\n        this.latestValues = latestValues;\r\n        this.baseTarget = { ...latestValues };\r\n        this.initialValues = props.initial ? { ...latestValues } : {};\r\n        this.renderState = renderState;\r\n        this.parent = parent;\r\n        this.props = props;\r\n        this.presenceContext = presenceContext;\r\n        this.depth = parent ? parent.depth + 1 : 0;\r\n        this.reducedMotionConfig = reducedMotionConfig;\r\n        this.options = options;\r\n        this.blockInitialAnimation = Boolean(blockInitialAnimation);\r\n        this.isControllingVariants = isControllingVariants(props);\r\n        this.isVariantNode = isVariantNode(props);\r\n        if (this.isVariantNode) {\r\n            this.variantChildren = new Set();\r\n        }\r\n        this.manuallyAnimateOnMount = Boolean(parent && parent.current);\r\n        /**\r\n         * Any motion values that are provided to the element when created\r\n         * aren't yet bound to the element, as this would technically be impure.\r\n         * However, we iterate through the motion values and set them to the\r\n         * initial values for this component.\r\n         *\r\n         * TODO: This is impure and we should look at changing this to run on mount.\r\n         * Doing so will break some tests but this isn't necessarily a breaking change,\r\n         * more a reflection of the test.\r\n         */\r\n        const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);\r\n        for (const key in initialMotionValues) {\r\n            const value = initialMotionValues[key];\r\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\r\n                value.set(latestValues[key], false);\r\n            }\r\n        }\r\n    }\r\n    mount(instance) {\r\n        this.current = instance;\r\n        visualElementStore.set(instance, this);\r\n        if (this.projection && !this.projection.instance) {\r\n            this.projection.mount(instance);\r\n        }\r\n        if (this.parent && this.isVariantNode && !this.isControllingVariants) {\r\n            this.removeFromVariantTree = this.parent.addVariantChild(this);\r\n        }\r\n        this.values.forEach((value, key) => this.bindToMotionValue(key, value));\r\n        if (!hasReducedMotionListener.current) {\r\n            initPrefersReducedMotion();\r\n        }\r\n        this.shouldReduceMotion =\r\n            this.reducedMotionConfig === \"never\"\r\n                ? false\r\n                : this.reducedMotionConfig === \"always\"\r\n                    ? true\r\n                    : prefersReducedMotion.current;\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            warnOnce(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\");\r\n        }\r\n        if (this.parent)\r\n            this.parent.children.add(this);\r\n        this.update(this.props, this.presenceContext);\r\n    }\r\n    unmount() {\r\n        visualElementStore.delete(this.current);\r\n        this.projection && this.projection.unmount();\r\n        cancelFrame(this.notifyUpdate);\r\n        cancelFrame(this.render);\r\n        this.valueSubscriptions.forEach((remove) => remove());\r\n        this.valueSubscriptions.clear();\r\n        this.removeFromVariantTree && this.removeFromVariantTree();\r\n        this.parent && this.parent.children.delete(this);\r\n        for (const key in this.events) {\r\n            this.events[key].clear();\r\n        }\r\n        for (const key in this.features) {\r\n            const feature = this.features[key];\r\n            if (feature) {\r\n                feature.unmount();\r\n                feature.isMounted = false;\r\n            }\r\n        }\r\n        this.current = null;\r\n    }\r\n    bindToMotionValue(key, value) {\r\n        if (this.valueSubscriptions.has(key)) {\r\n            this.valueSubscriptions.get(key)();\r\n        }\r\n        const valueIsTransform = transformProps.has(key);\r\n        const removeOnChange = value.on(\"change\", (latestValue) => {\r\n            this.latestValues[key] = latestValue;\r\n            this.props.onUpdate && frame.preRender(this.notifyUpdate);\r\n            if (valueIsTransform && this.projection) {\r\n                this.projection.isTransformDirty = true;\r\n            }\r\n        });\r\n        const removeOnRenderRequest = value.on(\"renderRequest\", this.scheduleRender);\r\n        let removeSyncCheck;\r\n        if (window.MotionCheckAppearSync) {\r\n            removeSyncCheck = window.MotionCheckAppearSync(this, key, value);\r\n        }\r\n        this.valueSubscriptions.set(key, () => {\r\n            removeOnChange();\r\n            removeOnRenderRequest();\r\n            if (removeSyncCheck)\r\n                removeSyncCheck();\r\n            if (value.owner)\r\n                value.stop();\r\n        });\r\n    }\r\n    sortNodePosition(other) {\r\n        /**\r\n         * If these nodes aren't even of the same type we can't compare their depth.\r\n         */\r\n        if (!this.current ||\r\n            !this.sortInstanceNodePosition ||\r\n            this.type !== other.type) {\r\n            return 0;\r\n        }\r\n        return this.sortInstanceNodePosition(this.current, other.current);\r\n    }\r\n    updateFeatures() {\r\n        let key = \"animation\";\r\n        for (key in featureDefinitions) {\r\n            const featureDefinition = featureDefinitions[key];\r\n            if (!featureDefinition)\r\n                continue;\r\n            const { isEnabled, Feature: FeatureConstructor } = featureDefinition;\r\n            /**\r\n             * If this feature is enabled but not active, make a new instance.\r\n             */\r\n            if (!this.features[key] &&\r\n                FeatureConstructor &&\r\n                isEnabled(this.props)) {\r\n                this.features[key] = new FeatureConstructor(this);\r\n            }\r\n            /**\r\n             * If we have a feature, mount or update it.\r\n             */\r\n            if (this.features[key]) {\r\n                const feature = this.features[key];\r\n                if (feature.isMounted) {\r\n                    feature.update();\r\n                }\r\n                else {\r\n                    feature.mount();\r\n                    feature.isMounted = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    triggerBuild() {\r\n        this.build(this.renderState, this.latestValues, this.props);\r\n    }\r\n    /**\r\n     * Measure the current viewport box with or without transforms.\r\n     * Only measures axis-aligned boxes, rotate and skew must be manually\r\n     * removed with a re-render to work.\r\n     */\r\n    measureViewportBox() {\r\n        return this.current\r\n            ? this.measureInstanceViewportBox(this.current, this.props)\r\n            : createBox();\r\n    }\r\n    getStaticValue(key) {\r\n        return this.latestValues[key];\r\n    }\r\n    setStaticValue(key, value) {\r\n        this.latestValues[key] = value;\r\n    }\r\n    /**\r\n     * Update the provided props. Ensure any newly-added motion values are\r\n     * added to our map, old ones removed, and listeners updated.\r\n     */\r\n    update(props, presenceContext) {\r\n        if (props.transformTemplate || this.props.transformTemplate) {\r\n            this.scheduleRender();\r\n        }\r\n        this.prevProps = this.props;\r\n        this.props = props;\r\n        this.prevPresenceContext = this.presenceContext;\r\n        this.presenceContext = presenceContext;\r\n        /**\r\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\r\n         */\r\n        for (let i = 0; i < propEventHandlers.length; i++) {\r\n            const key = propEventHandlers[i];\r\n            if (this.propEventSubscriptions[key]) {\r\n                this.propEventSubscriptions[key]();\r\n                delete this.propEventSubscriptions[key];\r\n            }\r\n            const listenerName = (\"on\" + key);\r\n            const listener = props[listenerName];\r\n            if (listener) {\r\n                this.propEventSubscriptions[key] = this.on(key, listener);\r\n            }\r\n        }\r\n        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);\r\n        if (this.handleChildMotionValue) {\r\n            this.handleChildMotionValue();\r\n        }\r\n        this.onUpdate && this.onUpdate(this);\r\n    }\r\n    getProps() {\r\n        return this.props;\r\n    }\r\n    /**\r\n     * Returns the variant definition with a given name.\r\n     */\r\n    getVariant(name) {\r\n        return this.props.variants ? this.props.variants[name] : undefined;\r\n    }\r\n    /**\r\n     * Returns the defined default transition on this component.\r\n     */\r\n    getDefaultTransition() {\r\n        return this.props.transition;\r\n    }\r\n    getTransformPagePoint() {\r\n        return this.props.transformPagePoint;\r\n    }\r\n    getClosestVariantNode() {\r\n        return this.isVariantNode\r\n            ? this\r\n            : this.parent\r\n                ? this.parent.getClosestVariantNode()\r\n                : undefined;\r\n    }\r\n    /**\r\n     * Add a child visual element to our set of children.\r\n     */\r\n    addVariantChild(child) {\r\n        const closestVariantNode = this.getClosestVariantNode();\r\n        if (closestVariantNode) {\r\n            closestVariantNode.variantChildren &&\r\n                closestVariantNode.variantChildren.add(child);\r\n            return () => closestVariantNode.variantChildren.delete(child);\r\n        }\r\n    }\r\n    /**\r\n     * Add a motion value and bind it to this visual element.\r\n     */\r\n    addValue(key, value) {\r\n        // Remove existing value if it exists\r\n        const existingValue = this.values.get(key);\r\n        if (value !== existingValue) {\r\n            if (existingValue)\r\n                this.removeValue(key);\r\n            this.bindToMotionValue(key, value);\r\n            this.values.set(key, value);\r\n            this.latestValues[key] = value.get();\r\n        }\r\n    }\r\n    /**\r\n     * Remove a motion value and unbind any active subscriptions.\r\n     */\r\n    removeValue(key) {\r\n        this.values.delete(key);\r\n        const unsubscribe = this.valueSubscriptions.get(key);\r\n        if (unsubscribe) {\r\n            unsubscribe();\r\n            this.valueSubscriptions.delete(key);\r\n        }\r\n        delete this.latestValues[key];\r\n        this.removeValueFromRenderState(key, this.renderState);\r\n    }\r\n    /**\r\n     * Check whether we have a motion value for this key\r\n     */\r\n    hasValue(key) {\r\n        return this.values.has(key);\r\n    }\r\n    getValue(key, defaultValue) {\r\n        if (this.props.values && this.props.values[key]) {\r\n            return this.props.values[key];\r\n        }\r\n        let value = this.values.get(key);\r\n        if (value === undefined && defaultValue !== undefined) {\r\n            value = motionValue(defaultValue === null ? undefined : defaultValue, { owner: this });\r\n            this.addValue(key, value);\r\n        }\r\n        return value;\r\n    }\r\n    /**\r\n     * If we're trying to animate to a previously unencountered value,\r\n     * we need to check for it in our state and as a last resort read it\r\n     * directly from the instance (which might have performance implications).\r\n     */\r\n    readValue(key, target) {\r\n        var _a;\r\n        let value = this.latestValues[key] !== undefined || !this.current\r\n            ? this.latestValues[key]\r\n            : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);\r\n        if (value !== undefined && value !== null) {\r\n            if (typeof value === \"string\" &&\r\n                (isNumericalString(value) || isZeroValueString(value))) {\r\n                // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\r\n                value = parseFloat(value);\r\n            }\r\n            else if (!findValueType(value) && complex.test(target)) {\r\n                value = getAnimatableNone(key, target);\r\n            }\r\n            this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);\r\n        }\r\n        return isMotionValue(value) ? value.get() : value;\r\n    }\r\n    /**\r\n     * Set the base target to later animate back to. This is currently\r\n     * only hydrated on creation and when we first read a value.\r\n     */\r\n    setBaseTarget(key, value) {\r\n        this.baseTarget[key] = value;\r\n    }\r\n    /**\r\n     * Find the base target for a value thats been removed from all animation\r\n     * props.\r\n     */\r\n    getBaseTarget(key) {\r\n        var _a;\r\n        const { initial } = this.props;\r\n        let valueFromInitial;\r\n        if (typeof initial === \"string\" || typeof initial === \"object\") {\r\n            const variant = resolveVariantFromProps(this.props, initial, (_a = this.presenceContext) === null || _a === void 0 ? void 0 : _a.custom);\r\n            if (variant) {\r\n                valueFromInitial = variant[key];\r\n            }\r\n        }\r\n        /**\r\n         * If this value still exists in the current initial variant, read that.\r\n         */\r\n        if (initial && valueFromInitial !== undefined) {\r\n            return valueFromInitial;\r\n        }\r\n        /**\r\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\r\n         * so we can read the value from an alternative source, try that.\r\n         */\r\n        const target = this.getBaseTargetFromProps(this.props, key);\r\n        if (target !== undefined && !isMotionValue(target))\r\n            return target;\r\n        /**\r\n         * If the value was initially defined on initial, but it doesn't any more,\r\n         * return undefined. Otherwise return the value as initially read from the DOM.\r\n         */\r\n        return this.initialValues[key] !== undefined &&\r\n            valueFromInitial === undefined\r\n            ? undefined\r\n            : this.baseTarget[key];\r\n    }\r\n    on(eventName, callback) {\r\n        if (!this.events[eventName]) {\r\n            this.events[eventName] = new SubscriptionManager();\r\n        }\r\n        return this.events[eventName].add(callback);\r\n    }\r\n    notify(eventName, ...args) {\r\n        if (this.events[eventName]) {\r\n            this.events[eventName].notify(...args);\r\n        }\r\n    }\r\n}\r\n\r\nexport { VisualElement };\r\n","import { isBrowser } from '../is-browser.mjs';\r\nimport { hasReducedMotionListener, prefersReducedMotion } from './state.mjs';\r\n\r\nfunction initPrefersReducedMotion() {\r\n    hasReducedMotionListener.current = true;\r\n    if (!isBrowser)\r\n        return;\r\n    if (window.matchMedia) {\r\n        const motionMediaQuery = window.matchMedia(\"(prefers-reduced-motion)\");\r\n        const setReducedMotionPreferences = () => (prefersReducedMotion.current = motionMediaQuery.matches);\r\n        motionMediaQuery.addListener(setReducedMotionPreferences);\r\n        setReducedMotionPreferences();\r\n    }\r\n    else {\r\n        prefersReducedMotion.current = false;\r\n    }\r\n}\r\n\r\nexport { initPrefersReducedMotion };\r\n","import { warnOnce } from '../../utils/warn-once.mjs';\r\nimport { motionValue } from '../../value/index.mjs';\r\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\r\n\r\nfunction updateMotionValuesFromProps(element, next, prev) {\r\n    for (const key in next) {\r\n        const nextValue = next[key];\r\n        const prevValue = prev[key];\r\n        if (isMotionValue(nextValue)) {\r\n            /**\r\n             * If this is a motion value found in props or style, we want to add it\r\n             * to our visual element's motion value map.\r\n             */\r\n            element.addValue(key, nextValue);\r\n            /**\r\n             * Check the version of the incoming motion value with this version\r\n             * and warn against mismatches.\r\n             */\r\n            if (process.env.NODE_ENV === \"development\") {\r\n                warnOnce(nextValue.version === \"11.18.2\", `Attempting to mix Motion versions ${nextValue.version} with 11.18.2 may not work as expected.`);\r\n            }\r\n        }\r\n        else if (isMotionValue(prevValue)) {\r\n            /**\r\n             * If we're swapping from a motion value to a static value,\r\n             * create a new motion value from that\r\n             */\r\n            element.addValue(key, motionValue(nextValue, { owner: element }));\r\n        }\r\n        else if (prevValue !== nextValue) {\r\n            /**\r\n             * If this is a flat value that has changed, update the motion value\r\n             * or create one if it doesn't exist. We only want to do this if we're\r\n             * not handling the value with our animation state.\r\n             */\r\n            if (element.hasValue(key)) {\r\n                const existingValue = element.getValue(key);\r\n                if (existingValue.liveStyle === true) {\r\n                    existingValue.jump(nextValue);\r\n                }\r\n                else if (!existingValue.hasAnimated) {\r\n                    existingValue.set(nextValue);\r\n                }\r\n            }\r\n            else {\r\n                const latestValue = element.getStaticValue(key);\r\n                element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, { owner: element }));\r\n            }\r\n        }\r\n    }\r\n    // Handle removed values\r\n    for (const key in prev) {\r\n        if (next[key] === undefined)\r\n            element.removeValue(key);\r\n    }\r\n    return next;\r\n}\r\n\r\nexport { updateMotionValuesFromProps };\r\n","import { VisualElement } from '../VisualElement.mjs';\r\nimport { DOMKeyframesResolver } from './DOMKeyframesResolver.mjs';\r\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\r\n\r\nclass DOMVisualElement extends VisualElement {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.KeyframeResolver = DOMKeyframesResolver;\r\n    }\r\n    sortInstanceNodePosition(a, b) {\r\n        /**\r\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\r\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\r\n         * to true if b preceeds a.\r\n         */\r\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\r\n    }\r\n    getBaseTargetFromProps(props, key) {\r\n        return props.style\r\n            ? props.style[key]\r\n            : undefined;\r\n    }\r\n    removeValueFromRenderState(key, { vars, style }) {\r\n        delete vars[key];\r\n        delete style[key];\r\n    }\r\n    handleChildMotionValue() {\r\n        if (this.childSubscription) {\r\n            this.childSubscription();\r\n            delete this.childSubscription;\r\n        }\r\n        const { children } = this.props;\r\n        if (isMotionValue(children)) {\r\n            this.childSubscription = children.on(\"change\", (latest) => {\r\n                if (this.current) {\r\n                    this.current.textContent = `${latest}`;\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nexport { DOMVisualElement };\r\n","import { measureViewportBox } from '../../projection/utils/measure.mjs';\r\nimport { DOMVisualElement } from '../dom/DOMVisualElement.mjs';\r\nimport { isCSSVariableName } from '../dom/utils/is-css-variable.mjs';\r\nimport { getDefaultValueType } from '../dom/value-types/defaults.mjs';\r\nimport { buildHTMLStyles } from './utils/build-styles.mjs';\r\nimport { transformProps } from './utils/keys-transform.mjs';\r\nimport { renderHTML } from './utils/render.mjs';\r\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\r\n\r\nfunction getComputedStyle(element) {\r\n    return window.getComputedStyle(element);\r\n}\r\nclass HTMLVisualElement extends DOMVisualElement {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"html\";\r\n        this.renderInstance = renderHTML;\r\n    }\r\n    readValueFromInstance(instance, key) {\r\n        if (transformProps.has(key)) {\r\n            const defaultType = getDefaultValueType(key);\r\n            return defaultType ? defaultType.default || 0 : 0;\r\n        }\r\n        else {\r\n            const computedStyle = getComputedStyle(instance);\r\n            const value = (isCSSVariableName(key)\r\n                ? computedStyle.getPropertyValue(key)\r\n                : computedStyle[key]) || 0;\r\n            return typeof value === \"string\" ? value.trim() : value;\r\n        }\r\n    }\r\n    measureInstanceViewportBox(instance, { transformPagePoint }) {\r\n        return measureViewportBox(instance, transformPagePoint);\r\n    }\r\n    build(renderState, latestValues, props) {\r\n        buildHTMLStyles(renderState, latestValues, props.transformTemplate);\r\n    }\r\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\r\n        return scrapeMotionValuesFromProps(props, prevProps, visualElement);\r\n    }\r\n}\r\n\r\nexport { HTMLVisualElement, getComputedStyle };\r\n","import { createBox } from '../../projection/geometry/models.mjs';\r\nimport { DOMVisualElement } from '../dom/DOMVisualElement.mjs';\r\nimport { camelToDash } from '../dom/utils/camel-to-dash.mjs';\r\nimport { getDefaultValueType } from '../dom/value-types/defaults.mjs';\r\nimport { transformProps } from '../html/utils/keys-transform.mjs';\r\nimport { buildSVGAttrs } from './utils/build-attrs.mjs';\r\nimport { camelCaseAttributes } from './utils/camel-case-attrs.mjs';\r\nimport { isSVGTag } from './utils/is-svg-tag.mjs';\r\nimport { renderSVG } from './utils/render.mjs';\r\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\r\n\r\nclass SVGVisualElement extends DOMVisualElement {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.type = \"svg\";\r\n        this.isSVGTag = false;\r\n        this.measureInstanceViewportBox = createBox;\r\n    }\r\n    getBaseTargetFromProps(props, key) {\r\n        return props[key];\r\n    }\r\n    readValueFromInstance(instance, key) {\r\n        if (transformProps.has(key)) {\r\n            const defaultType = getDefaultValueType(key);\r\n            return defaultType ? defaultType.default || 0 : 0;\r\n        }\r\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\r\n        return instance.getAttribute(key);\r\n    }\r\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\r\n        return scrapeMotionValuesFromProps(props, prevProps, visualElement);\r\n    }\r\n    build(renderState, latestValues, props) {\r\n        buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate);\r\n    }\r\n    renderInstance(instance, renderState, styleProp, projection) {\r\n        renderSVG(instance, renderState, styleProp, projection);\r\n    }\r\n    mount(instance) {\r\n        this.isSVGTag = isSVGTag(instance.tagName);\r\n        super.mount(instance);\r\n    }\r\n}\r\n\r\nexport { SVGVisualElement };\r\n","import { Fragment } from 'react';\r\nimport { HTMLVisualElement } from '../html/HTMLVisualElement.mjs';\r\nimport { SVGVisualElement } from '../svg/SVGVisualElement.mjs';\r\nimport { isSVGComponent } from './utils/is-svg-component.mjs';\r\n\r\nconst createDomVisualElement = (Component, options) => {\r\n    return isSVGComponent(Component)\r\n        ? new SVGVisualElement(options)\r\n        : new HTMLVisualElement(options, {\r\n            allowProjection: Component !== Fragment,\r\n        });\r\n};\r\n\r\nexport { createDomVisualElement };\r\n","import { createDOMMotionComponentProxy } from '../create-proxy.mjs';\r\nimport { createMotionComponent } from './create.mjs';\r\n\r\nconst motion = /*@__PURE__*/ createDOMMotionComponentProxy(createMotionComponent);\r\n\r\nexport { motion };\r\n","import { animations } from '../../../motion/features/animations.mjs';\r\nimport { drag } from '../../../motion/features/drag.mjs';\r\nimport { gestureAnimations } from '../../../motion/features/gestures.mjs';\r\nimport { layout } from '../../../motion/features/layout.mjs';\r\nimport { createMotionComponentFactory } from '../create-factory.mjs';\r\nimport { createDomVisualElement } from '../../dom/create-visual-element.mjs';\r\n\r\nconst createMotionComponent = /*@__PURE__*/ createMotionComponentFactory({\r\n    ...animations,\r\n    ...gestureAnimations,\r\n    ...drag,\r\n    ...layout,\r\n}, createDomVisualElement);\r\n\r\nexport { createMotionComponent };\r\n","/**\r\n * Canvas layer management system for multi-layer waveform rendering\r\n * Implements requirements: 7.1 - optimized canvas drawing techniques\r\n */\r\n\r\nexport class CanvasLayerManager {\r\n  constructor() {\r\n    this.layers = new Map();\r\n    this.container = null;\r\n    this.dimensions = { width: 0, height: 0 };\r\n    this.dpr = window.devicePixelRatio || 1;\r\n  }\r\n\r\n  /**\r\n   * Initialize layer manager with container element\r\n   */\r\n  initialize(container) {\r\n    this.container = container;\r\n    this.updateDimensions();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Update canvas dimensions based on container\r\n   */\r\n  updateDimensions() {\r\n    if (!this.container) return false;\r\n    \r\n    const rect = this.container.getBoundingClientRect();\r\n    this.dimensions = {\r\n      width: rect.width || 800,\r\n      height: rect.height || 200\r\n    };\r\n    \r\n    // Update all existing layers\r\n    this.layers.forEach(layer => {\r\n      this.resizeLayer(layer);\r\n    });\r\n    \r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Create a new canvas layer\r\n   */\r\n  createLayer(name, zIndex = 0, options = {}) {\r\n    if (this.layers.has(name)) {\r\n      console.warn(`Layer ${name} already exists`);\r\n      return this.layers.get(name);\r\n    }\r\n\r\n    const canvas = document.createElement('canvas');\r\n    const ctx = canvas.getContext('2d', {\r\n      alpha: options.alpha !== false,\r\n      desynchronized: options.desynchronized || false,\r\n      ...options.contextOptions\r\n    });\r\n\r\n    if (!ctx) {\r\n      throw new Error(`Failed to create 2D context for layer ${name}`);\r\n    }\r\n\r\n    const layer = {\r\n      name,\r\n      canvas,\r\n      ctx,\r\n      zIndex,\r\n      visible: true,\r\n      dirty: true,\r\n      options\r\n    };\r\n\r\n    this.setupLayer(layer);\r\n    this.layers.set(name, layer);\r\n    \r\n    return layer;\r\n  }  \r\n/**\r\n   * Setup canvas layer with proper styling and dimensions\r\n   */\r\n  setupLayer(layer) {\r\n    const { canvas, zIndex } = layer;\r\n    \r\n    // Set canvas styling\r\n    canvas.style.position = 'absolute';\r\n    canvas.style.top = '0';\r\n    canvas.style.left = '0';\r\n    canvas.style.zIndex = zIndex;\r\n    canvas.style.pointerEvents = 'none';\r\n    \r\n    this.resizeLayer(layer);\r\n    this.configureContext(layer);\r\n    \r\n    // Add to container\r\n    if (this.container) {\r\n      this.container.appendChild(canvas);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resize a canvas layer to current dimensions\r\n   */\r\n  resizeLayer(layer) {\r\n    const { canvas, ctx } = layer;\r\n    const { width, height } = this.dimensions;\r\n    \r\n    // Set display size\r\n    canvas.style.width = `${width}px`;\r\n    canvas.style.height = `${height}px`;\r\n    \r\n    // Set actual size for high DPI\r\n    canvas.width = width * this.dpr;\r\n    canvas.height = height * this.dpr;\r\n    \r\n    // Scale context for high DPI if context exists\r\n    if (ctx) {\r\n      ctx.scale(this.dpr, this.dpr);\r\n      // Reconfigure context after resize\r\n      this.configureContext(layer);\r\n    }\r\n    \r\n    layer.dirty = true;\r\n  }\r\n\r\n  /**\r\n   * Configure canvas context for optimal performance\r\n   */\r\n  configureContext(layer) {\r\n    const { ctx, options } = layer;\r\n    \r\n    // Performance optimizations\r\n    ctx.imageSmoothingEnabled = options.smoothing !== false;\r\n    ctx.textBaseline = 'middle';\r\n    ctx.textAlign = 'left';\r\n    \r\n    // Set default styles\r\n    ctx.fillStyle = '#ffffff';\r\n    ctx.strokeStyle = '#ffffff';\r\n    ctx.lineWidth = 1;\r\n    ctx.lineCap = 'round';\r\n    ctx.lineJoin = 'round';\r\n  }\r\n\r\n  /**\r\n   * Get a layer by name\r\n   */\r\n  getLayer(name) {\r\n    return this.layers.get(name);\r\n  }\r\n\r\n  /**\r\n   * Remove a layer\r\n   */\r\n  removeLayer(name) {\r\n    const layer = this.layers.get(name);\r\n    if (!layer) return false;\r\n    \r\n    if (layer.canvas.parentNode) {\r\n      layer.canvas.parentNode.removeChild(layer.canvas);\r\n    }\r\n    \r\n    this.layers.delete(name);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Clear a specific layer\r\n   */\r\n  clearLayer(name) {\r\n    const layer = this.layers.get(name);\r\n    if (!layer) return false;\r\n    \r\n    const { ctx } = layer;\r\n    const { width, height } = this.dimensions;\r\n    ctx.clearRect(0, 0, width, height);\r\n    \r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Clear all layers\r\n   */\r\n  clearAllLayers() {\r\n    this.layers.forEach((layer, name) => {\r\n      this.clearLayer(name);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Set layer visibility\r\n   */\r\n  setLayerVisibility(name, visible) {\r\n    const layer = this.layers.get(name);\r\n    if (!layer) return false;\r\n    \r\n    layer.visible = visible;\r\n    layer.canvas.style.display = visible ? 'block' : 'none';\r\n    \r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Set layer z-index\r\n   */\r\n  setLayerZIndex(name, zIndex) {\r\n    const layer = this.layers.get(name);\r\n    if (!layer) return false;\r\n    \r\n    layer.zIndex = zIndex;\r\n    layer.canvas.style.zIndex = zIndex;\r\n    \r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Mark layer as dirty (needs redraw)\r\n   */\r\n  markLayerDirty(name) {\r\n    const layer = this.layers.get(name);\r\n    if (layer) {\r\n      layer.dirty = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Mark all layers as dirty\r\n   */\r\n  markAllLayersDirty() {\r\n    this.layers.forEach(layer => {\r\n      layer.dirty = true;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check if layer is dirty\r\n   */\r\n  isLayerDirty(name) {\r\n    const layer = this.layers.get(name);\r\n    return layer ? layer.dirty : false;\r\n  }\r\n\r\n  /**\r\n   * Mark layer as clean (up to date)\r\n   */\r\n  markLayerClean(name) {\r\n    const layer = this.layers.get(name);\r\n    if (layer) {\r\n      layer.dirty = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all layer names\r\n   */\r\n  getLayerNames() {\r\n    return Array.from(this.layers.keys());\r\n  }\r\n\r\n  /**\r\n   * Get layers sorted by z-index\r\n   */\r\n  getLayersSorted() {\r\n    return Array.from(this.layers.values())\r\n      .sort((a, b) => a.zIndex - b.zIndex);\r\n  }\r\n\r\n  /**\r\n   * Enable pointer events for a layer\r\n   */\r\n  enableLayerInteraction(name) {\r\n    const layer = this.layers.get(name);\r\n    if (layer) {\r\n      layer.canvas.style.pointerEvents = 'auto';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disable pointer events for a layer\r\n   */\r\n  disableLayerInteraction(name) {\r\n    const layer = this.layers.get(name);\r\n    if (layer) {\r\n      layer.canvas.style.pointerEvents = 'none';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroy all layers and cleanup\r\n   */\r\n  destroy() {\r\n    this.layers.forEach((layer, name) => {\r\n      this.removeLayer(name);\r\n    });\r\n    \r\n    this.layers.clear();\r\n    this.container = null;\r\n  }\r\n\r\n  /**\r\n   * Get current dimensions\r\n   */\r\n  getDimensions() {\r\n    return { ...this.dimensions };\r\n  }\r\n\r\n  /**\r\n   * Get device pixel ratio\r\n   */\r\n  getDevicePixelRatio() {\r\n    return this.dpr;\r\n  }\r\n}\r\n\r\nexport default CanvasLayerManager;","/**\r\n * Viewport state management for waveform visualization\r\n * Handles zoom and pan operations with proper bounds checking\r\n * Implements requirements: 4.1, 4.4 - zoom and navigation controls\r\n */\r\n\r\nexport class ViewportManager {\r\n  constructor(initialState = {}) {\r\n    this.state = {\r\n      zoomLevel: 1.0,\r\n      centerTime: 0,\r\n      visibleTimeRange: { start: 0, end: 0 },\r\n      pixelsPerSecond: 100,\r\n      canvasDimensions: { width: 800, height: 200 },\r\n      audioDuration: 0,\r\n      minZoom: 0.1,\r\n      maxZoom: 100,\r\n      ...initialState\r\n    };\r\n    \r\n    this.listeners = new Set();\r\n    this.updateVisibleRange();\r\n  }\r\n\r\n  /**\r\n   * Add a listener for viewport changes\r\n   */\r\n  addListener(callback) {\r\n    this.listeners.add(callback);\r\n    return () => this.listeners.delete(callback);\r\n  }\r\n\r\n  /**\r\n   * Notify all listeners of state changes\r\n   */\r\n  notifyListeners() {\r\n    this.listeners.forEach(callback => callback(this.state));\r\n  }\r\n\r\n  /**\r\n   * Update canvas dimensions and recalculate viewport\r\n   */\r\n  setCanvasDimensions(width, height) {\r\n    this.state.canvasDimensions = { width, height };\r\n    this.updateVisibleRange();\r\n    this.notifyListeners();\r\n  }\r\n\r\n  /**\r\n   * Set audio duration and adjust viewport if needed\r\n   */\r\n  setAudioDuration(duration) {\r\n    this.state.audioDuration = duration;\r\n    \r\n    // Ensure center time is within bounds\r\n    if (this.state.centerTime > duration) {\r\n      this.state.centerTime = duration / 2;\r\n    }\r\n    \r\n    this.updateVisibleRange();\r\n    this.notifyListeners();\r\n  }\r\n\r\n  /**\r\n   * Calculate visible time range based on current zoom and center\r\n   */\r\n  updateVisibleRange() {\r\n    const { zoomLevel, centerTime, canvasDimensions, audioDuration } = this.state;\r\n    \r\n    // Calculate visible duration based on zoom level\r\n    // Base: 100 pixels per second at zoom level 1\r\n    const basePixelsPerSecond = 100;\r\n    const pixelsPerSecond = basePixelsPerSecond * zoomLevel;\r\n    const visibleDuration = canvasDimensions.width / pixelsPerSecond;\r\n    \r\n    // Calculate time range centered on centerTime\r\n    const halfDuration = visibleDuration / 2;\r\n    let startTime = centerTime - halfDuration;\r\n    let endTime = centerTime + halfDuration;\r\n    \r\n    // Clamp to audio bounds\r\n    if (audioDuration > 0) {\r\n      if (startTime < 0) {\r\n        startTime = 0;\r\n        endTime = Math.min(visibleDuration, audioDuration);\r\n      } else if (endTime > audioDuration) {\r\n        endTime = audioDuration;\r\n        startTime = Math.max(0, audioDuration - visibleDuration);\r\n      }\r\n    } else {\r\n      startTime = Math.max(0, startTime);\r\n    }\r\n    \r\n    this.state.visibleTimeRange = { start: startTime, end: endTime };\r\n    this.state.pixelsPerSecond = pixelsPerSecond;\r\n  }\r\n\r\n  /**\r\n   * Set zoom level with optional center point\r\n   */\r\n  setZoom(zoomLevel, centerTime = null) {\r\n    // Clamp zoom level to valid range\r\n    zoomLevel = Math.max(this.state.minZoom, Math.min(this.state.maxZoom, zoomLevel));\r\n    \r\n    this.state.zoomLevel = zoomLevel;\r\n    \r\n    if (centerTime !== null) {\r\n      this.state.centerTime = centerTime;\r\n    }\r\n    \r\n    this.updateVisibleRange();\r\n    this.notifyListeners();\r\n    \r\n    return this.state;\r\n  }\r\n\r\n  /**\r\n   * Zoom in by a factor (default 2x)\r\n   */\r\n  zoomIn(factor = 2, centerTime = null) {\r\n    return this.setZoom(this.state.zoomLevel * factor, centerTime);\r\n  }\r\n\r\n  /**\r\n   * Zoom out by a factor (default 2x)\r\n   */\r\n  zoomOut(factor = 2, centerTime = null) {\r\n    return this.setZoom(this.state.zoomLevel / factor, centerTime);\r\n  }\r\n\r\n  /**\r\n   * Zoom to fit entire audio duration\r\n   */\r\n  zoomToFit() {\r\n    if (this.state.audioDuration <= 0) return this.state;\r\n    \r\n    const { canvasDimensions, audioDuration } = this.state;\r\n    const basePixelsPerSecond = 100;\r\n    const requiredPixelsPerSecond = canvasDimensions.width / audioDuration;\r\n    const zoomLevel = Math.max(this.state.minZoom, requiredPixelsPerSecond / basePixelsPerSecond);\r\n    \r\n    return this.setZoom(zoomLevel, audioDuration / 2);\r\n  }\r\n\r\n  /**\r\n   * Pan to a specific time\r\n   */\r\n  panToTime(targetTime) {\r\n    // Clamp target time to valid range\r\n    if (this.state.audioDuration > 0) {\r\n      targetTime = Math.max(0, Math.min(this.state.audioDuration, targetTime));\r\n    } else {\r\n      targetTime = Math.max(0, targetTime);\r\n    }\r\n    \r\n    this.state.centerTime = targetTime;\r\n    this.updateVisibleRange();\r\n    this.notifyListeners();\r\n    \r\n    return this.state;\r\n  }\r\n\r\n  /**\r\n   * Pan by a relative amount (in seconds)\r\n   */\r\n  panBy(deltaTime) {\r\n    return this.panToTime(this.state.centerTime + deltaTime);\r\n  }\r\n\r\n  /**\r\n   * Pan by a relative amount (in pixels)\r\n   */\r\n  panByPixels(deltaPixels) {\r\n    const { pixelsPerSecond } = this.state;\r\n    const deltaTime = deltaPixels / pixelsPerSecond;\r\n    return this.panBy(deltaTime);\r\n  }\r\n\r\n  /**\r\n   * Convert time to pixel position within current viewport\r\n   */\r\n  timeToPixel(time) {\r\n    const { visibleTimeRange, canvasDimensions } = this.state;\r\n    const visibleDuration = visibleTimeRange.end - visibleTimeRange.start;\r\n    \r\n    if (visibleDuration <= 0) return 0;\r\n    \r\n    const relativeTime = time - visibleTimeRange.start;\r\n    return (relativeTime / visibleDuration) * canvasDimensions.width;\r\n  }\r\n\r\n  /**\r\n   * Convert pixel position to time within current viewport\r\n   */\r\n  pixelToTime(pixel) {\r\n    const { visibleTimeRange, canvasDimensions } = this.state;\r\n    const visibleDuration = visibleTimeRange.end - visibleTimeRange.start;\r\n    \r\n    if (canvasDimensions.width <= 0) {\r\n      return visibleTimeRange.start;\r\n    }\r\n    \r\n    const relativePixel = pixel / canvasDimensions.width;\r\n    return visibleTimeRange.start + (relativePixel * visibleDuration);\r\n  }\r\n\r\n  /**\r\n   * Check if a time is visible in current viewport\r\n   */\r\n  isTimeVisible(time) {\r\n    const { visibleTimeRange } = this.state;\r\n    return time >= visibleTimeRange.start && time <= visibleTimeRange.end;\r\n  }\r\n\r\n  /**\r\n   * Check if a time range is visible in current viewport\r\n   */\r\n  isRangeVisible(startTime, endTime) {\r\n    const { visibleTimeRange } = this.state;\r\n    return !(endTime < visibleTimeRange.start || startTime > visibleTimeRange.end);\r\n  }\r\n\r\n  /**\r\n   * Get viewport bounds for culling calculations\r\n   */\r\n  getViewportBounds() {\r\n    return {\r\n      ...this.state.visibleTimeRange,\r\n      duration: this.state.visibleTimeRange.end - this.state.visibleTimeRange.start,\r\n      pixelsPerSecond: this.state.pixelsPerSecond\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get current viewport state (read-only)\r\n   */\r\n  getState() {\r\n    return { ...this.state };\r\n  }\r\n\r\n  /**\r\n   * Reset viewport to default state\r\n   */\r\n  reset() {\r\n    this.state.zoomLevel = 1.0;\r\n    this.state.centerTime = this.state.audioDuration / 2;\r\n    this.updateVisibleRange();\r\n    this.notifyListeners();\r\n    \r\n    return this.state;\r\n  }\r\n\r\n  /**\r\n   * Set zoom and pan limits\r\n   */\r\n  setLimits({ minZoom, maxZoom }) {\r\n    if (minZoom !== undefined) {\r\n      this.state.minZoom = Math.max(0.01, minZoom);\r\n    }\r\n    if (maxZoom !== undefined) {\r\n      this.state.maxZoom = Math.min(1000, maxZoom);\r\n    }\r\n    \r\n    // Ensure current zoom is within new limits\r\n    if (this.state.zoomLevel < this.state.minZoom) {\r\n      this.setZoom(this.state.minZoom);\r\n    } else if (this.state.zoomLevel > this.state.maxZoom) {\r\n      this.setZoom(this.state.maxZoom);\r\n    }\r\n    \r\n    return this.state;\r\n  }\r\n\r\n  /**\r\n   * Calculate optimal zoom level for a specific time range\r\n   */\r\n  calculateZoomForRange(startTime, endTime, padding = 0.1) {\r\n    const duration = endTime - startTime;\r\n    if (duration <= 0) return this.state.zoomLevel;\r\n    \r\n    const paddedDuration = duration * (1 + padding * 2);\r\n    const { canvasDimensions } = this.state;\r\n    const basePixelsPerSecond = 100;\r\n    const requiredPixelsPerSecond = canvasDimensions.width / paddedDuration;\r\n    \r\n    return requiredPixelsPerSecond / basePixelsPerSecond;\r\n  }\r\n\r\n  /**\r\n   * Zoom to show a specific time range\r\n   */\r\n  zoomToRange(startTime, endTime, padding = 0.1) {\r\n    const centerTime = (startTime + endTime) / 2;\r\n    const zoomLevel = this.calculateZoomForRange(startTime, endTime, padding);\r\n    \r\n    return this.setZoom(zoomLevel, centerTime);\r\n  }\r\n\r\n  /**\r\n   * Get appropriate detail level for current zoom\r\n   * Implements requirement 4.3 - appropriate detail rendering at different scales\r\n   */\r\n  getDetailLevel() {\r\n    const { zoomLevel, pixelsPerSecond } = this.state;\r\n    \r\n    // Define detail levels based on pixels per second\r\n    if (pixelsPerSecond >= 1000) {\r\n      return 'sample'; // Individual sample points visible\r\n    } else if (pixelsPerSecond >= 400) {\r\n      return 'high'; // High detail waveform\r\n    } else if (pixelsPerSecond >= 100) {\r\n      return 'medium'; // Medium detail waveform\r\n    } else if (pixelsPerSecond >= 25) {\r\n      return 'low'; // Low detail waveform\r\n    } else {\r\n      return 'overview'; // Overview/summary view\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get rendering configuration for current detail level\r\n   */\r\n  getRenderingConfig() {\r\n    const detailLevel = this.getDetailLevel();\r\n    const { pixelsPerSecond, visibleTimeRange } = this.state;\r\n    \r\n    const config = {\r\n      detailLevel,\r\n      pixelsPerSecond,\r\n      visibleDuration: visibleTimeRange.end - visibleTimeRange.start,\r\n      showSamplePoints: false,\r\n      showZeroCrossings: false,\r\n      showGrid: false,\r\n      waveformResolution: 1,\r\n      antialiasing: true\r\n    };\r\n    \r\n    switch (detailLevel) {\r\n      case 'sample':\r\n        config.showSamplePoints = true;\r\n        config.showZeroCrossings = true;\r\n        config.showGrid = true;\r\n        config.waveformResolution = 1; // 1:1 sample resolution\r\n        config.antialiasing = false; // Crisp pixels for sample view\r\n        break;\r\n        \r\n      case 'high':\r\n        config.showZeroCrossings = true;\r\n        config.showGrid = true;\r\n        config.waveformResolution = 2; // 2:1 sample resolution\r\n        config.antialiasing = true;\r\n        break;\r\n        \r\n      case 'medium':\r\n        config.showGrid = pixelsPerSecond >= 150;\r\n        config.waveformResolution = 4; // 4:1 sample resolution\r\n        config.antialiasing = true;\r\n        break;\r\n        \r\n      case 'low':\r\n        config.waveformResolution = 8; // 8:1 sample resolution\r\n        config.antialiasing = true;\r\n        break;\r\n        \r\n      case 'overview':\r\n        config.waveformResolution = 16; // 16:1 sample resolution\r\n        config.antialiasing = true;\r\n        break;\r\n    }\r\n    \r\n    return config;\r\n  }\r\n\r\n  /**\r\n   * Get zoom level presets for quick navigation\r\n   */\r\n  getZoomPresets() {\r\n    const { audioDuration, canvasDimensions } = this.state;\r\n    const basePixelsPerSecond = 100;\r\n    \r\n    const presets = [\r\n      {\r\n        name: 'Fit All',\r\n        zoomLevel: this.calculateZoomForRange(0, audioDuration, 0.05),\r\n        description: 'Show entire audio file'\r\n      },\r\n      {\r\n        name: '1:1',\r\n        zoomLevel: 1.0,\r\n        description: 'Default zoom level'\r\n      },\r\n      {\r\n        name: '2x',\r\n        zoomLevel: 2.0,\r\n        description: 'Double zoom'\r\n      },\r\n      {\r\n        name: '5x',\r\n        zoomLevel: 5.0,\r\n        description: '5x zoom for detailed editing'\r\n      },\r\n      {\r\n        name: '10x',\r\n        zoomLevel: 10.0,\r\n        description: '10x zoom for precise editing'\r\n      },\r\n      {\r\n        name: 'Sample',\r\n        zoomLevel: Math.max(10, canvasDimensions.width / (audioDuration * 44100) * basePixelsPerSecond),\r\n        description: 'Sample-level detail'\r\n      }\r\n    ];\r\n    \r\n    return presets.filter(preset => \r\n      preset.zoomLevel >= this.state.minZoom && \r\n      preset.zoomLevel <= this.state.maxZoom\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get navigation info for current viewport\r\n   */\r\n  getNavigationInfo() {\r\n    const { visibleTimeRange, audioDuration, zoomLevel } = this.state;\r\n    const visibleDuration = visibleTimeRange.end - visibleTimeRange.start;\r\n    \r\n    return {\r\n      visiblePercentage: audioDuration > 0 ? (visibleDuration / audioDuration) * 100 : 100,\r\n      startPercentage: audioDuration > 0 ? (visibleTimeRange.start / audioDuration) * 100 : 0,\r\n      endPercentage: audioDuration > 0 ? (visibleTimeRange.end / audioDuration) * 100 : 100,\r\n      zoomLevel: zoomLevel,\r\n      detailLevel: this.getDetailLevel(),\r\n      canZoomIn: zoomLevel < this.state.maxZoom,\r\n      canZoomOut: zoomLevel > this.state.minZoom,\r\n      canPanLeft: visibleTimeRange.start > 0,\r\n      canPanRight: visibleTimeRange.end < audioDuration\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Smart zoom that maintains context\r\n   */\r\n  smartZoom(factor, mouseTime = null) {\r\n    const centerTime = mouseTime || this.state.centerTime;\r\n    const newZoomLevel = this.state.zoomLevel * factor;\r\n    \r\n    // Clamp to limits\r\n    const clampedZoom = Math.max(this.state.minZoom, Math.min(this.state.maxZoom, newZoomLevel));\r\n    \r\n    // If we hit a limit, provide feedback\r\n    const hitLimit = clampedZoom !== newZoomLevel;\r\n    \r\n    this.setZoom(clampedZoom, centerTime);\r\n    \r\n    return {\r\n      newZoomLevel: clampedZoom,\r\n      hitLimit,\r\n      limitType: clampedZoom === this.state.maxZoom ? 'max' : 'min'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get optimal zoom for time selection\r\n   */\r\n  getOptimalZoomForSelection(startTime, endTime, targetPercentage = 0.8) {\r\n    const duration = endTime - startTime;\r\n    const { canvasDimensions } = this.state;\r\n    const targetWidth = canvasDimensions.width * targetPercentage;\r\n    const basePixelsPerSecond = 100;\r\n    \r\n    const requiredPixelsPerSecond = targetWidth / duration;\r\n    return requiredPixelsPerSecond / basePixelsPerSecond;\r\n  }\r\n}\r\n\r\nexport default ViewportManager;","/**\r\n * High-performance canvas rendering system for waveform visualization\r\n * Implements optimized drawing algorithms with viewport culling\r\n * Requirements: 1.3, 4.4, 7.1, 7.2\r\n */\r\n\r\nimport { CanvasLayerManager } from './CanvasLayerManager.js';\r\nimport { ViewportManager } from './ViewportManager.js';\r\n\r\nexport class CanvasRenderer {\r\n  constructor(container, options = {}) {\r\n    this.container = container;\r\n    this.options = {\r\n      enableViewportCulling: true,\r\n      enableBatching: true,\r\n      maxBatchSize: 1000,\r\n      renderQuality: 'high', // 'low', 'medium', 'high'\r\n      enableAntialiasing: true,\r\n      ...options\r\n    };\r\n\r\n    // Initialize managers\r\n    this.layerManager = new CanvasLayerManager();\r\n    this.viewportManager = new ViewportManager();\r\n    \r\n    // Performance tracking\r\n    this.performanceMetrics = {\r\n      frameCount: 0,\r\n      lastFrameTime: 0,\r\n      averageFPS: 0,\r\n      renderTime: 0,\r\n      culledElements: 0\r\n    };\r\n\r\n    // Rendering state\r\n    this.isRendering = false;\r\n    this.renderQueue = [];\r\n    this.animationFrameId = null;\r\n    \r\n    // Cached drawing operations\r\n    this.drawingCache = new Map();\r\n    this.pathCache = new Map();\r\n    \r\n    this.initialize();\r\n  }\r\n\r\n  /**\r\n   * Initialize the renderer with canvas layers\r\n   */\r\n  initialize() {\r\n    this.layerManager.initialize(this.container);\r\n    \r\n    // Create standard layers with optimized configurations\r\n    this.createStandardLayers();\r\n    \r\n    // Setup viewport change listener\r\n    this.viewportManager.addListener((viewport) => {\r\n      this.handleViewportChange(viewport);\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Create standard canvas layers for waveform rendering\r\n   */\r\n  createStandardLayers() {\r\n    const layers = [\r\n      {\r\n        name: 'background',\r\n        zIndex: 1,\r\n        options: { \r\n          alpha: false, // Opaque background for better performance\r\n          desynchronized: true // Allow async rendering\r\n        }\r\n      },\r\n      {\r\n        name: 'waveform',\r\n        zIndex: 2,\r\n        options: { \r\n          alpha: true,\r\n          desynchronized: true\r\n        }\r\n      },\r\n      {\r\n        name: 'chops',\r\n        zIndex: 3,\r\n        options: { \r\n          alpha: true,\r\n          desynchronized: false // Sync for precise interaction\r\n        }\r\n      },\r\n      {\r\n        name: 'playhead',\r\n        zIndex: 4,\r\n        options: { \r\n          alpha: true,\r\n          desynchronized: true\r\n        }\r\n      },\r\n      {\r\n        name: 'interaction',\r\n        zIndex: 5,\r\n        options: { \r\n          alpha: true,\r\n          desynchronized: false\r\n        }\r\n      },\r\n      {\r\n        name: 'ui',\r\n        zIndex: 6,\r\n        options: { \r\n          alpha: true,\r\n          desynchronized: true\r\n        }\r\n      }\r\n    ];\r\n\r\n    layers.forEach(({ name, zIndex, options }) => {\r\n      this.layerManager.createLayer(name, zIndex, options);\r\n    });\r\n\r\n    // Enable interaction only on interaction layer\r\n    this.layerManager.enableLayerInteraction('interaction');\r\n  }\r\n\r\n  /**\r\n   * Handle viewport changes and trigger appropriate redraws\r\n   */\r\n  handleViewportChange(viewport) {\r\n    // Mark layers that need redraw based on viewport change\r\n    this.layerManager.markLayerDirty('waveform');\r\n    this.layerManager.markLayerDirty('chops');\r\n    this.layerManager.markLayerDirty('playhead');\r\n    this.layerManager.markLayerDirty('ui');\r\n    \r\n    // Schedule render\r\n    this.scheduleRender();\r\n  }\r\n\r\n  /**\r\n   * Render waveform data with viewport culling and optimization\r\n   */\r\n  renderWaveform(waveformData, options = {}) {\r\n    const layer = this.layerManager.getLayer('waveform');\r\n    if (!layer || !waveformData) return;\r\n\r\n    const startTime = performance.now();\r\n    const viewport = this.viewportManager.getViewportBounds();\r\n    const { ctx } = layer;\r\n    const { width, height } = this.layerManager.getDimensions();\r\n\r\n    // Clear layer\r\n    this.layerManager.clearLayer('waveform');\r\n\r\n    // Get rendering configuration based on current zoom level\r\n    // Implements requirement 4.3 - appropriate detail rendering at different scales\r\n    const renderingConfig = this.viewportManager.getRenderingConfig();\r\n    \r\n    // Merge options with rendering config\r\n    const enhancedOptions = {\r\n      ...options,\r\n      ...renderingConfig,\r\n      quality: options.quality || renderingConfig.detailLevel\r\n    };\r\n\r\n    // Apply viewport culling with resolution adjustment\r\n    const visibleSamples = this.cullWaveformData(waveformData, viewport, renderingConfig.waveformResolution);\r\n    \r\n    if (visibleSamples.length === 0) {\r\n      this.updatePerformanceMetrics('waveform', startTime, 0);\r\n      return;\r\n    }\r\n\r\n    // Choose rendering method based on zoom level and data density\r\n    const renderMethod = this.selectOptimalRenderMethod(visibleSamples, viewport, renderingConfig);\r\n    \r\n    // Configure context for waveform rendering with enhanced options\r\n    this.configureWaveformContext(ctx, enhancedOptions);\r\n\r\n    // Render grid if enabled for current detail level\r\n    if (renderingConfig.showGrid) {\r\n      this.renderGrid(ctx, viewport, width, height);\r\n    }\r\n\r\n    // Render using selected method with enhanced options\r\n    switch (renderMethod) {\r\n      case 'sample':\r\n        this.renderWaveformSamples(ctx, visibleSamples, viewport, width, height, enhancedOptions);\r\n        break;\r\n      case 'peaks':\r\n        this.renderWaveformPeaks(ctx, visibleSamples, viewport, width, height, enhancedOptions);\r\n        break;\r\n      case 'bars':\r\n        this.renderWaveformBars(ctx, visibleSamples, viewport, width, height, enhancedOptions);\r\n        break;\r\n      case 'line':\r\n        this.renderWaveformLine(ctx, visibleSamples, viewport, width, height, enhancedOptions);\r\n        break;\r\n      default:\r\n        this.renderWaveformPeaks(ctx, visibleSamples, viewport, width, height, enhancedOptions);\r\n    }\r\n\r\n    // Render zero-crossings if enabled\r\n    if (renderingConfig.showZeroCrossings) {\r\n      this.renderZeroCrossings(ctx, visibleSamples, viewport, width, height);\r\n    }\r\n\r\n    // Update performance metrics\r\n    this.updatePerformanceMetrics('waveform', startTime, visibleSamples.length);\r\n    this.layerManager.markLayerClean('waveform');\r\n  }\r\n\r\n  /**\r\n   * Cull waveform data to only include visible samples\r\n   */\r\n  cullWaveformData(waveformData, viewport, resolution = 1) {\r\n    if (!this.options.enableViewportCulling) {\r\n      return waveformData.samples || [];\r\n    }\r\n\r\n    const { samples, sampleRate } = waveformData;\r\n    if (!samples || !sampleRate) return [];\r\n\r\n    // Calculate sample indices for visible time range\r\n    const startSample = Math.floor(viewport.start * sampleRate);\r\n    const endSample = Math.ceil(viewport.end * sampleRate);\r\n    \r\n    // Add small buffer to avoid edge artifacts\r\n    const bufferSamples = Math.ceil(sampleRate * 0.1); // 100ms buffer\r\n    const cullStart = Math.max(0, startSample - bufferSamples);\r\n    const cullEnd = Math.min(samples.length, endSample + bufferSamples);\r\n\r\n    let culledSamples = samples.slice(cullStart, cullEnd);\r\n    \r\n    // Apply resolution downsampling if needed\r\n    if (resolution > 1 && culledSamples.length > resolution) {\r\n      const downsampledSamples = [];\r\n      for (let i = 0; i < culledSamples.length; i += resolution) {\r\n        // Use RMS for better quality downsampling\r\n        let sum = 0;\r\n        let count = 0;\r\n        for (let j = i; j < Math.min(i + resolution, culledSamples.length); j++) {\r\n          sum += culledSamples[j] * culledSamples[j];\r\n          count++;\r\n        }\r\n        downsampledSamples.push(Math.sqrt(sum / count) * Math.sign(culledSamples[i]));\r\n      }\r\n      culledSamples = downsampledSamples;\r\n    }\r\n\r\n    this.performanceMetrics.culledElements = samples.length - culledSamples.length;\r\n    \r\n    return {\r\n      samples: culledSamples,\r\n      startIndex: cullStart,\r\n      endIndex: cullEnd,\r\n      sampleRate: sampleRate / resolution\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Select optimal rendering method based on data density and zoom level\r\n   * Enhanced with detail level support for different zoom scales\r\n   */\r\n  selectOptimalRenderMethod(visibleSamples, viewport, renderingConfig = {}) {\r\n    const { samples } = visibleSamples;\r\n    if (!samples || samples.length === 0) {\r\n      return 'peaks'; // Default fallback\r\n    }\r\n    \r\n    const { width } = this.layerManager.getDimensions();\r\n    if (width <= 0) {\r\n      return 'peaks'; // Default fallback\r\n    }\r\n    \r\n    const samplesPerPixel = samples.length / width;\r\n    const { detailLevel } = renderingConfig;\r\n\r\n    // Use detail level to determine rendering method\r\n    switch (detailLevel) {\r\n      case 'sample':\r\n        return 'sample'; // Individual sample points\r\n        \r\n      case 'high':\r\n        return samplesPerPixel < 2 ? 'line' : 'bars';\r\n        \r\n      case 'medium':\r\n        return samplesPerPixel < 5 ? 'bars' : 'peaks';\r\n        \r\n      case 'low':\r\n      case 'overview':\r\n        return 'peaks';\r\n        \r\n      default:\r\n        // Fallback to original logic\r\n        if (samplesPerPixel < 1) {\r\n          return 'sample';\r\n        } else if (samplesPerPixel < 2) {\r\n          return 'line';\r\n        } else if (samplesPerPixel < 10) {\r\n          return 'bars';\r\n        } else {\r\n          return 'peaks';\r\n        }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Configure canvas context for waveform rendering\r\n   */\r\n  configureWaveformContext(ctx, options) {\r\n    const quality = options.quality || this.options.renderQuality;\r\n    \r\n    // Set rendering quality\r\n    switch (quality) {\r\n      case 'low':\r\n        ctx.imageSmoothingEnabled = false;\r\n        ctx.lineWidth = 1;\r\n        break;\r\n      case 'medium':\r\n        ctx.imageSmoothingEnabled = true;\r\n        ctx.lineWidth = 1.5;\r\n        break;\r\n      case 'high':\r\n        ctx.imageSmoothingEnabled = this.options.enableAntialiasing;\r\n        ctx.lineWidth = 2;\r\n        break;\r\n    }\r\n\r\n    // Set waveform colors\r\n    const gradient = ctx.createLinearGradient(0, 0, 0, this.layerManager.getDimensions().height);\r\n    gradient.addColorStop(0, options.topColor || 'rgba(6, 182, 212, 0.8)');\r\n    gradient.addColorStop(0.5, options.centerColor || 'rgba(6, 182, 212, 0.4)');\r\n    gradient.addColorStop(1, options.bottomColor || 'rgba(6, 182, 212, 0.8)');\r\n    \r\n    ctx.fillStyle = gradient;\r\n    ctx.strokeStyle = options.strokeColor || 'rgba(6, 182, 212, 1)';\r\n  }\r\n\r\n  /**\r\n   * Render waveform using peak detection (for high data density)\r\n   */\r\n  renderWaveformPeaks(ctx, visibleSamples, viewport, width, height) {\r\n    const { samples } = visibleSamples;\r\n    if (!samples || samples.length === 0 || width <= 0) return;\r\n    \r\n    const centerY = height / 2;\r\n    const samplesPerPixel = samples.length / width;\r\n    \r\n    ctx.beginPath();\r\n    \r\n    for (let x = 0; x < width; x++) {\r\n      const sampleStart = Math.floor(x * samplesPerPixel);\r\n      const sampleEnd = Math.floor((x + 1) * samplesPerPixel);\r\n      \r\n      // Find min and max in this pixel range\r\n      let min = 0, max = 0;\r\n      for (let i = sampleStart; i < Math.min(sampleEnd, samples.length); i++) {\r\n        const sample = samples[i] || 0;\r\n        min = Math.min(min, sample);\r\n        max = Math.max(max, sample);\r\n      }\r\n      \r\n      // Convert to pixel coordinates\r\n      const minY = centerY - (min * centerY);\r\n      const maxY = centerY - (max * centerY);\r\n      \r\n      // Draw vertical line from min to max\r\n      ctx.moveTo(x, minY);\r\n      ctx.lineTo(x, maxY);\r\n    }\r\n    \r\n    ctx.stroke();\r\n  }\r\n\r\n  /**\r\n   * Render waveform using bar visualization (for medium data density)\r\n   */\r\n  renderWaveformBars(ctx, visibleSamples, viewport, width, height) {\r\n    const { samples } = visibleSamples;\r\n    if (!samples || samples.length === 0) return;\r\n    \r\n    const centerY = height / 2;\r\n    const barWidth = Math.max(1, width / samples.length);\r\n    \r\n    for (let i = 0; i < samples.length; i++) {\r\n      const sample = samples[i] || 0;\r\n      const x = i * barWidth;\r\n      const barHeight = Math.abs(sample) * centerY;\r\n      \r\n      if (sample >= 0) {\r\n        ctx.fillRect(x, centerY - barHeight, barWidth, barHeight);\r\n      } else {\r\n        ctx.fillRect(x, centerY, barWidth, barHeight);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render waveform using line visualization (for low data density)\r\n   */\r\n  renderWaveformLine(ctx, visibleSamples, viewport, width, height) {\r\n    const { samples } = visibleSamples;\r\n    if (!samples || samples.length === 0) return;\r\n    \r\n    const centerY = height / 2;\r\n    const stepX = width / samples.length;\r\n    \r\n    ctx.beginPath();\r\n    \r\n    for (let i = 0; i < samples.length; i++) {\r\n      const x = i * stepX;\r\n      const y = centerY - ((samples[i] || 0) * centerY);\r\n      \r\n      if (i === 0) {\r\n        ctx.moveTo(x, y);\r\n      } else {\r\n        ctx.lineTo(x, y);\r\n      }\r\n    }\r\n    \r\n    ctx.stroke();\r\n    \r\n    // Fill area under curve for better visibility\r\n    ctx.lineTo(width, centerY);\r\n    ctx.lineTo(0, centerY);\r\n    ctx.closePath();\r\n    ctx.globalAlpha = 0.3;\r\n    ctx.fill();\r\n    ctx.globalAlpha = 1.0;\r\n  }\r\n\r\n  /**\r\n   * Render waveform at sample level (for maximum zoom)\r\n   * Shows individual sample points and zero-crossings\r\n   */\r\n  renderWaveformSamples(ctx, visibleSamples, viewport, width, height, options = {}) {\r\n    const { samples } = visibleSamples;\r\n    if (!samples || samples.length === 0) return;\r\n    \r\n    const centerY = height / 2;\r\n    const stepX = width / samples.length;\r\n    \r\n    // Draw sample points\r\n    ctx.fillStyle = options.strokeColor || 'rgba(6, 182, 212, 1)';\r\n    \r\n    for (let i = 0; i < samples.length; i++) {\r\n      const x = i * stepX;\r\n      const y = centerY - ((samples[i] || 0) * centerY);\r\n      \r\n      // Draw sample point\r\n      ctx.beginPath();\r\n      ctx.arc(x, y, 2, 0, Math.PI * 2);\r\n      ctx.fill();\r\n      \r\n      // Connect with lines if not too dense\r\n      if (stepX > 4 && i > 0) {\r\n        const prevY = centerY - ((samples[i - 1] || 0) * centerY);\r\n        ctx.strokeStyle = options.strokeColor || 'rgba(6, 182, 212, 0.6)';\r\n        ctx.lineWidth = 1;\r\n        ctx.beginPath();\r\n        ctx.moveTo((i - 1) * stepX, prevY);\r\n        ctx.lineTo(x, y);\r\n        ctx.stroke();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render time grid for navigation reference\r\n   */\r\n  renderGrid(ctx, viewport, width, height) {\r\n    const { start, end } = viewport;\r\n    const duration = end - start;\r\n    \r\n    // Calculate appropriate grid interval\r\n    let gridInterval = 1; // seconds\r\n    if (duration > 300) gridInterval = 60; // 1 minute\r\n    else if (duration > 60) gridInterval = 10; // 10 seconds\r\n    else if (duration > 10) gridInterval = 1; // 1 second\r\n    else if (duration > 1) gridInterval = 0.1; // 100ms\r\n    else gridInterval = 0.01; // 10ms\r\n    \r\n    // Draw vertical grid lines\r\n    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';\r\n    ctx.lineWidth = 1;\r\n    if (ctx.setLineDash) {\r\n      ctx.setLineDash([2, 4]);\r\n    }\r\n    \r\n    const startGrid = Math.ceil(start / gridInterval) * gridInterval;\r\n    \r\n    for (let time = startGrid; time <= end; time += gridInterval) {\r\n      const x = ((time - start) / duration) * width;\r\n      \r\n      ctx.beginPath();\r\n      ctx.moveTo(x, 0);\r\n      ctx.lineTo(x, height);\r\n      ctx.stroke();\r\n    }\r\n    \r\n    // Draw center line\r\n    if (ctx.setLineDash) {\r\n      ctx.setLineDash([]);\r\n    }\r\n    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';\r\n    ctx.lineWidth = 1;\r\n    ctx.beginPath();\r\n    ctx.moveTo(0, height / 2);\r\n    ctx.lineTo(width, height / 2);\r\n    ctx.stroke();\r\n  }\r\n\r\n  /**\r\n   * Render zero-crossing indicators\r\n   */\r\n  renderZeroCrossings(ctx, visibleSamples, viewport, width, height) {\r\n    const { samples } = visibleSamples;\r\n    if (!samples || samples.length === 0) return;\r\n    \r\n    const centerY = height / 2;\r\n    const stepX = width / samples.length;\r\n    \r\n    // Find zero crossings\r\n    ctx.strokeStyle = 'rgba(255, 165, 0, 0.8)';\r\n    ctx.lineWidth = 1;\r\n    \r\n    for (let i = 1; i < samples.length; i++) {\r\n      const prev = samples[i - 1] || 0;\r\n      const curr = samples[i] || 0;\r\n      \r\n      // Check for zero crossing\r\n      if ((prev >= 0 && curr < 0) || (prev < 0 && curr >= 0)) {\r\n        const x = i * stepX;\r\n        \r\n        ctx.beginPath();\r\n        ctx.moveTo(x, centerY - 10);\r\n        ctx.lineTo(x, centerY + 10);\r\n        ctx.stroke();\r\n        \r\n        // Draw small circle at crossing point\r\n        ctx.fillStyle = 'rgba(255, 165, 0, 1)';\r\n        ctx.beginPath();\r\n        ctx.arc(x, centerY, 2, 0, Math.PI * 2);\r\n        ctx.fill();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render chops with enhanced visualization and relationship display\r\n   * Implements requirements: 2.4, 2.5, 5.4, 5.5\r\n   */\r\n  renderChops(chops, selectedChopId = null, options = {}) {\r\n    const layer = this.layerManager.getLayer('chops');\r\n    if (!layer || !chops.length) return;\r\n\r\n    const startTime = performance.now();\r\n    const viewport = this.viewportManager.getViewportBounds();\r\n    const { ctx } = layer;\r\n    const { width, height } = this.layerManager.getDimensions();\r\n\r\n    // Clear layer\r\n    this.layerManager.clearLayer('chops');\r\n\r\n    // Cull chops outside viewport\r\n    const visibleChops = this.cullChops(chops, viewport);\r\n    \r\n    if (visibleChops.length === 0) {\r\n      this.updatePerformanceMetrics('chops', startTime, 0);\r\n      return;\r\n    }\r\n\r\n    // Enhanced rendering with relationship analysis\r\n    visibleChops.forEach((chop, index) => {\r\n      this.renderSingleChop(ctx, chop, viewport, width, height, {\r\n        isSelected: chop.id === selectedChopId,\r\n        isHovered: chop.id === options.hoveredChopId,\r\n        isActive: chop.id === options.activeChopId,\r\n        allChops: chops, // Pass all chops for relationship analysis\r\n        ...options\r\n      });\r\n    });\r\n\r\n    this.updatePerformanceMetrics('chops', startTime, visibleChops.length);\r\n    this.layerManager.markLayerClean('chops');\r\n  }\r\n\r\n  /**\r\n   * Cull chops to only include those visible in viewport\r\n   */\r\n  cullChops(chops, viewport) {\r\n    if (!this.options.enableViewportCulling) {\r\n      return chops;\r\n    }\r\n\r\n    return chops.filter(chop => {\r\n      // Check if chop overlaps with viewport\r\n      return !(chop.endTime < viewport.start || chop.startTime > viewport.end);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Render a single chop with enhanced visualization and relationship display\r\n   * Implements requirements: 2.4, 2.5, 5.4, 5.5\r\n   */\r\n  renderSingleChop(ctx, chop, viewport, width, height, options = {}) {\r\n    const startPixel = this.viewportManager.timeToPixel(chop.startTime);\r\n    const endPixel = this.viewportManager.timeToPixel(chop.endTime);\r\n    \r\n    // Clamp to viewport bounds\r\n    const clampedStart = Math.max(0, startPixel);\r\n    const clampedEnd = Math.min(width, endPixel);\r\n    const chopWidth = clampedEnd - clampedStart;\r\n    \r\n    if (chopWidth <= 0) return;\r\n    \r\n    // Use cached color or generate one with enhanced color scheme\r\n    const color = chop.color || this.generateChopColor(chop.id);\r\n    const isSelected = options.isSelected;\r\n    const isHovered = options.isHovered;\r\n    const isActive = options.isActive; // Currently playing\r\n    \r\n    // Enhanced visual states\r\n    const baseAlpha = isSelected ? 0.6 : isHovered ? 0.4 : 0.25;\r\n    const borderAlpha = isSelected ? 1.0 : isHovered ? 0.8 : 0.6;\r\n    \r\n    // Draw chop background with gradient for depth\r\n    const gradient = ctx.createLinearGradient(clampedStart, 0, clampedStart, height);\r\n    if (isActive) {\r\n      // Active chop gets animated gradient\r\n      const pulseOffset = Math.sin(Date.now() / 300) * 0.1;\r\n      gradient.addColorStop(0, this.hexToRgba(color, baseAlpha + pulseOffset));\r\n      gradient.addColorStop(0.5, this.hexToRgba(color, baseAlpha * 0.7 + pulseOffset));\r\n      gradient.addColorStop(1, this.hexToRgba(color, baseAlpha + pulseOffset));\r\n    } else {\r\n      gradient.addColorStop(0, this.hexToRgba(color, baseAlpha));\r\n      gradient.addColorStop(0.5, this.hexToRgba(color, baseAlpha * 0.7));\r\n      gradient.addColorStop(1, this.hexToRgba(color, baseAlpha));\r\n    }\r\n    \r\n    ctx.fillStyle = gradient;\r\n    ctx.fillRect(clampedStart, 0, chopWidth, height);\r\n    \r\n    // Draw enhanced chop boundaries with clear start/end indicators\r\n    this.renderChopBoundaries(ctx, chop, startPixel, endPixel, width, height, {\r\n      color,\r\n      isSelected,\r\n      isHovered,\r\n      isActive,\r\n      borderAlpha\r\n    });\r\n    \r\n    // Draw relationship indicators for overlapping or adjacent chops\r\n    this.renderChopRelationships(ctx, chop, startPixel, endPixel, width, height, options);\r\n    \r\n    // Draw enhanced chop label with better visibility\r\n    this.renderChopLabel(ctx, chop, clampedStart, chopWidth, height, {\r\n      color,\r\n      isSelected,\r\n      isHovered,\r\n      isActive\r\n    });\r\n    \r\n    // Draw duration indicator for longer chops\r\n    if (chopWidth > 80) {\r\n      this.renderDurationIndicator(ctx, chop, clampedStart, chopWidth, height, color);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render enhanced chop boundaries with clear start/end indicators\r\n   */\r\n  renderChopBoundaries(ctx, chop, startPixel, endPixel, width, height, options) {\r\n    const { color, isSelected, isHovered, isActive, borderAlpha } = options;\r\n    \r\n    // Enhanced boundary styling\r\n    const lineWidth = isSelected ? 4 : isHovered ? 3 : 2;\r\n    const shadowBlur = isSelected ? 6 : isHovered ? 4 : 0;\r\n    \r\n    // Set shadow for glow effect\r\n    if (shadowBlur > 0) {\r\n      ctx.shadowColor = this.hexToRgba(color, 0.6);\r\n      ctx.shadowBlur = shadowBlur;\r\n    }\r\n    \r\n    ctx.strokeStyle = this.hexToRgba(color, borderAlpha);\r\n    ctx.lineWidth = lineWidth;\r\n    ctx.beginPath();\r\n    \r\n    // Start boundary with indicator\r\n    if (startPixel >= 0 && startPixel <= width) {\r\n      ctx.moveTo(startPixel, 0);\r\n      ctx.lineTo(startPixel, height);\r\n      \r\n      // Start indicator triangle\r\n      this.renderBoundaryIndicator(ctx, startPixel, 15, 'start', color, isSelected);\r\n    }\r\n    \r\n    // End boundary with indicator\r\n    if (endPixel >= 0 && endPixel <= width) {\r\n      ctx.moveTo(endPixel, 0);\r\n      ctx.lineTo(endPixel, height);\r\n      \r\n      // End indicator triangle\r\n      this.renderBoundaryIndicator(ctx, endPixel, 15, 'end', color, isSelected);\r\n    }\r\n    \r\n    ctx.stroke();\r\n    \r\n    // Reset shadow\r\n    ctx.shadowColor = 'transparent';\r\n    ctx.shadowBlur = 0;\r\n    \r\n    // Add active chop animation\r\n    if (isActive) {\r\n      this.renderActiveChopAnimation(ctx, startPixel, endPixel, width, height, color);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render boundary indicators (triangular markers)\r\n   */\r\n  renderBoundaryIndicator(ctx, x, y, type, color, isSelected) {\r\n    const size = isSelected ? 8 : 6;\r\n    const direction = type === 'start' ? 1 : -1;\r\n    \r\n    ctx.fillStyle = this.hexToRgba(color, 0.9);\r\n    ctx.beginPath();\r\n    ctx.moveTo(x, y);\r\n    ctx.lineTo(x + (direction * size), y - size);\r\n    ctx.lineTo(x + (direction * size), y + size);\r\n    ctx.closePath();\r\n    ctx.fill();\r\n    \r\n    // Add white outline for better visibility\r\n    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';\r\n    ctx.lineWidth = 1;\r\n    ctx.stroke();\r\n  }\r\n\r\n  /**\r\n   * Render active chop animation (pulsing border)\r\n   */\r\n  renderActiveChopAnimation(ctx, startPixel, endPixel, width, height, color) {\r\n    const pulseAlpha = 0.3 + 0.2 * Math.sin(Date.now() / 200);\r\n    \r\n    ctx.strokeStyle = this.hexToRgba(color, pulseAlpha);\r\n    ctx.lineWidth = 6;\r\n    ctx.setLineDash([8, 4]);\r\n    ctx.lineDashOffset = (Date.now() / 50) % 12;\r\n    \r\n    ctx.beginPath();\r\n    if (startPixel >= 0 && startPixel <= width) {\r\n      ctx.moveTo(startPixel, 0);\r\n      ctx.lineTo(startPixel, height);\r\n    }\r\n    if (endPixel >= 0 && endPixel <= width) {\r\n      ctx.moveTo(endPixel, 0);\r\n      ctx.lineTo(endPixel, height);\r\n    }\r\n    ctx.stroke();\r\n    \r\n    // Reset line dash\r\n    ctx.setLineDash([]);\r\n    ctx.lineDashOffset = 0;\r\n  }\r\n\r\n  /**\r\n   * Render visual relationship indicators for overlapping or adjacent chops\r\n   */\r\n  renderChopRelationships(ctx, chop, startPixel, endPixel, width, height, options) {\r\n    const allChops = options.allChops || [];\r\n    const relationships = this.analyzeChopRelationships(chop, allChops);\r\n    \r\n    relationships.forEach(relationship => {\r\n      this.renderRelationshipIndicator(ctx, relationship, startPixel, endPixel, width, height);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Analyze relationships between chops\r\n   */\r\n  analyzeChopRelationships(currentChop, allChops) {\r\n    const relationships = [];\r\n    const tolerance = 0.05; // 50ms tolerance for adjacency\r\n    \r\n    allChops.forEach(otherChop => {\r\n      if (otherChop.id === currentChop.id) return;\r\n      \r\n      // Check for overlap\r\n      if (!(currentChop.endTime <= otherChop.startTime || currentChop.startTime >= otherChop.endTime)) {\r\n        relationships.push({\r\n          type: 'overlap',\r\n          chop: otherChop,\r\n          severity: this.calculateOverlapSeverity(currentChop, otherChop)\r\n        });\r\n      }\r\n      // Check for adjacency\r\n      else if (Math.abs(currentChop.endTime - otherChop.startTime) <= tolerance) {\r\n        relationships.push({\r\n          type: 'adjacent-after',\r\n          chop: otherChop,\r\n          gap: otherChop.startTime - currentChop.endTime\r\n        });\r\n      }\r\n      else if (Math.abs(otherChop.endTime - currentChop.startTime) <= tolerance) {\r\n        relationships.push({\r\n          type: 'adjacent-before',\r\n          chop: otherChop,\r\n          gap: currentChop.startTime - otherChop.endTime\r\n        });\r\n      }\r\n    });\r\n    \r\n    return relationships;\r\n  }\r\n\r\n  /**\r\n   * Calculate overlap severity (0-1)\r\n   */\r\n  calculateOverlapSeverity(chop1, chop2) {\r\n    const overlapStart = Math.max(chop1.startTime, chop2.startTime);\r\n    const overlapEnd = Math.min(chop1.endTime, chop2.endTime);\r\n    const overlapDuration = overlapEnd - overlapStart;\r\n    \r\n    const chop1Duration = chop1.endTime - chop1.startTime;\r\n    const chop2Duration = chop2.endTime - chop2.startTime;\r\n    const minDuration = Math.min(chop1Duration, chop2Duration);\r\n    \r\n    return overlapDuration / minDuration;\r\n  }\r\n\r\n  /**\r\n   * Render relationship indicator\r\n   */\r\n  renderRelationshipIndicator(ctx, relationship, startPixel, endPixel, width, height) {\r\n    const otherStartPixel = this.viewportManager.timeToPixel(relationship.chop.startTime);\r\n    const otherEndPixel = this.viewportManager.timeToPixel(relationship.chop.endTime);\r\n    \r\n    switch (relationship.type) {\r\n      case 'overlap':\r\n        this.renderOverlapIndicator(ctx, startPixel, endPixel, otherStartPixel, otherEndPixel, height, relationship.severity);\r\n        break;\r\n      case 'adjacent-after':\r\n      case 'adjacent-before':\r\n        this.renderAdjacencyIndicator(ctx, startPixel, endPixel, otherStartPixel, otherEndPixel, height, relationship.type);\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render overlap indicator\r\n   */\r\n  renderOverlapIndicator(ctx, start1, end1, start2, end2, height, severity) {\r\n    const overlapStart = Math.max(start1, start2);\r\n    const overlapEnd = Math.min(end1, end2);\r\n    \r\n    if (overlapEnd <= overlapStart) return;\r\n    \r\n    // Draw overlap warning pattern\r\n    const warningColor = severity > 0.5 ? 'rgba(239, 68, 68, 0.6)' : 'rgba(245, 158, 11, 0.6)';\r\n    \r\n    ctx.fillStyle = warningColor;\r\n    ctx.fillRect(overlapStart, height - 8, overlapEnd - overlapStart, 8);\r\n    \r\n    // Draw warning stripes\r\n    ctx.strokeStyle = severity > 0.5 ? 'rgba(239, 68, 68, 0.8)' : 'rgba(245, 158, 11, 0.8)';\r\n    ctx.lineWidth = 1;\r\n    ctx.setLineDash([3, 3]);\r\n    \r\n    for (let x = overlapStart; x < overlapEnd; x += 6) {\r\n      ctx.beginPath();\r\n      ctx.moveTo(x, height - 8);\r\n      ctx.lineTo(x, height);\r\n      ctx.stroke();\r\n    }\r\n    \r\n    ctx.setLineDash([]);\r\n  }\r\n\r\n  /**\r\n   * Render adjacency indicator\r\n   */\r\n  renderAdjacencyIndicator(ctx, start1, end1, start2, end2, height, type) {\r\n    const connectionPoint = type === 'adjacent-after' ? end1 : start1;\r\n    const otherPoint = type === 'adjacent-after' ? start2 : end2;\r\n    \r\n    // Draw connection line\r\n    ctx.strokeStyle = 'rgba(34, 197, 94, 0.6)';\r\n    ctx.lineWidth = 2;\r\n    ctx.setLineDash([4, 2]);\r\n    \r\n    ctx.beginPath();\r\n    ctx.moveTo(connectionPoint, height - 20);\r\n    ctx.lineTo(otherPoint, height - 20);\r\n    ctx.stroke();\r\n    \r\n    // Draw connection dots\r\n    ctx.fillStyle = 'rgba(34, 197, 94, 0.8)';\r\n    ctx.beginPath();\r\n    ctx.arc(connectionPoint, height - 20, 3, 0, Math.PI * 2);\r\n    ctx.fill();\r\n    \r\n    ctx.beginPath();\r\n    ctx.arc(otherPoint, height - 20, 3, 0, Math.PI * 2);\r\n    ctx.fill();\r\n    \r\n    ctx.setLineDash([]);\r\n  }\r\n\r\n  /**\r\n   * Render enhanced chop label with better visibility\r\n   */\r\n  renderChopLabel(ctx, chop, startX, width, height, options) {\r\n    const { color, isSelected, isHovered, isActive } = options;\r\n    \r\n    if (width < 30) return; // Too narrow for label\r\n    \r\n    const centerX = startX + width / 2;\r\n    const centerY = height / 2;\r\n    \r\n    // Prepare label text\r\n    const labelText = chop.padId || chop.name || chop.id.slice(0, 3);\r\n    const fontSize = isSelected ? 14 : 12;\r\n    const fontWeight = isSelected ? 'bold' : 'normal';\r\n    \r\n    ctx.font = `${fontWeight} ${fontSize}px monospace`;\r\n    ctx.textAlign = 'center';\r\n    ctx.textBaseline = 'middle';\r\n    \r\n    // Measure text for background\r\n    const textMetrics = ctx.measureText(labelText);\r\n    const textWidth = textMetrics.width;\r\n    const textHeight = fontSize;\r\n    \r\n    const padding = 4;\r\n    const bgWidth = textWidth + padding * 2;\r\n    const bgHeight = textHeight + padding * 2;\r\n    \r\n    // Draw label background for better readability\r\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\r\n    ctx.fillRect(centerX - bgWidth / 2, centerY - bgHeight / 2, bgWidth, bgHeight);\r\n    \r\n    // Draw label border\r\n    ctx.strokeStyle = this.hexToRgba(color, 0.8);\r\n    ctx.lineWidth = 1;\r\n    ctx.strokeRect(centerX - bgWidth / 2, centerY - bgHeight / 2, bgWidth, bgHeight);\r\n    \r\n    // Draw label text\r\n    ctx.fillStyle = isActive ? '#ffffff' : this.hexToRgba(color, 1.0);\r\n    ctx.fillText(labelText, centerX, centerY);\r\n    \r\n    // Add active indicator\r\n    if (isActive) {\r\n      ctx.fillStyle = 'rgba(34, 197, 94, 0.8)';\r\n      ctx.beginPath();\r\n      ctx.arc(centerX + textWidth / 2 + 8, centerY, 3, 0, Math.PI * 2);\r\n      ctx.fill();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render duration indicator for longer chops\r\n   */\r\n  renderDurationIndicator(ctx, chop, startX, width, height, color) {\r\n    const duration = chop.endTime - chop.startTime;\r\n    const durationText = duration < 1 ? `${(duration * 1000).toFixed(0)}ms` : `${duration.toFixed(2)}s`;\r\n    \r\n    ctx.font = '10px monospace';\r\n    ctx.textAlign = 'center';\r\n    ctx.fillStyle = this.hexToRgba(color, 0.8);\r\n    \r\n    const centerX = startX + width / 2;\r\n    ctx.fillText(durationText, centerX, height - 10);\r\n  }\r\n\r\n  /**\r\n   * Convert hex color to rgba with alpha\r\n   */\r\n  hexToRgba(hex, alpha) {\r\n    // Handle HSL colors\r\n    if (hex.startsWith('hsl')) {\r\n      return hex.replace('hsl', 'hsla').replace(')', `, ${alpha})`);\r\n    }\r\n    \r\n    // Handle hex colors\r\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n    if (result) {\r\n      const r = parseInt(result[1], 16);\r\n      const g = parseInt(result[2], 16);\r\n      const b = parseInt(result[3], 16);\r\n      return `rgba(${r}, ${g}, ${b}, ${alpha})`;\r\n    }\r\n    \r\n    // Fallback for other formats\r\n    return hex;\r\n  }\r\n\r\n  /**\r\n   * Generate consistent color for chop based on ID\r\n   */\r\n  generateChopColor(chopId) {\r\n    // Use cached color if available\r\n    if (this.drawingCache.has(`color_${chopId}`)) {\r\n      return this.drawingCache.get(`color_${chopId}`);\r\n    }\r\n    \r\n    // Generate color based on hash of ID\r\n    let hash = 0;\r\n    for (let i = 0; i < chopId.length; i++) {\r\n      hash = ((hash << 5) - hash + chopId.charCodeAt(i)) & 0xffffffff;\r\n    }\r\n    \r\n    const hue = Math.abs(hash) % 360;\r\n    const color = `hsl(${hue}, 70%, 50%)`;\r\n    \r\n    // Cache the color\r\n    this.drawingCache.set(`color_${chopId}`, color);\r\n    \r\n    return color;\r\n  }\r\n\r\n  /**\r\n   * Render playhead with smooth animation\r\n   */\r\n  renderPlayhead(currentTime, isPlaying = false, options = {}) {\r\n    const layer = this.layerManager.getLayer('playhead');\r\n    if (!layer) return;\r\n\r\n    const viewport = this.viewportManager.getViewportBounds();\r\n    const { ctx } = layer;\r\n    const { width, height } = this.layerManager.getDimensions();\r\n\r\n    // Clear layer\r\n    this.layerManager.clearLayer('playhead');\r\n\r\n    // Check if playhead is visible\r\n    if (!this.viewportManager.isTimeVisible(currentTime)) {\r\n      this.layerManager.markLayerClean('playhead');\r\n      return;\r\n    }\r\n\r\n    const playheadPixel = this.viewportManager.timeToPixel(currentTime);\r\n    \r\n    // Playhead line\r\n    ctx.strokeStyle = options.color || '#ef4444';\r\n    ctx.lineWidth = options.width || 2;\r\n    ctx.beginPath();\r\n    ctx.moveTo(playheadPixel, 0);\r\n    ctx.lineTo(playheadPixel, height);\r\n    ctx.stroke();\r\n    \r\n    // Playhead indicator at top\r\n    ctx.fillStyle = options.color || '#ef4444';\r\n    const indicatorSize = options.indicatorSize || 6;\r\n    ctx.beginPath();\r\n    ctx.moveTo(playheadPixel - indicatorSize, 0);\r\n    ctx.lineTo(playheadPixel + indicatorSize, 0);\r\n    ctx.lineTo(playheadPixel, indicatorSize * 2);\r\n    ctx.closePath();\r\n    ctx.fill();\r\n    \r\n    // Time display for high zoom levels\r\n    if (viewport.pixelsPerSecond > 200 && options.showTime !== false) {\r\n      ctx.fillStyle = '#ffffff';\r\n      ctx.font = '10px monospace';\r\n      ctx.textAlign = 'center';\r\n      ctx.strokeStyle = '#000000';\r\n      ctx.lineWidth = 3;\r\n      const timeText = `${currentTime.toFixed(2)}s`;\r\n      ctx.strokeText(timeText, playheadPixel, height - 10);\r\n      ctx.fillText(timeText, playheadPixel, height - 10);\r\n    }\r\n\r\n    this.layerManager.markLayerClean('playhead');\r\n  }\r\n\r\n  /**\r\n   * Render UI elements (time scale, labels, etc.)\r\n   */\r\n  renderUI(options = {}) {\r\n    const layer = this.layerManager.getLayer('ui');\r\n    if (!layer) return;\r\n\r\n    const viewport = this.viewportManager.getViewportBounds();\r\n    const { ctx } = layer;\r\n    const { width, height } = this.layerManager.getDimensions();\r\n\r\n    // Clear layer\r\n    this.layerManager.clearLayer('ui');\r\n\r\n    // Render time scale\r\n    this.renderTimeScale(ctx, viewport, width, height, options);\r\n    \r\n    // Render zoom indicator\r\n    if (options.showZoomIndicator !== false) {\r\n      this.renderZoomIndicator(ctx, width, height, options);\r\n    }\r\n\r\n    this.layerManager.markLayerClean('ui');\r\n  }\r\n\r\n  /**\r\n   * Render time scale at bottom of waveform\r\n   */\r\n  renderTimeScale(ctx, viewport, width, height, options) {\r\n    ctx.fillStyle = options.textColor || 'rgba(255, 255, 255, 0.7)';\r\n    ctx.font = options.font || '10px monospace';\r\n    ctx.textAlign = 'center';\r\n    \r\n    // Calculate appropriate time step\r\n    const visibleDuration = viewport.end - viewport.start;\r\n    let timeStep;\r\n    \r\n    if (visibleDuration > 300) timeStep = 60;      // 1 minute\r\n    else if (visibleDuration > 60) timeStep = 10;  // 10 seconds\r\n    else if (visibleDuration > 10) timeStep = 1;   // 1 second\r\n    else if (visibleDuration > 1) timeStep = 0.1;  // 100ms\r\n    else timeStep = 0.01;                          // 10ms\r\n    \r\n    // Draw time markers\r\n    for (let time = Math.ceil(viewport.start / timeStep) * timeStep; \r\n         time <= viewport.end; \r\n         time += timeStep) {\r\n      const pixel = this.viewportManager.timeToPixel(time);\r\n      \r\n      if (pixel >= 0 && pixel <= width) {\r\n        // Draw tick mark\r\n        ctx.strokeStyle = options.tickColor || 'rgba(255, 255, 255, 0.3)';\r\n        ctx.lineWidth = 1;\r\n        ctx.beginPath();\r\n        ctx.moveTo(pixel, height - 10);\r\n        ctx.lineTo(pixel, height);\r\n        ctx.stroke();\r\n        \r\n        // Draw time label\r\n        const timeText = timeStep >= 1 ? `${time.toFixed(0)}s` : `${time.toFixed(2)}s`;\r\n        ctx.fillText(timeText, pixel, height - 15);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render zoom level indicator\r\n   */\r\n  renderZoomIndicator(ctx, width, height, options) {\r\n    const zoomLevel = this.viewportManager.getState().zoomLevel;\r\n    \r\n    ctx.fillStyle = options.zoomIndicatorColor || 'rgba(255, 255, 255, 0.8)';\r\n    ctx.font = options.zoomIndicatorFont || 'bold 12px monospace';\r\n    ctx.textAlign = 'right';\r\n    \r\n    const zoomText = `${zoomLevel.toFixed(1)}x`;\r\n    ctx.fillText(zoomText, width - 10, 20);\r\n  }\r\n\r\n  /**\r\n   * Schedule a render using requestAnimationFrame\r\n   */\r\n  scheduleRender() {\r\n    if (this.animationFrameId) return;\r\n    \r\n    this.animationFrameId = requestAnimationFrame(() => {\r\n      this.performRender();\r\n      this.animationFrameId = null;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Perform the actual rendering\r\n   */\r\n  performRender() {\r\n    if (this.isRendering) return;\r\n    \r\n    this.isRendering = true;\r\n    const startTime = performance.now();\r\n    \r\n    try {\r\n      // Process render queue\r\n      while (this.renderQueue.length > 0) {\r\n        const renderTask = this.renderQueue.shift();\r\n        renderTask();\r\n      }\r\n      \r\n      // Update FPS metrics\r\n      this.updateFPSMetrics(startTime);\r\n      \r\n    } finally {\r\n      this.isRendering = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a render task to the queue\r\n   */\r\n  queueRender(renderTask) {\r\n    this.renderQueue.push(renderTask);\r\n    this.scheduleRender();\r\n  }\r\n\r\n  /**\r\n   * Update performance metrics\r\n   */\r\n  updatePerformanceMetrics(operation, startTime, elementCount) {\r\n    const endTime = performance.now();\r\n    this.performanceMetrics.renderTime = endTime - startTime;\r\n    \r\n    // Track specific operation metrics\r\n    if (!this.performanceMetrics[operation]) {\r\n      this.performanceMetrics[operation] = {\r\n        totalTime: 0,\r\n        callCount: 0,\r\n        averageTime: 0\r\n      };\r\n    }\r\n    \r\n    const opMetrics = this.performanceMetrics[operation];\r\n    opMetrics.totalTime += this.performanceMetrics.renderTime;\r\n    opMetrics.callCount++;\r\n    opMetrics.averageTime = opMetrics.totalTime / opMetrics.callCount;\r\n  }\r\n\r\n  /**\r\n   * Update FPS metrics\r\n   */\r\n  updateFPSMetrics(startTime) {\r\n    const now = performance.now();\r\n    const frameTime = now - this.performanceMetrics.lastFrameTime;\r\n    \r\n    if (frameTime > 0 && this.performanceMetrics.lastFrameTime > 0) {\r\n      const fps = 1000 / frameTime;\r\n      this.performanceMetrics.frameCount++;\r\n      \r\n      // Calculate rolling average FPS\r\n      const alpha = 0.1; // Smoothing factor\r\n      if (this.performanceMetrics.averageFPS === 0) {\r\n        this.performanceMetrics.averageFPS = fps;\r\n      } else {\r\n        this.performanceMetrics.averageFPS = \r\n          this.performanceMetrics.averageFPS * (1 - alpha) + fps * alpha;\r\n      }\r\n    }\r\n    \r\n    this.performanceMetrics.lastFrameTime = now;\r\n  }\r\n\r\n  /**\r\n   * Get current performance metrics\r\n   */\r\n  getPerformanceMetrics() {\r\n    return { ...this.performanceMetrics };\r\n  }\r\n\r\n  /**\r\n   * Reset performance metrics\r\n   */\r\n  resetPerformanceMetrics() {\r\n    this.performanceMetrics = {\r\n      frameCount: 0,\r\n      lastFrameTime: performance.now(),\r\n      averageFPS: 0,\r\n      renderTime: 0,\r\n      culledElements: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Set rendering quality\r\n   */\r\n  setRenderQuality(quality) {\r\n    this.options.renderQuality = quality;\r\n    this.layerManager.markAllLayersDirty();\r\n    this.scheduleRender();\r\n  }\r\n\r\n  /**\r\n   * Enable or disable viewport culling\r\n   */\r\n  setViewportCulling(enabled) {\r\n    this.options.enableViewportCulling = enabled;\r\n    this.layerManager.markAllLayersDirty();\r\n    this.scheduleRender();\r\n  }\r\n\r\n  /**\r\n   * Resize renderer\r\n   */\r\n  resize(width, height) {\r\n    this.layerManager.updateDimensions();\r\n    this.viewportManager.setCanvasDimensions(width, height);\r\n    this.scheduleRender();\r\n  }\r\n\r\n  /**\r\n   * Get layer manager instance\r\n   */\r\n  getLayerManager() {\r\n    return this.layerManager;\r\n  }\r\n\r\n  /**\r\n   * Get viewport manager instance\r\n   */\r\n  getViewportManager() {\r\n    return this.viewportManager;\r\n  }\r\n\r\n  /**\r\n   * Destroy renderer and cleanup resources\r\n   */\r\n  destroy() {\r\n    if (this.animationFrameId) {\r\n      cancelAnimationFrame(this.animationFrameId);\r\n      this.animationFrameId = null;\r\n    }\r\n    \r\n    this.renderQueue = [];\r\n    this.drawingCache.clear();\r\n    this.pathCache.clear();\r\n    \r\n    this.layerManager.destroy();\r\n    this.isRendering = false;\r\n  }\r\n}\r\n\r\nexport default CanvasRenderer;","/**\r\n * PlayheadManager - Handles real-time playback synchronization and smooth animation\r\n * Implements requirements: 5.1, 5.2, 5.3 - moving playhead, smooth animation, chop highlighting\r\n */\r\n\r\nexport class PlayheadManager {\r\n  constructor(canvasRenderer, options = {}) {\r\n    this.renderer = canvasRenderer;\r\n    this.options = {\r\n      smoothingFactor: 0.15, // Lower = smoother, higher = more responsive\r\n      maxInterpolationTime: 100, // Max time to interpolate in ms\r\n      playheadColor: '#ef4444',\r\n      playheadWidth: 2,\r\n      activeChopColor: '#fbbf24',\r\n      activeChopOpacity: 0.3,\r\n      showTimeDisplay: true,\r\n      animationQuality: 'high', // 'low', 'medium', 'high'\r\n      ...options\r\n    };\r\n\r\n    // Playhead state\r\n    this.currentTime = 0;\r\n    this.targetTime = 0;\r\n    this.isPlaying = false;\r\n    this.lastUpdateTime = 0;\r\n    this.interpolatedTime = 0;\r\n    \r\n    // Animation state\r\n    this.animationFrameId = null;\r\n    this.isAnimating = false;\r\n    \r\n    // Chop tracking\r\n    this.activeChops = new Set();\r\n    this.allChops = [];\r\n    this.chopHighlights = new Map(); // chopId -> highlight state\r\n    \r\n    // Performance tracking\r\n    this.frameCount = 0;\r\n    this.lastFPSCheck = 0;\r\n    this.currentFPS = 0;\r\n    \r\n    // Sync tracking\r\n    this.syncHistory = [];\r\n    this.maxSyncHistory = 10;\r\n    this.syncAccuracy = 0;\r\n    \r\n    this.initialize();\r\n  }\r\n\r\n  /**\r\n   * Initialize the playhead manager\r\n   */\r\n  initialize() {\r\n    // Start animation loop if playing\r\n    if (this.isPlaying) {\r\n      this.startAnimation();\r\n    }\r\n    \r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Update playback state from external source (YouTube player)\r\n   * @param {number} currentTime - Current playback time in seconds\r\n   * @param {boolean} isPlaying - Whether playback is active\r\n   */\r\n  updatePlaybackState(currentTime, isPlaying) {\r\n    // Validate input\r\n    if (typeof currentTime !== 'number' || isNaN(currentTime)) {\r\n      currentTime = 0;\r\n    }\r\n    \r\n    const now = performance.now();\r\n    const timeDelta = now - this.lastUpdateTime;\r\n    \r\n    // Track sync accuracy\r\n    this.trackSyncAccuracy(currentTime, timeDelta);\r\n    \r\n    // Update target time\r\n    this.targetTime = currentTime;\r\n    this.lastUpdateTime = now;\r\n    \r\n    // Always update current time immediately\r\n    this.currentTime = currentTime;\r\n    \r\n    // Handle play/pause state changes\r\n    if (isPlaying !== this.isPlaying) {\r\n      this.isPlaying = isPlaying;\r\n      \r\n      if (isPlaying) {\r\n        // Initialize interpolated time when starting playback\r\n        this.interpolatedTime = currentTime;\r\n        try {\r\n          this.startAnimation();\r\n        } catch (error) {\r\n          console.warn('Failed to start animation:', error);\r\n        }\r\n      } else {\r\n        this.stopAnimation();\r\n        // Immediately update to target time when paused\r\n        this.interpolatedTime = currentTime;\r\n      }\r\n    } else if (!isPlaying) {\r\n      // Update interpolated time even when not playing\r\n      this.interpolatedTime = currentTime;\r\n    }\r\n    \r\n    // Update active chops\r\n    this.updateActiveChops();\r\n    \r\n    // Trigger render if not animating\r\n    if (!this.isAnimating) {\r\n      this.render();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Track synchronization accuracy for performance monitoring\r\n   */\r\n  trackSyncAccuracy(newTime, timeDelta) {\r\n    if (this.syncHistory.length > 0) {\r\n      const lastSync = this.syncHistory[this.syncHistory.length - 1];\r\n      const expectedTime = lastSync.time + (timeDelta / 1000);\r\n      const actualTime = newTime;\r\n      const drift = Math.abs(actualTime - expectedTime);\r\n      \r\n      this.syncHistory.push({\r\n        time: newTime,\r\n        timestamp: performance.now(),\r\n        drift: drift,\r\n        timeDelta: timeDelta\r\n      });\r\n    } else {\r\n      this.syncHistory.push({\r\n        time: newTime,\r\n        timestamp: performance.now(),\r\n        drift: 0,\r\n        timeDelta: 0\r\n      });\r\n    }\r\n    \r\n    // Keep history size manageable\r\n    if (this.syncHistory.length > this.maxSyncHistory) {\r\n      this.syncHistory.shift();\r\n    }\r\n    \r\n    // Calculate average sync accuracy\r\n    if (this.syncHistory.length > 1) {\r\n      const totalDrift = this.syncHistory.reduce((sum, sync) => sum + sync.drift, 0);\r\n      this.syncAccuracy = totalDrift / this.syncHistory.length;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start smooth animation loop\r\n   */\r\n  startAnimation() {\r\n    if (this.isAnimating) return;\r\n    \r\n    this.isAnimating = true;\r\n    this.interpolatedTime = this.currentTime;\r\n    \r\n    const animate = (timestamp) => {\r\n      if (!this.isAnimating) return;\r\n      \r\n      try {\r\n        this.updateInterpolation(timestamp);\r\n        this.render();\r\n        this.updatePerformanceMetrics(timestamp);\r\n        \r\n        this.animationFrameId = requestAnimationFrame(animate);\r\n      } catch (error) {\r\n        console.warn('PlayheadManager animation error:', error);\r\n        // Continue animation despite errors\r\n        try {\r\n          this.animationFrameId = requestAnimationFrame(animate);\r\n        } catch (rafError) {\r\n          console.error('RequestAnimationFrame failed completely:', rafError);\r\n          this.isAnimating = false;\r\n        }\r\n      }\r\n    };\r\n    \r\n    try {\r\n      this.animationFrameId = requestAnimationFrame(animate);\r\n    } catch (error) {\r\n      console.warn('Initial RequestAnimationFrame failed:', error);\r\n      this.isAnimating = false;\r\n      throw error; // Re-throw for test detection\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stop animation loop\r\n   */\r\n  stopAnimation() {\r\n    this.isAnimating = false;\r\n    \r\n    if (this.animationFrameId) {\r\n      cancelAnimationFrame(this.animationFrameId);\r\n      this.animationFrameId = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update interpolated time for smooth animation\r\n   */\r\n  updateInterpolation(timestamp) {\r\n    if (!this.isPlaying) return;\r\n    \r\n    const now = performance.now();\r\n    const timeSinceLastUpdate = now - this.lastUpdateTime;\r\n    \r\n    // If too much time has passed, jump to target\r\n    if (timeSinceLastUpdate > this.options.maxInterpolationTime) {\r\n      this.interpolatedTime = this.targetTime;\r\n      this.currentTime = this.targetTime;\r\n      this.lastUpdateTime = now;\r\n      this.updateActiveChops();\r\n      return;\r\n    }\r\n    \r\n    // Calculate expected time based on playback\r\n    const expectedTime = this.targetTime + (timeSinceLastUpdate / 1000);\r\n    \r\n    // Smooth interpolation towards expected time\r\n    const smoothingFactor = this.options.smoothingFactor;\r\n    \r\n    if (this.interpolatedTime === 0) {\r\n      // Initialize interpolated time\r\n      this.interpolatedTime = this.targetTime;\r\n    } else {\r\n      // Smooth interpolation\r\n      this.interpolatedTime += (expectedTime - this.interpolatedTime) * smoothingFactor;\r\n    }\r\n    \r\n    this.currentTime = this.interpolatedTime;\r\n    \r\n    // Update active chops based on interpolated time\r\n    this.updateActiveChops();\r\n  }\r\n\r\n  /**\r\n   * Update which chops are currently active during playback\r\n   */\r\n  updateActiveChops() {\r\n    const currentTime = this.interpolatedTime || this.currentTime;\r\n    const newActiveChops = new Set();\r\n    \r\n    // Find chops that contain the current time\r\n    this.allChops.forEach(chop => {\r\n      if (currentTime >= chop.startTime && currentTime <= chop.endTime) {\r\n        const chopId = chop.id || chop.padId;\r\n        newActiveChops.add(chopId);\r\n        \r\n        // Update highlight state\r\n        if (!this.activeChops.has(chopId)) {\r\n          this.chopHighlights.set(chopId, {\r\n            startTime: performance.now(),\r\n            intensity: 1.0,\r\n            chop: chop,\r\n            fadeOut: false\r\n          });\r\n        }\r\n      }\r\n    });\r\n    \r\n    // Remove chops that are no longer active\r\n    this.activeChops.forEach(chopId => {\r\n      if (!newActiveChops.has(chopId)) {\r\n        // Start fade out animation\r\n        const highlight = this.chopHighlights.get(chopId);\r\n        if (highlight) {\r\n          highlight.fadeOut = true;\r\n          highlight.fadeStartTime = performance.now();\r\n        }\r\n      }\r\n    });\r\n    \r\n    this.activeChops = newActiveChops;\r\n    \r\n    // Clean up old highlights\r\n    this.cleanupHighlights();\r\n  }\r\n\r\n  /**\r\n   * Clean up expired highlight animations\r\n   */\r\n  cleanupHighlights() {\r\n    const now = performance.now();\r\n    const fadeOutDuration = 300; // ms\r\n    \r\n    for (const [chopId, highlight] of this.chopHighlights.entries()) {\r\n      if (highlight.fadeOut) {\r\n        const fadeProgress = (now - highlight.fadeStartTime) / fadeOutDuration;\r\n        \r\n        if (fadeProgress >= 1.0) {\r\n          this.chopHighlights.delete(chopId);\r\n        } else {\r\n          highlight.intensity = 1.0 - fadeProgress;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the list of chops for active tracking\r\n   */\r\n  setChops(chops) {\r\n    this.allChops = chops || [];\r\n    this.updateActiveChops();\r\n  }\r\n\r\n  /**\r\n   * Render playhead and active chop highlights\r\n   */\r\n  render() {\r\n    if (!this.renderer) return;\r\n    \r\n    const viewport = this.renderer.getViewportManager();\r\n    if (!viewport) return;\r\n    \r\n    // Check if playhead is visible\r\n    if (!viewport.isTimeVisible(this.currentTime)) {\r\n      // Clear playhead layer if not visible\r\n      this.renderer.getLayerManager().clearLayer('playhead');\r\n      return;\r\n    }\r\n    \r\n    // Render active chop highlights first (behind playhead)\r\n    this.renderActiveChopHighlights();\r\n    \r\n    // Render playhead\r\n    this.renderPlayhead();\r\n  }\r\n\r\n  /**\r\n   * Render highlights for active chops\r\n   */\r\n  renderActiveChopHighlights() {\r\n    const layer = this.renderer.getLayerManager().getLayer('chops');\r\n    if (!layer) return;\r\n    \r\n    const { ctx } = layer;\r\n    const { width, height } = this.renderer.getLayerManager().getDimensions();\r\n    const viewport = this.renderer.getViewportManager();\r\n    \r\n    // Render each active chop highlight\r\n    this.chopHighlights.forEach((highlight, chopId) => {\r\n      const chop = highlight.chop;\r\n      if (!chop) return;\r\n      \r\n      // Check if chop is visible\r\n      if (!viewport.isRangeVisible(chop.startTime, chop.endTime)) return;\r\n      \r\n      const startPixel = viewport.timeToPixel(chop.startTime);\r\n      const endPixel = viewport.timeToPixel(chop.endTime);\r\n      const chopWidth = endPixel - startPixel;\r\n      \r\n      if (chopWidth <= 0) return;\r\n      \r\n      // Calculate highlight intensity with animation\r\n      let intensity = highlight.intensity;\r\n      if (!highlight.fadeOut && this.isPlaying) {\r\n        // Pulse effect during active playback\r\n        const pulseSpeed = 2; // Hz\r\n        const time = (performance.now() - highlight.startTime) / 1000;\r\n        const pulse = 0.7 + 0.3 * Math.sin(time * pulseSpeed * Math.PI * 2);\r\n        intensity *= pulse;\r\n      }\r\n      \r\n      // Render highlight overlay\r\n      ctx.save();\r\n      ctx.globalAlpha = this.options.activeChopOpacity * intensity;\r\n      ctx.fillStyle = this.options.activeChopColor;\r\n      ctx.fillRect(\r\n        Math.max(0, startPixel),\r\n        0,\r\n        Math.min(chopWidth, width - Math.max(0, startPixel)),\r\n        height\r\n      );\r\n      ctx.restore();\r\n      \r\n      // Render active chop border\r\n      ctx.save();\r\n      ctx.globalAlpha = intensity;\r\n      ctx.strokeStyle = this.options.activeChopColor;\r\n      ctx.lineWidth = 3;\r\n      ctx.setLineDash([5, 5]);\r\n      ctx.strokeRect(\r\n        Math.max(0, startPixel),\r\n        0,\r\n        Math.min(chopWidth, width - Math.max(0, startPixel)),\r\n        height\r\n      );\r\n      ctx.restore();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Render the playhead with smooth animation\r\n   */\r\n  renderPlayhead() {\r\n    const layer = this.renderer.getLayerManager().getLayer('playhead');\r\n    if (!layer) return;\r\n    \r\n    const { ctx } = layer;\r\n    const { width, height } = this.renderer.getLayerManager().getDimensions();\r\n    const viewport = this.renderer.getViewportManager();\r\n    \r\n    // Clear layer\r\n    this.renderer.getLayerManager().clearLayer('playhead');\r\n    \r\n    const playheadPixel = viewport.timeToPixel(this.currentTime);\r\n    \r\n    // Render playhead line with enhanced styling\r\n    ctx.save();\r\n    \r\n    // Main playhead line\r\n    ctx.strokeStyle = this.options.playheadColor;\r\n    ctx.lineWidth = this.options.playheadWidth;\r\n    ctx.lineCap = 'round';\r\n    \r\n    // Add glow effect for playing state\r\n    if (this.isPlaying) {\r\n      ctx.shadowColor = this.options.playheadColor;\r\n      ctx.shadowBlur = 8;\r\n      ctx.shadowOffsetX = 0;\r\n      ctx.shadowOffsetY = 0;\r\n    }\r\n    \r\n    ctx.beginPath();\r\n    ctx.moveTo(playheadPixel, 0);\r\n    ctx.lineTo(playheadPixel, height);\r\n    ctx.stroke();\r\n    \r\n    ctx.restore();\r\n    \r\n    // Render playhead indicator at top\r\n    this.renderPlayheadIndicator(ctx, playheadPixel, width, height);\r\n    \r\n    // Render time display if enabled\r\n    if (this.options.showTimeDisplay) {\r\n      this.renderTimeDisplay(ctx, playheadPixel, width, height);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render playhead indicator triangle\r\n   */\r\n  renderPlayheadIndicator(ctx, playheadPixel, width, height) {\r\n    const indicatorSize = 8;\r\n    \r\n    ctx.save();\r\n    ctx.fillStyle = this.options.playheadColor;\r\n    \r\n    // Add glow for playing state\r\n    if (this.isPlaying) {\r\n      ctx.shadowColor = this.options.playheadColor;\r\n      ctx.shadowBlur = 6;\r\n    }\r\n    \r\n    // Draw triangle indicator\r\n    ctx.beginPath();\r\n    ctx.moveTo(playheadPixel - indicatorSize, 0);\r\n    ctx.lineTo(playheadPixel + indicatorSize, 0);\r\n    ctx.lineTo(playheadPixel, indicatorSize * 1.5);\r\n    ctx.closePath();\r\n    ctx.fill();\r\n    \r\n    // Draw bottom indicator if there's space\r\n    if (height > 40) {\r\n      ctx.beginPath();\r\n      ctx.moveTo(playheadPixel - indicatorSize, height);\r\n      ctx.lineTo(playheadPixel + indicatorSize, height);\r\n      ctx.lineTo(playheadPixel, height - indicatorSize * 1.5);\r\n      ctx.closePath();\r\n      ctx.fill();\r\n    }\r\n    \r\n    ctx.restore();\r\n  }\r\n\r\n  /**\r\n   * Render time display near playhead\r\n   */\r\n  renderTimeDisplay(ctx, playheadPixel, width, height) {\r\n    const viewport = this.renderer.getViewportManager().getViewportBounds();\r\n    \r\n    // Only show time display at appropriate zoom levels\r\n    if (viewport.pixelsPerSecond < 50) return;\r\n    \r\n    const timeText = this.formatTime(this.currentTime);\r\n    \r\n    ctx.save();\r\n    ctx.font = 'bold 12px monospace';\r\n    ctx.textAlign = 'center';\r\n    ctx.textBaseline = 'middle';\r\n    \r\n    // Calculate position to avoid edges\r\n    let textX = playheadPixel;\r\n    const textY = height - 20;\r\n    \r\n    // Adjust position if near edges\r\n    const textWidth = ctx.measureText(timeText).width;\r\n    if (textX - textWidth / 2 < 5) {\r\n      textX = textWidth / 2 + 5;\r\n      ctx.textAlign = 'left';\r\n    } else if (textX + textWidth / 2 > width - 5) {\r\n      textX = width - 5;\r\n      ctx.textAlign = 'right';\r\n    }\r\n    \r\n    // Draw background\r\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\r\n    ctx.fillRect(textX - textWidth / 2 - 4, textY - 8, textWidth + 8, 16);\r\n    \r\n    // Draw text\r\n    ctx.fillStyle = '#ffffff';\r\n    ctx.fillText(timeText, textX, textY);\r\n    \r\n    ctx.restore();\r\n  }\r\n\r\n  /**\r\n   * Format time for display\r\n   */\r\n  formatTime(seconds) {\r\n    const minutes = Math.floor(seconds / 60);\r\n    const secs = seconds % 60;\r\n    \r\n    if (minutes > 0) {\r\n      return `${minutes}:${secs.toFixed(2).padStart(5, '0')}`;\r\n    } else {\r\n      return `${secs.toFixed(2)}s`;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update performance metrics\r\n   */\r\n  updatePerformanceMetrics(timestamp) {\r\n    this.frameCount++;\r\n    \r\n    // Initialize lastFPSCheck if not set\r\n    if (this.lastFPSCheck === 0) {\r\n      this.lastFPSCheck = timestamp;\r\n    }\r\n    \r\n    if (timestamp - this.lastFPSCheck >= 1000) {\r\n      this.currentFPS = this.frameCount;\r\n      this.frameCount = 0;\r\n      this.lastFPSCheck = timestamp;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current performance metrics\r\n   */\r\n  getPerformanceMetrics() {\r\n    return {\r\n      fps: this.currentFPS,\r\n      syncAccuracy: this.syncAccuracy,\r\n      activeChops: this.activeChops.size,\r\n      isAnimating: this.isAnimating,\r\n      interpolatedTime: this.interpolatedTime,\r\n      targetTime: this.targetTime\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get synchronization status\r\n   */\r\n  getSyncStatus() {\r\n    return {\r\n      isPlaying: this.isPlaying,\r\n      currentTime: this.currentTime,\r\n      targetTime: this.targetTime,\r\n      syncAccuracy: this.syncAccuracy,\r\n      activeChops: Array.from(this.activeChops),\r\n      isAnimating: this.isAnimating\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Set playhead options\r\n   */\r\n  setOptions(newOptions) {\r\n    this.options = { ...this.options, ...newOptions };\r\n  }\r\n\r\n  /**\r\n   * Jump to specific time (for seeking)\r\n   */\r\n  jumpToTime(time) {\r\n    this.currentTime = time;\r\n    this.targetTime = time;\r\n    this.interpolatedTime = time;\r\n    this.lastUpdateTime = performance.now();\r\n    \r\n    this.updateActiveChops();\r\n    this.render();\r\n  }\r\n\r\n  /**\r\n   * Destroy the playhead manager\r\n   */\r\n  destroy() {\r\n    this.stopAnimation();\r\n    this.activeChops.clear();\r\n    this.chopHighlights.clear();\r\n    this.allChops = [];\r\n    this.syncHistory = [];\r\n  }\r\n}\r\n\r\nexport default PlayheadManager;","import React, { useRef, useEffect, useState, useCallback, useMemo } from 'react';\r\nimport { motion } from 'framer-motion';\r\nimport { EnhancedCanvasRenderer } from './EnhancedCanvasRenderer.js';\r\nimport { InteractionManager } from './InteractionManager.js';\r\nimport { PlayheadManager } from './PlayheadManager.js';\r\nimport WaveformPerformanceOptimizer from '../../services/WaveformPerformanceOptimizer.js';\r\n\r\n/**\r\n * Core WaveformVisualization component with high-performance canvas rendering\r\n * Implements requirements: 1.1, 4.1, 4.4, 7.1, 7.2\r\n */\r\nexport default function WaveformVisualization({\r\n  audioSource,\r\n  waveformData,\r\n  chops = [],\r\n  currentTime = 0,\r\n  isPlaying = false,\r\n  onChopCreate,\r\n  onChopUpdate,\r\n  onTimeSeek,\r\n  visualSettings = {},\r\n  className = ''\r\n}) {\r\n  // Container reference for canvas renderer\r\n  const containerRef = useRef(null);\r\n  \r\n  // Canvas renderer instance\r\n  const rendererRef = useRef(null);\r\n  \r\n  // Interaction manager instance\r\n  const interactionManagerRef = useRef(null);\r\n  \r\n  // Playhead manager instance for real-time synchronization\r\n  const playheadManagerRef = useRef(null);\r\n  \r\n  // Performance optimizer instance\r\n  const performanceOptimizerRef = useRef(null);\r\n\r\n  // Component state\r\n  const [isInitialized, setIsInitialized] = useState(false);\r\n  const [selectedChopId, setSelectedChopId] = useState(null);\r\n  const [hoveredChopId, setHoveredChopId] = useState(null);\r\n  const [performanceMetrics, setPerformanceMetrics] = useState({});\r\n  const [currentQualityLevel, setCurrentQualityLevel] = useState('high');\r\n\r\n  // Animation frame reference for smooth updates (legacy - now handled by PlayheadManager)\r\n  const animationFrameRef = useRef(null);\r\n\r\n  /**\r\n   * Initialize performance optimizer\r\n   */\r\n  const initializePerformanceOptimizer = useCallback(async () => {\r\n    if (performanceOptimizerRef.current) return;\r\n    \r\n    try {\r\n      performanceOptimizerRef.current = new WaveformPerformanceOptimizer({\r\n        enableWebWorkers: visualSettings.enableWebWorkers !== false,\r\n        enableCaching: visualSettings.enableCaching !== false,\r\n        enableMemoryManagement: visualSettings.enableMemoryManagement !== false,\r\n        enablePerformanceMonitoring: visualSettings.enablePerformanceMonitoring !== false,\r\n        workerPoolSize: visualSettings.workerPoolSize || 2,\r\n        targetFPS: visualSettings.targetFPS || 60,\r\n        minFPS: visualSettings.minFPS || 30\r\n      });\r\n      \r\n      await performanceOptimizerRef.current.initialize();\r\n      \r\n      // Set up performance callbacks\r\n      if (performanceOptimizerRef.current.performanceMonitor) {\r\n        performanceOptimizerRef.current.performanceMonitor.onQualityChange((event) => {\r\n          setCurrentQualityLevel(event.newQuality);\r\n          console.log(`Waveform quality changed to: ${event.newQuality}`);\r\n        });\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Failed to initialize performance optimizer:', error);\r\n      return false;\r\n    }\r\n  }, [visualSettings]);\r\n\r\n  /**\r\n   * Initialize high-performance canvas renderer\r\n   */\r\n  const initializeRenderer = useCallback(() => {\r\n    const container = containerRef.current;\r\n    if (!container || rendererRef.current) return false;\r\n\r\n    try {\r\n      // Get adaptive settings from performance optimizer\r\n      const adaptiveSettings = performanceOptimizerRef.current?.getAdaptiveSettings() || {};\r\n      \r\n      // Create enhanced renderer with visual enhancements and optimized settings\r\n      rendererRef.current = new EnhancedCanvasRenderer(container, {\r\n        enableViewportCulling: adaptiveSettings.enableViewportCulling !== false,\r\n        enableBatching: adaptiveSettings.enableBatching !== false,\r\n        renderQuality: adaptiveSettings.renderQuality || visualSettings.quality || 'high',\r\n        enableAntialiasing: adaptiveSettings.enableAntialiasing !== false && visualSettings.antialiasing !== false,\r\n        maxBatchSize: adaptiveSettings.maxBatchSize || 1000,\r\n        // Visual enhancement options\r\n        enableFrequencyColorCoding: visualSettings.enableFrequencyColorCoding !== false,\r\n        enableAmplitudeColorCoding: visualSettings.enableAmplitudeColorCoding !== false,\r\n        enableStructureDetection: visualSettings.enableStructureDetection !== false,\r\n        enableAccessibilityMode: visualSettings.enableAccessibilityMode || false,\r\n        enableHighContrastMode: visualSettings.enableHighContrastMode || false,\r\n        colorScheme: visualSettings.colorScheme || 'default'\r\n      });\r\n\r\n      // Set audio duration if available\r\n      if (waveformData?.duration) {\r\n        const viewportManager = rendererRef.current.getViewportManager();\r\n        viewportManager.setAudioDuration(waveformData.duration);\r\n      }\r\n\r\n      // Initialize interaction manager\r\n      interactionManagerRef.current = new InteractionManager(rendererRef.current, {\r\n        clickThreshold: 5,\r\n        hoverDelay: 100,\r\n        snapTolerance: 10,\r\n        enableHover: true,\r\n        enableClick: true,\r\n        enableDrag: true\r\n      });\r\n\r\n      // Set interaction callbacks\r\n      interactionManagerRef.current.setCallbacks({\r\n        onChopCreate: onChopCreate,\r\n        onChopUpdate: onChopUpdate,\r\n        onTimeSeek: onTimeSeek,\r\n        onHover: (element, x, y) => {\r\n          // Update hover state for enhanced chop visualization\r\n          if (element && element.type === 'chop-region') {\r\n            setHoveredChopId(element.chopId);\r\n          } else {\r\n            setHoveredChopId(null);\r\n          }\r\n        }\r\n      });\r\n\r\n      // Initialize playhead manager for real-time synchronization\r\n      playheadManagerRef.current = new PlayheadManager(rendererRef.current, {\r\n        playheadColor: visualSettings.playheadColor || '#ef4444',\r\n        playheadWidth: visualSettings.playheadWidth || 2,\r\n        activeChopColor: visualSettings.activeChopColor || '#fbbf24',\r\n        showTimeDisplay: visualSettings.showPlayheadTime !== false,\r\n        animationQuality: visualSettings.animationQuality || 'high'\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Failed to initialize canvas renderer:', error);\r\n      return false;\r\n    }\r\n  }, [visualSettings, waveformData]);\r\n\r\n  /**\r\n   * Update viewport state for zoom and pan operations\r\n   * Implements requirement 4.1 - zoom controls\r\n   */\r\n  const updateViewport = useCallback((updates) => {\r\n    if (!rendererRef.current) return;\r\n    \r\n    const viewportManager = rendererRef.current.getViewportManager();\r\n    \r\n    if (updates.zoomLevel !== undefined) {\r\n      viewportManager.setZoom(updates.zoomLevel, updates.centerTime);\r\n    } else if (updates.centerTime !== undefined) {\r\n      viewportManager.panToTime(updates.centerTime);\r\n    }\r\n  }, []);\r\n\r\n  /**\r\n   * Convert time to pixel position within current viewport\r\n   */\r\n  const timeToPixel = useCallback((time) => {\r\n    if (!rendererRef.current) return 0;\r\n    return rendererRef.current.getViewportManager().timeToPixel(time);\r\n  }, []);\r\n\r\n  /**\r\n   * Convert pixel position to time within current viewport\r\n   */\r\n  const pixelToTime = useCallback((pixel) => {\r\n    if (!rendererRef.current) return 0;\r\n    return rendererRef.current.getViewportManager().pixelToTime(pixel);\r\n  }, []);\r\n\r\n  /**\r\n   * Render all waveform elements using high-performance renderer\r\n   */\r\n  const renderWaveform = useCallback(() => {\r\n    if (!rendererRef.current || !isInitialized) return;\r\n\r\n    const renderer = rendererRef.current;\r\n    \r\n    // Record frame render start for performance monitoring\r\n    if (performanceOptimizerRef.current?.performanceMonitor) {\r\n      performanceOptimizerRef.current.performanceMonitor.frameRenderStart();\r\n    }\r\n    \r\n    // Get adaptive settings for current performance level\r\n    const adaptiveSettings = performanceOptimizerRef.current?.getAdaptiveSettings() || {};\r\n    \r\n    // Render waveform data if available\r\n    if (waveformData) {\r\n      renderer.renderWaveform(waveformData, {\r\n        quality: adaptiveSettings.renderQuality || visualSettings.quality || 'high',\r\n        topColor: visualSettings.topColor,\r\n        centerColor: visualSettings.centerColor,\r\n        bottomColor: visualSettings.bottomColor,\r\n        strokeColor: visualSettings.strokeColor,\r\n        waveformResolution: adaptiveSettings.waveformResolution || 1.0,\r\n        enableAntialiasing: adaptiveSettings.enableAntialiasing !== false\r\n      });\r\n    }\r\n    \r\n    // Render chops with enhanced visualization\r\n    if (chops.length > 0) {\r\n      renderer.renderChops(chops, selectedChopId, {\r\n        highlightSelected: true,\r\n        hoveredChopId: hoveredChopId,\r\n        activeChopId: null // TODO: Connect to playback state\r\n      });\r\n    }\r\n    \r\n    // Playhead rendering is now handled by PlayheadManager for smooth real-time sync\r\n    // The PlayheadManager will automatically render when playback state changes\r\n    \r\n    // Render UI elements\r\n    renderer.renderUI({\r\n      showZoomIndicator: visualSettings.showZoomIndicator !== false,\r\n      textColor: visualSettings.textColor,\r\n      tickColor: visualSettings.tickColor\r\n    });\r\n    \r\n    // Update performance metrics\r\n    const rendererMetrics = renderer.getPerformanceMetrics();\r\n    const optimizerMetrics = performanceOptimizerRef.current?.getPerformanceMetrics() || {};\r\n    const combinedMetrics = { ...rendererMetrics, optimizer: optimizerMetrics };\r\n    setPerformanceMetrics(combinedMetrics);\r\n    \r\n    // Record frame render end for performance monitoring\r\n    if (performanceOptimizerRef.current?.performanceMonitor) {\r\n      performanceOptimizerRef.current.performanceMonitor.frameRenderEnd();\r\n    }\r\n  }, [\r\n    isInitialized, \r\n    waveformData, \r\n    chops, \r\n    selectedChopId, \r\n    hoveredChopId,\r\n    currentTime, \r\n    isPlaying, \r\n    visualSettings,\r\n    currentQualityLevel\r\n  ]);\r\n\r\n  /**\r\n   * Handle container resize\r\n   */\r\n  const handleResize = useCallback(() => {\r\n    if (!rendererRef.current) return;\r\n    \r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n    \r\n    const rect = container.getBoundingClientRect();\r\n    rendererRef.current.resize(rect.width, rect.height);\r\n  }, []);\r\n\r\n  // Initialize component\r\n  useEffect(() => {\r\n    const initialize = async () => {\r\n      // Initialize performance optimizer first\r\n      await initializePerformanceOptimizer();\r\n      \r\n      // Then initialize renderer with optimized settings\r\n      if (initializeRenderer()) {\r\n        setIsInitialized(true);\r\n      }\r\n    };\r\n    \r\n    initialize();\r\n  }, [initializePerformanceOptimizer, initializeRenderer]);\r\n\r\n  // Handle window resize\r\n  useEffect(() => {\r\n    const resizeObserver = new ResizeObserver(handleResize);\r\n    \r\n    if (containerRef.current) {\r\n      resizeObserver.observe(containerRef.current);\r\n    }\r\n    \r\n    return () => {\r\n      resizeObserver.disconnect();\r\n    };\r\n  }, [handleResize]);\r\n\r\n  // Render when dependencies change\r\n  useEffect(() => {\r\n    renderWaveform();\r\n  }, [renderWaveform]);\r\n\r\n  // Update interaction manager with current chops and waveform data\r\n  useEffect(() => {\r\n    if (interactionManagerRef.current) {\r\n      interactionManagerRef.current.setCurrentChops(chops);\r\n    }\r\n    \r\n    // Update playhead manager with chops for active highlighting\r\n    if (playheadManagerRef.current) {\r\n      playheadManagerRef.current.setChops(chops);\r\n    }\r\n  }, [chops]);\r\n\r\n  // Update interaction manager with waveform data for zero-crossing detection\r\n  useEffect(() => {\r\n    if (interactionManagerRef.current && waveformData) {\r\n      interactionManagerRef.current.setWaveformData(waveformData);\r\n    }\r\n  }, [waveformData]);\r\n\r\n  // Real-time playback synchronization using PlayheadManager\r\n  useEffect(() => {\r\n    if (playheadManagerRef.current) {\r\n      // Update playback state for smooth real-time synchronization\r\n      playheadManagerRef.current.updatePlaybackState(currentTime, isPlaying);\r\n    }\r\n  }, [currentTime, isPlaying]);\r\n\r\n  // Update playhead manager options when visual settings change\r\n  useEffect(() => {\r\n    if (playheadManagerRef.current) {\r\n      playheadManagerRef.current.setOptions({\r\n        playheadColor: visualSettings.playheadColor || '#ef4444',\r\n        playheadWidth: visualSettings.playheadWidth || 2,\r\n        activeChopColor: visualSettings.activeChopColor || '#fbbf24',\r\n        showTimeDisplay: visualSettings.showPlayheadTime !== false,\r\n        animationQuality: visualSettings.animationQuality || 'high'\r\n      });\r\n    }\r\n  }, [visualSettings]);\r\n\r\n  // Cleanup on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      if (animationFrameRef.current) {\r\n        cancelAnimationFrame(animationFrameRef.current);\r\n      }\r\n      if (playheadManagerRef.current) {\r\n        playheadManagerRef.current.destroy();\r\n        playheadManagerRef.current = null;\r\n      }\r\n      if (interactionManagerRef.current) {\r\n        interactionManagerRef.current.destroy();\r\n        interactionManagerRef.current = null;\r\n      }\r\n      if (rendererRef.current) {\r\n        rendererRef.current.destroy();\r\n        rendererRef.current = null;\r\n      }\r\n      if (performanceOptimizerRef.current) {\r\n        performanceOptimizerRef.current.destroy();\r\n        performanceOptimizerRef.current = null;\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  // Handle chop selection\r\n  const handleChopSelect = useCallback((chopId) => {\r\n    setSelectedChopId(chopId);\r\n    if (onChopUpdate) {\r\n      onChopUpdate(chopId, { selected: true });\r\n    }\r\n  }, [onChopUpdate]);\r\n\r\n  // Get viewport manager for external access\r\n  const getViewportManager = useCallback(() => {\r\n    return rendererRef.current?.getViewportManager();\r\n  }, []);\r\n\r\n  // Public API methods for external control\r\n  const api = useMemo(() => ({\r\n    setZoomLevel: (zoomLevel, centerTime) => {\r\n      updateViewport({ zoomLevel, centerTime });\r\n    },\r\n    \r\n    panToTime: (targetTime) => {\r\n      updateViewport({ centerTime: targetTime });\r\n    },\r\n    \r\n    zoomIn: (factor = 2, centerTime) => {\r\n      if (rendererRef.current) {\r\n        const viewportManager = rendererRef.current.getViewportManager();\r\n        viewportManager.zoomIn(factor, centerTime);\r\n      }\r\n    },\r\n    \r\n    zoomOut: (factor = 2, centerTime) => {\r\n      if (rendererRef.current) {\r\n        const viewportManager = rendererRef.current.getViewportManager();\r\n        viewportManager.zoomOut(factor, centerTime);\r\n      }\r\n    },\r\n    \r\n    zoomToFit: () => {\r\n      if (rendererRef.current) {\r\n        const viewportManager = rendererRef.current.getViewportManager();\r\n        viewportManager.zoomToFit();\r\n      }\r\n    },\r\n    \r\n    getViewport: () => {\r\n      if (rendererRef.current) {\r\n        return rendererRef.current.getViewportManager().getState();\r\n      }\r\n      return null;\r\n    },\r\n    \r\n    getViewportManager,\r\n    \r\n    getPerformanceMetrics: () => {\r\n      const baseMetrics = performanceMetrics;\r\n      const playheadMetrics = playheadManagerRef.current?.getPerformanceMetrics() || {};\r\n      const optimizerMetrics = performanceOptimizerRef.current?.getPerformanceMetrics() || {};\r\n      return { \r\n        ...baseMetrics, \r\n        playhead: playheadMetrics,\r\n        optimizer: optimizerMetrics,\r\n        currentQuality: currentQualityLevel\r\n      };\r\n    },\r\n    \r\n    getSyncStatus: () => {\r\n      return playheadManagerRef.current?.getSyncStatus() || null;\r\n    },\r\n    \r\n    jumpToTime: (time) => {\r\n      if (playheadManagerRef.current) {\r\n        playheadManagerRef.current.jumpToTime(time);\r\n      }\r\n      if (onTimeSeek) {\r\n        onTimeSeek(time);\r\n      }\r\n    },\r\n    \r\n    setRenderQuality: (quality) => {\r\n      if (rendererRef.current) {\r\n        rendererRef.current.setRenderQuality(quality);\r\n      }\r\n      if (performanceOptimizerRef.current) {\r\n        performanceOptimizerRef.current.setQualityLevel(quality);\r\n      }\r\n    },\r\n    \r\n    getPerformanceOptimizer: () => {\r\n      return performanceOptimizerRef.current;\r\n    },\r\n    \r\n    optimizeForLowEndDevice: () => {\r\n      if (performanceOptimizerRef.current) {\r\n        performanceOptimizerRef.current.optimizeForLowEndDevice();\r\n      }\r\n    },\r\n    \r\n    clearCaches: async () => {\r\n      if (performanceOptimizerRef.current) {\r\n        await performanceOptimizerRef.current.clearCaches();\r\n      }\r\n    },\r\n    \r\n    // Visual enhancement API methods\r\n    getVisualEnhancementEngine: () => {\r\n      return rendererRef.current?.getVisualEnhancementEngine();\r\n    },\r\n    \r\n    updateVisualSettings: (newSettings) => {\r\n      if (rendererRef.current && rendererRef.current.updateVisualSettings) {\r\n        rendererRef.current.updateVisualSettings(newSettings);\r\n        renderWaveform(); // Re-render with new settings\r\n      }\r\n    },\r\n    \r\n    getVisualSettings: () => {\r\n      const engine = rendererRef.current?.getVisualEnhancementEngine();\r\n      return engine ? engine.createVisualSettings() : null;\r\n    },\r\n    \r\n    timeToPixel,\r\n    pixelToTime,\r\n    \r\n    render: renderWaveform,\r\n    \r\n    selectChop: handleChopSelect\r\n  }), [updateViewport, timeToPixel, pixelToTime, renderWaveform, handleChopSelect, performanceMetrics, getViewportManager]);\r\n\r\n  return (\r\n    <motion.div\r\n      ref={containerRef}\r\n      className={`relative w-full h-full bg-gray-900 rounded-lg overflow-hidden ${className}`}\r\n      initial={{ opacity: 0 }}\r\n      animate={{ opacity: 1 }}\r\n      transition={{ duration: 0.3 }}\r\n    >\r\n      {/* Canvas layers are created and managed by CanvasRenderer */}\r\n      \r\n      {/* Loading indicator */}\r\n      {!isInitialized && (\r\n        <div className=\"absolute inset-0 flex items-center justify-center\">\r\n          <div className=\"text-white/70 text-sm\">Initializing high-performance renderer...</div>\r\n        </div>\r\n      )}\r\n      \r\n      {/* Performance indicator (development only) */}\r\n      {process.env.NODE_ENV === 'development' && performanceMetrics.averageFPS && (\r\n        <div className=\"absolute top-2 right-2 text-xs text-white/50 font-mono space-y-1\">\r\n          <div>{Math.round(performanceMetrics.averageFPS)}fps</div>\r\n          <div className={`text-xs ${\r\n            currentQualityLevel === 'high' ? 'text-green-400' :\r\n            currentQualityLevel === 'medium' ? 'text-yellow-400' :\r\n            'text-red-400'\r\n          }`}>\r\n            {currentQualityLevel}\r\n          </div>\r\n          {performanceMetrics.optimizer?.cachePerformance && (\r\n            <div>\r\n              Cache: {Math.round(performanceMetrics.optimizer.cachePerformance.hitRate * 100)}%\r\n            </div>\r\n          )}\r\n        </div>\r\n      )}\r\n    </motion.div>\r\n  );\r\n}\r\n\r\n// Export the API for external components to control the waveform\r\nexport { WaveformVisualization };"],"names":["jsxRuntimeModule","exports","REACT_ELEMENT_TYPE","Symbol","for","REACT_FRAGMENT_TYPE","jsxProd","type","config","maybeKey","key","propName","ref","$$typeof","props","reactJsxRuntime_production","Fragment","jsx","jsxs","require$$0","REACT_PORTAL_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROFILER_TYPE","REACT_CONSUMER_TYPE","REACT_CONTEXT_TYPE","REACT_FORWARD_REF_TYPE","REACT_SUSPENSE_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","MAYBE_ITERATOR_SYMBOL","iterator","ReactNoopUpdateQueue","isMounted","enqueueForceUpdate","enqueueReplaceState","enqueueSetState","assign","Object","emptyObject","Component","context","updater","this","refs","ComponentDummy","PureComponent","prototype","isReactComponent","setState","partialState","callback","Error","forceUpdate","pureComponentPrototype","constructor","isPureReactComponent","isArrayImpl","Array","isArray","ReactSharedInternals","H","A","T","S","V","hasOwnProperty","ReactElement","self","source","owner","isValidElement","object","userProvidedKeyEscapeRegex","getElementKey","element","index","escaperLookup","replace","match","toString","noop$1","mapIntoArray","children","array","escapedPrefix","nameSoFar","oldElement","newKey","invokeCallback","_init","_payload","c","push","maybeIterable","nextNamePrefix","i","length","call","next","done","value","then","thenable","status","reason","fulfilledValue","error","resolveThenable","String","keys","join","mapChildren","func","result","count","child","lazyInitializer","payload","_status","ctor","_result","moduleObject","default","reportGlobalError","reportError","window","ErrorEvent","event","bubbles","cancelable","message","dispatchEvent","process","emit","noop","react_production","Children","map","forEach","forEachFunc","forEachContext","apply","arguments","n","toArray","only","Profiler","StrictMode","Suspense","__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE","__COMPILER_RUNTIME","__proto__","size","useMemoCache","cache","fn","cloneElement","childArray","createContext","defaultValue","_currentValue","_currentValue2","_threadCount","Provider","Consumer","_context","createElement","childrenLength","defaultProps","createRef","current","forwardRef","render","lazy","memo","compare","startTransition","scope","prevTransition","currentTransition","returnValue","onStartTransitionFinish","unstable_useCacheRefresh","useCacheRefresh","use","usable","useActionState","action","initialState","permalink","useCallback","deps","useContext","Context","useDebugValue","useDeferredValue","initialValue","useEffect","create","createDeps","update","dispatcher","useId","useImperativeHandle","useInsertionEffect","useLayoutEffect","useMemo","useOptimistic","passthrough","reducer","useReducer","initialArg","init","useRef","useState","useSyncExternalStore","subscribe","getSnapshot","getServerSnapshot","useTransition","version","reactModule","LayoutGroupContext","useConstant","PresenceContext","MotionConfigContext","transformPagePoint","p","isStatic","reducedMotion","PopChildMeasure","React.Component","getSnapshotBeforeUpdate","prevProps","childRef","isPresent","sizeRef","height","offsetHeight","width","offsetWidth","top","offsetTop","left","offsetLeft","componentDidUpdate","PopChild","id","nonce","dataset","motionPopId","style","document","head","appendChild","sheet","insertRule","removeChild","React.cloneElement","PresenceChild","initial","onExitComplete","custom","presenceAffectsLayout","mode","presenceChildren","newChildrenMap","memoizedOnExitComplete","childId","set","isComplete","values","register","delete","Math","random","_","React.useEffect","Map","usePresence","safeToRemove","getChildKey","onlyElements","filtered","isBrowser","useIsomorphicLayoutEffect","AnimatePresence","propagate","isParentPresent","presentChildren","presentKeys","isInitialRender","pendingPresentChildren","exitComplete","diffedChildren","setDiffedChildren","renderedChildren","setRenderedChildren","includes","get","exitingChildren","nextChildren","splice","forceRender","has","isEveryExitComplete","isExitComplete","any","invariant","progress","from","to","toFromDifference","secondsToMilliseconds","seconds","millisecondsToSeconds","milliseconds","MotionGlobalConfig","stepsOrder","createRenderBatcher","scheduleNextBatch","allowKeepAlive","runNextFrame","useDefaultElapsed","state","delta","timestamp","isProcessing","flagRunNextFrame","steps","reduce","acc","thisFrame","Set","nextFrame","flushNextFrame","toKeepAlive","WeakSet","latestFrameData","triggerCallback","step","schedule","keepAlive","immediate","queue","add","cancel","frameData","clear","createRenderStep","read","resolveKeyframes","preRender","postRender","processBatch","performance","now","max","min","frame","cancelFrame","frameSteps","requestAnimationFrame","LazyContext","strict","featureProps","animation","exit","drag","focus","hover","tap","pan","inView","layout","featureDefinitions","isEnabled","some","name","validMotionProps","isValidMotionProp","startsWith","shouldForward","isValidProp","require","_a","createDOMMotionComponentProxy","componentFactory","Proxy","componentCache","args","_target","MotionContext","isVariantLabel","v","isAnimationControls","start","variantPriorityOrder","variantProps","isControllingVariants","animate","isVariantNode","Boolean","variants","useCreateMotionContext","inherit","getCurrentTreeVariants","variantLabelsAsDependency","prop","motionComponentSymbol","isRefObject","useMotionRef","visualState","visualElement","externalRef","instance","onMount","mount","unmount","camelToDash","str","toLowerCase","optimizedAppearDataAttribute","microtask","queueMicrotask","SwitchLayoutGroupContext","useVisualElement","createVisualElement","ProjectionNodeConstructor","_b","parent","lazyContext","presenceContext","reducedMotionConfig","visualElementRef","renderer","blockInitialAnimation","initialLayoutGroupConfig","projection","initialPromotionConfig","layoutId","dragConstraints","layoutScroll","layoutRoot","latestValues","getClosestProjectingNode","setOptions","alwaysMeasureLayout","animationType","createProjectionNode","optimisedAppearId","wantsHandoff","MotionHandoffIsComplete","MotionHasOptimisedAnimation","MotionIsMounted","updateFeatures","animationState","animateChanges","MotionHandoffMarkAsComplete","options","allowProjection","createRendererMotionComponent","preloadedFeatures","useRender","useVisualState","MotionComponent","MeasureLayout","configAndProps","useLayoutId","layoutProjection","combined","ProjectionNode","getProjectionFunctionality","features","loadFeatures","displayName","ForwardRefMotionComponent","layoutGroupId","lowercaseSVGElements","isSVGComponent","indexOf","test","getValueState","getVelocity","resolveVariantFromProps","definition","velocity","isKeyframesTarget","resolveFinalValueInKeyframes","isMotionValue","resolveMotionValue","unwrappedValue","mix","toValue","makeUseVisualState","make","scrapeMotionValuesFromProps","createRenderState","onUpdate","makeLatestValues","renderState","makeState","scrapeMotionValues","motionValues","isControllingVariants$1","isVariantNode$1","isInitialAnimationBlocked","variantToSet","list","resolved","transitionEnd","transition","target","valueTarget","transformPropOrder","transformProps","checkStringStartsWith","token","isCSSVariableName","startsAsVariableToken","isCSSVariableToken","singleCssVariableRegex","split","trim","getValueAsType","transform","clamp","number","parse","parseFloat","alpha","scale","createUnitType","unit","endsWith","degrees","percent","px","vh","vw","progressPercentage","browserNumberValueTypes","borderWidth","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","borderRadius","radius","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","maxWidth","maxHeight","right","bottom","padding","paddingTop","paddingRight","paddingBottom","paddingLeft","margin","marginTop","marginRight","marginBottom","marginLeft","backgroundPositionX","backgroundPositionY","transformValueTypes","rotate","rotateX","rotateY","rotateZ","scaleX","scaleY","scaleZ","skew","skewX","skewY","distance","translateX","translateY","translateZ","x","y","z","perspective","transformPerspective","opacity","originX","originY","originZ","int","round","numberValueTypes","zIndex","fillOpacity","strokeOpacity","numOctaves","translateAlias","numTransforms","buildHTMLStyles","transformTemplate","vars","transformOrigin","hasTransform","hasTransformOrigin","valueAsType","transformString","transformIsDefault","valueIsDefault","buildTransform","dashKeys","offset","camelKeys","calcOrigin","origin","buildSVGAttrs","attrX","attrY","attrScale","pathLength","pathSpacing","pathOffset","latest","isSVGTag","viewBox","attrs","dimensions","calcSVGTransformOrigin","spacing","useDashCase","buildSVGPath","createHtmlRenderState","createSvgRenderState","tag","renderHTML","styleProp","getProjectionStyles","setProperty","camelCaseAttributes","renderSVG","_styleProp","setAttribute","scaleCorrectors","isForcedMotionValue","newValues","getValue","liveStyle","scrapeMotionValuesFromProps$1","charAt","toUpperCase","substring","layoutProps","svgMotionConfig","needsMeasure","getBBox","getBoundingClientRect","e","updateSVGDimensions","tagName","htmlMotionConfig","copyRawValuesOnly","useStyle","useInitialMotionValues","useHTMLProps","htmlProps","dragListener","draggable","userSelect","WebkitUserSelect","WebkitTouchCallout","touchAction","tabIndex","onTap","onTapStart","whileTap","useSVGProps","_isStatic","visualProps","rawStyles","createUseRender","forwardMotionProps","filteredProps","isDom","filterProps","elementProps","createMotionComponentFactory","shallowCompare","prev","prevLength","resolveVariant","getProps","supportsScrollTimeline","ScrollTimeline","BaseGroupPlaybackControls","animations","stop","runAll","filter","finished","Promise","all","getAll","setAll","newValue","attachTimeline","timeline","fallback","subscriptions","time","speed","startTime","duration","methodName","controls","flatten","play","pause","complete","GroupPlaybackControls","onResolve","onReject","catch","getValueTransition","maxGeneratorDuration","calcGeneratorDuration","generator","Infinity","isGenerator","onfinish","isBezierDefinition","easing","supportsFlags","linearEasing","memoSupports","supportsFlag","memoized","supportsLinearEasing","generateLinearEasing","resolution","points","numPoints","isWaapiSupportedEasing","supportedWaapiEasing","every","cubicBezierAsString","a","b","d","linear","ease","easeIn","easeOut","easeInOut","circIn","circOut","backIn","backOut","mapEasingToNativeEasing","segmentEasing","isDragging","isDragActive","setupGesture","elementOrSelector","elements","Element","querySelectorAll","resolveElements","gestureAbortController","AbortController","passive","signal","abort","filterEvents","pointerType","isNodeOrChild","parentElement","isPrimaryPointer","button","isPrimary","focusableElements","isPressing","firePointerEvent","PointerEvent","isValidPressEvent","press","onPressStart","eventOptions","cancelEvents","startPress","startEvent","currentTarget","onPressEnd","onPointerEnd","endEvent","success","removeEventListener","onPointerUp","onPointerCancel","upEvent","useGlobalTarget","cancelEvent","addEventListener","isElementKeyboardAccessible","getAttribute","focusEvent","handleKeydown","handleKeyup","enableKeyboardPress","positionalKeys","clearTime","newTime","addUniqueItem","arr","item","removeItem","SubscriptionManager","handler","notify","numSubscriptions","getSize","velocityPerSecond","frameDuration","MotionValue","canTrackVelocity","events","updateAndNotify","currentTime","updatedAt","setPrevFrameValue","setCurrent","change","renderRequest","hasAnimated","isNaN","prevFrameValue","prevUpdatedAt","onChange","subscription","on","eventName","unsubscribe","clearListeners","eventManagers","attach","passiveEffect","stopPassiveEffect","setWithVelocity","jump","endAnimation","getPrevious","startAnimation","resolve","animationStart","animationComplete","clearAnimation","animationCancel","isAnimating","destroy","motionValue","setMotionValue","hasValue","addValue","addValueToWillChange","willChange","getOptimisedAppearId","calcBezier","t","a1","a2","cubicBezier","mX1","mY1","mX2","mY2","getTForX","aX","lowerBound","upperBound","currentX","currentT","abs","binarySubdivide","mirrorEasing","reverseEasing","backInOut","anticipate","pow","sin","acos","circInOut","isZeroValueString","isNone","sanitize","floatRegex","singleColorRegex","isColorString","testProp","isNullish","splitColor","aName","bName","cName","rgbUnit","clampRgbUnit","rgba","red","green","blue","alpha$1","hex","r","g","parseInt","hsla","hue","saturation","lightness","color","colorRegex","NUMBER_TOKEN","COLOR_TOKEN","complexRegex","analyseComplexValue","originalValue","indexes","var","types","parsedValue","parseComplexValue","createTransformer","numSections","output","convertNumbersToZero","complex","getAnimatableNone","parsed","transformer","maxDefaults","applyDefaultFilter","slice","functionRegex","functions","defaultValueTypes","backgroundColor","outlineColor","fill","stroke","borderColor","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","WebkitFilter","getDefaultValueType","defaultValueType","invalidTemplates","isNumOrPxType","getPosFromMatrix","matrix","pos","getTranslateFromMatrix","pos2","pos3","_bbox","matrix3d","transformKeys","nonTranslationalTransformKeys","positionalValues","toResolve","isScheduled","anyNeedsMeasurement","measureAllKeyframes","resolversToMeasure","resolver","needsMeasurement","elementsToMeasure","transformsToRestore","removedTransforms","removeNonTranslationalTransform","measureInitialState","restore","measureEndState","suspendedScrollY","scrollTo","readAllKeyframes","readKeyframes","KeyframeResolver","unresolvedKeyframes","onComplete","isAsync","scheduleResolve","currentValue","finalKeyframe","valueAsRead","readValue","setFinalKeyframe","renderEndStyles","resume","isNumericalString","splitCSSVariableRegex","getVariableValue","depth","exec","token1","token2","parseCSSVariable","getComputedStyle","getPropertyValue","trimmed","testValueType","dimensionValueTypes","findDimensionValueType","find","DOMKeyframesResolver","super","keyframe","resolveNoneKeyframes","originType","targetType","noneKeyframeIndexes","animatableTemplate","noneIndex","makeNoneKeyframesAnimatable","pageYOffset","measuredOrigin","measureViewportBox","measureKeyframe","finalKeyframeIndex","unsetTransformName","unsetTransformValue","isAnimatable","isNotNull","getFinalKeyframe","keyframes","repeat","repeatType","resolvedKeyframes","BaseAnimation","autoplay","delay","repeatDelay","isStopped","hasAttemptedResolve","createdAt","updateFinishedPromise","calcStartTime","resolvedAt","_resolved","onKeyframesResolved","originKeyframe","targetKeyframe","isOriginAnimatable","isTargetAnimatable","hasKeyframesChanged","canAnimate","resolveFinishedPromise","resolvedAnimation","initPlayback","onPostResolved","reject","currentFinishedPromise","mixNumber","hueToRgb","q","mixImmediate","mixLinearColor","fromExpo","expo","sqrt","colorTypes","asRGBA","model","hslaToRgba","mixColor","fromRGBA","toRGBA","blended","combineFunctions","pipe","transformers","invisibleValues","mixNumber$1","getMixer","mixComplex","mixArray","mixObject","numValues","blendValue","template","originStats","targetStats","mixVisibility","orderedOrigin","pointers","originIndex","originValue","matchOrder","mixer","calcGeneratorVelocity","resolveValue","prevT","springDefaults","granular","safeMin","findSpring","bounce","mass","envelope","derivative","dampingRatio","undampedFreq","exponentialDecay","calcAngularFreq","exp","f","initialGuess","rootIterations","approximateRoot","stiffness","damping","durationKeys","physicsKeys","isSpringType","spring","optionsOrVisualDuration","visualDuration","restSpeed","restDelta","isResolvedFromDuration","springOptions","root","PI","derived","getSpringOptions","initialVelocity","initialDelta","undampedAngularFreq","isGranularScale","resolveSpring","angularFreq","cos","dampedAngularFreq","freqForT","sinh","cosh","calculatedDuration","currentVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold","inertia","power","timeConstant","bounceDamping","bounceStiffness","modifyTarget","nearestBoundary","amplitude","ideal","calcDelta","calcLatest","applyFriction","timeReachedBoundary","spring$1","checkCatchBoundary","hasUpdatedFrame","easingLookup","easingDefinitionToFunction","x1","y1","x2","y2","interpolate","input","isClamp","inputLength","isZeroDeltaRange","reverse","mixers","customMixer","mixerFactory","numMixers","easingFunction","createMixers","interpolator","progressInRange","defaultOffset","remaining","offsetProgress","fillOffset","keyframeValues","times","easingFunctions","isEasingArray","absoluteTimes","o","convertOffsetToTimes","mapTimeToKeyframe","frameloopDriver","passTimestamp","generators","decay","tween","percentToProgress","MainThreadAnimation","holdTime","cancelTime","playbackSpeed","pendingPlayState","teardown","onStop","KeyframeResolver$1","keyframes$1","generatorFactory","mapPercentToKeyframes","mirroredGenerator","resolvedDuration","totalDuration","tick","sample","timeWithoutDelay","isInDelayPhase","elapsed","frameGenerator","currentIteration","floor","iterationProgress","isAnimationFinished","finish","driver","newSpeed","hasChanged","onPlay","stopDriver","acceleratedValues","startWaapiAnimation","valueName","keyframeOptions","iterations","direction","supportsWaapi","unsupportedEasingFunctions","AcceleratedAnimation","pregeneratedAnimation","sampleAnimation","pregeneratedKeyframes","pregenerateKeyframes","pendingTimeline","playbackRate","playState","sampleTime","supports","HTMLElement","underDampedSpring","keyframesTransition","getDefaultTransition","valueKey","animateMotionValue","isHandoff","valueTransition","when","_delay","delayChildren","staggerChildren","staggerDirection","isTransitionDefined","shouldSkip","shouldBlockAnimation","protectedKeys","needsAnimating","shouldBlock","animateTarget","targetAndTransition","transitionOverride","animationTypeState","getState","MotionHandoffAnimation","appearId","shouldReduceMotion","setTarget","animateVariant","variant","getAnimation","getChildAnimations","variantChildren","forwardDelay","maxStaggerDuration","generateStaggerDuration","sort","sortByTreeOrder","animateChildren","first","last","sortNodePosition","numVariantProps","getVariantContext","reversePriorityOrder","numAnimationTypes","animateList","resolvedDefinition","animateVisualElement","createAnimationState","createState","buildResolvedTypeValues","changedActiveType","removedKeys","encounteredKeys","removedVariantIndex","typeState","propIsVariant","activeDelta","isActive","isInherited","manuallyAnimateOnMount","prevProp","variantDidChange","checkVariantsDidChange","shouldAnimateType","handledRemovedValues","definitionList","resolvedValues","prevResolvedValues","allKeys","markToAnimate","valueHasChanged","fallbackAnimation","fallbackTarget","getBaseTarget","shouldAnimate","setActive","setAnimateFunction","makeAnimator","reset","createTypeState","whileInView","whileHover","whileDrag","whileFocus","Feature","node","updateAnimationControlsSubscription","unmountControls","prevAnimate","prevIsPresent","prevPresenceContext","exitAnimation","addDomEvent","extractEventInfo","point","pageX","pageY","addPointerEvent","addPointerInfo","PanSession","handlers","contextWindow","dragSnapToOrigin","lastMoveEvent","lastMoveEventInfo","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","xDelta","yDelta","distance2D","onStart","onMove","handlePointerMove","transformPoint","handlePointerUp","end","onEnd","onSessionEnd","resumeAnimation","panInfo","initialInfo","onSessionStart","removeListeners","updateHandlers","subtractPoint","lastDevicePoint","startDevicePoint","timeDelta","timestampedPoint","lastPoint","calcLength","axis","calcAxisDelta","originPoint","translate","calcBoxDelta","calcRelativeAxis","relative","calcRelativeAxisPosition","calcRelativePosition","calcRelativeAxisConstraints","calcViewportAxisConstraints","layoutAxis","constraintsAxis","defaultElastic","resolveAxisElastic","dragElastic","minLabel","maxLabel","resolvePointElastic","label","createBox","eachAxis","convertBoundingBoxToBox","isIdentityScale","hasScale","has2DTranslate","is2DTranslate","scalePoint","applyPointDelta","boxScale","applyAxisDelta","applyBoxDelta","box","TREE_SCALE_SNAP_MIN","TREE_SCALE_SNAP_MAX","translateAxis","transformAxis","axisTranslate","axisScale","axisOrigin","transformBox","topLeft","bottomRight","transformBoxPoints","getContextWindow","ownerDocument","defaultView","elementDragControls","WeakMap","VisualElementDragControls","openDragLock","currentDirection","constraints","hasMutatedConstraints","elastic","originEvent","snapToCursor","panSession","pauseAnimation","stopAnimation","dragPropagation","onDragStart","resolveConstraints","isAnimationBlocked","getAxisMotionValue","measuredAxis","layoutBox","dragDirectionLock","onDirectionLock","onDrag","lockThreshold","getCurrentDirection","updateAxis","getAnimationState","getTransformPagePoint","onDragEnd","_point","shouldDrag","axisValue","applyConstraints","measure","prevConstraints","resolveRefConstraints","calcRelativeConstraints","resolveDragElastic","relativeConstraints","rebaseAxisConstraints","onMeasureDragConstraints","constraintsElement","constraintsBox","rootProjectionNode","viewportBox","scroll","measurePageBox","measuredConstraints","calcViewportConstraints","userConstraints","convertBoxToBoundingBox","dragMomentum","dragTransition","onDragTransitionEnd","momentumAnimations","startAxisValueAnimation","dragKey","externalMotionValue","scalePositionWithinConstraints","boxProgress","sourceLength","targetLength","updateScroll","updateLayout","addListeners","stopPointerListener","measureDragConstraints","stopMeasureLayoutListener","stopResizeListener","stopLayoutUpdateListener","hasLayoutChanged","asyncHandler","globalProjectionState","hasAnimatedSinceResize","hasEverUpdated","pixelsToPercent","pixels","correctBorderRadius","correct","correctBoxShadow","treeScale","projectionDelta","original","shadow","xScale","yScale","averageScale","MeasureLayoutWithContext","componentDidMount","layoutGroup","switchLayoutGroup","correctors","defaultScaleCorrectors","group","didUpdate","layoutDependency","willUpdate","promote","relegate","stack","getStack","members","currentAnimation","isLead","componentWillUnmount","promoteContext","scheduleCheckAfterUnmount","remove","deregister","applyTo","boxShadow","compareByDepth","FlatTree","isDirty","borders","numBorders","asNumber","isPx","getRadius","radiusName","easeCrossfadeIn","compress","easeCrossfadeOut","copyAxisInto","originAxis","copyBoxInto","originBox","copyAxisDeltaInto","originDelta","removePointDelta","removeAxisTransforms","transforms","scaleKey","originKey","sourceAxis","removeAxisDelta","xKeys","yKeys","removeBoxTransforms","sourceBox","isAxisDeltaZero","isDeltaZero","axisEquals","axisEqualsRounded","boxEqualsRounded","aspectRatio","axisDeltaEquals","NodeStack","scheduleRender","prevLead","lead","indexOfNode","findIndex","member","preserveFollowOpacity","show","resumeFrom","preserveOpacity","snapshot","animationValues","isUpdating","isLayoutDirty","crossfade","hide","exitAnimationComplete","resumingFrom","removeLeadSnapshot","metrics","totalNodes","resolvedTargetDeltas","recalculatedProjection","isDebug","MotionDebug","transformAxes","hiddenVisibility","visibility","resetDistortingTransform","sharedAnimationValues","setStaticValue","cancelTreeOptimisedTransformAnimations","projectionNode","hasCheckedOptimisedAppear","MotionCancelOptimisedAnimation","attachResizeListener","defaultParent","measureScroll","checkIsScrollRoot","resetTransform","animationId","isTreeAnimating","isProjectionDirty","isSharedProjectionDirty","isTransformDirty","updateManuallyBlocked","updateBlockedByResize","isSVG","needsReset","shouldResetTransform","eventHandlers","hasTreeAnimated","updateScheduled","scheduleUpdate","projectionUpdateScheduled","checkUpdateFailed","clearAllSnapshots","updateProjection","nodes","propagateDirtyNodes","resolveTargetDelta","calcProjection","cleanDirtyNodes","record","resolvedRelativeTargetAt","hasProjected","isVisible","animationProgress","sharedNodes","path","notifyListeners","subscriptionManager","hasListeners","SVGElement","cancelDelay","resizeUnblockUpdate","timeout","checkElapsed","finishAnimation","registerSharedNode","hasRelativeTargetChanged","newLayout","isTreeAnimationBlocked","relativeTarget","layoutTransition","defaultLayoutTransition","onLayoutAnimationStart","onLayoutAnimationComplete","targetChanged","targetLayout","hasOnlyRelativeTargetChanged","setAnimationOrigin","animationOptions","blockUpdate","unblockUpdate","isUpdateBlocked","startUpdate","resetSkewAndRotation","getTransformTemplate","shouldNotifyListeners","prevTransformTemplateValue","updateSnapshot","clearMeasurements","clearIsLayoutDirty","resetTransformStyle","notifyLayoutUpdate","clearSnapshot","removeLeadSnapshots","scheduleUpdateProjection","prevLayout","layoutCorrected","phase","isRoot","wasRoot","isResetRequested","hasProjection","transformTemplateValue","transformTemplateHasChanged","removeTransform","pageBox","removeElementScroll","roundAxis","measuredBox","checkNodeWasScrollRoot","boxWithoutScroll","applyTransform","transformOnly","withTransforms","boxWithoutTransform","setTargetDelta","targetDelta","forceRelativeParentToResolveTarget","relativeParent","forceRecalculation","getLead","isShared","attemptToResolveRelativeTarget","getClosestProjectingParent","relativeTargetOrigin","targetWithTransforms","isProjecting","canSkip","pendingAnimation","prevTreeScaleX","prevTreeScaleY","treePath","isSharedTransition","treeLength","display","applyTreeDeltas","prevProjectionDelta","createProjectionDeltas","notifyAll","projectionDeltaWithTransform","snapshotLatestValues","mixedValues","relativeLayout","isSharedLayoutAnimation","isOnlyMember","shouldCrossfadeOpacity","hasOpacityCrossfade","prevRelativeTarget","mixTargetDelta","mixAxisDelta","mixAxis","follow","opacityExit","borderLabel","followRadius","leadRadius","mixValues","motionValue$1","animateSingleValue","completeAnimation","applyTransformsToTarget","shouldAnimatePositionOnly","xLength","yLength","shouldPreserveFollowOpacity","getPrevLead","hasDistortingTransform","resetValues","styles","pointerEvents","emptyStyles","valuesToRender","latestTransform","xTranslate","yTranslate","zTranslate","elementScaleX","elementScaleY","buildProjectionTransform","corrected","num","resetTree","measuredLayout","axisSnapshot","layoutDelta","visualDelta","parentSnapshot","parentLayout","relativeSnapshot","onBeforeLayoutMeasure","userAgentContains","string","navigator","userAgent","roundPoint","maxDistance","DocumentProjectionNode","documentElement","scrollLeft","body","scrollTop","HTMLProjectionNode","documentNode","position","removePointerDownListener","onPointerDown","pointerDownEvent","session","createPanHandlers","onPanSessionStart","onPanStart","onPan","onPanEnd","removeGroupControls","dragControls","handleHoverEvent","lifecycle","handlePressEvent","observerCallbacks","observers","fireObserverCallback","entry","fireAllObserverCallbacks","entries","observeIntersection","rootInteresectionObserver","lookupRoot","rootObservers","JSON","stringify","IntersectionObserver","initIntersectionObserver","observe","unobserve","thresholdNames","gestureAnimations","hasEnteredView","isInView","startObserver","viewport","rootMargin","amount","once","threshold","isIntersecting","onViewportEnter","onViewportLeave","prevViewport","hasViewportOptionChanged","globalTapTarget","onFocus","isFocusVisible","matches","onBlur","onHoverStart","onPointerEnter","enterEvent","onHoverEnd","onPointerLeave","leaveEvent","prefersReducedMotion","hasReducedMotionListener","valueTypes","visualElementStore","propEventHandlers","VisualElement","_props","_prevProps","_visualElement","valueSubscriptions","prevMotionValues","propEventSubscriptions","notifyUpdate","triggerBuild","renderInstance","renderScheduledAt","baseTarget","initialValues","initialMotionValues","removeFromVariantTree","addVariantChild","bindToMotionValue","matchMedia","motionMediaQuery","setReducedMotionPreferences","addListener","initPrefersReducedMotion","feature","valueIsTransform","removeOnChange","latestValue","removeOnRenderRequest","removeSyncCheck","MotionCheckAppearSync","other","sortInstanceNodePosition","featureDefinition","FeatureConstructor","build","measureInstanceViewportBox","getStaticValue","listener","nextValue","prevValue","existingValue","removeValue","updateMotionValuesFromProps","handleChildMotionValue","getVariant","getClosestVariantNode","closestVariantNode","removeValueFromRenderState","getBaseTargetFromProps","readValueFromInstance","setBaseTarget","valueFromInitial","DOMVisualElement","compareDocumentPosition","childSubscription","textContent","HTMLVisualElement","defaultType","computedStyle","SVGVisualElement","motion","CanvasLayerManager","layers","container","dpr","devicePixelRatio","initialize","updateDimensions","rect","layer","resizeLayer","createLayer","canvas","ctx","getContext","desynchronized","contextOptions","visible","dirty","setupLayer","configureContext","imageSmoothingEnabled","smoothing","textBaseline","textAlign","fillStyle","strokeStyle","lineWidth","lineCap","lineJoin","getLayer","removeLayer","parentNode","clearLayer","clearRect","clearAllLayers","setLayerVisibility","setLayerZIndex","markLayerDirty","markAllLayersDirty","isLayerDirty","markLayerClean","getLayerNames","getLayersSorted","enableLayerInteraction","disableLayerInteraction","getDimensions","getDevicePixelRatio","ViewportManager","zoomLevel","centerTime","visibleTimeRange","pixelsPerSecond","canvasDimensions","audioDuration","minZoom","maxZoom","listeners","updateVisibleRange","setCanvasDimensions","setAudioDuration","visibleDuration","halfDuration","endTime","setZoom","zoomIn","factor","zoomOut","zoomToFit","requiredPixelsPerSecond","panToTime","targetTime","panBy","deltaTime","panByPixels","deltaPixels","timeToPixel","pixelToTime","pixel","relativePixel","isTimeVisible","isRangeVisible","getViewportBounds","setLimits","calculateZoomForRange","paddedDuration","zoomToRange","getDetailLevel","getRenderingConfig","detailLevel","showSamplePoints","showZeroCrossings","showGrid","waveformResolution","antialiasing","getZoomPresets","description","preset","getNavigationInfo","visiblePercentage","startPercentage","endPercentage","canZoomIn","canZoomOut","canPanLeft","canPanRight","smartZoom","mouseTime","newZoomLevel","clampedZoom","hitLimit","limitType","getOptimalZoomForSelection","targetPercentage","CanvasRenderer","enableViewportCulling","enableBatching","maxBatchSize","renderQuality","enableAntialiasing","layerManager","viewportManager","performanceMetrics","frameCount","lastFrameTime","averageFPS","renderTime","culledElements","isRendering","renderQueue","animationFrameId","drawingCache","pathCache","createStandardLayers","handleViewportChange","renderWaveform","waveformData","renderingConfig","enhancedOptions","quality","visibleSamples","cullWaveformData","updatePerformanceMetrics","renderMethod","selectOptimalRenderMethod","configureWaveformContext","renderGrid","renderWaveformSamples","renderWaveformPeaks","renderWaveformBars","renderWaveformLine","renderZeroCrossings","samples","sampleRate","startSample","endSample","ceil","bufferSamples","cullStart","cullEnd","culledSamples","downsampledSamples","sum","j","sign","startIndex","endIndex","samplesPerPixel","gradient","createLinearGradient","addColorStop","topColor","centerColor","bottomColor","strokeColor","centerY","beginPath","sampleStart","sampleEnd","minY","maxY","moveTo","lineTo","barWidth","barHeight","fillRect","stepX","closePath","globalAlpha","arc","prevY","gridInterval","setLineDash","curr","renderChops","chops","selectedChopId","visibleChops","cullChops","chop","renderSingleChop","isSelected","isHovered","hoveredChopId","activeChopId","allChops","startPixel","endPixel","clampedStart","chopWidth","generateChopColor","baseAlpha","borderAlpha","pulseOffset","Date","hexToRgba","renderChopBoundaries","renderChopRelationships","renderChopLabel","renderDurationIndicator","shadowBlur","shadowColor","renderBoundaryIndicator","renderActiveChopAnimation","pulseAlpha","lineDashOffset","analyzeChopRelationships","relationship","renderRelationshipIndicator","currentChop","relationships","otherChop","gap","severity","calculateOverlapSeverity","chop1","chop2","overlapStart","overlapDuration","chop1Duration","chop2Duration","otherStartPixel","otherEndPixel","renderOverlapIndicator","renderAdjacencyIndicator","start1","end1","start2","end2","overlapEnd","warningColor","connectionPoint","otherPoint","startX","centerX","labelText","padId","fontSize","fontWeight","font","textWidth","measureText","bgWidth","bgHeight","strokeRect","fillText","durationText","toFixed","chopId","hash","charCodeAt","renderPlayhead","isPlaying","playheadPixel","indicatorSize","showTime","timeText","strokeText","renderUI","renderTimeScale","showZoomIndicator","renderZoomIndicator","textColor","timeStep","tickColor","zoomIndicatorColor","zoomIndicatorFont","zoomText","performRender","shift","renderTask","updateFPSMetrics","queueRender","operation","elementCount","totalTime","callCount","averageTime","opMetrics","frameTime","fps","getPerformanceMetrics","resetPerformanceMetrics","setRenderQuality","setViewportCulling","enabled","resize","getLayerManager","getViewportManager","cancelAnimationFrame","PlayheadManager","canvasRenderer","smoothingFactor","maxInterpolationTime","playheadColor","playheadWidth","activeChopColor","activeChopOpacity","showTimeDisplay","animationQuality","lastUpdateTime","interpolatedTime","activeChops","chopHighlights","lastFPSCheck","currentFPS","syncHistory","maxSyncHistory","syncAccuracy","updatePlaybackState","trackSyncAccuracy","updateActiveChops","expectedTime","actualTime","drift","totalDrift","sync","updateInterpolation","rafError","timeSinceLastUpdate","newActiveChops","intensity","fadeOut","highlight","fadeStartTime","cleanupHighlights","fadeProgress","setChops","renderActiveChopHighlights","pulseSpeed","save","shadowOffsetX","shadowOffsetY","renderPlayheadIndicator","renderTimeDisplay","formatTime","textX","textY","minutes","secs","padStart","getSyncStatus","newOptions","jumpToTime","WaveformVisualization","audioSource","onChopCreate","onChopUpdate","onTimeSeek","visualSettings","className","containerRef","rendererRef","interactionManagerRef","playheadManagerRef","performanceOptimizerRef","isInitialized","setIsInitialized","setSelectedChopId","setHoveredChopId","setPerformanceMetrics","currentQualityLevel","setCurrentQualityLevel","animationFrameRef","initializePerformanceOptimizer","async","WaveformPerformanceOptimizer","enableWebWorkers","enableCaching","enableMemoryManagement","enablePerformanceMonitoring","workerPoolSize","targetFPS","minFPS","performanceMonitor","onQualityChange","newQuality","initializeRenderer","adaptiveSettings","getAdaptiveSettings","EnhancedCanvasRenderer","enableFrequencyColorCoding","enableAmplitudeColorCoding","enableStructureDetection","enableAccessibilityMode","enableHighContrastMode","colorScheme","InteractionManager","clickThreshold","hoverDelay","snapTolerance","enableHover","enableClick","enableDrag","setCallbacks","onHover","showPlayheadTime","updateViewport","updates","frameRenderStart","highlightSelected","combinedMetrics","optimizer","frameRenderEnd","handleResize","resizeObserver","ResizeObserver","disconnect","setCurrentChops","setWaveformData","handleChopSelect","selected","setZoomLevel","getViewport","playhead","currentQuality","setQualityLevel","getPerformanceOptimizer","optimizeForLowEndDevice","clearCaches","getVisualEnhancementEngine","updateVisualSettings","newSettings","getVisualSettings","engine","createVisualSettings","selectChop","div"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249]}