{"version":3,"file":"WaveformVisualization-DKyQ2tMh.js","sources":["../../src/components/waveform/EnhancedCanvasRenderer.js","../../src/components/waveform/PlayheadManager.js","../../src/services/WaveformCache.js","../../src/services/WaveformMemoryManager.js","../../src/services/WaveformPerformanceMonitor.js","../../src/services/WaveformPerformanceOptimizer.js","../../src/components/waveform/WaveformVisualization.jsx"],"sourcesContent":["/**\r\n * Enhanced Canvas Renderer with Visual Enhancements and Accessibility Features\r\n * Extends the base CanvasRenderer with color coding, structure detection, and accessibility\r\n * Requirements: 8.1, 8.2, 8.3, 8.4, 8.5\r\n */\r\n\r\nimport { CanvasRenderer } from './CanvasRenderer.js';\r\nimport { VisualEnhancementEngine } from './VisualEnhancementEngine.js';\r\n\r\nexport class EnhancedCanvasRenderer extends CanvasRenderer {\r\n  constructor(container, options = {}) {\r\n    super(container, options);\r\n    \r\n    // Initialize visual enhancement engine\r\n    this.visualEnhancementEngine = new VisualEnhancementEngine({\r\n      enableFrequencyColorCoding: options.enableFrequencyColorCoding !== false,\r\n      enableAmplitudeColorCoding: options.enableAmplitudeColorCoding !== false,\r\n      enableStructureDetection: options.enableStructureDetection !== false,\r\n      enableAccessibilityMode: options.enableAccessibilityMode || false,\r\n      enableHighContrastMode: options.enableHighContrastMode || false,\r\n      colorScheme: options.colorScheme || 'default'\r\n    });\r\n    \r\n    // Enhanced rendering state\r\n    this.frequencyColorData = null;\r\n    this.amplitudeColorData = null;\r\n    this.structureData = null;\r\n    this.accessibilityPatterns = null;\r\n    \r\n    // Pattern cache for accessibility features\r\n    this.patternCache = new Map();\r\n    \r\n    // Animation state for enhanced effects\r\n    this.animationState = {\r\n      time: 0,\r\n      pulsePhase: 0,\r\n      particleSystem: null\r\n    };\r\n    \r\n    this.initializeEnhancedFeatures();\r\n  }\r\n\r\n  /**\r\n   * Initialize enhanced rendering features\r\n   */\r\n  initializeEnhancedFeatures() {\r\n    // Create additional layers for enhanced features\r\n    this.layerManager.createLayer('frequency-overlay', 1.5, { alpha: true });\r\n    this.layerManager.createLayer('structure-overlay', 2.5, { alpha: true });\r\n    this.layerManager.createLayer('accessibility-patterns', 3.5, { alpha: true });\r\n    this.layerManager.createLayer('enhancements', 5.5, { alpha: true });\r\n    \r\n    // Initialize pattern cache for accessibility\r\n    this.initializeAccessibilityPatterns();\r\n    \r\n    // Start animation loop for enhanced effects\r\n    this.startEnhancementAnimationLoop();\r\n  }\r\n\r\n  /**\r\n   * Enhanced waveform rendering with visual enhancements\r\n   * Overrides base renderWaveform to add color coding and accessibility features\r\n   */\r\n  renderWaveform(waveformData, options = {}) {\r\n    // Call base rendering first\r\n    super.renderWaveform(waveformData, options);\r\n    \r\n    // Apply visual enhancements if enabled\r\n    if (this.visualEnhancementEngine) {\r\n      this.renderVisualEnhancements(waveformData, options);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render visual enhancements including color coding and structure detection\r\n   */\r\n  renderVisualEnhancements(waveformData, options = {}) {\r\n    const viewport = this.viewportManager.getViewportBounds();\r\n    const { width, height } = this.layerManager.getDimensions();\r\n    \r\n    // Generate enhanced visual data\r\n    this.generateEnhancedVisualData(waveformData, options);\r\n    \r\n    // Render frequency color coding\r\n    if (this.frequencyColorData && this.visualEnhancementEngine.options.enableFrequencyColorCoding) {\r\n      this.renderFrequencyColorOverlay(viewport, width, height);\r\n    }\r\n    \r\n    // Render amplitude color coding\r\n    if (this.amplitudeColorData && this.visualEnhancementEngine.options.enableAmplitudeColorCoding) {\r\n      this.renderAmplitudeColorOverlay(viewport, width, height);\r\n    }\r\n    \r\n    // Render song structure detection\r\n    if (this.structureData && this.visualEnhancementEngine.options.enableStructureDetection) {\r\n      this.renderStructureOverlay(viewport, width, height);\r\n    }\r\n    \r\n    // Render accessibility patterns\r\n    if (this.accessibilityPatterns && this.visualEnhancementEngine.options.enableAccessibilityMode) {\r\n      this.renderAccessibilityPatterns(viewport, width, height);\r\n    }\r\n    \r\n    // Apply high contrast mode if enabled\r\n    if (this.visualEnhancementEngine.options.enableHighContrastMode) {\r\n      this.applyHighContrastMode();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate enhanced visual data from waveform and frequency data\r\n   */\r\n  generateEnhancedVisualData(waveformData, options = {}) {\r\n    const { frequencyData } = options;\r\n    \r\n    // Generate frequency color coding\r\n    if (frequencyData) {\r\n      this.frequencyColorData = this.visualEnhancementEngine.applyFrequencyColorCoding(\r\n        waveformData, \r\n        frequencyData\r\n      );\r\n    }\r\n    \r\n    // Generate amplitude color coding\r\n    this.amplitudeColorData = this.visualEnhancementEngine.applyAmplitudeColorCoding(waveformData);\r\n    \r\n    // Detect song structure\r\n    this.structureData = this.visualEnhancementEngine.detectSongStructure(\r\n      waveformData, \r\n      options.metadata || {}\r\n    );\r\n    \r\n    // Generate accessibility patterns\r\n    if (frequencyData) {\r\n      this.accessibilityPatterns = this.visualEnhancementEngine.generateAccessibilityPatterns(frequencyData);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render frequency-based color overlay\r\n   * Requirement 8.1: Color coding for different frequency ranges\r\n   */\r\n  renderFrequencyColorOverlay(viewport, width, height) {\r\n    const layer = this.layerManager.getLayer('frequency-overlay');\r\n    if (!layer || !this.frequencyColorData) return;\r\n    \r\n    const { ctx } = layer;\r\n    this.layerManager.clearLayer('frequency-overlay');\r\n    \r\n    // Render frequency color segments\r\n    this.frequencyColorData.forEach(segment => {\r\n      if (segment.endTime < viewport.start || segment.startTime > viewport.end) return;\r\n      \r\n      const startX = this.viewportManager.timeToPixel(Math.max(segment.startTime, viewport.start));\r\n      const endX = this.viewportManager.timeToPixel(Math.min(segment.endTime, viewport.end));\r\n      const segmentWidth = endX - startX;\r\n      \r\n      if (segmentWidth <= 0) return;\r\n      \r\n      // Create frequency-based gradient\r\n      const gradient = this.createFrequencyGradient(ctx, startX, height, segment.color, segment.frequencyProfile);\r\n      \r\n      // Apply blend mode for color overlay\r\n      ctx.globalCompositeOperation = 'multiply';\r\n      ctx.fillStyle = gradient;\r\n      ctx.fillRect(startX, 0, segmentWidth, height);\r\n      ctx.globalCompositeOperation = 'source-over';\r\n    });\r\n    \r\n    this.layerManager.markLayerClean('frequency-overlay');\r\n  }\r\n\r\n  /**\r\n   * Create frequency-based gradient\r\n   */\r\n  createFrequencyGradient(ctx, x, height, color, frequencyProfile) {\r\n    const gradient = ctx.createLinearGradient(x, 0, x, height);\r\n    \r\n    // Map frequency ranges to gradient stops\r\n    const { bassEnergy, lowMidEnergy, midEnergy, highMidEnergy, trebleEnergy } = frequencyProfile;\r\n    const totalEnergy = bassEnergy + lowMidEnergy + midEnergy + highMidEnergy + trebleEnergy;\r\n    \r\n    if (totalEnergy === 0) {\r\n      gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, 0.1)`);\r\n      gradient.addColorStop(1, `rgba(${color.r}, ${color.g}, ${color.b}, 0.1)`);\r\n      return gradient;\r\n    }\r\n    \r\n    // Create gradient based on frequency distribution\r\n    let currentStop = 0;\r\n    \r\n    // Bass (bottom)\r\n    const bassRatio = bassEnergy / totalEnergy;\r\n    if (bassRatio > 0.1) {\r\n      gradient.addColorStop(currentStop, `rgba(220, 38, 127, ${bassRatio * color.a})`);\r\n      currentStop += bassRatio;\r\n    }\r\n    \r\n    // Low-mid\r\n    const lowMidRatio = lowMidEnergy / totalEnergy;\r\n    if (lowMidRatio > 0.1) {\r\n      gradient.addColorStop(Math.min(currentStop, 1), `rgba(239, 68, 68, ${lowMidRatio * color.a})`);\r\n      currentStop += lowMidRatio;\r\n    }\r\n    \r\n    // Mid (center)\r\n    const midRatio = midEnergy / totalEnergy;\r\n    if (midRatio > 0.1) {\r\n      gradient.addColorStop(Math.min(currentStop, 1), `rgba(245, 158, 11, ${midRatio * color.a})`);\r\n      currentStop += midRatio;\r\n    }\r\n    \r\n    // High-mid\r\n    const highMidRatio = highMidEnergy / totalEnergy;\r\n    if (highMidRatio > 0.1) {\r\n      gradient.addColorStop(Math.min(currentStop, 1), `rgba(34, 197, 94, ${highMidRatio * color.a})`);\r\n      currentStop += highMidRatio;\r\n    }\r\n    \r\n    // Treble (top)\r\n    const trebleRatio = trebleEnergy / totalEnergy;\r\n    if (trebleRatio > 0.1) {\r\n      gradient.addColorStop(1, `rgba(59, 130, 246, ${trebleRatio * color.a})`);\r\n    }\r\n    \r\n    return gradient;\r\n  }\r\n\r\n  /**\r\n   * Render amplitude-based color overlay\r\n   * Requirement 8.1: Color coding for amplitude levels\r\n   */\r\n  renderAmplitudeColorOverlay(viewport, width, height) {\r\n    const layer = this.layerManager.getLayer('frequency-overlay');\r\n    if (!layer || !this.amplitudeColorData) return;\r\n    \r\n    const { ctx } = layer;\r\n    \r\n    // Render amplitude color segments\r\n    this.amplitudeColorData.forEach(segment => {\r\n      if (segment.endTime < viewport.start || segment.startTime > viewport.end) return;\r\n      \r\n      const startX = this.viewportManager.timeToPixel(Math.max(segment.startTime, viewport.start));\r\n      const endX = this.viewportManager.timeToPixel(Math.min(segment.endTime, viewport.end));\r\n      const segmentWidth = endX - startX;\r\n      \r\n      if (segmentWidth <= 0) return;\r\n      \r\n      // Apply amplitude-based color modification\r\n      const { alpha, brightness } = segment.colorModifier;\r\n      \r\n      ctx.globalCompositeOperation = 'overlay';\r\n      ctx.globalAlpha = alpha;\r\n      \r\n      // Create amplitude-based color\r\n      const amplitudeColor = this.getAmplitudeLevelColor(segment.level, brightness);\r\n      ctx.fillStyle = amplitudeColor;\r\n      ctx.fillRect(startX, 0, segmentWidth, height);\r\n      \r\n      ctx.globalAlpha = 1.0;\r\n      ctx.globalCompositeOperation = 'source-over';\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get color for amplitude level\r\n   */\r\n  getAmplitudeLevelColor(level, brightness) {\r\n    const colors = {\r\n      silent: { r: 64, g: 64, b: 64 },      // Dark gray\r\n      quiet: { r: 100, g: 149, b: 237 },    // Blue\r\n      moderate: { r: 34, g: 197, b: 94 },   // Green\r\n      loud: { r: 245, g: 158, b: 11 },      // Orange\r\n      peak: { r: 239, g: 68, b: 68 }        // Red\r\n    };\r\n    \r\n    const color = colors[level] || colors.moderate;\r\n    return `rgba(${Math.round(color.r * brightness)}, ${Math.round(color.g * brightness)}, ${Math.round(color.b * brightness)}, 0.3)`;\r\n  }\r\n\r\n  /**\r\n   * Render song structure overlay\r\n   * Requirement 8.2: Visual cues for song structure detection\r\n   */\r\n  renderStructureOverlay(viewport, width, height) {\r\n    const layer = this.layerManager.getLayer('structure-overlay');\r\n    if (!layer || !this.structureData) return;\r\n    \r\n    const { ctx } = layer;\r\n    this.layerManager.clearLayer('structure-overlay');\r\n    \r\n    // Render structure sections\r\n    this.structureData.forEach(section => {\r\n      if (section.endTime < viewport.start || section.startTime > viewport.end) return;\r\n      \r\n      const startX = this.viewportManager.timeToPixel(Math.max(section.startTime, viewport.start));\r\n      const endX = this.viewportManager.timeToPixel(Math.min(section.endTime, viewport.end));\r\n      const sectionWidth = endX - startX;\r\n      \r\n      if (sectionWidth <= 0) return;\r\n      \r\n      // Render section background\r\n      this.renderStructureSection(ctx, section, startX, sectionWidth, height);\r\n      \r\n      // Render section label if enabled\r\n      if (this.visualEnhancementEngine.options.structureDetection?.showLabels) {\r\n        this.renderStructureLabel(ctx, section, startX, sectionWidth, height);\r\n      }\r\n    });\r\n    \r\n    this.layerManager.markLayerClean('structure-overlay');\r\n  }\r\n\r\n  /**\r\n   * Render individual structure section\r\n   */\r\n  renderStructureSection(ctx, section, startX, width, height) {\r\n    const { visualPattern } = section;\r\n    const { color, pattern } = visualPattern;\r\n    \r\n    // Set base color with low opacity\r\n    const baseColor = `rgba(${color.r}, ${color.g}, ${color.b}, 0.1)`;\r\n    \r\n    switch (pattern) {\r\n      case 'solid':\r\n        ctx.fillStyle = baseColor;\r\n        ctx.fillRect(startX, 0, width, height);\r\n        break;\r\n        \r\n      case 'gradient':\r\n        const gradient = ctx.createLinearGradient(startX, 0, startX + width, 0);\r\n        gradient.addColorStop(0, baseColor);\r\n        gradient.addColorStop(0.5, `rgba(${color.r}, ${color.g}, ${color.b}, 0.2)`);\r\n        gradient.addColorStop(1, baseColor);\r\n        ctx.fillStyle = gradient;\r\n        ctx.fillRect(startX, 0, width, height);\r\n        break;\r\n        \r\n      case 'dashed':\r\n        ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.4)`;\r\n        ctx.lineWidth = 2;\r\n        ctx.setLineDash([8, 4]);\r\n        ctx.strokeRect(startX, 10, width, height - 20);\r\n        ctx.setLineDash([]);\r\n        break;\r\n        \r\n      case 'dotted':\r\n        ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.3)`;\r\n        for (let x = startX; x < startX + width; x += 12) {\r\n          for (let y = 10; y < height - 10; y += 12) {\r\n            ctx.beginPath();\r\n            ctx.arc(x, y, 2, 0, Math.PI * 2);\r\n            ctx.fill();\r\n          }\r\n        }\r\n        break;\r\n        \r\n      case 'sparse':\r\n        ctx.fillStyle = baseColor;\r\n        ctx.fillRect(startX, height * 0.4, width, height * 0.2);\r\n        break;\r\n        \r\n      default:\r\n        ctx.fillStyle = baseColor;\r\n        ctx.fillRect(startX, 0, width, height);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render structure section label\r\n   */\r\n  renderStructureLabel(ctx, section, startX, width, height) {\r\n    if (width < 60) return; // Too narrow for label\r\n    \r\n    const centerX = startX + width / 2;\r\n    const labelY = 25;\r\n    \r\n    // Prepare label text\r\n    const labelText = section.type.toUpperCase();\r\n    ctx.font = 'bold 12px monospace';\r\n    ctx.textAlign = 'center';\r\n    ctx.textBaseline = 'middle';\r\n    \r\n    // Measure text for background\r\n    const textMetrics = ctx.measureText(labelText);\r\n    const textWidth = textMetrics.width;\r\n    const padding = 6;\r\n    \r\n    // Draw label background\r\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\r\n    ctx.fillRect(centerX - textWidth / 2 - padding, labelY - 8, textWidth + padding * 2, 16);\r\n    \r\n    // Draw label border\r\n    const { color } = section.visualPattern;\r\n    ctx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.8)`;\r\n    ctx.lineWidth = 1;\r\n    ctx.strokeRect(centerX - textWidth / 2 - padding, labelY - 8, textWidth + padding * 2, 16);\r\n    \r\n    // Draw label text\r\n    ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 1)`;\r\n    ctx.fillText(labelText, centerX, labelY);\r\n  }\r\n\r\n  /**\r\n   * Render accessibility patterns for non-color visual cues\r\n   * Requirement 8.3: Alternative visual representations for accessibility\r\n   */\r\n  renderAccessibilityPatterns(viewport, width, height) {\r\n    const layer = this.layerManager.getLayer('accessibility-patterns');\r\n    if (!layer || !this.accessibilityPatterns) return;\r\n    \r\n    const { ctx } = layer;\r\n    this.layerManager.clearLayer('accessibility-patterns');\r\n    \r\n    // Render accessibility patterns\r\n    this.accessibilityPatterns.forEach(patternSegment => {\r\n      if (patternSegment.endTime < viewport.start || patternSegment.startTime > viewport.end) return;\r\n      \r\n      const startX = this.viewportManager.timeToPixel(Math.max(patternSegment.startTime, viewport.start));\r\n      const endX = this.viewportManager.timeToPixel(Math.min(patternSegment.endTime, viewport.end));\r\n      const segmentWidth = endX - startX;\r\n      \r\n      if (segmentWidth <= 0) return;\r\n      \r\n      this.renderAccessibilityPattern(ctx, patternSegment, startX, segmentWidth, height);\r\n    });\r\n    \r\n    this.layerManager.markLayerClean('accessibility-patterns');\r\n  }\r\n\r\n  /**\r\n   * Render individual accessibility pattern\r\n   */\r\n  renderAccessibilityPattern(ctx, patternSegment, startX, width, height) {\r\n    const { pattern, density, frequencyType } = patternSegment;\r\n    \r\n    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';\r\n    ctx.lineWidth = 1;\r\n    \r\n    const densityMap = { high: 4, medium: 8, low: 16, sparse: 32 };\r\n    const spacing = densityMap[density] || 8;\r\n    \r\n    switch (pattern) {\r\n      case 'vertical-lines':\r\n        for (let x = startX; x < startX + width; x += spacing) {\r\n          ctx.beginPath();\r\n          ctx.moveTo(x, 0);\r\n          ctx.lineTo(x, height);\r\n          ctx.stroke();\r\n        }\r\n        break;\r\n        \r\n      case 'horizontal-lines':\r\n        for (let y = 0; y < height; y += spacing) {\r\n          ctx.beginPath();\r\n          ctx.moveTo(startX, y);\r\n          ctx.lineTo(startX + width, y);\r\n          ctx.stroke();\r\n        }\r\n        break;\r\n        \r\n      case 'diagonal-lines':\r\n        for (let offset = -height; offset < width + height; offset += spacing) {\r\n          ctx.beginPath();\r\n          ctx.moveTo(startX + offset, 0);\r\n          ctx.lineTo(startX + offset + height, height);\r\n          ctx.stroke();\r\n        }\r\n        break;\r\n        \r\n      case 'dots':\r\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';\r\n        for (let x = startX; x < startX + width; x += spacing) {\r\n          for (let y = spacing / 2; y < height; y += spacing) {\r\n            ctx.beginPath();\r\n            ctx.arc(x, y, 1, 0, Math.PI * 2);\r\n            ctx.fill();\r\n          }\r\n        }\r\n        break;\r\n        \r\n      case 'cross-hatch':\r\n        // Vertical lines\r\n        for (let x = startX; x < startX + width; x += spacing) {\r\n          ctx.beginPath();\r\n          ctx.moveTo(x, 0);\r\n          ctx.lineTo(x, height);\r\n          ctx.stroke();\r\n        }\r\n        // Horizontal lines\r\n        for (let y = 0; y < height; y += spacing) {\r\n          ctx.beginPath();\r\n          ctx.moveTo(startX, y);\r\n          ctx.lineTo(startX + width, y);\r\n          ctx.stroke();\r\n        }\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply high contrast mode to all layers\r\n   * Requirement 8.3: High contrast mode for accessibility\r\n   */\r\n  applyHighContrastMode() {\r\n    // Apply high contrast filter to all layers\r\n    const layers = ['waveform', 'chops', 'frequency-overlay', 'structure-overlay'];\r\n    \r\n    layers.forEach(layerName => {\r\n      const layer = this.layerManager.getLayer(layerName);\r\n      if (layer && layer.canvas) {\r\n        const { ctx } = layer;\r\n        \r\n        // Apply high contrast filter\r\n        ctx.filter = 'contrast(200%) brightness(150%)';\r\n        \r\n        // Redraw layer content with high contrast\r\n        // This would typically involve re-rendering the layer content\r\n        // For now, we apply the filter to existing content\r\n        \r\n        // Reset filter\r\n        ctx.filter = 'none';\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Initialize accessibility pattern cache\r\n   */\r\n  initializeAccessibilityPatterns() {\r\n    const patterns = ['vertical-lines', 'horizontal-lines', 'diagonal-lines', 'dots', 'cross-hatch'];\r\n    const densities = ['high', 'medium', 'low', 'sparse'];\r\n    \r\n    patterns.forEach(pattern => {\r\n      densities.forEach(density => {\r\n        const key = `${pattern}-${density}`;\r\n        // Pre-generate pattern data for performance\r\n        this.patternCache.set(key, this.generatePatternData(pattern, density));\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Generate pattern data for caching\r\n   */\r\n  generatePatternData(pattern, density) {\r\n    return {\r\n      pattern,\r\n      density,\r\n      spacing: { high: 4, medium: 8, low: 16, sparse: 32 }[density] || 8\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Start animation loop for enhanced effects\r\n   */\r\n  startEnhancementAnimationLoop() {\r\n    const animate = (timestamp) => {\r\n      this.animationState.time = timestamp;\r\n      this.animationState.pulsePhase = (timestamp / 1000) % (Math.PI * 2);\r\n      \r\n      // Update animated elements if enabled\r\n      if (this.visualEnhancementEngine.options.enhancements?.animatedElements) {\r\n        this.updateAnimatedElements();\r\n      }\r\n      \r\n      requestAnimationFrame(animate);\r\n    };\r\n    \r\n    requestAnimationFrame(animate);\r\n  }\r\n\r\n  /**\r\n   * Update animated elements\r\n   */\r\n  updateAnimatedElements() {\r\n    // Update any animated visual elements\r\n    // This could include pulsing effects, particle systems, etc.\r\n    \r\n    // Mark layers dirty if animations are active\r\n    if (this.animationState.pulsePhase % (Math.PI / 4) < 0.1) {\r\n      this.layerManager.markLayerDirty('enhancements');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update visual enhancement settings\r\n   */\r\n  updateVisualSettings(newSettings) {\r\n    if (this.visualEnhancementEngine) {\r\n      this.visualEnhancementEngine.updateVisualSettings(newSettings, () => {\r\n        // Clear cached data to force regeneration\r\n        this.frequencyColorData = null;\r\n        this.amplitudeColorData = null;\r\n        this.structureData = null;\r\n        this.accessibilityPatterns = null;\r\n        \r\n        // Mark layers dirty for re-rendering\r\n        this.layerManager.markLayerDirty('frequency-overlay');\r\n        this.layerManager.markLayerDirty('structure-overlay');\r\n        this.layerManager.markLayerDirty('accessibility-patterns');\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get visual enhancement engine for external access\r\n   */\r\n  getVisualEnhancementEngine() {\r\n    return this.visualEnhancementEngine;\r\n  }\r\n\r\n  /**\r\n   * Cleanup enhanced features\r\n   */\r\n  destroy() {\r\n    super.destroy();\r\n    \r\n    if (this.visualEnhancementEngine) {\r\n      this.visualEnhancementEngine.destroy();\r\n    }\r\n    \r\n    this.patternCache.clear();\r\n  }\r\n}","/**\r\n * PlayheadManager - Handles real-time playback synchronization and smooth animation\r\n * Implements requirements: 5.1, 5.2, 5.3 - moving playhead, smooth animation, chop highlighting\r\n */\r\n\r\nexport class PlayheadManager {\r\n  constructor(canvasRenderer, options = {}) {\r\n    this.renderer = canvasRenderer;\r\n    this.options = {\r\n      smoothingFactor: 0.15, // Lower = smoother, higher = more responsive\r\n      maxInterpolationTime: 100, // Max time to interpolate in ms\r\n      playheadColor: '#ef4444',\r\n      playheadWidth: 2,\r\n      activeChopColor: '#fbbf24',\r\n      activeChopOpacity: 0.3,\r\n      showTimeDisplay: true,\r\n      animationQuality: 'high', // 'low', 'medium', 'high'\r\n      ...options\r\n    };\r\n\r\n    // Playhead state\r\n    this.currentTime = 0;\r\n    this.targetTime = 0;\r\n    this.isPlaying = false;\r\n    this.lastUpdateTime = 0;\r\n    this.interpolatedTime = 0;\r\n    \r\n    // Animation state\r\n    this.animationFrameId = null;\r\n    this.isAnimating = false;\r\n    \r\n    // Chop tracking\r\n    this.activeChops = new Set();\r\n    this.allChops = [];\r\n    this.chopHighlights = new Map(); // chopId -> highlight state\r\n    \r\n    // Performance tracking\r\n    this.frameCount = 0;\r\n    this.lastFPSCheck = 0;\r\n    this.currentFPS = 0;\r\n    \r\n    // Sync tracking\r\n    this.syncHistory = [];\r\n    this.maxSyncHistory = 10;\r\n    this.syncAccuracy = 0;\r\n    \r\n    this.initialize();\r\n  }\r\n\r\n  /**\r\n   * Initialize the playhead manager\r\n   */\r\n  initialize() {\r\n    // Start animation loop if playing\r\n    if (this.isPlaying) {\r\n      this.startAnimation();\r\n    }\r\n    \r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Update playback state from external source (YouTube player)\r\n   * @param {number} currentTime - Current playback time in seconds\r\n   * @param {boolean} isPlaying - Whether playback is active\r\n   */\r\n  updatePlaybackState(currentTime, isPlaying) {\r\n    // Validate input\r\n    if (typeof currentTime !== 'number' || isNaN(currentTime)) {\r\n      currentTime = 0;\r\n    }\r\n    \r\n    const now = performance.now();\r\n    const timeDelta = now - this.lastUpdateTime;\r\n    \r\n    // Track sync accuracy\r\n    this.trackSyncAccuracy(currentTime, timeDelta);\r\n    \r\n    // Update target time\r\n    this.targetTime = currentTime;\r\n    this.lastUpdateTime = now;\r\n    \r\n    // Always update current time immediately\r\n    this.currentTime = currentTime;\r\n    \r\n    // Handle play/pause state changes\r\n    if (isPlaying !== this.isPlaying) {\r\n      this.isPlaying = isPlaying;\r\n      \r\n      if (isPlaying) {\r\n        // Initialize interpolated time when starting playback\r\n        this.interpolatedTime = currentTime;\r\n        try {\r\n          this.startAnimation();\r\n        } catch (error) {\r\n          console.warn('Failed to start animation:', error);\r\n        }\r\n      } else {\r\n        this.stopAnimation();\r\n        // Immediately update to target time when paused\r\n        this.interpolatedTime = currentTime;\r\n      }\r\n    } else if (!isPlaying) {\r\n      // Update interpolated time even when not playing\r\n      this.interpolatedTime = currentTime;\r\n    }\r\n    \r\n    // Update active chops\r\n    this.updateActiveChops();\r\n    \r\n    // Trigger render if not animating\r\n    if (!this.isAnimating) {\r\n      this.render();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Track synchronization accuracy for performance monitoring\r\n   */\r\n  trackSyncAccuracy(newTime, timeDelta) {\r\n    if (this.syncHistory.length > 0) {\r\n      const lastSync = this.syncHistory[this.syncHistory.length - 1];\r\n      const expectedTime = lastSync.time + (timeDelta / 1000);\r\n      const actualTime = newTime;\r\n      const drift = Math.abs(actualTime - expectedTime);\r\n      \r\n      this.syncHistory.push({\r\n        time: newTime,\r\n        timestamp: performance.now(),\r\n        drift: drift,\r\n        timeDelta: timeDelta\r\n      });\r\n    } else {\r\n      this.syncHistory.push({\r\n        time: newTime,\r\n        timestamp: performance.now(),\r\n        drift: 0,\r\n        timeDelta: 0\r\n      });\r\n    }\r\n    \r\n    // Keep history size manageable\r\n    if (this.syncHistory.length > this.maxSyncHistory) {\r\n      this.syncHistory.shift();\r\n    }\r\n    \r\n    // Calculate average sync accuracy\r\n    if (this.syncHistory.length > 1) {\r\n      const totalDrift = this.syncHistory.reduce((sum, sync) => sum + sync.drift, 0);\r\n      this.syncAccuracy = totalDrift / this.syncHistory.length;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start smooth animation loop\r\n   */\r\n  startAnimation() {\r\n    if (this.isAnimating) return;\r\n    \r\n    this.isAnimating = true;\r\n    this.interpolatedTime = this.currentTime;\r\n    \r\n    const animate = (timestamp) => {\r\n      if (!this.isAnimating) return;\r\n      \r\n      try {\r\n        this.updateInterpolation(timestamp);\r\n        this.render();\r\n        this.updatePerformanceMetrics(timestamp);\r\n        \r\n        this.animationFrameId = requestAnimationFrame(animate);\r\n      } catch (error) {\r\n        console.warn('PlayheadManager animation error:', error);\r\n        // Continue animation despite errors\r\n        try {\r\n          this.animationFrameId = requestAnimationFrame(animate);\r\n        } catch (rafError) {\r\n          console.error('RequestAnimationFrame failed completely:', rafError);\r\n          this.isAnimating = false;\r\n        }\r\n      }\r\n    };\r\n    \r\n    try {\r\n      this.animationFrameId = requestAnimationFrame(animate);\r\n    } catch (error) {\r\n      console.warn('Initial RequestAnimationFrame failed:', error);\r\n      this.isAnimating = false;\r\n      throw error; // Re-throw for test detection\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Stop animation loop\r\n   */\r\n  stopAnimation() {\r\n    this.isAnimating = false;\r\n    \r\n    if (this.animationFrameId) {\r\n      cancelAnimationFrame(this.animationFrameId);\r\n      this.animationFrameId = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update interpolated time for smooth animation\r\n   */\r\n  updateInterpolation(timestamp) {\r\n    if (!this.isPlaying) return;\r\n    \r\n    const now = performance.now();\r\n    const timeSinceLastUpdate = now - this.lastUpdateTime;\r\n    \r\n    // If too much time has passed, jump to target\r\n    if (timeSinceLastUpdate > this.options.maxInterpolationTime) {\r\n      this.interpolatedTime = this.targetTime;\r\n      this.currentTime = this.targetTime;\r\n      this.lastUpdateTime = now;\r\n      this.updateActiveChops();\r\n      return;\r\n    }\r\n    \r\n    // Calculate expected time based on playback\r\n    const expectedTime = this.targetTime + (timeSinceLastUpdate / 1000);\r\n    \r\n    // Smooth interpolation towards expected time\r\n    const smoothingFactor = this.options.smoothingFactor;\r\n    \r\n    if (this.interpolatedTime === 0) {\r\n      // Initialize interpolated time\r\n      this.interpolatedTime = this.targetTime;\r\n    } else {\r\n      // Smooth interpolation\r\n      this.interpolatedTime += (expectedTime - this.interpolatedTime) * smoothingFactor;\r\n    }\r\n    \r\n    this.currentTime = this.interpolatedTime;\r\n    \r\n    // Update active chops based on interpolated time\r\n    this.updateActiveChops();\r\n  }\r\n\r\n  /**\r\n   * Update which chops are currently active during playback\r\n   */\r\n  updateActiveChops() {\r\n    const currentTime = this.interpolatedTime || this.currentTime;\r\n    const newActiveChops = new Set();\r\n    \r\n    // Find chops that contain the current time\r\n    this.allChops.forEach(chop => {\r\n      if (currentTime >= chop.startTime && currentTime <= chop.endTime) {\r\n        const chopId = chop.id || chop.padId;\r\n        newActiveChops.add(chopId);\r\n        \r\n        // Update highlight state\r\n        if (!this.activeChops.has(chopId)) {\r\n          this.chopHighlights.set(chopId, {\r\n            startTime: performance.now(),\r\n            intensity: 1.0,\r\n            chop: chop,\r\n            fadeOut: false\r\n          });\r\n        }\r\n      }\r\n    });\r\n    \r\n    // Remove chops that are no longer active\r\n    this.activeChops.forEach(chopId => {\r\n      if (!newActiveChops.has(chopId)) {\r\n        // Start fade out animation\r\n        const highlight = this.chopHighlights.get(chopId);\r\n        if (highlight) {\r\n          highlight.fadeOut = true;\r\n          highlight.fadeStartTime = performance.now();\r\n        }\r\n      }\r\n    });\r\n    \r\n    this.activeChops = newActiveChops;\r\n    \r\n    // Clean up old highlights\r\n    this.cleanupHighlights();\r\n  }\r\n\r\n  /**\r\n   * Clean up expired highlight animations\r\n   */\r\n  cleanupHighlights() {\r\n    const now = performance.now();\r\n    const fadeOutDuration = 300; // ms\r\n    \r\n    for (const [chopId, highlight] of this.chopHighlights.entries()) {\r\n      if (highlight.fadeOut) {\r\n        const fadeProgress = (now - highlight.fadeStartTime) / fadeOutDuration;\r\n        \r\n        if (fadeProgress >= 1.0) {\r\n          this.chopHighlights.delete(chopId);\r\n        } else {\r\n          highlight.intensity = 1.0 - fadeProgress;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the list of chops for active tracking\r\n   */\r\n  setChops(chops) {\r\n    this.allChops = chops || [];\r\n    this.updateActiveChops();\r\n  }\r\n\r\n  /**\r\n   * Render playhead and active chop highlights\r\n   */\r\n  render() {\r\n    if (!this.renderer) return;\r\n    \r\n    const viewport = this.renderer.getViewportManager();\r\n    if (!viewport) return;\r\n    \r\n    // Check if playhead is visible\r\n    if (!viewport.isTimeVisible(this.currentTime)) {\r\n      // Clear playhead layer if not visible\r\n      this.renderer.getLayerManager().clearLayer('playhead');\r\n      return;\r\n    }\r\n    \r\n    // Render active chop highlights first (behind playhead)\r\n    this.renderActiveChopHighlights();\r\n    \r\n    // Render playhead\r\n    this.renderPlayhead();\r\n  }\r\n\r\n  /**\r\n   * Render highlights for active chops\r\n   */\r\n  renderActiveChopHighlights() {\r\n    const layer = this.renderer.getLayerManager().getLayer('chops');\r\n    if (!layer) return;\r\n    \r\n    const { ctx } = layer;\r\n    const { width, height } = this.renderer.getLayerManager().getDimensions();\r\n    const viewport = this.renderer.getViewportManager();\r\n    \r\n    // Render each active chop highlight\r\n    this.chopHighlights.forEach((highlight, chopId) => {\r\n      const chop = highlight.chop;\r\n      if (!chop) return;\r\n      \r\n      // Check if chop is visible\r\n      if (!viewport.isRangeVisible(chop.startTime, chop.endTime)) return;\r\n      \r\n      const startPixel = viewport.timeToPixel(chop.startTime);\r\n      const endPixel = viewport.timeToPixel(chop.endTime);\r\n      const chopWidth = endPixel - startPixel;\r\n      \r\n      if (chopWidth <= 0) return;\r\n      \r\n      // Calculate highlight intensity with animation\r\n      let intensity = highlight.intensity;\r\n      if (!highlight.fadeOut && this.isPlaying) {\r\n        // Pulse effect during active playback\r\n        const pulseSpeed = 2; // Hz\r\n        const time = (performance.now() - highlight.startTime) / 1000;\r\n        const pulse = 0.7 + 0.3 * Math.sin(time * pulseSpeed * Math.PI * 2);\r\n        intensity *= pulse;\r\n      }\r\n      \r\n      // Render highlight overlay\r\n      ctx.save();\r\n      ctx.globalAlpha = this.options.activeChopOpacity * intensity;\r\n      ctx.fillStyle = this.options.activeChopColor;\r\n      ctx.fillRect(\r\n        Math.max(0, startPixel),\r\n        0,\r\n        Math.min(chopWidth, width - Math.max(0, startPixel)),\r\n        height\r\n      );\r\n      ctx.restore();\r\n      \r\n      // Render active chop border\r\n      ctx.save();\r\n      ctx.globalAlpha = intensity;\r\n      ctx.strokeStyle = this.options.activeChopColor;\r\n      ctx.lineWidth = 3;\r\n      ctx.setLineDash([5, 5]);\r\n      ctx.strokeRect(\r\n        Math.max(0, startPixel),\r\n        0,\r\n        Math.min(chopWidth, width - Math.max(0, startPixel)),\r\n        height\r\n      );\r\n      ctx.restore();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Render the playhead with smooth animation\r\n   */\r\n  renderPlayhead() {\r\n    const layer = this.renderer.getLayerManager().getLayer('playhead');\r\n    if (!layer) return;\r\n    \r\n    const { ctx } = layer;\r\n    const { width, height } = this.renderer.getLayerManager().getDimensions();\r\n    const viewport = this.renderer.getViewportManager();\r\n    \r\n    // Clear layer\r\n    this.renderer.getLayerManager().clearLayer('playhead');\r\n    \r\n    const playheadPixel = viewport.timeToPixel(this.currentTime);\r\n    \r\n    // Render playhead line with enhanced styling\r\n    ctx.save();\r\n    \r\n    // Main playhead line\r\n    ctx.strokeStyle = this.options.playheadColor;\r\n    ctx.lineWidth = this.options.playheadWidth;\r\n    ctx.lineCap = 'round';\r\n    \r\n    // Add glow effect for playing state\r\n    if (this.isPlaying) {\r\n      ctx.shadowColor = this.options.playheadColor;\r\n      ctx.shadowBlur = 8;\r\n      ctx.shadowOffsetX = 0;\r\n      ctx.shadowOffsetY = 0;\r\n    }\r\n    \r\n    ctx.beginPath();\r\n    ctx.moveTo(playheadPixel, 0);\r\n    ctx.lineTo(playheadPixel, height);\r\n    ctx.stroke();\r\n    \r\n    ctx.restore();\r\n    \r\n    // Render playhead indicator at top\r\n    this.renderPlayheadIndicator(ctx, playheadPixel, width, height);\r\n    \r\n    // Render time display if enabled\r\n    if (this.options.showTimeDisplay) {\r\n      this.renderTimeDisplay(ctx, playheadPixel, width, height);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render playhead indicator triangle\r\n   */\r\n  renderPlayheadIndicator(ctx, playheadPixel, width, height) {\r\n    const indicatorSize = 8;\r\n    \r\n    ctx.save();\r\n    ctx.fillStyle = this.options.playheadColor;\r\n    \r\n    // Add glow for playing state\r\n    if (this.isPlaying) {\r\n      ctx.shadowColor = this.options.playheadColor;\r\n      ctx.shadowBlur = 6;\r\n    }\r\n    \r\n    // Draw triangle indicator\r\n    ctx.beginPath();\r\n    ctx.moveTo(playheadPixel - indicatorSize, 0);\r\n    ctx.lineTo(playheadPixel + indicatorSize, 0);\r\n    ctx.lineTo(playheadPixel, indicatorSize * 1.5);\r\n    ctx.closePath();\r\n    ctx.fill();\r\n    \r\n    // Draw bottom indicator if there's space\r\n    if (height > 40) {\r\n      ctx.beginPath();\r\n      ctx.moveTo(playheadPixel - indicatorSize, height);\r\n      ctx.lineTo(playheadPixel + indicatorSize, height);\r\n      ctx.lineTo(playheadPixel, height - indicatorSize * 1.5);\r\n      ctx.closePath();\r\n      ctx.fill();\r\n    }\r\n    \r\n    ctx.restore();\r\n  }\r\n\r\n  /**\r\n   * Render time display near playhead\r\n   */\r\n  renderTimeDisplay(ctx, playheadPixel, width, height) {\r\n    const viewport = this.renderer.getViewportManager().getViewportBounds();\r\n    \r\n    // Only show time display at appropriate zoom levels\r\n    if (viewport.pixelsPerSecond < 50) return;\r\n    \r\n    const timeText = this.formatTime(this.currentTime);\r\n    \r\n    ctx.save();\r\n    ctx.font = 'bold 12px monospace';\r\n    ctx.textAlign = 'center';\r\n    ctx.textBaseline = 'middle';\r\n    \r\n    // Calculate position to avoid edges\r\n    let textX = playheadPixel;\r\n    const textY = height - 20;\r\n    \r\n    // Adjust position if near edges\r\n    const textWidth = ctx.measureText(timeText).width;\r\n    if (textX - textWidth / 2 < 5) {\r\n      textX = textWidth / 2 + 5;\r\n      ctx.textAlign = 'left';\r\n    } else if (textX + textWidth / 2 > width - 5) {\r\n      textX = width - 5;\r\n      ctx.textAlign = 'right';\r\n    }\r\n    \r\n    // Draw background\r\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';\r\n    ctx.fillRect(textX - textWidth / 2 - 4, textY - 8, textWidth + 8, 16);\r\n    \r\n    // Draw text\r\n    ctx.fillStyle = '#ffffff';\r\n    ctx.fillText(timeText, textX, textY);\r\n    \r\n    ctx.restore();\r\n  }\r\n\r\n  /**\r\n   * Format time for display\r\n   */\r\n  formatTime(seconds) {\r\n    const minutes = Math.floor(seconds / 60);\r\n    const secs = seconds % 60;\r\n    \r\n    if (minutes > 0) {\r\n      return `${minutes}:${secs.toFixed(2).padStart(5, '0')}`;\r\n    } else {\r\n      return `${secs.toFixed(2)}s`;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update performance metrics\r\n   */\r\n  updatePerformanceMetrics(timestamp) {\r\n    this.frameCount++;\r\n    \r\n    // Initialize lastFPSCheck if not set\r\n    if (this.lastFPSCheck === 0) {\r\n      this.lastFPSCheck = timestamp;\r\n    }\r\n    \r\n    if (timestamp - this.lastFPSCheck >= 1000) {\r\n      this.currentFPS = this.frameCount;\r\n      this.frameCount = 0;\r\n      this.lastFPSCheck = timestamp;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current performance metrics\r\n   */\r\n  getPerformanceMetrics() {\r\n    return {\r\n      fps: this.currentFPS,\r\n      syncAccuracy: this.syncAccuracy,\r\n      activeChops: this.activeChops.size,\r\n      isAnimating: this.isAnimating,\r\n      interpolatedTime: this.interpolatedTime,\r\n      targetTime: this.targetTime\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get synchronization status\r\n   */\r\n  getSyncStatus() {\r\n    return {\r\n      isPlaying: this.isPlaying,\r\n      currentTime: this.currentTime,\r\n      targetTime: this.targetTime,\r\n      syncAccuracy: this.syncAccuracy,\r\n      activeChops: Array.from(this.activeChops),\r\n      isAnimating: this.isAnimating\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Set playhead options\r\n   */\r\n  setOptions(newOptions) {\r\n    this.options = { ...this.options, ...newOptions };\r\n  }\r\n\r\n  /**\r\n   * Jump to specific time (for seeking)\r\n   */\r\n  jumpToTime(time) {\r\n    this.currentTime = time;\r\n    this.targetTime = time;\r\n    this.interpolatedTime = time;\r\n    this.lastUpdateTime = performance.now();\r\n    \r\n    this.updateActiveChops();\r\n    this.render();\r\n  }\r\n\r\n  /**\r\n   * Destroy the playhead manager\r\n   */\r\n  destroy() {\r\n    this.stopAnimation();\r\n    this.activeChops.clear();\r\n    this.chopHighlights.clear();\r\n    this.allChops = [];\r\n    this.syncHistory = [];\r\n  }\r\n}\r\n\r\nexport default PlayheadManager;","/**\r\n * Intelligent caching system for generated waveform data\r\n * Implements LRU cache with memory management and persistence\r\n * Requirements: 7.2, 7.3, 7.4\r\n */\r\n\r\nexport class WaveformCache {\r\n  constructor(options = {}) {\r\n    this.maxMemorySize = options.maxMemorySize || 100 * 1024 * 1024; // 100MB default\r\n    this.maxCacheEntries = options.maxCacheEntries || 50;\r\n    this.persistenceEnabled = options.persistenceEnabled !== false;\r\n    this.compressionEnabled = options.compressionEnabled !== false;\r\n    this.ttl = options.ttl || 24 * 60 * 60 * 1000; // 24 hours default\r\n    \r\n    // In-memory cache with LRU ordering\r\n    this.memoryCache = new Map();\r\n    this.accessOrder = new Map(); // Track access times for LRU\r\n    this.memorySizeUsed = 0;\r\n    \r\n    // Persistence layer\r\n    this.persistentCache = null;\r\n    this.initializePersistence();\r\n    \r\n    // Performance metrics\r\n    this.metrics = {\r\n      hits: 0,\r\n      misses: 0,\r\n      evictions: 0,\r\n      compressionSavings: 0,\r\n      averageCompressionRatio: 0,\r\n      persistenceHits: 0,\r\n      persistenceMisses: 0\r\n    };\r\n    \r\n    // Cleanup interval\r\n    this.cleanupInterval = setInterval(() => {\r\n      this.performMaintenance();\r\n    }, 5 * 60 * 1000); // Every 5 minutes\r\n  }\r\n\r\n  /**\r\n   * Initialize persistence layer using IndexedDB\r\n   */\r\n  async initializePersistence() {\r\n    if (!this.persistenceEnabled || typeof indexedDB === 'undefined') {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      this.persistentCache = await this.openIndexedDB();\r\n    } catch (error) {\r\n      console.warn('Failed to initialize persistent cache:', error);\r\n      this.persistenceEnabled = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Open IndexedDB for persistent caching\r\n   */\r\n  openIndexedDB() {\r\n    return new Promise((resolve, reject) => {\r\n      const request = indexedDB.open('WaveformCache', 1);\r\n      \r\n      request.onerror = () => reject(request.error);\r\n      \r\n      request.onsuccess = () => {\r\n        const db = request.result;\r\n        resolve(db);\r\n      };\r\n      \r\n      request.onupgradeneeded = (event) => {\r\n        const db = event.target.result;\r\n        \r\n        // Create object store for waveform data\r\n        if (!db.objectStoreNames.contains('waveforms')) {\r\n          const store = db.createObjectStore('waveforms', { keyPath: 'key' });\r\n          store.createIndex('timestamp', 'timestamp', { unique: false });\r\n          store.createIndex('size', 'size', { unique: false });\r\n        }\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Generate cache key from waveform parameters\r\n   */\r\n  generateCacheKey(audioSource, options = {}) {\r\n    const keyData = {\r\n      source: this.getSourceIdentifier(audioSource),\r\n      sampleRate: options.sampleRate || 1000,\r\n      quality: options.quality || 'medium',\r\n      analysisMethod: options.analysisMethod || 'auto',\r\n      duration: options.duration || 0\r\n    };\r\n    \r\n    // Create hash from key data\r\n    return this.hashObject(keyData);\r\n  }\r\n\r\n  /**\r\n   * Get waveform data from cache\r\n   */\r\n  async get(cacheKey) {\r\n    // Check memory cache first\r\n    const memoryResult = this.getFromMemory(cacheKey);\r\n    if (memoryResult) {\r\n      this.metrics.hits++;\r\n      return memoryResult;\r\n    }\r\n    \r\n    // Check persistent cache\r\n    if (this.persistenceEnabled && this.persistentCache) {\r\n      const persistentResult = await this.getFromPersistent(cacheKey);\r\n      if (persistentResult) {\r\n        this.metrics.persistenceHits++;\r\n        this.metrics.hits++;\r\n        \r\n        // Promote to memory cache\r\n        this.setInMemory(cacheKey, persistentResult);\r\n        return persistentResult;\r\n      } else {\r\n        this.metrics.persistenceMisses++;\r\n      }\r\n    }\r\n    \r\n    this.metrics.misses++;\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Store waveform data in cache\r\n   */\r\n  async set(cacheKey, waveformData, metadata = {}) {\r\n    const cacheEntry = {\r\n      key: cacheKey,\r\n      data: waveformData,\r\n      metadata: {\r\n        ...metadata,\r\n        timestamp: Date.now(),\r\n        accessCount: 1,\r\n        size: this.calculateDataSize(waveformData)\r\n      }\r\n    };\r\n    \r\n    // Compress data if enabled\r\n    if (this.compressionEnabled) {\r\n      const compressed = await this.compressData(cacheEntry);\r\n      if (compressed.size < cacheEntry.metadata.size) {\r\n        const savings = cacheEntry.metadata.size - compressed.size;\r\n        this.metrics.compressionSavings += savings;\r\n        this.updateCompressionRatio(cacheEntry.metadata.size, compressed.size);\r\n        cacheEntry.compressed = true;\r\n        cacheEntry.data = compressed.data;\r\n        cacheEntry.metadata.size = compressed.size;\r\n      }\r\n    }\r\n    \r\n    // Store in memory cache\r\n    this.setInMemory(cacheKey, cacheEntry);\r\n    \r\n    // Store in persistent cache\r\n    if (this.persistenceEnabled && this.persistentCache) {\r\n      await this.setInPersistent(cacheKey, cacheEntry);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get data from memory cache\r\n   */\r\n  getFromMemory(cacheKey) {\r\n    const entry = this.memoryCache.get(cacheKey);\r\n    if (!entry) return null;\r\n    \r\n    // Check TTL\r\n    if (Date.now() - entry.metadata.timestamp > this.ttl) {\r\n      this.memoryCache.delete(cacheKey);\r\n      this.accessOrder.delete(cacheKey);\r\n      this.memorySizeUsed -= entry.metadata.size;\r\n      return null;\r\n    }\r\n    \r\n    // Update access order for LRU\r\n    this.accessOrder.set(cacheKey, Date.now());\r\n    entry.metadata.accessCount++;\r\n    \r\n    // Decompress if needed\r\n    if (entry.compressed) {\r\n      const decompressed = this.decompressData(entry);\r\n      return {\r\n        ...entry,\r\n        data: decompressed,\r\n        compressed: false\r\n      };\r\n    }\r\n    \r\n    return entry;\r\n  }\r\n\r\n  /**\r\n   * Set data in memory cache with LRU eviction\r\n   */\r\n  setInMemory(cacheKey, cacheEntry) {\r\n    // Check if we need to evict entries\r\n    while (\r\n      (this.memorySizeUsed + cacheEntry.metadata.size > this.maxMemorySize) ||\r\n      (this.memoryCache.size >= this.maxCacheEntries)\r\n    ) {\r\n      this.evictLRU();\r\n    }\r\n    \r\n    // Remove existing entry if updating\r\n    if (this.memoryCache.has(cacheKey)) {\r\n      const existing = this.memoryCache.get(cacheKey);\r\n      this.memorySizeUsed -= existing.metadata.size;\r\n    }\r\n    \r\n    // Add new entry\r\n    this.memoryCache.set(cacheKey, cacheEntry);\r\n    this.accessOrder.set(cacheKey, Date.now());\r\n    this.memorySizeUsed += cacheEntry.metadata.size;\r\n  }\r\n\r\n  /**\r\n   * Get data from persistent cache\r\n   */\r\n  async getFromPersistent(cacheKey) {\r\n    if (!this.persistentCache) return null;\r\n    \r\n    try {\r\n      const transaction = this.persistentCache.transaction(['waveforms'], 'readonly');\r\n      const store = transaction.objectStore('waveforms');\r\n      const request = store.get(cacheKey);\r\n      \r\n      return new Promise((resolve, reject) => {\r\n        request.onsuccess = () => {\r\n          const result = request.result;\r\n          if (!result) {\r\n            resolve(null);\r\n            return;\r\n          }\r\n          \r\n          // Check TTL\r\n          if (Date.now() - result.timestamp > this.ttl) {\r\n            // Delete expired entry\r\n            this.deleteFromPersistent(cacheKey);\r\n            resolve(null);\r\n            return;\r\n          }\r\n          \r\n          // Decompress if needed\r\n          if (result.compressed) {\r\n            const decompressed = this.decompressData(result);\r\n            resolve({\r\n              ...result,\r\n              data: decompressed,\r\n              compressed: false\r\n            });\r\n          } else {\r\n            resolve(result);\r\n          }\r\n        };\r\n        \r\n        request.onerror = () => reject(request.error);\r\n      });\r\n    } catch (error) {\r\n      console.warn('Failed to get from persistent cache:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set data in persistent cache\r\n   */\r\n  async setInPersistent(cacheKey, cacheEntry) {\r\n    if (!this.persistentCache) return;\r\n    \r\n    try {\r\n      const transaction = this.persistentCache.transaction(['waveforms'], 'readwrite');\r\n      const store = transaction.objectStore('waveforms');\r\n      \r\n      // Create persistent entry\r\n      const persistentEntry = {\r\n        key: cacheKey,\r\n        data: cacheEntry.data,\r\n        metadata: cacheEntry.metadata,\r\n        compressed: cacheEntry.compressed || false,\r\n        timestamp: cacheEntry.metadata.timestamp,\r\n        size: cacheEntry.metadata.size\r\n      };\r\n      \r\n      store.put(persistentEntry);\r\n      \r\n      return new Promise((resolve, reject) => {\r\n        transaction.oncomplete = () => resolve();\r\n        transaction.onerror = () => reject(transaction.error);\r\n      });\r\n    } catch (error) {\r\n      console.warn('Failed to set in persistent cache:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete entry from persistent cache\r\n   */\r\n  async deleteFromPersistent(cacheKey) {\r\n    if (!this.persistentCache) return;\r\n    \r\n    try {\r\n      const transaction = this.persistentCache.transaction(['waveforms'], 'readwrite');\r\n      const store = transaction.objectStore('waveforms');\r\n      store.delete(cacheKey);\r\n    } catch (error) {\r\n      console.warn('Failed to delete from persistent cache:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Evict least recently used entry from memory cache\r\n   */\r\n  evictLRU() {\r\n    if (this.accessOrder.size === 0) return;\r\n    \r\n    // Find least recently used entry\r\n    let oldestKey = null;\r\n    let oldestTime = Date.now();\r\n    \r\n    for (const [key, accessTime] of this.accessOrder) {\r\n      if (accessTime < oldestTime) {\r\n        oldestTime = accessTime;\r\n        oldestKey = key;\r\n      }\r\n    }\r\n    \r\n    if (oldestKey) {\r\n      const entry = this.memoryCache.get(oldestKey);\r\n      if (entry) {\r\n        this.memorySizeUsed -= entry.metadata.size;\r\n      }\r\n      \r\n      this.memoryCache.delete(oldestKey);\r\n      this.accessOrder.delete(oldestKey);\r\n      this.metrics.evictions++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Compress waveform data\r\n   */\r\n  async compressData(cacheEntry) {\r\n    try {\r\n      // Simple compression using JSON stringify and compression\r\n      const jsonData = JSON.stringify(cacheEntry.data);\r\n      \r\n      // Use CompressionStream if available (modern browsers)\r\n      if (typeof CompressionStream !== 'undefined') {\r\n        const stream = new CompressionStream('gzip');\r\n        const writer = stream.writable.getWriter();\r\n        const reader = stream.readable.getReader();\r\n        \r\n        writer.write(new TextEncoder().encode(jsonData));\r\n        writer.close();\r\n        \r\n        const chunks = [];\r\n        let done = false;\r\n        \r\n        while (!done) {\r\n          const { value, done: readerDone } = await reader.read();\r\n          done = readerDone;\r\n          if (value) chunks.push(value);\r\n        }\r\n        \r\n        const compressed = new Uint8Array(chunks.reduce((acc, chunk) => acc + chunk.length, 0));\r\n        let offset = 0;\r\n        for (const chunk of chunks) {\r\n          compressed.set(chunk, offset);\r\n          offset += chunk.length;\r\n        }\r\n        \r\n        return {\r\n          data: compressed,\r\n          size: compressed.length,\r\n          originalSize: jsonData.length\r\n        };\r\n      } else {\r\n        // Fallback: simple string compression\r\n        const compressed = this.simpleCompress(jsonData);\r\n        return {\r\n          data: compressed,\r\n          size: compressed.length,\r\n          originalSize: jsonData.length\r\n        };\r\n      }\r\n    } catch (error) {\r\n      console.warn('Compression failed:', error);\r\n      return {\r\n        data: cacheEntry.data,\r\n        size: cacheEntry.metadata.size,\r\n        originalSize: cacheEntry.metadata.size\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Decompress waveform data\r\n   */\r\n  decompressData(cacheEntry) {\r\n    try {\r\n      if (cacheEntry.data instanceof Uint8Array) {\r\n        // Decompress using DecompressionStream if available\r\n        if (typeof DecompressionStream !== 'undefined') {\r\n          // This would need to be async, but for simplicity using fallback\r\n          return this.simpleDecompress(new TextDecoder().decode(cacheEntry.data));\r\n        } else {\r\n          return this.simpleDecompress(new TextDecoder().decode(cacheEntry.data));\r\n        }\r\n      } else if (typeof cacheEntry.data === 'string') {\r\n        return this.simpleDecompress(cacheEntry.data);\r\n      } else {\r\n        return cacheEntry.data;\r\n      }\r\n    } catch (error) {\r\n      console.warn('Decompression failed:', error);\r\n      return cacheEntry.data;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Simple compression fallback\r\n   */\r\n  simpleCompress(data) {\r\n    // Basic RLE compression for demonstration\r\n    let compressed = '';\r\n    let count = 1;\r\n    let current = data[0];\r\n    \r\n    for (let i = 1; i < data.length; i++) {\r\n      if (data[i] === current && count < 255) {\r\n        count++;\r\n      } else {\r\n        compressed += String.fromCharCode(count) + current;\r\n        current = data[i];\r\n        count = 1;\r\n      }\r\n    }\r\n    compressed += String.fromCharCode(count) + current;\r\n    \r\n    return compressed;\r\n  }\r\n\r\n  /**\r\n   * Simple decompression fallback\r\n   */\r\n  simpleDecompress(compressed) {\r\n    try {\r\n      return JSON.parse(compressed);\r\n    } catch {\r\n      // If not JSON, try RLE decompression\r\n      let decompressed = '';\r\n      for (let i = 0; i < compressed.length; i += 2) {\r\n        const count = compressed.charCodeAt(i);\r\n        const char = compressed[i + 1];\r\n        decompressed += char.repeat(count);\r\n      }\r\n      return JSON.parse(decompressed);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate data size in bytes\r\n   */\r\n  calculateDataSize(data) {\r\n    if (data instanceof ArrayBuffer) {\r\n      return data.byteLength;\r\n    } else if (data instanceof Float32Array || data instanceof Uint8Array) {\r\n      return data.length * data.BYTES_PER_ELEMENT;\r\n    } else if (typeof data === 'string') {\r\n      return data.length * 2; // Approximate UTF-16 size\r\n    } else {\r\n      // Estimate JSON size\r\n      return JSON.stringify(data).length * 2;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate source identifier for caching\r\n   */\r\n  getSourceIdentifier(audioSource) {\r\n    if (typeof audioSource === 'string') {\r\n      return audioSource; // URL or identifier\r\n    } else if (audioSource && audioSource.videoId) {\r\n      return `youtube:${audioSource.videoId}`;\r\n    } else if (audioSource && audioSource.src) {\r\n      return audioSource.src;\r\n    } else {\r\n      return 'unknown';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Hash object to create cache key\r\n   */\r\n  hashObject(obj) {\r\n    const str = JSON.stringify(obj, Object.keys(obj).sort());\r\n    let hash = 0;\r\n    \r\n    for (let i = 0; i < str.length; i++) {\r\n      const char = str.charCodeAt(i);\r\n      hash = ((hash << 5) - hash) + char;\r\n      hash = hash & hash; // Convert to 32-bit integer\r\n    }\r\n    \r\n    return `waveform_${Math.abs(hash).toString(36)}`;\r\n  }\r\n\r\n  /**\r\n   * Update compression ratio metrics\r\n   */\r\n  updateCompressionRatio(originalSize, compressedSize) {\r\n    const ratio = compressedSize / originalSize;\r\n    const count = this.metrics.hits + this.metrics.misses;\r\n    \r\n    this.metrics.averageCompressionRatio = \r\n      (this.metrics.averageCompressionRatio * (count - 1) + ratio) / count;\r\n  }\r\n\r\n  /**\r\n   * Perform cache maintenance\r\n   */\r\n  async performMaintenance() {\r\n    // Clean expired entries from memory cache\r\n    const now = Date.now();\r\n    const expiredKeys = [];\r\n    \r\n    for (const [key, entry] of this.memoryCache) {\r\n      if (now - entry.metadata.timestamp > this.ttl) {\r\n        expiredKeys.push(key);\r\n      }\r\n    }\r\n    \r\n    for (const key of expiredKeys) {\r\n      const entry = this.memoryCache.get(key);\r\n      if (entry) {\r\n        this.memorySizeUsed -= entry.metadata.size;\r\n      }\r\n      this.memoryCache.delete(key);\r\n      this.accessOrder.delete(key);\r\n    }\r\n    \r\n    // Clean expired entries from persistent cache\r\n    if (this.persistenceEnabled && this.persistentCache) {\r\n      await this.cleanExpiredPersistent();\r\n    }\r\n    \r\n    // Optimize memory usage if needed\r\n    if (this.memorySizeUsed > this.maxMemorySize * 0.8) {\r\n      this.optimizeMemoryUsage();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean expired entries from persistent cache\r\n   */\r\n  async cleanExpiredPersistent() {\r\n    try {\r\n      const transaction = this.persistentCache.transaction(['waveforms'], 'readwrite');\r\n      const store = transaction.objectStore('waveforms');\r\n      const index = store.index('timestamp');\r\n      \r\n      const cutoffTime = Date.now() - this.ttl;\r\n      const range = IDBKeyRange.upperBound(cutoffTime);\r\n      \r\n      const request = index.openCursor(range);\r\n      \r\n      request.onsuccess = (event) => {\r\n        const cursor = event.target.result;\r\n        if (cursor) {\r\n          cursor.delete();\r\n          cursor.continue();\r\n        }\r\n      };\r\n    } catch (error) {\r\n      console.warn('Failed to clean expired persistent cache:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Optimize memory usage by evicting less frequently used entries\r\n   */\r\n  optimizeMemoryUsage() {\r\n    // Sort entries by access frequency and recency\r\n    const entries = Array.from(this.memoryCache.entries()).map(([key, entry]) => ({\r\n      key,\r\n      entry,\r\n      score: entry.metadata.accessCount * (Date.now() - entry.metadata.timestamp)\r\n    }));\r\n    \r\n    entries.sort((a, b) => a.score - b.score);\r\n    \r\n    // Remove bottom 25% of entries\r\n    const toRemove = Math.floor(entries.length * 0.25);\r\n    for (let i = 0; i < toRemove; i++) {\r\n      const { key, entry } = entries[i];\r\n      this.memorySizeUsed -= entry.metadata.size;\r\n      this.memoryCache.delete(key);\r\n      this.accessOrder.delete(key);\r\n      this.metrics.evictions++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get cache statistics\r\n   */\r\n  getStats() {\r\n    const hitRate = this.metrics.hits / (this.metrics.hits + this.metrics.misses) || 0;\r\n    const persistentHitRate = this.metrics.persistenceHits / this.metrics.persistenceMisses || 0;\r\n    \r\n    return {\r\n      memoryCache: {\r\n        entries: this.memoryCache.size,\r\n        sizeUsed: this.memorySizeUsed,\r\n        maxSize: this.maxMemorySize,\r\n        utilizationPercent: (this.memorySizeUsed / this.maxMemorySize) * 100\r\n      },\r\n      performance: {\r\n        hitRate: hitRate * 100,\r\n        persistentHitRate: persistentHitRate * 100,\r\n        totalHits: this.metrics.hits,\r\n        totalMisses: this.metrics.misses,\r\n        evictions: this.metrics.evictions\r\n      },\r\n      compression: {\r\n        enabled: this.compressionEnabled,\r\n        totalSavings: this.metrics.compressionSavings,\r\n        averageRatio: this.metrics.averageCompressionRatio\r\n      },\r\n      persistence: {\r\n        enabled: this.persistenceEnabled,\r\n        hits: this.metrics.persistenceHits,\r\n        misses: this.metrics.persistenceMisses\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clear all cache data\r\n   */\r\n  async clear() {\r\n    // Clear memory cache\r\n    this.memoryCache.clear();\r\n    this.accessOrder.clear();\r\n    this.memorySizeUsed = 0;\r\n    \r\n    // Clear persistent cache\r\n    if (this.persistenceEnabled && this.persistentCache) {\r\n      try {\r\n        const transaction = this.persistentCache.transaction(['waveforms'], 'readwrite');\r\n        const store = transaction.objectStore('waveforms');\r\n        store.clear();\r\n      } catch (error) {\r\n        console.warn('Failed to clear persistent cache:', error);\r\n      }\r\n    }\r\n    \r\n    // Reset metrics\r\n    this.metrics = {\r\n      hits: 0,\r\n      misses: 0,\r\n      evictions: 0,\r\n      compressionSavings: 0,\r\n      averageCompressionRatio: 0,\r\n      persistenceHits: 0,\r\n      persistenceMisses: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Destroy cache and cleanup resources\r\n   */\r\n  destroy() {\r\n    // Clear cleanup interval\r\n    if (this.cleanupInterval) {\r\n      clearInterval(this.cleanupInterval);\r\n      this.cleanupInterval = null;\r\n    }\r\n    \r\n    // Clear all data\r\n    this.clear();\r\n    \r\n    // Close persistent cache\r\n    if (this.persistentCache) {\r\n      this.persistentCache.close();\r\n      this.persistentCache = null;\r\n    }\r\n  }\r\n}\r\n\r\nexport default WaveformCache;","/**\r\n * Memory cleanup strategies for large audio files\r\n * Implements intelligent memory management and garbage collection\r\n * Requirements: 7.3, 7.4, 7.5\r\n */\r\n\r\nexport class WaveformMemoryManager {\r\n  constructor(options = {}) {\r\n    this.maxMemoryThreshold = options.maxMemoryThreshold || 150 * 1024 * 1024; // 150MB\r\n    this.warningThreshold = options.warningThreshold || 100 * 1024 * 1024; // 100MB\r\n    this.cleanupInterval = options.cleanupInterval || 30 * 1000; // 30 seconds\r\n    this.aggressiveCleanupThreshold = options.aggressiveCleanupThreshold || 200 * 1024 * 1024; // 200MB\r\n    \r\n    // Memory tracking\r\n    this.allocatedBuffers = new Map();\r\n    this.bufferPool = new Map(); // Reusable buffers\r\n    this.memoryUsage = {\r\n      current: 0,\r\n      peak: 0,\r\n      allocated: 0,\r\n      pooled: 0\r\n    };\r\n    \r\n    // Cleanup strategies\r\n    this.cleanupStrategies = new Map();\r\n    this.initializeCleanupStrategies();\r\n    \r\n    // Performance monitoring\r\n    this.performanceMetrics = {\r\n      cleanupCount: 0,\r\n      memoryReclaimed: 0,\r\n      bufferReuses: 0,\r\n      gcTriggers: 0,\r\n      averageCleanupTime: 0\r\n    };\r\n    \r\n    // Auto cleanup\r\n    this.cleanupTimer = setInterval(() => {\r\n      this.performAutomaticCleanup();\r\n    }, this.cleanupInterval);\r\n    \r\n    // Memory pressure monitoring\r\n    this.memoryPressureObserver = null;\r\n    this.initializeMemoryPressureMonitoring();\r\n  }\r\n\r\n  /**\r\n   * Initialize cleanup strategies\r\n   */\r\n  initializeCleanupStrategies() {\r\n    this.cleanupStrategies.set('buffer-pool', {\r\n      priority: 1,\r\n      execute: () => this.cleanupBufferPool(),\r\n      description: 'Clean unused buffers from pool'\r\n    });\r\n    \r\n    this.cleanupStrategies.set('old-allocations', {\r\n      priority: 2,\r\n      execute: () => this.cleanupOldAllocations(),\r\n      description: 'Remove old allocated buffers'\r\n    });\r\n    \r\n    this.cleanupStrategies.set('large-buffers', {\r\n      priority: 3,\r\n      execute: () => this.cleanupLargeBuffers(),\r\n      description: 'Clean up large unused buffers'\r\n    });\r\n    \r\n    this.cleanupStrategies.set('force-gc', {\r\n      priority: 4,\r\n      execute: () => this.forceGarbageCollection(),\r\n      description: 'Force garbage collection'\r\n    });\r\n    \r\n    this.cleanupStrategies.set('emergency-cleanup', {\r\n      priority: 5,\r\n      execute: () => this.emergencyCleanup(),\r\n      description: 'Emergency memory cleanup'\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Initialize memory pressure monitoring\r\n   */\r\n  initializeMemoryPressureMonitoring() {\r\n    // Use Performance Observer API if available\r\n    if (typeof PerformanceObserver !== 'undefined') {\r\n      try {\r\n        this.memoryPressureObserver = new PerformanceObserver((list) => {\r\n          const entries = list.getEntries();\r\n          for (const entry of entries) {\r\n            if (entry.entryType === 'measure' && entry.name.includes('memory')) {\r\n              this.handleMemoryPressure(entry);\r\n            }\r\n          }\r\n        });\r\n        \r\n        this.memoryPressureObserver.observe({ entryTypes: ['measure'] });\r\n      } catch (error) {\r\n        console.warn('Memory pressure monitoring not available:', error);\r\n      }\r\n    }\r\n    \r\n    // Fallback: monitor memory usage manually\r\n    setInterval(() => {\r\n      this.checkMemoryPressure();\r\n    }, 5000); // Check every 5 seconds\r\n  }\r\n\r\n  /**\r\n   * Allocate buffer with tracking\r\n   */\r\n  allocateBuffer(size, type = 'waveform', metadata = {}) {\r\n    const bufferId = this.generateBufferId();\r\n    \r\n    // Try to reuse buffer from pool\r\n    const pooledBuffer = this.getPooledBuffer(size, type);\r\n    if (pooledBuffer) {\r\n      this.allocatedBuffers.set(bufferId, {\r\n        buffer: pooledBuffer,\r\n        size,\r\n        type,\r\n        metadata: {\r\n          ...metadata,\r\n          allocatedAt: Date.now(),\r\n          reused: true\r\n        }\r\n      });\r\n      \r\n      this.performanceMetrics.bufferReuses++;\r\n      return { bufferId, buffer: pooledBuffer };\r\n    }\r\n    \r\n    // Allocate new buffer\r\n    let buffer;\r\n    try {\r\n      switch (type) {\r\n        case 'waveform':\r\n        case 'float32':\r\n          buffer = new Float32Array(size);\r\n          break;\r\n        case 'uint8':\r\n          buffer = new Uint8Array(size);\r\n          break;\r\n        case 'int16':\r\n          buffer = new Int16Array(size);\r\n          break;\r\n        case 'arraybuffer':\r\n          buffer = new ArrayBuffer(size);\r\n          break;\r\n        default:\r\n          buffer = new Float32Array(size);\r\n      }\r\n      \r\n      const actualSize = buffer.byteLength || (buffer.length * buffer.BYTES_PER_ELEMENT);\r\n      \r\n      this.allocatedBuffers.set(bufferId, {\r\n        buffer,\r\n        size: actualSize,\r\n        type,\r\n        metadata: {\r\n          ...metadata,\r\n          allocatedAt: Date.now(),\r\n          reused: false\r\n        }\r\n      });\r\n      \r\n      this.memoryUsage.current += actualSize;\r\n      this.memoryUsage.allocated += actualSize;\r\n      this.memoryUsage.peak = Math.max(this.memoryUsage.peak, this.memoryUsage.current);\r\n      \r\n      // Check if we need cleanup\r\n      if (this.memoryUsage.current > this.warningThreshold) {\r\n        this.scheduleCleanup('memory-warning');\r\n      }\r\n      \r\n      return { bufferId, buffer };\r\n      \r\n    } catch (error) {\r\n      console.error('Buffer allocation failed:', error);\r\n      \r\n      // Try emergency cleanup and retry once\r\n      if (this.memoryUsage.current > this.maxMemoryThreshold * 0.8) {\r\n        this.emergencyCleanup();\r\n        \r\n        try {\r\n          buffer = new Float32Array(size);\r\n          const actualSize = buffer.byteLength || (buffer.length * buffer.BYTES_PER_ELEMENT);\r\n          \r\n          this.allocatedBuffers.set(bufferId, {\r\n            buffer,\r\n            size: actualSize,\r\n            type,\r\n            metadata: {\r\n              ...metadata,\r\n              allocatedAt: Date.now(),\r\n              reused: false,\r\n              emergencyRetry: true\r\n            }\r\n          });\r\n          \r\n          this.memoryUsage.current += actualSize;\r\n          this.memoryUsage.allocated += actualSize;\r\n          \r\n          return { bufferId, buffer };\r\n        } catch (retryError) {\r\n          throw new Error(`Buffer allocation failed after emergency cleanup: ${retryError.message}`);\r\n        }\r\n      }\r\n      \r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deallocate buffer and optionally pool for reuse\r\n   */\r\n  deallocateBuffer(bufferId, options = {}) {\r\n    const allocation = this.allocatedBuffers.get(bufferId);\r\n    if (!allocation) {\r\n      console.warn(`Buffer ${bufferId} not found for deallocation`);\r\n      return false;\r\n    }\r\n    \r\n    const { buffer, size, type } = allocation;\r\n    const { poolForReuse = true, reason = 'manual' } = options;\r\n    \r\n    // Remove from allocated buffers\r\n    this.allocatedBuffers.delete(bufferId);\r\n    this.memoryUsage.current -= size;\r\n    \r\n    // Pool buffer for reuse if requested and suitable\r\n    if (poolForReuse && this.shouldPoolBuffer(buffer, size, type)) {\r\n      this.addToBufferPool(buffer, size, type);\r\n    }\r\n    \r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Get pooled buffer if available\r\n   */\r\n  getPooledBuffer(size, type) {\r\n    const poolKey = `${type}_${size}`;\r\n    const pool = this.bufferPool.get(poolKey);\r\n    \r\n    if (pool && pool.length > 0) {\r\n      const buffer = pool.pop();\r\n      \r\n      // Clear buffer data\r\n      if (buffer.fill) {\r\n        buffer.fill(0);\r\n      } else if (buffer instanceof ArrayBuffer) {\r\n        new Uint8Array(buffer).fill(0);\r\n      }\r\n      \r\n      // Update pool size tracking\r\n      this.memoryUsage.pooled -= size;\r\n      \r\n      return buffer;\r\n    }\r\n    \r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Add buffer to pool for reuse\r\n   */\r\n  addToBufferPool(buffer, size, type) {\r\n    const poolKey = `${type}_${size}`;\r\n    \r\n    if (!this.bufferPool.has(poolKey)) {\r\n      this.bufferPool.set(poolKey, []);\r\n    }\r\n    \r\n    const pool = this.bufferPool.get(poolKey);\r\n    \r\n    // Limit pool size to prevent excessive memory usage\r\n    const maxPoolSize = Math.max(2, Math.floor(this.maxMemoryThreshold / size / 10));\r\n    \r\n    if (pool.length < maxPoolSize) {\r\n      pool.push(buffer);\r\n      this.memoryUsage.pooled += size;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if buffer should be pooled\r\n   */\r\n  shouldPoolBuffer(buffer, size, type) {\r\n    // Don't pool very large buffers\r\n    if (size > 10 * 1024 * 1024) { // 10MB\r\n      return false;\r\n    }\r\n    \r\n    // Don't pool if we're already using too much memory\r\n    if (this.memoryUsage.current > this.warningThreshold) {\r\n      return false;\r\n    }\r\n    \r\n    // Only pool common buffer types\r\n    const poolableTypes = ['waveform', 'float32', 'uint8', 'int16'];\r\n    return poolableTypes.includes(type);\r\n  }\r\n\r\n  /**\r\n   * Perform automatic cleanup based on memory usage\r\n   */\r\n  performAutomaticCleanup() {\r\n    const currentUsage = this.getCurrentMemoryUsage();\r\n    \r\n    if (currentUsage > this.aggressiveCleanupThreshold) {\r\n      this.performCleanup(['emergency-cleanup', 'force-gc', 'large-buffers']);\r\n    } else if (currentUsage > this.maxMemoryThreshold) {\r\n      this.performCleanup(['large-buffers', 'old-allocations', 'buffer-pool']);\r\n    } else if (currentUsage > this.warningThreshold) {\r\n      this.performCleanup(['buffer-pool', 'old-allocations']);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Perform cleanup using specified strategies\r\n   */\r\n  async performCleanup(strategyNames = []) {\r\n    const startTime = performance.now();\r\n    const initialMemory = this.getCurrentMemoryUsage();\r\n    \r\n    // Sort strategies by priority\r\n    const strategies = strategyNames\r\n      .map(name => ({ name, ...this.cleanupStrategies.get(name) }))\r\n      .filter(strategy => strategy.execute)\r\n      .sort((a, b) => a.priority - b.priority);\r\n    \r\n    let totalReclaimed = 0;\r\n    \r\n    for (const strategy of strategies) {\r\n      try {\r\n        const beforeMemory = this.getCurrentMemoryUsage();\r\n        await strategy.execute();\r\n        const afterMemory = this.getCurrentMemoryUsage();\r\n        const reclaimed = beforeMemory - afterMemory;\r\n        \r\n        if (reclaimed > 0) {\r\n          totalReclaimed += reclaimed;\r\n          console.log(`Cleanup strategy '${strategy.name}' reclaimed ${this.formatBytes(reclaimed)}`);\r\n        }\r\n        \r\n        // Stop if we've reclaimed enough memory\r\n        if (afterMemory < this.warningThreshold) {\r\n          break;\r\n        }\r\n      } catch (error) {\r\n        console.error(`Cleanup strategy '${strategy.name}' failed:`, error);\r\n      }\r\n    }\r\n    \r\n    const cleanupTime = performance.now() - startTime;\r\n    this.updateCleanupMetrics(cleanupTime, totalReclaimed);\r\n    \r\n    return {\r\n      strategiesUsed: strategies.map(s => s.name),\r\n      memoryReclaimed: totalReclaimed,\r\n      cleanupTime,\r\n      finalMemoryUsage: this.getCurrentMemoryUsage()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Schedule cleanup for later execution\r\n   */\r\n  scheduleCleanup(reason = 'scheduled', delay = 0) {\r\n    setTimeout(() => {\r\n      this.performAutomaticCleanup();\r\n    }, delay);\r\n  }\r\n\r\n  /**\r\n   * Cleanup buffer pool\r\n   */\r\n  cleanupBufferPool() {\r\n    let reclaimed = 0;\r\n    const now = Date.now();\r\n    const maxAge = 5 * 60 * 1000; // 5 minutes\r\n    \r\n    for (const [poolKey, pool] of this.bufferPool) {\r\n      const [type, sizeStr] = poolKey.split('_');\r\n      const size = parseInt(sizeStr);\r\n      \r\n      // Remove old or excess buffers\r\n      const keepCount = Math.max(1, Math.floor(pool.length / 2));\r\n      const removed = pool.splice(keepCount);\r\n      \r\n      reclaimed += removed.length * size;\r\n      this.memoryUsage.pooled -= removed.length * size;\r\n    }\r\n    \r\n    return reclaimed;\r\n  }\r\n\r\n  /**\r\n   * Cleanup old allocations\r\n   */\r\n  cleanupOldAllocations() {\r\n    let reclaimed = 0;\r\n    const now = Date.now();\r\n    const maxAge = 10 * 60 * 1000; // 10 minutes\r\n    const toRemove = [];\r\n    \r\n    for (const [bufferId, allocation] of this.allocatedBuffers) {\r\n      const age = now - allocation.metadata.allocatedAt;\r\n      \r\n      // Remove old allocations that haven't been accessed recently\r\n      if (age > maxAge && !allocation.metadata.pinned) {\r\n        toRemove.push(bufferId);\r\n        reclaimed += allocation.size;\r\n      }\r\n    }\r\n    \r\n    for (const bufferId of toRemove) {\r\n      this.deallocateBuffer(bufferId, { poolForReuse: false, reason: 'age-cleanup' });\r\n    }\r\n    \r\n    return reclaimed;\r\n  }\r\n\r\n  /**\r\n   * Cleanup large buffers\r\n   */\r\n  cleanupLargeBuffers() {\r\n    let reclaimed = 0;\r\n    const largeBufferThreshold = 5 * 1024 * 1024; // 5MB\r\n    const toRemove = [];\r\n    \r\n    // Sort by size (largest first)\r\n    const sortedAllocations = Array.from(this.allocatedBuffers.entries())\r\n      .sort(([, a], [, b]) => b.size - a.size);\r\n    \r\n    for (const [bufferId, allocation] of sortedAllocations) {\r\n      if (allocation.size > largeBufferThreshold && !allocation.metadata.pinned) {\r\n        toRemove.push(bufferId);\r\n        reclaimed += allocation.size;\r\n        \r\n        // Stop after reclaiming significant memory\r\n        if (reclaimed > this.maxMemoryThreshold * 0.2) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    \r\n    for (const bufferId of toRemove) {\r\n      this.deallocateBuffer(bufferId, { poolForReuse: false, reason: 'size-cleanup' });\r\n    }\r\n    \r\n    return reclaimed;\r\n  }\r\n\r\n  /**\r\n   * Force garbage collection if available\r\n   */\r\n  forceGarbageCollection() {\r\n    if (typeof gc === 'function') {\r\n      try {\r\n        gc();\r\n        this.performanceMetrics.gcTriggers++;\r\n        return true;\r\n      } catch (error) {\r\n        console.warn('Garbage collection failed:', error);\r\n      }\r\n    }\r\n    \r\n    // Fallback: create memory pressure to trigger GC\r\n    try {\r\n      const tempArrays = [];\r\n      for (let i = 0; i < 100; i++) {\r\n        tempArrays.push(new Float32Array(1024));\r\n      }\r\n      // Let arrays go out of scope\r\n    } catch (error) {\r\n      // Ignore allocation errors\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Emergency cleanup - remove all non-pinned allocations\r\n   */\r\n  emergencyCleanup() {\r\n    let reclaimed = 0;\r\n    const toRemove = [];\r\n    \r\n    // Remove all non-pinned allocations\r\n    for (const [bufferId, allocation] of this.allocatedBuffers) {\r\n      if (!allocation.metadata.pinned) {\r\n        toRemove.push(bufferId);\r\n        reclaimed += allocation.size;\r\n      }\r\n    }\r\n    \r\n    for (const bufferId of toRemove) {\r\n      this.deallocateBuffer(bufferId, { poolForReuse: false, reason: 'emergency' });\r\n    }\r\n    \r\n    // Clear buffer pool\r\n    this.bufferPool.clear();\r\n    this.memoryUsage.pooled = 0;\r\n    \r\n    // Force GC\r\n    this.forceGarbageCollection();\r\n    \r\n    console.warn(`Emergency cleanup reclaimed ${this.formatBytes(reclaimed)}`);\r\n    return reclaimed;\r\n  }\r\n\r\n  /**\r\n   * Pin buffer to prevent cleanup\r\n   */\r\n  pinBuffer(bufferId, reason = 'user-request') {\r\n    const allocation = this.allocatedBuffers.get(bufferId);\r\n    if (allocation) {\r\n      allocation.metadata.pinned = true;\r\n      allocation.metadata.pinnedReason = reason;\r\n      allocation.metadata.pinnedAt = Date.now();\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Unpin buffer to allow cleanup\r\n   */\r\n  unpinBuffer(bufferId) {\r\n    const allocation = this.allocatedBuffers.get(bufferId);\r\n    if (allocation) {\r\n      allocation.metadata.pinned = false;\r\n      delete allocation.metadata.pinnedReason;\r\n      delete allocation.metadata.pinnedAt;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Get current memory usage\r\n   */\r\n  getCurrentMemoryUsage() {\r\n    // Try to get actual memory usage if available\r\n    if (typeof performance !== 'undefined' && performance.memory) {\r\n      return performance.memory.usedJSHeapSize;\r\n    }\r\n    \r\n    // Fallback to tracked usage\r\n    return this.memoryUsage.current + this.memoryUsage.pooled;\r\n  }\r\n\r\n  /**\r\n   * Check memory pressure and trigger cleanup if needed\r\n   */\r\n  checkMemoryPressure() {\r\n    const currentUsage = this.getCurrentMemoryUsage();\r\n    const pressureLevel = this.calculateMemoryPressure(currentUsage);\r\n    \r\n    if (pressureLevel > 0.8) {\r\n      this.performAutomaticCleanup();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate memory pressure level (0-1)\r\n   */\r\n  calculateMemoryPressure(currentUsage) {\r\n    return Math.min(1, currentUsage / this.maxMemoryThreshold);\r\n  }\r\n\r\n  /**\r\n   * Handle memory pressure events\r\n   */\r\n  handleMemoryPressure(entry) {\r\n    console.warn('Memory pressure detected:', entry);\r\n    this.performAutomaticCleanup();\r\n  }\r\n\r\n  /**\r\n   * Update cleanup metrics\r\n   */\r\n  updateCleanupMetrics(cleanupTime, memoryReclaimed) {\r\n    this.performanceMetrics.cleanupCount++;\r\n    this.performanceMetrics.memoryReclaimed += memoryReclaimed;\r\n    \r\n    const avgTime = this.performanceMetrics.averageCleanupTime;\r\n    const count = this.performanceMetrics.cleanupCount;\r\n    this.performanceMetrics.averageCleanupTime = \r\n      (avgTime * (count - 1) + cleanupTime) / count;\r\n  }\r\n\r\n  /**\r\n   * Generate unique buffer ID\r\n   */\r\n  generateBufferId() {\r\n    return `buffer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  /**\r\n   * Format bytes for display\r\n   */\r\n  formatBytes(bytes) {\r\n    if (bytes === 0) return '0 Bytes';\r\n    \r\n    const k = 1024;\r\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\r\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\r\n    \r\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\r\n  }\r\n\r\n  /**\r\n   * Get memory statistics\r\n   */\r\n  getMemoryStats() {\r\n    const currentUsage = this.getCurrentMemoryUsage();\r\n    const pressureLevel = this.calculateMemoryPressure(currentUsage);\r\n    \r\n    return {\r\n      usage: {\r\n        current: currentUsage,\r\n        peak: this.memoryUsage.peak,\r\n        allocated: this.memoryUsage.allocated,\r\n        pooled: this.memoryUsage.pooled,\r\n        formatted: {\r\n          current: this.formatBytes(currentUsage),\r\n          peak: this.formatBytes(this.memoryUsage.peak),\r\n          allocated: this.formatBytes(this.memoryUsage.allocated),\r\n          pooled: this.formatBytes(this.memoryUsage.pooled)\r\n        }\r\n      },\r\n      thresholds: {\r\n        warning: this.warningThreshold,\r\n        max: this.maxMemoryThreshold,\r\n        aggressive: this.aggressiveCleanupThreshold,\r\n        formatted: {\r\n          warning: this.formatBytes(this.warningThreshold),\r\n          max: this.formatBytes(this.maxMemoryThreshold),\r\n          aggressive: this.formatBytes(this.aggressiveCleanupThreshold)\r\n        }\r\n      },\r\n      pressure: {\r\n        level: pressureLevel,\r\n        status: pressureLevel > 0.8 ? 'high' : pressureLevel > 0.6 ? 'medium' : 'low'\r\n      },\r\n      allocations: {\r\n        count: this.allocatedBuffers.size,\r\n        pooledBuffers: Array.from(this.bufferPool.values()).reduce((sum, pool) => sum + pool.length, 0),\r\n        pinnedBuffers: Array.from(this.allocatedBuffers.values()).filter(a => a.metadata.pinned).length\r\n      },\r\n      performance: this.performanceMetrics\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Destroy memory manager and cleanup resources\r\n   */\r\n  destroy() {\r\n    // Clear cleanup timer\r\n    if (this.cleanupTimer) {\r\n      clearInterval(this.cleanupTimer);\r\n      this.cleanupTimer = null;\r\n    }\r\n    \r\n    // Disconnect memory pressure observer\r\n    if (this.memoryPressureObserver) {\r\n      this.memoryPressureObserver.disconnect();\r\n      this.memoryPressureObserver = null;\r\n    }\r\n    \r\n    // Emergency cleanup\r\n    this.emergencyCleanup();\r\n    \r\n    // Clear all data structures\r\n    this.allocatedBuffers.clear();\r\n    this.bufferPool.clear();\r\n    this.cleanupStrategies.clear();\r\n  }\r\n}\r\n\r\nexport default WaveformMemoryManager;","/**\r\n * Performance monitoring and graceful degradation for resource-constrained environments\r\n * Implements adaptive quality settings and performance optimization\r\n * Requirements: 7.4, 7.5\r\n */\r\n\r\nexport class WaveformPerformanceMonitor {\r\n  constructor(options = {}) {\r\n    this.options = {\r\n      targetFPS: options.targetFPS || 60,\r\n      minFPS: options.minFPS || 30,\r\n      performanceWindow: options.performanceWindow || 5000, // 5 seconds\r\n      degradationThreshold: options.degradationThreshold || 0.7, // 70% of target\r\n      recoveryThreshold: options.recoveryThreshold || 0.9, // 90% of target\r\n      maxDegradationLevel: options.maxDegradationLevel || 3,\r\n      ...options\r\n    };\r\n    \r\n    // Performance tracking\r\n    this.metrics = {\r\n      fps: {\r\n        current: 0,\r\n        average: 0,\r\n        min: Infinity,\r\n        max: 0,\r\n        samples: []\r\n      },\r\n      renderTime: {\r\n        current: 0,\r\n        average: 0,\r\n        min: Infinity,\r\n        max: 0,\r\n        samples: []\r\n      },\r\n      memoryUsage: {\r\n        current: 0,\r\n        peak: 0,\r\n        trend: 'stable' // 'increasing', 'decreasing', 'stable'\r\n      },\r\n      cpuUsage: {\r\n        estimated: 0,\r\n        trend: 'stable'\r\n      }\r\n    };\r\n    \r\n    // Performance state\r\n    this.currentQualityLevel = 'high';\r\n    this.degradationLevel = 0;\r\n    this.isMonitoring = false;\r\n    this.adaptiveSettings = this.getDefaultAdaptiveSettings();\r\n    \r\n    // Callbacks for quality changes\r\n    this.qualityChangeCallbacks = new Set();\r\n    this.performanceWarningCallbacks = new Set();\r\n    \r\n    // Monitoring intervals\r\n    this.monitoringInterval = null;\r\n    this.metricsCollectionInterval = null;\r\n    \r\n    // Frame timing\r\n    this.lastFrameTime = 0;\r\n    this.frameCount = 0;\r\n    this.renderStartTime = 0;\r\n    \r\n    // Device capabilities detection\r\n    this.deviceCapabilities = null;\r\n    this.detectDeviceCapabilities();\r\n  }\r\n\r\n  /**\r\n   * Start performance monitoring\r\n   */\r\n  startMonitoring() {\r\n    if (this.isMonitoring) return;\r\n    \r\n    this.isMonitoring = true;\r\n    this.lastFrameTime = performance.now();\r\n    \r\n    // Start metrics collection\r\n    this.metricsCollectionInterval = setInterval(() => {\r\n      this.collectMetrics();\r\n    }, 1000); // Collect every second\r\n    \r\n    // Start performance analysis\r\n    this.monitoringInterval = setInterval(() => {\r\n      this.analyzePerformance();\r\n    }, this.options.performanceWindow);\r\n    \r\n    console.log('Performance monitoring started');\r\n  }\r\n\r\n  /**\r\n   * Stop performance monitoring\r\n   */\r\n  stopMonitoring() {\r\n    if (!this.isMonitoring) return;\r\n    \r\n    this.isMonitoring = false;\r\n    \r\n    if (this.metricsCollectionInterval) {\r\n      clearInterval(this.metricsCollectionInterval);\r\n      this.metricsCollectionInterval = null;\r\n    }\r\n    \r\n    if (this.monitoringInterval) {\r\n      clearInterval(this.monitoringInterval);\r\n      this.monitoringInterval = null;\r\n    }\r\n    \r\n    console.log('Performance monitoring stopped');\r\n  }\r\n\r\n  /**\r\n   * Record frame render start\r\n   */\r\n  frameRenderStart() {\r\n    this.renderStartTime = performance.now();\r\n  }\r\n\r\n  /**\r\n   * Record frame render end and calculate metrics\r\n   */\r\n  frameRenderEnd() {\r\n    const now = performance.now();\r\n    const renderTime = now - this.renderStartTime;\r\n    const frameTime = now - this.lastFrameTime;\r\n    \r\n    // Calculate FPS\r\n    const fps = frameTime > 0 ? 1000 / frameTime : 0;\r\n    \r\n    // Update metrics\r\n    this.updateFPSMetrics(fps);\r\n    this.updateRenderTimeMetrics(renderTime);\r\n    \r\n    this.lastFrameTime = now;\r\n    this.frameCount++;\r\n    \r\n    // Check for immediate performance issues\r\n    if (fps < this.options.minFPS) {\r\n      this.handleLowPerformance('fps', fps);\r\n    }\r\n    \r\n    if (renderTime > 33) { // More than 2 frames at 60fps\r\n      this.handleLowPerformance('renderTime', renderTime);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update FPS metrics\r\n   */\r\n  updateFPSMetrics(fps) {\r\n    this.metrics.fps.current = fps;\r\n    this.metrics.fps.min = Math.min(this.metrics.fps.min, fps);\r\n    this.metrics.fps.max = Math.max(this.metrics.fps.max, fps);\r\n    \r\n    // Keep sliding window of samples\r\n    this.metrics.fps.samples.push(fps);\r\n    if (this.metrics.fps.samples.length > 60) { // Keep last 60 samples\r\n      this.metrics.fps.samples.shift();\r\n    }\r\n    \r\n    // Calculate average\r\n    this.metrics.fps.average = this.metrics.fps.samples.reduce((sum, sample) => sum + sample, 0) / this.metrics.fps.samples.length;\r\n  }\r\n\r\n  /**\r\n   * Update render time metrics\r\n   */\r\n  updateRenderTimeMetrics(renderTime) {\r\n    this.metrics.renderTime.current = renderTime;\r\n    this.metrics.renderTime.min = Math.min(this.metrics.renderTime.min, renderTime);\r\n    this.metrics.renderTime.max = Math.max(this.metrics.renderTime.max, renderTime);\r\n    \r\n    // Keep sliding window of samples\r\n    this.metrics.renderTime.samples.push(renderTime);\r\n    if (this.metrics.renderTime.samples.length > 60) {\r\n      this.metrics.renderTime.samples.shift();\r\n    }\r\n    \r\n    // Calculate average\r\n    this.metrics.renderTime.average = this.metrics.renderTime.samples.reduce((sum, sample) => sum + sample, 0) / this.metrics.renderTime.samples.length;\r\n  }\r\n\r\n  /**\r\n   * Collect system metrics\r\n   */\r\n  collectMetrics() {\r\n    // Memory usage\r\n    if (typeof performance !== 'undefined' && performance.memory) {\r\n      const memoryUsage = performance.memory.usedJSHeapSize;\r\n      this.metrics.memoryUsage.current = memoryUsage;\r\n      this.metrics.memoryUsage.peak = Math.max(this.metrics.memoryUsage.peak, memoryUsage);\r\n      \r\n      // Detect memory trend\r\n      this.updateMemoryTrend(memoryUsage);\r\n    }\r\n    \r\n    // Estimate CPU usage based on frame timing\r\n    this.estimateCPUUsage();\r\n  }\r\n\r\n  /**\r\n   * Update memory usage trend\r\n   */\r\n  updateMemoryTrend(currentMemory) {\r\n    if (!this.lastMemoryReading) {\r\n      this.lastMemoryReading = currentMemory;\r\n      return;\r\n    }\r\n    \r\n    const change = currentMemory - this.lastMemoryReading;\r\n    const changePercent = Math.abs(change) / this.lastMemoryReading;\r\n    \r\n    if (changePercent > 0.05) { // 5% change threshold\r\n      this.metrics.memoryUsage.trend = change > 0 ? 'increasing' : 'decreasing';\r\n    } else {\r\n      this.metrics.memoryUsage.trend = 'stable';\r\n    }\r\n    \r\n    this.lastMemoryReading = currentMemory;\r\n  }\r\n\r\n  /**\r\n   * Estimate CPU usage based on render performance\r\n   */\r\n  estimateCPUUsage() {\r\n    const targetRenderTime = 1000 / this.options.targetFPS;\r\n    const actualRenderTime = this.metrics.renderTime.average;\r\n    \r\n    // Rough estimation: higher render time indicates higher CPU usage\r\n    const estimatedUsage = Math.min(1, actualRenderTime / targetRenderTime);\r\n    this.metrics.cpuUsage.estimated = estimatedUsage;\r\n    \r\n    // Detect CPU trend\r\n    if (!this.lastCPUReading) {\r\n      this.lastCPUReading = estimatedUsage;\r\n      return;\r\n    }\r\n    \r\n    const change = estimatedUsage - this.lastCPUReading;\r\n    if (Math.abs(change) > 0.1) { // 10% change threshold\r\n      this.metrics.cpuUsage.trend = change > 0 ? 'increasing' : 'decreasing';\r\n    } else {\r\n      this.metrics.cpuUsage.trend = 'stable';\r\n    }\r\n    \r\n    this.lastCPUReading = estimatedUsage;\r\n  }\r\n\r\n  /**\r\n   * Analyze performance and trigger adaptations\r\n   */\r\n  analyzePerformance() {\r\n    const performanceScore = this.calculatePerformanceScore();\r\n    const shouldDegrade = performanceScore < this.options.degradationThreshold;\r\n    const shouldRecover = performanceScore > this.options.recoveryThreshold;\r\n    \r\n    if (shouldDegrade && this.degradationLevel < this.options.maxDegradationLevel) {\r\n      this.degradeQuality();\r\n    } else if (shouldRecover && this.degradationLevel > 0) {\r\n      this.improveQuality();\r\n    }\r\n    \r\n    // Check for critical performance issues\r\n    this.checkCriticalPerformance();\r\n  }\r\n\r\n  /**\r\n   * Calculate overall performance score (0-1)\r\n   */\r\n  calculatePerformanceScore() {\r\n    const fpsScore = Math.min(1, this.metrics.fps.average / this.options.targetFPS);\r\n    const renderTimeScore = Math.min(1, (1000 / this.options.targetFPS) / this.metrics.renderTime.average);\r\n    const memoryScore = this.calculateMemoryScore();\r\n    const cpuScore = 1 - this.metrics.cpuUsage.estimated;\r\n    \r\n    // Weighted average\r\n    return (fpsScore * 0.4 + renderTimeScore * 0.3 + memoryScore * 0.2 + cpuScore * 0.1);\r\n  }\r\n\r\n  /**\r\n   * Calculate memory performance score\r\n   */\r\n  calculateMemoryScore() {\r\n    if (!this.deviceCapabilities || !this.deviceCapabilities.memoryLimit) {\r\n      return 1; // Assume good if we can't measure\r\n    }\r\n    \r\n    const memoryUsageRatio = this.metrics.memoryUsage.current / this.deviceCapabilities.memoryLimit;\r\n    return Math.max(0, 1 - memoryUsageRatio);\r\n  }\r\n\r\n  /**\r\n   * Degrade quality to improve performance\r\n   */\r\n  degradeQuality() {\r\n    this.degradationLevel++;\r\n    \r\n    const newSettings = this.getAdaptiveSettings(this.degradationLevel);\r\n    this.applyAdaptiveSettings(newSettings);\r\n    \r\n    const qualityLevel = this.getQualityLevelName(this.degradationLevel);\r\n    console.log(`Performance degradation: level ${this.degradationLevel} (${qualityLevel})`);\r\n    \r\n    this.notifyQualityChange(qualityLevel, 'degraded', {\r\n      reason: 'performance',\r\n      score: this.calculatePerformanceScore(),\r\n      level: this.degradationLevel\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Improve quality when performance allows\r\n   */\r\n  improveQuality() {\r\n    this.degradationLevel--;\r\n    \r\n    const newSettings = this.getAdaptiveSettings(this.degradationLevel);\r\n    this.applyAdaptiveSettings(newSettings);\r\n    \r\n    const qualityLevel = this.getQualityLevelName(this.degradationLevel);\r\n    console.log(`Performance recovery: level ${this.degradationLevel} (${qualityLevel})`);\r\n    \r\n    this.notifyQualityChange(qualityLevel, 'improved', {\r\n      reason: 'performance-recovery',\r\n      score: this.calculatePerformanceScore(),\r\n      level: this.degradationLevel\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get adaptive settings for degradation level\r\n   */\r\n  getAdaptiveSettings(level) {\r\n    const settings = this.getDefaultAdaptiveSettings();\r\n    \r\n    switch (level) {\r\n      case 0: // High quality\r\n        return settings;\r\n        \r\n      case 1: // Medium-high quality\r\n        return {\r\n          ...settings,\r\n          renderQuality: 'medium',\r\n          waveformResolution: 0.8,\r\n          enableAntialiasing: true,\r\n          maxBatchSize: 800\r\n        };\r\n        \r\n      case 2: // Medium quality\r\n        return {\r\n          ...settings,\r\n          renderQuality: 'medium',\r\n          waveformResolution: 0.6,\r\n          enableAntialiasing: false,\r\n          maxBatchSize: 600,\r\n          enableViewportCulling: true,\r\n          chopRenderingDetail: 'medium'\r\n        };\r\n        \r\n      case 3: // Low quality\r\n        return {\r\n          ...settings,\r\n          renderQuality: 'low',\r\n          waveformResolution: 0.4,\r\n          enableAntialiasing: false,\r\n          maxBatchSize: 400,\r\n          enableViewportCulling: true,\r\n          chopRenderingDetail: 'low',\r\n          disableAnimations: true,\r\n          simplifiedRendering: true\r\n        };\r\n        \r\n      default:\r\n        return settings;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get default adaptive settings\r\n   */\r\n  getDefaultAdaptiveSettings() {\r\n    return {\r\n      renderQuality: 'high',\r\n      waveformResolution: 1.0,\r\n      enableAntialiasing: true,\r\n      maxBatchSize: 1000,\r\n      enableViewportCulling: true,\r\n      chopRenderingDetail: 'high',\r\n      disableAnimations: false,\r\n      simplifiedRendering: false,\r\n      targetFPS: this.options.targetFPS\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Apply adaptive settings\r\n   */\r\n  applyAdaptiveSettings(settings) {\r\n    this.adaptiveSettings = { ...settings };\r\n    this.currentQualityLevel = this.getQualityLevelName(this.degradationLevel);\r\n  }\r\n\r\n  /**\r\n   * Get quality level name\r\n   */\r\n  getQualityLevelName(level) {\r\n    const levels = ['high', 'medium-high', 'medium', 'low'];\r\n    return levels[Math.min(level, levels.length - 1)];\r\n  }\r\n\r\n  /**\r\n   * Handle immediate low performance\r\n   */\r\n  handleLowPerformance(metric, value) {\r\n    this.notifyPerformanceWarning({\r\n      metric,\r\n      value,\r\n      threshold: metric === 'fps' ? this.options.minFPS : 33,\r\n      timestamp: Date.now(),\r\n      currentQuality: this.currentQualityLevel,\r\n      degradationLevel: this.degradationLevel\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check for critical performance issues\r\n   */\r\n  checkCriticalPerformance() {\r\n    const criticalIssues = [];\r\n    \r\n    // Critical FPS drop\r\n    if (this.metrics.fps.average < this.options.minFPS * 0.5) {\r\n      criticalIssues.push({\r\n        type: 'critical-fps',\r\n        value: this.metrics.fps.average,\r\n        threshold: this.options.minFPS * 0.5\r\n      });\r\n    }\r\n    \r\n    // Critical memory usage\r\n    if (this.deviceCapabilities && this.deviceCapabilities.memoryLimit) {\r\n      const memoryUsageRatio = this.metrics.memoryUsage.current / this.deviceCapabilities.memoryLimit;\r\n      if (memoryUsageRatio > 0.9) {\r\n        criticalIssues.push({\r\n          type: 'critical-memory',\r\n          value: memoryUsageRatio,\r\n          threshold: 0.9\r\n        });\r\n      }\r\n    }\r\n    \r\n    // Critical render time\r\n    if (this.metrics.renderTime.average > 100) { // More than 6 frames at 60fps\r\n      criticalIssues.push({\r\n        type: 'critical-render-time',\r\n        value: this.metrics.renderTime.average,\r\n        threshold: 100\r\n      });\r\n    }\r\n    \r\n    if (criticalIssues.length > 0) {\r\n      this.handleCriticalPerformance(criticalIssues);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle critical performance issues\r\n   */\r\n  handleCriticalPerformance(issues) {\r\n    console.error('Critical performance issues detected:', issues);\r\n    \r\n    // Force maximum degradation\r\n    this.degradationLevel = this.options.maxDegradationLevel;\r\n    const emergencySettings = this.getEmergencySettings();\r\n    this.applyAdaptiveSettings(emergencySettings);\r\n    \r\n    this.notifyPerformanceWarning({\r\n      type: 'critical',\r\n      issues,\r\n      emergencyMode: true,\r\n      timestamp: Date.now()\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get emergency performance settings\r\n   */\r\n  getEmergencySettings() {\r\n    return {\r\n      renderQuality: 'low',\r\n      waveformResolution: 0.2,\r\n      enableAntialiasing: false,\r\n      maxBatchSize: 200,\r\n      enableViewportCulling: true,\r\n      chopRenderingDetail: 'minimal',\r\n      disableAnimations: true,\r\n      simplifiedRendering: true,\r\n      emergencyMode: true,\r\n      targetFPS: Math.max(15, this.options.minFPS * 0.5)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Detect device capabilities\r\n   */\r\n  detectDeviceCapabilities() {\r\n    this.deviceCapabilities = {\r\n      // Memory\r\n      memoryLimit: this.detectMemoryLimit(),\r\n      \r\n      // CPU estimation\r\n      cpuCores: navigator.hardwareConcurrency || 4,\r\n      \r\n      // GPU capabilities\r\n      webglSupport: this.detectWebGLSupport(),\r\n      \r\n      // Browser capabilities\r\n      performanceAPISupport: typeof performance !== 'undefined' && !!performance.memory,\r\n      \r\n      // Device type estimation\r\n      deviceType: this.detectDeviceType(),\r\n      \r\n      // Connection quality\r\n      connectionType: this.detectConnectionType()\r\n    };\r\n    \r\n    console.log('Device capabilities detected:', this.deviceCapabilities);\r\n  }\r\n\r\n  /**\r\n   * Detect memory limit\r\n   */\r\n  detectMemoryLimit() {\r\n    if (typeof performance !== 'undefined' && performance.memory) {\r\n      return performance.memory.jsHeapSizeLimit;\r\n    }\r\n    \r\n    // Fallback estimation based on device type\r\n    const deviceType = this.detectDeviceType();\r\n    switch (deviceType) {\r\n      case 'mobile': return 100 * 1024 * 1024; // 100MB\r\n      case 'tablet': return 200 * 1024 * 1024; // 200MB\r\n      case 'desktop': return 500 * 1024 * 1024; // 500MB\r\n      default: return 200 * 1024 * 1024; // 200MB default\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect WebGL support\r\n   */\r\n  detectWebGLSupport() {\r\n    try {\r\n      // Check if we're in a test environment\r\n      if (typeof document === 'undefined' || typeof HTMLCanvasElement === 'undefined') {\r\n        return false;\r\n      }\r\n      \r\n      const canvas = document.createElement('canvas');\r\n      const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');\r\n      return !!gl;\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect device type\r\n   */\r\n  detectDeviceType() {\r\n    const userAgent = navigator.userAgent.toLowerCase();\r\n    \r\n    if (/mobile|android|iphone|ipod|blackberry|iemobile|opera mini/i.test(userAgent)) {\r\n      return 'mobile';\r\n    } else if (/tablet|ipad/i.test(userAgent)) {\r\n      return 'tablet';\r\n    } else {\r\n      return 'desktop';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect connection type\r\n   */\r\n  detectConnectionType() {\r\n    if (navigator.connection) {\r\n      return {\r\n        effectiveType: navigator.connection.effectiveType,\r\n        downlink: navigator.connection.downlink,\r\n        rtt: navigator.connection.rtt\r\n      };\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Add quality change callback\r\n   */\r\n  onQualityChange(callback) {\r\n    this.qualityChangeCallbacks.add(callback);\r\n    return () => this.qualityChangeCallbacks.delete(callback);\r\n  }\r\n\r\n  /**\r\n   * Add performance warning callback\r\n   */\r\n  onPerformanceWarning(callback) {\r\n    this.performanceWarningCallbacks.add(callback);\r\n    return () => this.performanceWarningCallbacks.delete(callback);\r\n  }\r\n\r\n  /**\r\n   * Notify quality change\r\n   */\r\n  notifyQualityChange(newQuality, changeType, details) {\r\n    const event = {\r\n      newQuality,\r\n      changeType,\r\n      details,\r\n      settings: this.adaptiveSettings,\r\n      timestamp: Date.now()\r\n    };\r\n    \r\n    this.qualityChangeCallbacks.forEach(callback => {\r\n      try {\r\n        callback(event);\r\n      } catch (error) {\r\n        console.error('Quality change callback error:', error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Notify performance warning\r\n   */\r\n  notifyPerformanceWarning(warning) {\r\n    this.performanceWarningCallbacks.forEach(callback => {\r\n      try {\r\n        callback(warning);\r\n      } catch (error) {\r\n        console.error('Performance warning callback error:', error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get current performance metrics\r\n   */\r\n  getMetrics() {\r\n    return {\r\n      ...this.metrics,\r\n      performanceScore: this.calculatePerformanceScore(),\r\n      qualityLevel: this.currentQualityLevel,\r\n      degradationLevel: this.degradationLevel,\r\n      adaptiveSettings: this.adaptiveSettings,\r\n      deviceCapabilities: this.deviceCapabilities\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get current adaptive settings\r\n   */\r\n  getAdaptiveSettings() {\r\n    return { ...this.adaptiveSettings };\r\n  }\r\n\r\n  /**\r\n   * Force quality level\r\n   */\r\n  forceQualityLevel(level) {\r\n    const levelMap = { 'high': 0, 'medium-high': 1, 'medium': 2, 'low': 3 };\r\n    const degradationLevel = levelMap[level] || 0;\r\n    \r\n    this.degradationLevel = degradationLevel;\r\n    const settings = this.getAdaptiveSettings(degradationLevel);\r\n    this.applyAdaptiveSettings(settings);\r\n    \r\n    this.notifyQualityChange(level, 'forced', {\r\n      reason: 'user-override',\r\n      level: degradationLevel\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Reset to default quality\r\n   */\r\n  resetQuality() {\r\n    this.degradationLevel = 0;\r\n    const settings = this.getDefaultAdaptiveSettings();\r\n    this.applyAdaptiveSettings(settings);\r\n    \r\n    this.notifyQualityChange('high', 'reset', {\r\n      reason: 'user-reset'\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Destroy performance monitor\r\n   */\r\n  destroy() {\r\n    this.stopMonitoring();\r\n    this.qualityChangeCallbacks.clear();\r\n    this.performanceWarningCallbacks.clear();\r\n  }\r\n}\r\n\r\nexport default WaveformPerformanceMonitor;","/**\r\n * Main performance optimization service that integrates Web Workers, caching, and memory management\r\n * Provides unified interface for all performance optimization features\r\n * Requirements: 7.2, 7.3, 7.4, 7.5\r\n */\r\n\r\nimport WaveformCache from './WaveformCache.js';\r\nimport WaveformMemoryManager from './WaveformMemoryManager.js';\r\nimport WaveformPerformanceMonitor from './WaveformPerformanceMonitor.js';\r\n\r\nexport class WaveformPerformanceOptimizer {\r\n  constructor(options = {}) {\r\n    this.options = {\r\n      enableWebWorkers: options.enableWebWorkers !== false,\r\n      enableCaching: options.enableCaching !== false,\r\n      enableMemoryManagement: options.enableMemoryManagement !== false,\r\n      enablePerformanceMonitoring: options.enablePerformanceMonitoring !== false,\r\n      workerPoolSize: options.workerPoolSize || 2,\r\n      ...options\r\n    };\r\n    \r\n    // Initialize components\r\n    this.cache = null;\r\n    this.memoryManager = null;\r\n    this.performanceMonitor = null;\r\n    this.workerPool = [];\r\n    this.workerQueue = [];\r\n    \r\n    // State tracking\r\n    this.isInitialized = false;\r\n    this.activeWorkerTasks = new Map();\r\n    this.taskIdCounter = 0;\r\n    \r\n    // Performance metrics\r\n    this.metrics = {\r\n      workerTasks: {\r\n        completed: 0,\r\n        failed: 0,\r\n        averageTime: 0,\r\n        queueLength: 0\r\n      },\r\n      cachePerformance: {\r\n        hits: 0,\r\n        misses: 0,\r\n        hitRate: 0\r\n      },\r\n      memoryOptimization: {\r\n        cleanupCount: 0,\r\n        memoryReclaimed: 0,\r\n        currentUsage: 0\r\n      },\r\n      overallPerformance: {\r\n        score: 1.0,\r\n        qualityLevel: 'high',\r\n        degradationLevel: 0\r\n      }\r\n    };\r\n    \r\n    this.initialize();\r\n  }\r\n\r\n  /**\r\n   * Initialize all performance optimization components\r\n   */\r\n  async initialize() {\r\n    if (this.isInitialized) return;\r\n    \r\n    try {\r\n      // Initialize caching system\r\n      if (this.options.enableCaching) {\r\n        this.cache = new WaveformCache({\r\n          maxMemorySize: this.options.cacheMaxMemory || 100 * 1024 * 1024,\r\n          maxCacheEntries: this.options.cacheMaxEntries || 50,\r\n          persistenceEnabled: this.options.cachePersistence !== false,\r\n          compressionEnabled: this.options.cacheCompression !== false\r\n        });\r\n        \r\n        await this.cache.initializePersistence();\r\n      }\r\n      \r\n      // Initialize memory management\r\n      if (this.options.enableMemoryManagement) {\r\n        this.memoryManager = new WaveformMemoryManager({\r\n          maxMemoryThreshold: this.options.memoryMaxThreshold || 150 * 1024 * 1024,\r\n          warningThreshold: this.options.memoryWarningThreshold || 100 * 1024 * 1024,\r\n          cleanupInterval: this.options.memoryCleanupInterval || 30 * 1000\r\n        });\r\n      }\r\n      \r\n      // Initialize performance monitoring\r\n      if (this.options.enablePerformanceMonitoring) {\r\n        this.performanceMonitor = new WaveformPerformanceMonitor({\r\n          targetFPS: this.options.targetFPS || 60,\r\n          minFPS: this.options.minFPS || 30,\r\n          degradationThreshold: this.options.degradationThreshold || 0.7,\r\n          recoveryThreshold: this.options.recoveryThreshold || 0.9\r\n        });\r\n        \r\n        // Set up performance monitoring callbacks\r\n        this.setupPerformanceCallbacks();\r\n        this.performanceMonitor.startMonitoring();\r\n      }\r\n      \r\n      // Initialize Web Worker pool\r\n      if (this.options.enableWebWorkers) {\r\n        await this.initializeWorkerPool();\r\n      }\r\n      \r\n      this.isInitialized = true;\r\n      console.log('WaveformPerformanceOptimizer initialized successfully');\r\n      \r\n    } catch (error) {\r\n      console.error('Failed to initialize WaveformPerformanceOptimizer:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize Web Worker pool\r\n   */\r\n  async initializeWorkerPool() {\r\n    try {\r\n      // Handle test environment where import.meta.url might not be available\r\n      let workerScript;\r\n      try {\r\n        workerScript = new URL('../workers/WaveformWorker.js', import.meta.url);\r\n      } catch (error) {\r\n        // Fallback for test environment\r\n        workerScript = '../workers/WaveformWorker.js';\r\n      }\r\n      \r\n      for (let i = 0; i < this.options.workerPoolSize; i++) {\r\n        try {\r\n          const worker = new Worker(workerScript, { type: 'module' });\r\n          \r\n          worker.onmessage = (event) => {\r\n            this.handleWorkerMessage(worker, event);\r\n          };\r\n          \r\n          worker.onerror = (error) => {\r\n            this.handleWorkerError(worker, error);\r\n          };\r\n          \r\n          this.workerPool.push({\r\n            worker,\r\n            id: i,\r\n            busy: false,\r\n            currentTask: null\r\n          });\r\n          \r\n        } catch (error) {\r\n          console.warn(`Failed to create worker ${i}:`, error);\r\n        }\r\n      }\r\n      \r\n      console.log(`Initialized ${this.workerPool.length} Web Workers`);\r\n    } catch (error) {\r\n      console.warn('Failed to initialize worker pool:', error);\r\n      // Continue without workers\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Setup performance monitoring callbacks\r\n   */\r\n  setupPerformanceCallbacks() {\r\n    if (!this.performanceMonitor) return;\r\n    \r\n    // Handle quality changes\r\n    this.performanceMonitor.onQualityChange((event) => {\r\n      this.handleQualityChange(event);\r\n    });\r\n    \r\n    // Handle performance warnings\r\n    this.performanceMonitor.onPerformanceWarning((warning) => {\r\n      this.handlePerformanceWarning(warning);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Generate waveform with full optimization pipeline\r\n   */\r\n  async generateOptimizedWaveform(audioSource, options = {}) {\r\n    const startTime = performance.now();\r\n    \r\n    try {\r\n      // Record frame render start for performance monitoring\r\n      if (this.performanceMonitor) {\r\n        this.performanceMonitor.frameRenderStart();\r\n      }\r\n      \r\n      // Check cache first\r\n      let waveformData = null;\r\n      if (this.cache) {\r\n        const cacheKey = this.cache.generateCacheKey(audioSource, options);\r\n        waveformData = await this.cache.get(cacheKey);\r\n        \r\n        if (waveformData) {\r\n          this.updateCacheMetrics(true);\r\n          console.log('Waveform loaded from cache');\r\n          return waveformData;\r\n        } else {\r\n          this.updateCacheMetrics(false);\r\n        }\r\n      }\r\n      \r\n      // Get current adaptive settings for quality optimization\r\n      const adaptiveSettings = this.getAdaptiveSettings();\r\n      const optimizedOptions = {\r\n        ...options,\r\n        ...adaptiveSettings,\r\n        quality: adaptiveSettings.renderQuality || options.quality || 'medium'\r\n      };\r\n      \r\n      // Generate waveform using appropriate method\r\n      if (this.options.enableWebWorkers && this.workerPool.length > 0) {\r\n        waveformData = await this.generateWaveformWithWorker(audioSource, optimizedOptions);\r\n      } else {\r\n        waveformData = await this.generateWaveformDirect(audioSource, optimizedOptions);\r\n      }\r\n      \r\n      // Cache the result\r\n      if (this.cache && waveformData) {\r\n        const cacheKey = this.cache.generateCacheKey(audioSource, options);\r\n        await this.cache.set(cacheKey, waveformData, {\r\n          generationTime: performance.now() - startTime,\r\n          quality: optimizedOptions.quality,\r\n          method: this.options.enableWebWorkers ? 'worker' : 'direct'\r\n        });\r\n      }\r\n      \r\n      // Record frame render end for performance monitoring\r\n      if (this.performanceMonitor) {\r\n        this.performanceMonitor.frameRenderEnd();\r\n      }\r\n      \r\n      return waveformData;\r\n      \r\n    } catch (error) {\r\n      console.error('Optimized waveform generation failed:', error);\r\n      \r\n      // Try fallback generation with reduced quality\r\n      if (options.quality !== 'low') {\r\n        console.log('Attempting fallback generation with low quality');\r\n        return this.generateOptimizedWaveform(audioSource, {\r\n          ...options,\r\n          quality: 'low',\r\n          fallback: true\r\n        });\r\n      }\r\n      \r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate waveform using Web Worker\r\n   */\r\n  async generateWaveformWithWorker(audioSource, options) {\r\n    return new Promise((resolve, reject) => {\r\n      const taskId = this.generateTaskId();\r\n      const task = {\r\n        id: taskId,\r\n        type: 'ANALYZE_WAVEFORM',\r\n        data: {\r\n          audioBuffer: audioSource.buffer || audioSource,\r\n          options\r\n        },\r\n        resolve,\r\n        reject,\r\n        startTime: performance.now()\r\n      };\r\n      \r\n      // Try to assign to available worker\r\n      const availableWorker = this.getAvailableWorker();\r\n      if (availableWorker) {\r\n        this.assignTaskToWorker(task, availableWorker);\r\n      } else {\r\n        // Queue task if no workers available\r\n        this.workerQueue.push(task);\r\n        this.updateWorkerMetrics();\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Generate waveform directly (fallback)\r\n   */\r\n  async generateWaveformDirect(audioSource, options) {\r\n    // Simplified direct generation for fallback\r\n    const audioBuffer = audioSource.buffer || audioSource;\r\n    if (!audioBuffer || !audioBuffer.length) {\r\n      throw new Error('Invalid audio buffer');\r\n    }\r\n    \r\n    const targetSampleRate = options.targetSampleRate || 1000;\r\n    const quality = options.quality || 'medium';\r\n    \r\n    // Allocate buffer using memory manager\r\n    let bufferId = null;\r\n    let outputBuffer = null;\r\n    \r\n    if (this.memoryManager) {\r\n      const allocation = this.memoryManager.allocateBuffer(\r\n        Math.floor(audioBuffer.length * targetSampleRate / 44100),\r\n        'waveform',\r\n        { source: 'direct-generation', quality }\r\n      );\r\n      bufferId = allocation.bufferId;\r\n      outputBuffer = allocation.buffer;\r\n    } else {\r\n      outputBuffer = new Float32Array(Math.floor(audioBuffer.length * targetSampleRate / 44100));\r\n    }\r\n    \r\n    try {\r\n      // Simple downsampling based on quality\r\n      const step = audioBuffer.length / outputBuffer.length;\r\n      \r\n      for (let i = 0; i < outputBuffer.length; i++) {\r\n        const sourceIndex = Math.floor(i * step);\r\n        \r\n        if (quality === 'high') {\r\n          // RMS calculation for better quality\r\n          let sum = 0;\r\n          const windowSize = Math.max(1, Math.floor(step));\r\n          for (let j = 0; j < windowSize && sourceIndex + j < audioBuffer.length; j++) {\r\n            const sample = audioBuffer[sourceIndex + j] || 0;\r\n            sum += sample * sample;\r\n          }\r\n          outputBuffer[i] = Math.sqrt(sum / windowSize);\r\n        } else {\r\n          // Simple sampling for performance\r\n          outputBuffer[i] = Math.abs(audioBuffer[sourceIndex] || 0);\r\n        }\r\n      }\r\n      \r\n      return {\r\n        samples: outputBuffer,\r\n        sampleRate: targetSampleRate,\r\n        duration: outputBuffer.length / targetSampleRate,\r\n        channels: 1,\r\n        metadata: {\r\n          analysisMethod: 'direct-optimized',\r\n          quality: quality,\r\n          generatedAt: Date.now(),\r\n          bufferId: bufferId\r\n        }\r\n      };\r\n      \r\n    } catch (error) {\r\n      // Clean up allocated buffer on error\r\n      if (bufferId && this.memoryManager) {\r\n        this.memoryManager.deallocateBuffer(bufferId, { poolForReuse: false });\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get available worker from pool\r\n   */\r\n  getAvailableWorker() {\r\n    return this.workerPool.find(workerInfo => !workerInfo.busy);\r\n  }\r\n\r\n  /**\r\n   * Assign task to worker\r\n   */\r\n  assignTaskToWorker(task, workerInfo) {\r\n    workerInfo.busy = true;\r\n    workerInfo.currentTask = task;\r\n    this.activeWorkerTasks.set(task.id, { task, workerInfo });\r\n    \r\n    workerInfo.worker.postMessage({\r\n      type: task.type,\r\n      taskId: task.id,\r\n      data: task.data\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle worker message\r\n   */\r\n  handleWorkerMessage(worker, event) {\r\n    const { type, taskId, data, error } = event.data;\r\n    const taskInfo = this.activeWorkerTasks.get(taskId);\r\n    \r\n    if (!taskInfo) {\r\n      console.warn(`Received message for unknown task: ${taskId}`);\r\n      return;\r\n    }\r\n    \r\n    const { task, workerInfo } = taskInfo;\r\n    \r\n    switch (type) {\r\n      case 'RESULT':\r\n        this.handleWorkerResult(task, data);\r\n        this.completeWorkerTask(taskId, workerInfo);\r\n        break;\r\n        \r\n      case 'ERROR':\r\n        this.handleWorkerError(task, error);\r\n        this.completeWorkerTask(taskId, workerInfo);\r\n        break;\r\n        \r\n      case 'PROGRESS':\r\n        this.handleWorkerProgress(task, data);\r\n        break;\r\n        \r\n      case 'PERFORMANCE_METRICS':\r\n        this.handleWorkerPerformanceMetrics(data);\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle worker result\r\n   */\r\n  handleWorkerResult(task, data) {\r\n    const processingTime = performance.now() - task.startTime;\r\n    this.updateWorkerTaskMetrics(processingTime, true);\r\n    \r\n    task.resolve(data);\r\n  }\r\n\r\n  /**\r\n   * Handle worker error\r\n   */\r\n  handleWorkerError(task, error) {\r\n    const processingTime = performance.now() - task.startTime;\r\n    this.updateWorkerTaskMetrics(processingTime, false);\r\n    \r\n    task.reject(new Error(error || 'Worker task failed'));\r\n  }\r\n\r\n  /**\r\n   * Handle worker progress\r\n   */\r\n  handleWorkerProgress(task, progressData) {\r\n    // Could emit progress events here if needed\r\n    console.log(`Task ${task.id} progress:`, progressData.progress);\r\n  }\r\n\r\n  /**\r\n   * Handle worker performance metrics\r\n   */\r\n  handleWorkerPerformanceMetrics(metrics) {\r\n    // Update overall performance metrics\r\n    this.metrics.workerTasks = {\r\n      ...this.metrics.workerTasks,\r\n      ...metrics\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Complete worker task and process queue\r\n   */\r\n  completeWorkerTask(taskId, workerInfo) {\r\n    // Mark worker as available\r\n    workerInfo.busy = false;\r\n    workerInfo.currentTask = null;\r\n    \r\n    // Remove from active tasks\r\n    this.activeWorkerTasks.delete(taskId);\r\n    \r\n    // Process next task in queue\r\n    if (this.workerQueue.length > 0) {\r\n      const nextTask = this.workerQueue.shift();\r\n      this.assignTaskToWorker(nextTask, workerInfo);\r\n    }\r\n    \r\n    this.updateWorkerMetrics();\r\n  }\r\n\r\n  /**\r\n   * Handle quality change from performance monitor\r\n   */\r\n  handleQualityChange(event) {\r\n    console.log(`Quality changed to ${event.newQuality} (${event.changeType})`);\r\n    \r\n    this.metrics.overallPerformance.qualityLevel = event.newQuality;\r\n    this.metrics.overallPerformance.degradationLevel = event.details.level || 0;\r\n    \r\n    // Could trigger cache cleanup or other optimizations here\r\n    if (event.newQuality === 'low' && this.cache) {\r\n      // Clear some cache to free memory\r\n      this.cache.optimizeMemoryUsage();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle performance warning\r\n   */\r\n  handlePerformanceWarning(warning) {\r\n    console.warn('Performance warning:', warning);\r\n    \r\n    if (warning.type === 'critical') {\r\n      // Trigger emergency optimizations\r\n      this.triggerEmergencyOptimizations();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Trigger emergency optimizations\r\n   */\r\n  triggerEmergencyOptimizations() {\r\n    console.log('Triggering emergency optimizations');\r\n    \r\n    // Force memory cleanup\r\n    if (this.memoryManager) {\r\n      this.memoryManager.emergencyCleanup();\r\n    }\r\n    \r\n    // Clear cache\r\n    if (this.cache) {\r\n      this.cache.clear();\r\n    }\r\n    \r\n    // Reduce worker pool size temporarily\r\n    if (this.workerPool.length > 1) {\r\n      const excessWorkers = this.workerPool.splice(1);\r\n      excessWorkers.forEach(workerInfo => {\r\n        workerInfo.worker.terminate();\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current adaptive settings\r\n   */\r\n  getAdaptiveSettings() {\r\n    if (this.performanceMonitor) {\r\n      return this.performanceMonitor.getAdaptiveSettings();\r\n    }\r\n    \r\n    return {\r\n      renderQuality: 'medium',\r\n      waveformResolution: 1.0,\r\n      enableAntialiasing: true,\r\n      maxBatchSize: 1000\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Update cache metrics\r\n   */\r\n  updateCacheMetrics(hit) {\r\n    if (hit) {\r\n      this.metrics.cachePerformance.hits++;\r\n    } else {\r\n      this.metrics.cachePerformance.misses++;\r\n    }\r\n    \r\n    const total = this.metrics.cachePerformance.hits + this.metrics.cachePerformance.misses;\r\n    this.metrics.cachePerformance.hitRate = this.metrics.cachePerformance.hits / total;\r\n  }\r\n\r\n  /**\r\n   * Update worker task metrics\r\n   */\r\n  updateWorkerTaskMetrics(processingTime, success) {\r\n    if (success) {\r\n      this.metrics.workerTasks.completed++;\r\n      \r\n      const avgTime = this.metrics.workerTasks.averageTime;\r\n      const count = this.metrics.workerTasks.completed;\r\n      this.metrics.workerTasks.averageTime = (avgTime * (count - 1) + processingTime) / count;\r\n    } else {\r\n      this.metrics.workerTasks.failed++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update worker metrics\r\n   */\r\n  updateWorkerMetrics() {\r\n    this.metrics.workerTasks.queueLength = this.workerQueue.length;\r\n  }\r\n\r\n  /**\r\n   * Generate unique task ID\r\n   */\r\n  generateTaskId() {\r\n    return `task_${++this.taskIdCounter}_${Date.now()}`;\r\n  }\r\n\r\n  /**\r\n   * Get comprehensive performance metrics\r\n   */\r\n  getPerformanceMetrics() {\r\n    const baseMetrics = { ...this.metrics };\r\n    \r\n    // Add component-specific metrics\r\n    if (this.cache) {\r\n      baseMetrics.cache = this.cache.getStats();\r\n    }\r\n    \r\n    if (this.memoryManager) {\r\n      baseMetrics.memory = this.memoryManager.getMemoryStats();\r\n    }\r\n    \r\n    if (this.performanceMonitor) {\r\n      baseMetrics.performance = this.performanceMonitor.getMetrics();\r\n      baseMetrics.overallPerformance.score = baseMetrics.performance.performanceScore;\r\n    }\r\n    \r\n    return baseMetrics;\r\n  }\r\n\r\n  /**\r\n   * Force quality level\r\n   */\r\n  setQualityLevel(level) {\r\n    if (this.performanceMonitor) {\r\n      this.performanceMonitor.forceQualityLevel(level);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear all caches and reset state\r\n   */\r\n  async clearCaches() {\r\n    if (this.cache) {\r\n      await this.cache.clear();\r\n    }\r\n    \r\n    if (this.memoryManager) {\r\n      this.memoryManager.emergencyCleanup();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Optimize for low-end devices\r\n   */\r\n  optimizeForLowEndDevice() {\r\n    console.log('Optimizing for low-end device');\r\n    \r\n    // Force low quality\r\n    this.setQualityLevel('low');\r\n    \r\n    // Reduce worker pool size\r\n    if (this.workerPool.length > 1) {\r\n      const excessWorkers = this.workerPool.splice(1);\r\n      excessWorkers.forEach(workerInfo => {\r\n        workerInfo.worker.terminate();\r\n      });\r\n    }\r\n    \r\n    // Reduce cache size\r\n    if (this.cache) {\r\n      this.cache.maxMemorySize = 50 * 1024 * 1024; // 50MB\r\n      this.cache.maxCacheEntries = 25;\r\n    }\r\n    \r\n    // More aggressive memory management\r\n    if (this.memoryManager) {\r\n      this.memoryManager.maxMemoryThreshold = 100 * 1024 * 1024; // 100MB\r\n      this.memoryManager.warningThreshold = 75 * 1024 * 1024; // 75MB\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroy optimizer and cleanup resources\r\n   */\r\n  destroy() {\r\n    console.log('Destroying WaveformPerformanceOptimizer');\r\n    \r\n    // Stop performance monitoring\r\n    if (this.performanceMonitor) {\r\n      this.performanceMonitor.destroy();\r\n      this.performanceMonitor = null;\r\n    }\r\n    \r\n    // Destroy memory manager\r\n    if (this.memoryManager) {\r\n      this.memoryManager.destroy();\r\n      this.memoryManager = null;\r\n    }\r\n    \r\n    // Destroy cache\r\n    if (this.cache) {\r\n      this.cache.destroy();\r\n      this.cache = null;\r\n    }\r\n    \r\n    // Terminate all workers\r\n    this.workerPool.forEach(workerInfo => {\r\n      workerInfo.worker.terminate();\r\n    });\r\n    this.workerPool = [];\r\n    \r\n    // Clear active tasks\r\n    this.activeWorkerTasks.clear();\r\n    this.workerQueue = [];\r\n    \r\n    this.isInitialized = false;\r\n  }\r\n}\r\n\r\nexport default WaveformPerformanceOptimizer;","import React, { useRef, useEffect, useState, useCallback, useMemo } from 'react';\r\nimport { motion } from 'framer-motion';\r\nimport { EnhancedCanvasRenderer } from './EnhancedCanvasRenderer.js';\r\nimport { InteractionManager } from './InteractionManager.js';\r\nimport { PlayheadManager } from './PlayheadManager.js';\r\nimport WaveformPerformanceOptimizer from '../../services/WaveformPerformanceOptimizer.js';\r\n\r\n/**\r\n * Core WaveformVisualization component with high-performance canvas rendering\r\n * Implements requirements: 1.1, 4.1, 4.4, 7.1, 7.2\r\n */\r\nexport default function WaveformVisualization({\r\n  audioSource,\r\n  waveformData,\r\n  chops = [],\r\n  currentTime = 0,\r\n  isPlaying = false,\r\n  onChopCreate,\r\n  onChopUpdate,\r\n  onTimeSeek,\r\n  visualSettings = {},\r\n  className = ''\r\n}) {\r\n  // Container reference for canvas renderer\r\n  const containerRef = useRef(null);\r\n  \r\n  // Canvas renderer instance\r\n  const rendererRef = useRef(null);\r\n  \r\n  // Interaction manager instance\r\n  const interactionManagerRef = useRef(null);\r\n  \r\n  // Playhead manager instance for real-time synchronization\r\n  const playheadManagerRef = useRef(null);\r\n  \r\n  // Performance optimizer instance\r\n  const performanceOptimizerRef = useRef(null);\r\n\r\n  // Component state\r\n  const [isInitialized, setIsInitialized] = useState(false);\r\n  const [selectedChopId, setSelectedChopId] = useState(null);\r\n  const [hoveredChopId, setHoveredChopId] = useState(null);\r\n  const [performanceMetrics, setPerformanceMetrics] = useState({});\r\n  const [currentQualityLevel, setCurrentQualityLevel] = useState('high');\r\n\r\n  // Animation frame reference for smooth updates (legacy - now handled by PlayheadManager)\r\n  const animationFrameRef = useRef(null);\r\n\r\n  /**\r\n   * Initialize performance optimizer\r\n   */\r\n  const initializePerformanceOptimizer = useCallback(async () => {\r\n    if (performanceOptimizerRef.current) return;\r\n    \r\n    try {\r\n      performanceOptimizerRef.current = new WaveformPerformanceOptimizer({\r\n        enableWebWorkers: visualSettings.enableWebWorkers !== false,\r\n        enableCaching: visualSettings.enableCaching !== false,\r\n        enableMemoryManagement: visualSettings.enableMemoryManagement !== false,\r\n        enablePerformanceMonitoring: visualSettings.enablePerformanceMonitoring !== false,\r\n        workerPoolSize: visualSettings.workerPoolSize || 2,\r\n        targetFPS: visualSettings.targetFPS || 60,\r\n        minFPS: visualSettings.minFPS || 30\r\n      });\r\n      \r\n      await performanceOptimizerRef.current.initialize();\r\n      \r\n      // Set up performance callbacks\r\n      if (performanceOptimizerRef.current.performanceMonitor) {\r\n        performanceOptimizerRef.current.performanceMonitor.onQualityChange((event) => {\r\n          setCurrentQualityLevel(event.newQuality);\r\n          console.log(`Waveform quality changed to: ${event.newQuality}`);\r\n        });\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Failed to initialize performance optimizer:', error);\r\n      return false;\r\n    }\r\n  }, [visualSettings]);\r\n\r\n  /**\r\n   * Initialize high-performance canvas renderer\r\n   */\r\n  const initializeRenderer = useCallback(() => {\r\n    const container = containerRef.current;\r\n    if (!container || rendererRef.current) return false;\r\n\r\n    try {\r\n      // Get adaptive settings from performance optimizer\r\n      const adaptiveSettings = performanceOptimizerRef.current?.getAdaptiveSettings() || {};\r\n      \r\n      // Create enhanced renderer with visual enhancements and optimized settings\r\n      rendererRef.current = new EnhancedCanvasRenderer(container, {\r\n        enableViewportCulling: adaptiveSettings.enableViewportCulling !== false,\r\n        enableBatching: adaptiveSettings.enableBatching !== false,\r\n        renderQuality: adaptiveSettings.renderQuality || visualSettings.quality || 'high',\r\n        enableAntialiasing: adaptiveSettings.enableAntialiasing !== false && visualSettings.antialiasing !== false,\r\n        maxBatchSize: adaptiveSettings.maxBatchSize || 1000,\r\n        // Visual enhancement options\r\n        enableFrequencyColorCoding: visualSettings.enableFrequencyColorCoding !== false,\r\n        enableAmplitudeColorCoding: visualSettings.enableAmplitudeColorCoding !== false,\r\n        enableStructureDetection: visualSettings.enableStructureDetection !== false,\r\n        enableAccessibilityMode: visualSettings.enableAccessibilityMode || false,\r\n        enableHighContrastMode: visualSettings.enableHighContrastMode || false,\r\n        colorScheme: visualSettings.colorScheme || 'default'\r\n      });\r\n\r\n      // Set audio duration if available\r\n      if (waveformData?.duration) {\r\n        const viewportManager = rendererRef.current.getViewportManager();\r\n        viewportManager.setAudioDuration(waveformData.duration);\r\n      }\r\n\r\n      // Initialize interaction manager\r\n      interactionManagerRef.current = new InteractionManager(rendererRef.current, {\r\n        clickThreshold: 5,\r\n        hoverDelay: 100,\r\n        snapTolerance: 10,\r\n        enableHover: true,\r\n        enableClick: true,\r\n        enableDrag: true\r\n      });\r\n\r\n      // Set interaction callbacks\r\n      interactionManagerRef.current.setCallbacks({\r\n        onChopCreate: onChopCreate,\r\n        onChopUpdate: onChopUpdate,\r\n        onTimeSeek: onTimeSeek,\r\n        onHover: (element, x, y) => {\r\n          // Update hover state for enhanced chop visualization\r\n          if (element && element.type === 'chop-region') {\r\n            setHoveredChopId(element.chopId);\r\n          } else {\r\n            setHoveredChopId(null);\r\n          }\r\n        }\r\n      });\r\n\r\n      // Initialize playhead manager for real-time synchronization\r\n      playheadManagerRef.current = new PlayheadManager(rendererRef.current, {\r\n        playheadColor: visualSettings.playheadColor || '#ef4444',\r\n        playheadWidth: visualSettings.playheadWidth || 2,\r\n        activeChopColor: visualSettings.activeChopColor || '#fbbf24',\r\n        showTimeDisplay: visualSettings.showPlayheadTime !== false,\r\n        animationQuality: visualSettings.animationQuality || 'high'\r\n      });\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Failed to initialize canvas renderer:', error);\r\n      return false;\r\n    }\r\n  }, [visualSettings, waveformData]);\r\n\r\n  /**\r\n   * Update viewport state for zoom and pan operations\r\n   * Implements requirement 4.1 - zoom controls\r\n   */\r\n  const updateViewport = useCallback((updates) => {\r\n    if (!rendererRef.current) return;\r\n    \r\n    const viewportManager = rendererRef.current.getViewportManager();\r\n    \r\n    if (updates.zoomLevel !== undefined) {\r\n      viewportManager.setZoom(updates.zoomLevel, updates.centerTime);\r\n    } else if (updates.centerTime !== undefined) {\r\n      viewportManager.panToTime(updates.centerTime);\r\n    }\r\n  }, []);\r\n\r\n  /**\r\n   * Convert time to pixel position within current viewport\r\n   */\r\n  const timeToPixel = useCallback((time) => {\r\n    if (!rendererRef.current) return 0;\r\n    return rendererRef.current.getViewportManager().timeToPixel(time);\r\n  }, []);\r\n\r\n  /**\r\n   * Convert pixel position to time within current viewport\r\n   */\r\n  const pixelToTime = useCallback((pixel) => {\r\n    if (!rendererRef.current) return 0;\r\n    return rendererRef.current.getViewportManager().pixelToTime(pixel);\r\n  }, []);\r\n\r\n  /**\r\n   * Render all waveform elements using high-performance renderer\r\n   */\r\n  const renderWaveform = useCallback(() => {\r\n    if (!rendererRef.current || !isInitialized) return;\r\n\r\n    const renderer = rendererRef.current;\r\n    \r\n    // Record frame render start for performance monitoring\r\n    if (performanceOptimizerRef.current?.performanceMonitor) {\r\n      performanceOptimizerRef.current.performanceMonitor.frameRenderStart();\r\n    }\r\n    \r\n    // Get adaptive settings for current performance level\r\n    const adaptiveSettings = performanceOptimizerRef.current?.getAdaptiveSettings() || {};\r\n    \r\n    // Render waveform data if available\r\n    if (waveformData) {\r\n      renderer.renderWaveform(waveformData, {\r\n        quality: adaptiveSettings.renderQuality || visualSettings.quality || 'high',\r\n        topColor: visualSettings.topColor,\r\n        centerColor: visualSettings.centerColor,\r\n        bottomColor: visualSettings.bottomColor,\r\n        strokeColor: visualSettings.strokeColor,\r\n        waveformResolution: adaptiveSettings.waveformResolution || 1.0,\r\n        enableAntialiasing: adaptiveSettings.enableAntialiasing !== false\r\n      });\r\n    }\r\n    \r\n    // Render chops with enhanced visualization\r\n    if (chops.length > 0) {\r\n      renderer.renderChops(chops, selectedChopId, {\r\n        highlightSelected: true,\r\n        hoveredChopId: hoveredChopId,\r\n        activeChopId: null // TODO: Connect to playback state\r\n      });\r\n    }\r\n    \r\n    // Playhead rendering is now handled by PlayheadManager for smooth real-time sync\r\n    // The PlayheadManager will automatically render when playback state changes\r\n    \r\n    // Render UI elements\r\n    renderer.renderUI({\r\n      showZoomIndicator: visualSettings.showZoomIndicator !== false,\r\n      textColor: visualSettings.textColor,\r\n      tickColor: visualSettings.tickColor\r\n    });\r\n    \r\n    // Update performance metrics\r\n    const rendererMetrics = renderer.getPerformanceMetrics();\r\n    const optimizerMetrics = performanceOptimizerRef.current?.getPerformanceMetrics() || {};\r\n    const combinedMetrics = { ...rendererMetrics, optimizer: optimizerMetrics };\r\n    setPerformanceMetrics(combinedMetrics);\r\n    \r\n    // Record frame render end for performance monitoring\r\n    if (performanceOptimizerRef.current?.performanceMonitor) {\r\n      performanceOptimizerRef.current.performanceMonitor.frameRenderEnd();\r\n    }\r\n  }, [\r\n    isInitialized, \r\n    waveformData, \r\n    chops, \r\n    selectedChopId, \r\n    hoveredChopId,\r\n    currentTime, \r\n    isPlaying, \r\n    visualSettings,\r\n    currentQualityLevel\r\n  ]);\r\n\r\n  /**\r\n   * Handle container resize\r\n   */\r\n  const handleResize = useCallback(() => {\r\n    if (!rendererRef.current) return;\r\n    \r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n    \r\n    const rect = container.getBoundingClientRect();\r\n    rendererRef.current.resize(rect.width, rect.height);\r\n  }, []);\r\n\r\n  // Initialize component\r\n  useEffect(() => {\r\n    const initialize = async () => {\r\n      // Initialize performance optimizer first\r\n      await initializePerformanceOptimizer();\r\n      \r\n      // Then initialize renderer with optimized settings\r\n      if (initializeRenderer()) {\r\n        setIsInitialized(true);\r\n      }\r\n    };\r\n    \r\n    initialize();\r\n  }, [initializePerformanceOptimizer, initializeRenderer]);\r\n\r\n  // Handle window resize\r\n  useEffect(() => {\r\n    const resizeObserver = new ResizeObserver(handleResize);\r\n    \r\n    if (containerRef.current) {\r\n      resizeObserver.observe(containerRef.current);\r\n    }\r\n    \r\n    return () => {\r\n      resizeObserver.disconnect();\r\n    };\r\n  }, [handleResize]);\r\n\r\n  // Render when dependencies change\r\n  useEffect(() => {\r\n    renderWaveform();\r\n  }, [renderWaveform]);\r\n\r\n  // Update interaction manager with current chops and waveform data\r\n  useEffect(() => {\r\n    if (interactionManagerRef.current) {\r\n      interactionManagerRef.current.setCurrentChops(chops);\r\n    }\r\n    \r\n    // Update playhead manager with chops for active highlighting\r\n    if (playheadManagerRef.current) {\r\n      playheadManagerRef.current.setChops(chops);\r\n    }\r\n  }, [chops]);\r\n\r\n  // Update interaction manager with waveform data for zero-crossing detection\r\n  useEffect(() => {\r\n    if (interactionManagerRef.current && waveformData) {\r\n      interactionManagerRef.current.setWaveformData(waveformData);\r\n    }\r\n  }, [waveformData]);\r\n\r\n  // Real-time playback synchronization using PlayheadManager\r\n  useEffect(() => {\r\n    if (playheadManagerRef.current) {\r\n      // Update playback state for smooth real-time synchronization\r\n      playheadManagerRef.current.updatePlaybackState(currentTime, isPlaying);\r\n    }\r\n  }, [currentTime, isPlaying]);\r\n\r\n  // Update playhead manager options when visual settings change\r\n  useEffect(() => {\r\n    if (playheadManagerRef.current) {\r\n      playheadManagerRef.current.setOptions({\r\n        playheadColor: visualSettings.playheadColor || '#ef4444',\r\n        playheadWidth: visualSettings.playheadWidth || 2,\r\n        activeChopColor: visualSettings.activeChopColor || '#fbbf24',\r\n        showTimeDisplay: visualSettings.showPlayheadTime !== false,\r\n        animationQuality: visualSettings.animationQuality || 'high'\r\n      });\r\n    }\r\n  }, [visualSettings]);\r\n\r\n  // Cleanup on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      if (animationFrameRef.current) {\r\n        cancelAnimationFrame(animationFrameRef.current);\r\n      }\r\n      if (playheadManagerRef.current) {\r\n        playheadManagerRef.current.destroy();\r\n        playheadManagerRef.current = null;\r\n      }\r\n      if (interactionManagerRef.current) {\r\n        interactionManagerRef.current.destroy();\r\n        interactionManagerRef.current = null;\r\n      }\r\n      if (rendererRef.current) {\r\n        rendererRef.current.destroy();\r\n        rendererRef.current = null;\r\n      }\r\n      if (performanceOptimizerRef.current) {\r\n        performanceOptimizerRef.current.destroy();\r\n        performanceOptimizerRef.current = null;\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  // Handle chop selection\r\n  const handleChopSelect = useCallback((chopId) => {\r\n    setSelectedChopId(chopId);\r\n    if (onChopUpdate) {\r\n      onChopUpdate(chopId, { selected: true });\r\n    }\r\n  }, [onChopUpdate]);\r\n\r\n  // Get viewport manager for external access\r\n  const getViewportManager = useCallback(() => {\r\n    return rendererRef.current?.getViewportManager();\r\n  }, []);\r\n\r\n  // Public API methods for external control\r\n  const api = useMemo(() => ({\r\n    setZoomLevel: (zoomLevel, centerTime) => {\r\n      updateViewport({ zoomLevel, centerTime });\r\n    },\r\n    \r\n    panToTime: (targetTime) => {\r\n      updateViewport({ centerTime: targetTime });\r\n    },\r\n    \r\n    zoomIn: (factor = 2, centerTime) => {\r\n      if (rendererRef.current) {\r\n        const viewportManager = rendererRef.current.getViewportManager();\r\n        viewportManager.zoomIn(factor, centerTime);\r\n      }\r\n    },\r\n    \r\n    zoomOut: (factor = 2, centerTime) => {\r\n      if (rendererRef.current) {\r\n        const viewportManager = rendererRef.current.getViewportManager();\r\n        viewportManager.zoomOut(factor, centerTime);\r\n      }\r\n    },\r\n    \r\n    zoomToFit: () => {\r\n      if (rendererRef.current) {\r\n        const viewportManager = rendererRef.current.getViewportManager();\r\n        viewportManager.zoomToFit();\r\n      }\r\n    },\r\n    \r\n    getViewport: () => {\r\n      if (rendererRef.current) {\r\n        return rendererRef.current.getViewportManager().getState();\r\n      }\r\n      return null;\r\n    },\r\n    \r\n    getViewportManager,\r\n    \r\n    getPerformanceMetrics: () => {\r\n      const baseMetrics = performanceMetrics;\r\n      const playheadMetrics = playheadManagerRef.current?.getPerformanceMetrics() || {};\r\n      const optimizerMetrics = performanceOptimizerRef.current?.getPerformanceMetrics() || {};\r\n      return { \r\n        ...baseMetrics, \r\n        playhead: playheadMetrics,\r\n        optimizer: optimizerMetrics,\r\n        currentQuality: currentQualityLevel\r\n      };\r\n    },\r\n    \r\n    getSyncStatus: () => {\r\n      return playheadManagerRef.current?.getSyncStatus() || null;\r\n    },\r\n    \r\n    jumpToTime: (time) => {\r\n      if (playheadManagerRef.current) {\r\n        playheadManagerRef.current.jumpToTime(time);\r\n      }\r\n      if (onTimeSeek) {\r\n        onTimeSeek(time);\r\n      }\r\n    },\r\n    \r\n    setRenderQuality: (quality) => {\r\n      if (rendererRef.current) {\r\n        rendererRef.current.setRenderQuality(quality);\r\n      }\r\n      if (performanceOptimizerRef.current) {\r\n        performanceOptimizerRef.current.setQualityLevel(quality);\r\n      }\r\n    },\r\n    \r\n    getPerformanceOptimizer: () => {\r\n      return performanceOptimizerRef.current;\r\n    },\r\n    \r\n    optimizeForLowEndDevice: () => {\r\n      if (performanceOptimizerRef.current) {\r\n        performanceOptimizerRef.current.optimizeForLowEndDevice();\r\n      }\r\n    },\r\n    \r\n    clearCaches: async () => {\r\n      if (performanceOptimizerRef.current) {\r\n        await performanceOptimizerRef.current.clearCaches();\r\n      }\r\n    },\r\n    \r\n    // Visual enhancement API methods\r\n    getVisualEnhancementEngine: () => {\r\n      return rendererRef.current?.getVisualEnhancementEngine();\r\n    },\r\n    \r\n    updateVisualSettings: (newSettings) => {\r\n      if (rendererRef.current && rendererRef.current.updateVisualSettings) {\r\n        rendererRef.current.updateVisualSettings(newSettings);\r\n        renderWaveform(); // Re-render with new settings\r\n      }\r\n    },\r\n    \r\n    getVisualSettings: () => {\r\n      const engine = rendererRef.current?.getVisualEnhancementEngine();\r\n      return engine ? engine.createVisualSettings() : null;\r\n    },\r\n    \r\n    timeToPixel,\r\n    pixelToTime,\r\n    \r\n    render: renderWaveform,\r\n    \r\n    selectChop: handleChopSelect\r\n  }), [updateViewport, timeToPixel, pixelToTime, renderWaveform, handleChopSelect, performanceMetrics, getViewportManager]);\r\n\r\n  return (\r\n    <motion.div\r\n      ref={containerRef}\r\n      className={`relative w-full h-full bg-gray-900 rounded-lg overflow-hidden ${className}`}\r\n      initial={{ opacity: 0 }}\r\n      animate={{ opacity: 1 }}\r\n      transition={{ duration: 0.3 }}\r\n    >\r\n      {/* Canvas layers are created and managed by CanvasRenderer */}\r\n      \r\n      {/* Loading indicator */}\r\n      {!isInitialized && (\r\n        <div className=\"absolute inset-0 flex items-center justify-center\">\r\n          <div className=\"text-white/70 text-sm\">Initializing high-performance renderer...</div>\r\n        </div>\r\n      )}\r\n      \r\n      {/* Performance indicator (development only) */}\r\n      {process.env.NODE_ENV === 'development' && performanceMetrics.averageFPS && (\r\n        <div className=\"absolute top-2 right-2 text-xs text-white/50 font-mono space-y-1\">\r\n          <div>{Math.round(performanceMetrics.averageFPS)}fps</div>\r\n          <div className={`text-xs ${\r\n            currentQualityLevel === 'high' ? 'text-green-400' :\r\n            currentQualityLevel === 'medium' ? 'text-yellow-400' :\r\n            'text-red-400'\r\n          }`}>\r\n            {currentQualityLevel}\r\n          </div>\r\n          {performanceMetrics.optimizer?.cachePerformance && (\r\n            <div>\r\n              Cache: {Math.round(performanceMetrics.optimizer.cachePerformance.hitRate * 100)}%\r\n            </div>\r\n          )}\r\n        </div>\r\n      )}\r\n    </motion.div>\r\n  );\r\n}\r\n\r\n// Export the API for external components to control the waveform\r\nexport { WaveformVisualization };"],"names":["EnhancedCanvasRenderer","CanvasRenderer","constructor","container","options","super","this","visualEnhancementEngine","VisualEnhancementEngine","enableFrequencyColorCoding","enableAmplitudeColorCoding","enableStructureDetection","enableAccessibilityMode","enableHighContrastMode","colorScheme","frequencyColorData","amplitudeColorData","structureData","accessibilityPatterns","patternCache","Map","animationState","time","pulsePhase","particleSystem","initializeEnhancedFeatures","layerManager","createLayer","alpha","initializeAccessibilityPatterns","startEnhancementAnimationLoop","renderWaveform","waveformData","renderVisualEnhancements","viewport","viewportManager","getViewportBounds","width","height","getDimensions","generateEnhancedVisualData","renderFrequencyColorOverlay","renderAmplitudeColorOverlay","renderStructureOverlay","renderAccessibilityPatterns","applyHighContrastMode","frequencyData","applyFrequencyColorCoding","applyAmplitudeColorCoding","detectSongStructure","metadata","generateAccessibilityPatterns","layer","getLayer","ctx","clearLayer","forEach","segment","endTime","start","startTime","end","startX","timeToPixel","Math","max","segmentWidth","min","gradient","createFrequencyGradient","color","frequencyProfile","globalCompositeOperation","fillStyle","fillRect","markLayerClean","x","createLinearGradient","bassEnergy","lowMidEnergy","midEnergy","highMidEnergy","trebleEnergy","totalEnergy","addColorStop","r","g","b","currentStop","bassRatio","a","lowMidRatio","midRatio","highMidRatio","trebleRatio","brightness","colorModifier","globalAlpha","amplitudeColor","getAmplitudeLevelColor","level","colors","silent","quiet","moderate","loud","peak","round","section","sectionWidth","renderStructureSection","structureDetection","showLabels","renderStructureLabel","visualPattern","pattern","baseColor","strokeStyle","lineWidth","setLineDash","strokeRect","y","beginPath","arc","PI","fill","centerX","labelText","type","toUpperCase","font","textAlign","textBaseline","textWidth","measureText","labelY","padding","fillText","patternSegment","renderAccessibilityPattern","density","frequencyType","spacing","high","medium","low","sparse","moveTo","lineTo","stroke","offset","layerName","canvas","filter","densities","key","set","generatePatternData","animate","timestamp","enhancements","animatedElements","updateAnimatedElements","requestAnimationFrame","markLayerDirty","updateVisualSettings","newSettings","getVisualEnhancementEngine","destroy","clear","PlayheadManager","canvasRenderer","renderer","smoothingFactor","maxInterpolationTime","playheadColor","playheadWidth","activeChopColor","activeChopOpacity","showTimeDisplay","animationQuality","currentTime","targetTime","isPlaying","lastUpdateTime","interpolatedTime","animationFrameId","isAnimating","activeChops","Set","allChops","chopHighlights","frameCount","lastFPSCheck","currentFPS","syncHistory","maxSyncHistory","syncAccuracy","initialize","startAnimation","updatePlaybackState","isNaN","now","performance","timeDelta","trackSyncAccuracy","error","stopAnimation","updateActiveChops","render","newTime","length","expectedTime","actualTime","drift","abs","push","shift","totalDrift","reduce","sum","sync","updateInterpolation","updatePerformanceMetrics","rafError","cancelAnimationFrame","timeSinceLastUpdate","newActiveChops","chop","chopId","id","padId","add","has","intensity","fadeOut","highlight","get","fadeStartTime","cleanupHighlights","entries","fadeProgress","delete","setChops","chops","getViewportManager","isTimeVisible","renderActiveChopHighlights","renderPlayhead","getLayerManager","isRangeVisible","startPixel","chopWidth","pulseSpeed","sin","save","restore","playheadPixel","lineCap","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","renderPlayheadIndicator","renderTimeDisplay","indicatorSize","closePath","pixelsPerSecond","timeText","formatTime","textX","textY","seconds","minutes","floor","secs","toFixed","padStart","getPerformanceMetrics","fps","size","getSyncStatus","Array","from","setOptions","newOptions","jumpToTime","WaveformCache","maxMemorySize","maxCacheEntries","persistenceEnabled","compressionEnabled","ttl","memoryCache","accessOrder","memorySizeUsed","persistentCache","initializePersistence","metrics","hits","misses","evictions","compressionSavings","averageCompressionRatio","persistenceHits","persistenceMisses","cleanupInterval","setInterval","performMaintenance","indexedDB","openIndexedDB","Promise","resolve","reject","request","open","onerror","onsuccess","db","result","onupgradeneeded","event","target","objectStoreNames","contains","store","createObjectStore","keyPath","createIndex","unique","generateCacheKey","audioSource","keyData","source","getSourceIdentifier","sampleRate","quality","analysisMethod","duration","hashObject","cacheKey","memoryResult","getFromMemory","persistentResult","getFromPersistent","setInMemory","cacheEntry","data","Date","accessCount","calculateDataSize","compressed","compressData","savings","updateCompressionRatio","setInPersistent","entry","decompressed","decompressData","evictLRU","existing","transaction","objectStore","deleteFromPersistent","persistentEntry","put","oncomplete","oldestKey","oldestTime","accessTime","jsonData","JSON","stringify","CompressionStream","stream","writer","writable","getWriter","reader","readable","getReader","write","TextEncoder","encode","close","chunks","done","value","readerDone","read","Uint8Array","acc","chunk","originalSize","simpleCompress","simpleDecompress","TextDecoder","decode","count","current","i","String","fromCharCode","parse","charCodeAt","repeat","ArrayBuffer","byteLength","Float32Array","BYTES_PER_ELEMENT","videoId","src","obj","str","Object","keys","sort","hash","toString","compressedSize","ratio","expiredKeys","cleanExpiredPersistent","optimizeMemoryUsage","index","cutoffTime","range","IDBKeyRange","upperBound","openCursor","cursor","continue","map","score","toRemove","getStats","hitRate","persistentHitRate","sizeUsed","maxSize","utilizationPercent","totalHits","totalMisses","compression","enabled","totalSavings","averageRatio","persistence","clearInterval","WaveformMemoryManager","maxMemoryThreshold","warningThreshold","aggressiveCleanupThreshold","allocatedBuffers","bufferPool","memoryUsage","allocated","pooled","cleanupStrategies","initializeCleanupStrategies","performanceMetrics","cleanupCount","memoryReclaimed","bufferReuses","gcTriggers","averageCleanupTime","cleanupTimer","performAutomaticCleanup","memoryPressureObserver","initializeMemoryPressureMonitoring","priority","execute","cleanupBufferPool","description","cleanupOldAllocations","cleanupLargeBuffers","forceGarbageCollection","emergencyCleanup","PerformanceObserver","list","getEntries","entryType","name","includes","handleMemoryPressure","observe","entryTypes","checkMemoryPressure","allocateBuffer","bufferId","generateBufferId","pooledBuffer","getPooledBuffer","buffer","allocatedAt","reused","Int16Array","actualSize","scheduleCleanup","emergencyRetry","retryError","Error","message","deallocateBuffer","allocation","poolForReuse","reason","shouldPoolBuffer","addToBufferPool","poolKey","pool","pop","maxPoolSize","currentUsage","getCurrentMemoryUsage","performCleanup","strategyNames","strategies","strategy","totalReclaimed","beforeMemory","afterMemory","reclaimed","cleanupTime","updateCleanupMetrics","strategiesUsed","s","finalMemoryUsage","delay","setTimeout","sizeStr","split","parseInt","keepCount","removed","splice","pinned","sortedAllocations","gc","tempArrays","pinBuffer","pinnedReason","pinnedAt","unpinBuffer","memory","usedJSHeapSize","calculateMemoryPressure","avgTime","random","substr","formatBytes","bytes","log","parseFloat","pow","getMemoryStats","pressureLevel","usage","formatted","thresholds","warning","aggressive","pressure","status","allocations","pooledBuffers","values","pinnedBuffers","disconnect","WaveformPerformanceMonitor","targetFPS","minFPS","performanceWindow","degradationThreshold","recoveryThreshold","maxDegradationLevel","average","Infinity","samples","renderTime","trend","cpuUsage","estimated","currentQualityLevel","degradationLevel","isMonitoring","adaptiveSettings","getDefaultAdaptiveSettings","qualityChangeCallbacks","performanceWarningCallbacks","monitoringInterval","metricsCollectionInterval","lastFrameTime","renderStartTime","deviceCapabilities","detectDeviceCapabilities","startMonitoring","collectMetrics","analyzePerformance","stopMonitoring","frameRenderStart","frameRenderEnd","frameTime","updateFPSMetrics","updateRenderTimeMetrics","handleLowPerformance","sample","updateMemoryTrend","estimateCPUUsage","currentMemory","lastMemoryReading","change","changePercent","targetRenderTime","actualRenderTime","estimatedUsage","lastCPUReading","performanceScore","calculatePerformanceScore","shouldDegrade","shouldRecover","degradeQuality","improveQuality","checkCriticalPerformance","calculateMemoryScore","memoryLimit","memoryUsageRatio","getAdaptiveSettings","applyAdaptiveSettings","qualityLevel","getQualityLevelName","notifyQualityChange","settings","renderQuality","waveformResolution","enableAntialiasing","maxBatchSize","enableViewportCulling","chopRenderingDetail","disableAnimations","simplifiedRendering","levels","metric","notifyPerformanceWarning","threshold","currentQuality","criticalIssues","handleCriticalPerformance","issues","emergencySettings","getEmergencySettings","emergencyMode","detectMemoryLimit","cpuCores","navigator","hardwareConcurrency","webglSupport","detectWebGLSupport","performanceAPISupport","deviceType","detectDeviceType","connectionType","detectConnectionType","jsHeapSizeLimit","document","HTMLCanvasElement","createElement","getContext","userAgent","toLowerCase","test","connection","effectiveType","downlink","rtt","onQualityChange","callback","onPerformanceWarning","newQuality","changeType","details","getMetrics","forceQualityLevel","resetQuality","WaveformPerformanceOptimizer","enableWebWorkers","enableCaching","enableMemoryManagement","enablePerformanceMonitoring","workerPoolSize","cache","memoryManager","performanceMonitor","workerPool","workerQueue","isInitialized","activeWorkerTasks","taskIdCounter","workerTasks","completed","failed","averageTime","queueLength","cachePerformance","memoryOptimization","overallPerformance","cacheMaxMemory","cacheMaxEntries","cachePersistence","cacheCompression","memoryMaxThreshold","memoryWarningThreshold","memoryCleanupInterval","setupPerformanceCallbacks","initializeWorkerPool","workerScript","URL","url","worker","Worker","onmessage","handleWorkerMessage","handleWorkerError","busy","currentTask","handleQualityChange","handlePerformanceWarning","generateOptimizedWaveform","updateCacheMetrics","optimizedOptions","generateWaveformWithWorker","generateWaveformDirect","generationTime","method","fallback","task","generateTaskId","audioBuffer","availableWorker","getAvailableWorker","assignTaskToWorker","updateWorkerMetrics","targetSampleRate","outputBuffer","step","sourceIndex","windowSize","j","sqrt","channels","generatedAt","find","workerInfo","postMessage","taskId","taskInfo","handleWorkerResult","completeWorkerTask","handleWorkerProgress","handleWorkerPerformanceMetrics","processingTime","updateWorkerTaskMetrics","progressData","nextTask","triggerEmergencyOptimizations","terminate","hit","total","success","baseMetrics","setQualityLevel","clearCaches","optimizeForLowEndDevice","WaveformVisualization","onChopCreate","onChopUpdate","onTimeSeek","visualSettings","className","containerRef","useRef","rendererRef","interactionManagerRef","playheadManagerRef","performanceOptimizerRef","setIsInitialized","useState","selectedChopId","setSelectedChopId","hoveredChopId","setHoveredChopId","setPerformanceMetrics","setCurrentQualityLevel","animationFrameRef","initializePerformanceOptimizer","useCallback","async","initializeRenderer","enableBatching","antialiasing","setAudioDuration","InteractionManager","clickThreshold","hoverDelay","snapTolerance","enableHover","enableClick","enableDrag","setCallbacks","onHover","element","showPlayheadTime","updateViewport","updates","zoomLevel","setZoom","centerTime","panToTime","pixelToTime","pixel","topColor","centerColor","bottomColor","strokeColor","renderChops","highlightSelected","activeChopId","renderUI","showZoomIndicator","textColor","tickColor","combinedMetrics","optimizer","handleResize","rect","getBoundingClientRect","resize","useEffect","resizeObserver","ResizeObserver","setCurrentChops","setWaveformData","handleChopSelect","selected","useMemo","setZoomLevel","zoomIn","factor","zoomOut","zoomToFit","getViewport","getState","playhead","setRenderQuality","getPerformanceOptimizer","getVisualSettings","engine","createVisualSettings","selectChop","jsxs","motion","div","ref","initial","opacity","transition","children","jsx"],"mappings":"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"}