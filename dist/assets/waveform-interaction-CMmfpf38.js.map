{"version":3,"file":"waveform-interaction-CMmfpf38.js","sources":["../../src/components/waveform/ZoomControls.jsx","../../src/services/ZeroCrossingDetector.js","../../src/services/SmartSnapping.js","../../src/components/waveform/InteractionManager.js"],"sourcesContent":["import React, { useState, useEffect, useCallback } from 'react';\r\nimport { motion, AnimatePresence } from 'framer-motion';\r\n\r\n/**\r\n * Zoom and Navigation Controls for Waveform Visualization\r\n * Implements requirements: 4.1, 4.2, 4.3, 4.4\r\n */\r\nexport default function ZoomControls({\r\n  viewportManager,\r\n  className = '',\r\n  showPresets = true,\r\n  showNavigationInfo = true,\r\n  compact = false\r\n}) {\r\n  const [viewport, setViewport] = useState(null);\r\n  const [navigationInfo, setNavigationInfo] = useState(null);\r\n  const [zoomPresets, setZoomPresets] = useState([]);\r\n  const [isExpanded, setIsExpanded] = useState(!compact);\r\n\r\n  // Update viewport state when viewport changes\r\n  useEffect(() => {\r\n    if (!viewportManager) return;\r\n\r\n    const updateViewport = (newViewport) => {\r\n      setViewport(newViewport);\r\n      setNavigationInfo(viewportManager.getNavigationInfo());\r\n      setZoomPresets(viewportManager.getZoomPresets());\r\n    };\r\n\r\n    // Initial state\r\n    updateViewport(viewportManager.getState());\r\n\r\n    // Listen for changes\r\n    const unsubscribe = viewportManager.addListener(updateViewport);\r\n    return unsubscribe;\r\n  }, [viewportManager]);\r\n\r\n  // Zoom controls\r\n  const handleZoomIn = useCallback(() => {\r\n    if (viewportManager) {\r\n      viewportManager.zoomIn(1.5);\r\n    }\r\n  }, [viewportManager]);\r\n\r\n  const handleZoomOut = useCallback(() => {\r\n    if (viewportManager) {\r\n      viewportManager.zoomOut(1.5);\r\n    }\r\n  }, [viewportManager]);\r\n\r\n  const handleZoomToFit = useCallback(() => {\r\n    if (viewportManager) {\r\n      viewportManager.zoomToFit();\r\n    }\r\n  }, [viewportManager]);\r\n\r\n  const handleZoomPreset = useCallback((preset) => {\r\n    if (viewportManager && viewport) {\r\n      viewportManager.setZoom(preset.zoomLevel, viewport.centerTime);\r\n    }\r\n  }, [viewportManager, viewport]);\r\n\r\n  // Navigation controls\r\n  const handlePanLeft = useCallback(() => {\r\n    if (viewportManager && viewport) {\r\n      const visibleDuration = viewport.visibleTimeRange.end - viewport.visibleTimeRange.start;\r\n      const panDistance = visibleDuration * 0.25;\r\n      viewportManager.panToTime(viewport.centerTime - panDistance);\r\n    }\r\n  }, [viewportManager, viewport]);\r\n\r\n  const handlePanRight = useCallback(() => {\r\n    if (viewportManager && viewport) {\r\n      const visibleDuration = viewport.visibleTimeRange.end - viewport.visibleTimeRange.start;\r\n      const panDistance = visibleDuration * 0.25;\r\n      viewportManager.panToTime(viewport.centerTime + panDistance);\r\n    }\r\n  }, [viewportManager, viewport]);\r\n\r\n  const handleGoToStart = useCallback(() => {\r\n    if (viewportManager) {\r\n      viewportManager.panToTime(0);\r\n    }\r\n  }, [viewportManager]);\r\n\r\n  const handleGoToEnd = useCallback(() => {\r\n    if (viewportManager && viewport) {\r\n      viewportManager.panToTime(viewport.audioDuration);\r\n    }\r\n  }, [viewportManager, viewport]);\r\n\r\n  if (!viewport || !navigationInfo) {\r\n    return null;\r\n  }\r\n\r\n  const formatTime = (time) => {\r\n    const minutes = Math.floor(time / 60);\r\n    const seconds = (time % 60).toFixed(2);\r\n    return `${minutes}:${seconds.padStart(5, '0')}`;\r\n  };\r\n\r\n  const formatZoom = (zoom) => {\r\n    if (zoom >= 1) {\r\n      return `${zoom.toFixed(1)}x`;\r\n    } else {\r\n      return `1:${(1/zoom).toFixed(1)}`;\r\n    }\r\n  };\r\n\r\n  return (\r\n    <motion.div\r\n      className={`bg-gray-800 border border-gray-700 rounded-lg p-3 ${className}`}\r\n      initial={{ opacity: 0, y: 10 }}\r\n      animate={{ opacity: 1, y: 0 }}\r\n      transition={{ duration: 0.2 }}\r\n    >\r\n      {/* Main Controls */}\r\n      <div className=\"flex items-center gap-2 mb-2\">\r\n        {/* Zoom Controls */}\r\n        <div className=\"flex items-center gap-1\">\r\n          <button\r\n            onClick={handleZoomOut}\r\n            disabled={!navigationInfo.canZoomOut}\r\n            className=\"p-1.5 bg-gray-700 hover:bg-gray-600 disabled:bg-gray-800 disabled:text-gray-500 \r\n                     text-white rounded transition-colors text-sm font-mono\"\r\n            title=\"Zoom Out (Ctrl+-)\"\r\n          >\r\n            −\r\n          </button>\r\n          \r\n          <div className=\"px-2 py-1 bg-gray-900 text-white text-xs font-mono rounded min-w-[50px] text-center\">\r\n            {formatZoom(viewport.zoomLevel)}\r\n          </div>\r\n          \r\n          <button\r\n            onClick={handleZoomIn}\r\n            disabled={!navigationInfo.canZoomIn}\r\n            className=\"p-1.5 bg-gray-700 hover:bg-gray-600 disabled:bg-gray-800 disabled:text-gray-500 \r\n                     text-white rounded transition-colors text-sm font-mono\"\r\n            title=\"Zoom In (Ctrl++)\"\r\n          >\r\n            +\r\n          </button>\r\n          \r\n          <button\r\n            onClick={handleZoomToFit}\r\n            className=\"px-2 py-1.5 bg-blue-600 hover:bg-blue-500 text-white rounded transition-colors text-xs\"\r\n            title=\"Zoom to Fit (Ctrl+0)\"\r\n          >\r\n            Fit\r\n          </button>\r\n        </div>\r\n\r\n        {/* Navigation Controls */}\r\n        <div className=\"flex items-center gap-1 ml-2\">\r\n          <button\r\n            onClick={handleGoToStart}\r\n            disabled={!navigationInfo.canPanLeft}\r\n            className=\"p-1.5 bg-gray-700 hover:bg-gray-600 disabled:bg-gray-800 disabled:text-gray-500 \r\n                     text-white rounded transition-colors text-sm\"\r\n            title=\"Go to Start (Home)\"\r\n          >\r\n            ⏮\r\n          </button>\r\n          \r\n          <button\r\n            onClick={handlePanLeft}\r\n            disabled={!navigationInfo.canPanLeft}\r\n            className=\"p-1.5 bg-gray-700 hover:bg-gray-600 disabled:bg-gray-800 disabled:text-gray-500 \r\n                     text-white rounded transition-colors text-sm\"\r\n            title=\"Pan Left (←)\"\r\n          >\r\n            ◀\r\n          </button>\r\n          \r\n          <button\r\n            onClick={handlePanRight}\r\n            disabled={!navigationInfo.canPanRight}\r\n            className=\"p-1.5 bg-gray-700 hover:bg-gray-600 disabled:bg-gray-800 disabled:text-gray-500 \r\n                     text-white rounded transition-colors text-sm\"\r\n            title=\"Pan Right (→)\"\r\n          >\r\n            ▶\r\n          </button>\r\n          \r\n          <button\r\n            onClick={handleGoToEnd}\r\n            disabled={!navigationInfo.canPanRight}\r\n            className=\"p-1.5 bg-gray-700 hover:bg-gray-600 disabled:bg-gray-800 disabled:text-gray-500 \r\n                     text-white rounded transition-colors text-sm\"\r\n            title=\"Go to End (End)\"\r\n          >\r\n            ⏭\r\n          </button>\r\n        </div>\r\n\r\n        {/* Expand/Collapse Toggle */}\r\n        {compact && (\r\n          <button\r\n            onClick={() => setIsExpanded(!isExpanded)}\r\n            className=\"p-1.5 bg-gray-700 hover:bg-gray-600 text-white rounded transition-colors text-sm ml-auto\"\r\n            title={isExpanded ? \"Collapse\" : \"Expand\"}\r\n          >\r\n            {isExpanded ? '▼' : '▲'}\r\n          </button>\r\n        )}\r\n      </div>\r\n\r\n      {/* Expanded Controls */}\r\n      <AnimatePresence>\r\n        {isExpanded && (\r\n          <motion.div\r\n            initial={{ height: 0, opacity: 0 }}\r\n            animate={{ height: 'auto', opacity: 1 }}\r\n            exit={{ height: 0, opacity: 0 }}\r\n            transition={{ duration: 0.2 }}\r\n            className=\"overflow-hidden\"\r\n          >\r\n            {/* Navigation Info */}\r\n            {showNavigationInfo && (\r\n              <div className=\"mb-3 p-2 bg-gray-900 rounded text-xs\">\r\n                <div className=\"flex justify-between items-center mb-1\">\r\n                  <span className=\"text-gray-400\">Visible Range:</span>\r\n                  <span className=\"text-white font-mono\">\r\n                    {formatTime(viewport.visibleTimeRange.start)} - {formatTime(viewport.visibleTimeRange.end)}\r\n                  </span>\r\n                </div>\r\n                <div className=\"flex justify-between items-center mb-1\">\r\n                  <span className=\"text-gray-400\">Duration:</span>\r\n                  <span className=\"text-white font-mono\">\r\n                    {formatTime(viewport.visibleTimeRange.end - viewport.visibleTimeRange.start)}\r\n                  </span>\r\n                </div>\r\n                <div className=\"flex justify-between items-center\">\r\n                  <span className=\"text-gray-400\">Detail Level:</span>\r\n                  <span className=\"text-white capitalize\">{navigationInfo.detailLevel}</span>\r\n                </div>\r\n                \r\n                {/* Progress Bar */}\r\n                <div className=\"mt-2\">\r\n                  <div className=\"w-full bg-gray-700 rounded-full h-1.5\">\r\n                    <div \r\n                      className=\"bg-blue-500 h-1.5 rounded-full transition-all duration-200\"\r\n                      style={{\r\n                        width: `${navigationInfo.visiblePercentage}%`,\r\n                        marginLeft: `${navigationInfo.startPercentage}%`\r\n                      }}\r\n                    />\r\n                  </div>\r\n                  <div className=\"flex justify-between text-xs text-gray-400 mt-1\">\r\n                    <span>0:00</span>\r\n                    <span>{viewport.audioDuration ? formatTime(viewport.audioDuration) : '--:--'}</span>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n            )}\r\n\r\n            {/* Zoom Presets */}\r\n            {showPresets && zoomPresets.length > 0 && (\r\n              <div>\r\n                <div className=\"text-xs text-gray-400 mb-2\">Quick Zoom:</div>\r\n                <div className=\"flex flex-wrap gap-1\">\r\n                  {zoomPresets.map((preset, index) => (\r\n                    <button\r\n                      key={index}\r\n                      onClick={() => handleZoomPreset(preset)}\r\n                      className={`px-2 py-1 text-xs rounded transition-colors ${\r\n                        Math.abs(preset.zoomLevel - viewport.zoomLevel) < 0.1\r\n                          ? 'bg-blue-600 text-white'\r\n                          : 'bg-gray-700 hover:bg-gray-600 text-gray-300'\r\n                      }`}\r\n                      title={preset.description}\r\n                    >\r\n                      {preset.name}\r\n                    </button>\r\n                  ))}\r\n                </div>\r\n              </div>\r\n            )}\r\n\r\n            {/* Keyboard Shortcuts Help */}\r\n            <div className=\"mt-3 pt-2 border-t border-gray-700\">\r\n              <div className=\"text-xs text-gray-400 mb-1\">Keyboard Shortcuts:</div>\r\n              <div className=\"grid grid-cols-2 gap-1 text-xs text-gray-500\">\r\n                <div>Ctrl + / - : Zoom</div>\r\n                <div>← / → : Pan</div>\r\n                <div>Ctrl + 0 : Fit All</div>\r\n                <div>Home / End : Go to Start/End</div>\r\n                <div>Ctrl + 1/2/5 : Zoom Presets</div>\r\n                <div>Shift + ← / → : Large Pan</div>\r\n              </div>\r\n            </div>\r\n          </motion.div>\r\n        )}\r\n      </AnimatePresence>\r\n    </motion.div>\r\n  );\r\n}","/**\r\n * Zero-crossing detection service for clean sample cuts\r\n * Implements requirement 3.3 - zero-crossing detection algorithm\r\n */\r\n\r\nexport class ZeroCrossingDetector {\r\n  constructor(options = {}) {\r\n    this.options = {\r\n      // Minimum distance between zero-crossings (in samples)\r\n      minDistance: 32,\r\n      // Amplitude threshold for considering a zero-crossing significant\r\n      amplitudeThreshold: 0.01,\r\n      // Window size for analyzing zero-crossing quality\r\n      analysisWindow: 64,\r\n      // Maximum search distance from target time (in seconds)\r\n      maxSearchDistance: 0.1,\r\n      ...options\r\n    };\r\n    \r\n    // Cache for zero-crossing data\r\n    this.zeroCrossingCache = new Map();\r\n  }\r\n\r\n  /**\r\n   * Find zero-crossings in waveform data\r\n   * @param {Float32Array} samples - Audio sample data\r\n   * @param {number} sampleRate - Sample rate in Hz\r\n   * @returns {Array} Array of zero-crossing positions (in sample indices)\r\n   */\r\n  findZeroCrossings(samples, sampleRate) {\r\n    const cacheKey = this.generateCacheKey(samples, sampleRate);\r\n    \r\n    if (this.zeroCrossingCache.has(cacheKey)) {\r\n      return this.zeroCrossingCache.get(cacheKey);\r\n    }\r\n\r\n    const zeroCrossings = [];\r\n    const { minDistance, amplitudeThreshold, analysisWindow } = this.options;\r\n    \r\n    let lastZeroCrossing = -minDistance;\r\n    \r\n    for (let i = 1; i < samples.length; i++) {\r\n      const prevSample = samples[i - 1];\r\n      const currentSample = samples[i];\r\n      \r\n      // Check for sign change (zero-crossing)\r\n      if ((prevSample <= 0 && currentSample > 0) || (prevSample >= 0 && currentSample < 0)) {\r\n        // Ensure minimum distance from last zero-crossing\r\n        if (i - lastZeroCrossing >= minDistance) {\r\n          // Analyze the quality of this zero-crossing\r\n          const quality = this.analyzeZeroCrossingQuality(samples, i, analysisWindow, amplitudeThreshold);\r\n          \r\n          if (quality.isSignificant) {\r\n            zeroCrossings.push({\r\n              sampleIndex: i,\r\n              time: i / sampleRate,\r\n              quality: quality.score,\r\n              amplitude: Math.abs(currentSample),\r\n              slope: Math.abs(currentSample - prevSample)\r\n            });\r\n            \r\n            lastZeroCrossing = i;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Cache the results\r\n    this.zeroCrossingCache.set(cacheKey, zeroCrossings);\r\n    \r\n    return zeroCrossings;\r\n  }\r\n\r\n  /**\r\n   * Find the nearest zero-crossing to a target time\r\n   * @param {Float32Array} samples - Audio sample data\r\n   * @param {number} sampleRate - Sample rate in Hz\r\n   * @param {number} targetTime - Target time in seconds\r\n   * @param {number} tolerance - Search tolerance in seconds\r\n   * @returns {Object|null} Nearest zero-crossing or null if none found\r\n   */\r\n  findNearestZeroCrossing(samples, sampleRate, targetTime, tolerance = null) {\r\n    const searchTolerance = tolerance || this.options.maxSearchDistance;\r\n    const zeroCrossings = this.findZeroCrossings(samples, sampleRate);\r\n    \r\n    if (zeroCrossings.length === 0) {\r\n      return null;\r\n    }\r\n    \r\n    let nearestCrossing = null;\r\n    let minDistance = Infinity;\r\n    \r\n    for (const crossing of zeroCrossings) {\r\n      const distance = Math.abs(crossing.time - targetTime);\r\n      \r\n      if (distance <= searchTolerance && distance < minDistance) {\r\n        minDistance = distance;\r\n        nearestCrossing = crossing;\r\n      }\r\n    }\r\n    \r\n    return nearestCrossing;\r\n  }\r\n\r\n  /**\r\n   * Find optimal cut points within a time range\r\n   * @param {Float32Array} samples - Audio sample data\r\n   * @param {number} sampleRate - Sample rate in Hz\r\n   * @param {number} startTime - Start time in seconds\r\n   * @param {number} endTime - End time in seconds\r\n   * @returns {Object} Optimal start and end cut points\r\n   */\r\n  findOptimalCutPoints(samples, sampleRate, startTime, endTime) {\r\n    const startSample = Math.floor(startTime * sampleRate);\r\n    const endSample = Math.floor(endTime * sampleRate);\r\n    \r\n    // Find zero-crossings near the boundaries\r\n    const startZeroCrossing = this.findNearestZeroCrossing(samples, sampleRate, startTime);\r\n    const endZeroCrossing = this.findNearestZeroCrossing(samples, sampleRate, endTime);\r\n    \r\n    const result = {\r\n      originalStart: startTime,\r\n      originalEnd: endTime,\r\n      optimizedStart: startTime,\r\n      optimizedEnd: endTime,\r\n      startImprovement: 0,\r\n      endImprovement: 0,\r\n      quality: 'original'\r\n    };\r\n    \r\n    // Apply start boundary optimization\r\n    if (startZeroCrossing) {\r\n      const improvement = this.calculateCutQualityImprovement(\r\n        samples, startSample, startZeroCrossing.sampleIndex\r\n      );\r\n      \r\n      if (improvement > 0.1) { // Only apply if significant improvement\r\n        result.optimizedStart = startZeroCrossing.time;\r\n        result.startImprovement = improvement;\r\n      }\r\n    }\r\n    \r\n    // Apply end boundary optimization\r\n    if (endZeroCrossing) {\r\n      const improvement = this.calculateCutQualityImprovement(\r\n        samples, endSample, endZeroCrossing.sampleIndex\r\n      );\r\n      \r\n      if (improvement > 0.1) { // Only apply if significant improvement\r\n        result.optimizedEnd = endZeroCrossing.time;\r\n        result.endImprovement = improvement;\r\n      }\r\n    }\r\n    \r\n    // Determine overall quality\r\n    if (result.startImprovement > 0 || result.endImprovement > 0) {\r\n      const avgImprovement = (result.startImprovement + result.endImprovement) / 2;\r\n      if (avgImprovement > 0.7) {\r\n        result.quality = 'excellent';\r\n      } else if (avgImprovement > 0.4) {\r\n        result.quality = 'good';\r\n      } else {\r\n        result.quality = 'improved';\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Analyze the quality of a zero-crossing\r\n   * @param {Float32Array} samples - Audio sample data\r\n   * @param {number} crossingIndex - Index of the zero-crossing\r\n   * @param {number} windowSize - Analysis window size\r\n   * @param {number} threshold - Amplitude threshold\r\n   * @returns {Object} Quality analysis result\r\n   */\r\n  analyzeZeroCrossingQuality(samples, crossingIndex, windowSize, threshold) {\r\n    const halfWindow = Math.floor(windowSize / 2);\r\n    const startIndex = Math.max(0, crossingIndex - halfWindow);\r\n    const endIndex = Math.min(samples.length - 1, crossingIndex + halfWindow);\r\n    \r\n    // Calculate RMS amplitude in the analysis window\r\n    let rmsSum = 0;\r\n    let sampleCount = 0;\r\n    \r\n    for (let i = startIndex; i <= endIndex; i++) {\r\n      rmsSum += samples[i] * samples[i];\r\n      sampleCount++;\r\n    }\r\n    \r\n    const rmsAmplitude = Math.sqrt(rmsSum / sampleCount);\r\n    \r\n    // Calculate slope at zero-crossing\r\n    const prevSample = samples[crossingIndex - 1] || 0;\r\n    const nextSample = samples[crossingIndex + 1] || 0;\r\n    const slope = Math.abs(nextSample - prevSample);\r\n    \r\n    // Calculate quality score (0-1)\r\n    const amplitudeScore = Math.min(rmsAmplitude / threshold, 1.0);\r\n    const slopeScore = Math.min(slope * 10, 1.0); // Normalize slope\r\n    const qualityScore = (amplitudeScore + slopeScore) / 2;\r\n    \r\n    return {\r\n      isSignificant: rmsAmplitude >= threshold && slope > 0.001,\r\n      score: qualityScore,\r\n      rmsAmplitude,\r\n      slope,\r\n      windowStart: startIndex,\r\n      windowEnd: endIndex\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate improvement in cut quality when moving from original to zero-crossing\r\n   * @param {Float32Array} samples - Audio sample data\r\n   * @param {number} originalIndex - Original cut sample index\r\n   * @param {number} zeroCrossingIndex - Zero-crossing sample index\r\n   * @returns {number} Improvement score (0-1)\r\n   */\r\n  calculateCutQualityImprovement(samples, originalIndex, zeroCrossingIndex) {\r\n    if (originalIndex < 0 || originalIndex >= samples.length ||\r\n        zeroCrossingIndex < 0 || zeroCrossingIndex >= samples.length) {\r\n      return 0;\r\n    }\r\n    \r\n    // Calculate click/pop potential at original position\r\n    const originalAmplitude = Math.abs(samples[originalIndex]);\r\n    const originalClickPotential = originalAmplitude;\r\n    \r\n    // Zero-crossings have minimal click potential\r\n    const zeroCrossingClickPotential = 0.01;\r\n    \r\n    // Calculate improvement (reduction in click potential)\r\n    const improvement = Math.max(0, originalClickPotential - zeroCrossingClickPotential);\r\n    \r\n    // Normalize to 0-1 scale\r\n    return Math.min(improvement * 2, 1.0);\r\n  }\r\n\r\n  /**\r\n   * Get zero-crossings within a specific time range\r\n   * @param {Float32Array} samples - Audio sample data\r\n   * @param {number} sampleRate - Sample rate in Hz\r\n   * @param {number} startTime - Start time in seconds\r\n   * @param {number} endTime - End time in seconds\r\n   * @returns {Array} Zero-crossings within the time range\r\n   */\r\n  getZeroCrossingsInRange(samples, sampleRate, startTime, endTime) {\r\n    const zeroCrossings = this.findZeroCrossings(samples, sampleRate);\r\n    \r\n    return zeroCrossings.filter(crossing => \r\n      crossing.time >= startTime && crossing.time <= endTime\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Generate cache key for waveform data\r\n   * @param {Float32Array} samples - Audio sample data\r\n   * @param {number} sampleRate - Sample rate in Hz\r\n   * @returns {string} Cache key\r\n   */\r\n  generateCacheKey(samples, sampleRate) {\r\n    // Create a simple hash based on sample data characteristics\r\n    const sampleCount = samples.length;\r\n    const checksum = samples.reduce((sum, sample, index) => {\r\n      if (index % 1000 === 0) { // Sample every 1000th sample for performance\r\n        return sum + Math.abs(sample);\r\n      }\r\n      return sum;\r\n    }, 0);\r\n    \r\n    return `${sampleCount}_${sampleRate}_${checksum.toFixed(6)}`;\r\n  }\r\n\r\n  /**\r\n   * Clear the zero-crossing cache\r\n   */\r\n  clearCache() {\r\n    this.zeroCrossingCache.clear();\r\n  }\r\n\r\n  /**\r\n   * Get cache statistics\r\n   * @returns {Object} Cache statistics\r\n   */\r\n  getCacheStats() {\r\n    return {\r\n      size: this.zeroCrossingCache.size,\r\n      keys: Array.from(this.zeroCrossingCache.keys())\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Update detector options\r\n   * @param {Object} newOptions - New options to merge\r\n   */\r\n  updateOptions(newOptions) {\r\n    this.options = { ...this.options, ...newOptions };\r\n    // Clear cache when options change as results may be different\r\n    this.clearCache();\r\n  }\r\n}\r\n\r\nexport default ZeroCrossingDetector;","/**\r\n * Smart snapping service for waveform interactions\r\n * Implements requirement 3.4 - smart snapping with configurable tolerance\r\n */\r\n\r\nimport { ZeroCrossingDetector } from './ZeroCrossingDetector.js';\r\n\r\nexport class SmartSnapping {\r\n  constructor(options = {}) {\r\n    this.options = {\r\n      // Snap tolerance in pixels\r\n      snapTolerance: 10,\r\n      // Snap tolerance in seconds (fallback when pixel conversion not available)\r\n      snapToleranceTime: 0.05,\r\n      // Enable different snap types\r\n      enableZeroCrossingSnap: true,\r\n      enableChopBoundarySnap: true,\r\n      enableGridSnap: false,\r\n      enableBeatSnap: false,\r\n      // Snap priorities (higher number = higher priority)\r\n      snapPriorities: {\r\n        zeroCrossing: 3,\r\n        chopBoundary: 2,\r\n        grid: 1,\r\n        beat: 1\r\n      },\r\n      // Visual feedback options\r\n      showSnapIndicators: true,\r\n      snapIndicatorColor: 'rgba(255, 165, 0, 0.8)',\r\n      snapIndicatorWidth: 2,\r\n      // Zero-crossing detector options\r\n      zeroCrossingOptions: {\r\n        minDistance: 32,\r\n        amplitudeThreshold: 0.01,\r\n        analysisWindow: 64,\r\n        maxSearchDistance: 0.1\r\n      },\r\n      ...options\r\n    };\r\n\r\n    // Initialize zero-crossing detector\r\n    this.zeroCrossingDetector = new ZeroCrossingDetector(this.options.zeroCrossingOptions);\r\n    \r\n    // Current snap targets\r\n    this.snapTargets = [];\r\n    \r\n    // Current waveform data\r\n    this.waveformData = null;\r\n    this.chops = [];\r\n  }\r\n\r\n  /**\r\n   * Update waveform data for zero-crossing detection\r\n   * @param {Object} waveformData - Waveform data with samples and sample rate\r\n   */\r\n  setWaveformData(waveformData) {\r\n    this.waveformData = waveformData;\r\n    \r\n    // Pre-calculate zero-crossings if data is available\r\n    if (waveformData?.samples && waveformData?.sampleRate) {\r\n      this.zeroCrossingDetector.findZeroCrossings(\r\n        waveformData.samples, \r\n        waveformData.sampleRate\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update chop data for boundary snapping\r\n   * @param {Array} chops - Array of chop objects\r\n   */\r\n  setChops(chops) {\r\n    this.chops = chops || [];\r\n  }\r\n\r\n  /**\r\n   * Find the best snap target for a given time position\r\n   * @param {number} targetTime - Target time in seconds\r\n   * @param {number} pixelsPerSecond - Current viewport pixels per second\r\n   * @param {string} excludeChopId - Chop ID to exclude from boundary snapping\r\n   * @returns {Object|null} Best snap target or null if none found\r\n   */\r\n  findSnapTarget(targetTime, pixelsPerSecond = null, excludeChopId = null) {\r\n    const snapTargets = this.findAllSnapTargets(targetTime, pixelsPerSecond, excludeChopId);\r\n    \r\n    if (snapTargets.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    // Sort by priority and distance\r\n    snapTargets.sort((a, b) => {\r\n      // First sort by priority (higher is better)\r\n      if (a.priority !== b.priority) {\r\n        return b.priority - a.priority;\r\n      }\r\n      // Then sort by distance (closer is better)\r\n      return a.distance - b.distance;\r\n    });\r\n\r\n    return snapTargets[0];\r\n  }\r\n\r\n  /**\r\n   * Find all potential snap targets for a given time position\r\n   * @param {number} targetTime - Target time in seconds\r\n   * @param {number} pixelsPerSecond - Current viewport pixels per second\r\n   * @param {string} excludeChopId - Chop ID to exclude from boundary snapping\r\n   * @returns {Array} Array of snap targets\r\n   */\r\n  findAllSnapTargets(targetTime, pixelsPerSecond = null, excludeChopId = null) {\r\n    const snapTargets = [];\r\n    const tolerance = this.calculateSnapTolerance(pixelsPerSecond);\r\n\r\n    // Find zero-crossing snap targets\r\n    if (this.options.enableZeroCrossingSnap && this.waveformData) {\r\n      const zeroCrossingTarget = this.findZeroCrossingSnapTarget(targetTime, tolerance);\r\n      if (zeroCrossingTarget) {\r\n        snapTargets.push(zeroCrossingTarget);\r\n      }\r\n    }\r\n\r\n    // Find chop boundary snap targets\r\n    if (this.options.enableChopBoundarySnap) {\r\n      const boundaryTargets = this.findChopBoundarySnapTargets(targetTime, tolerance, excludeChopId);\r\n      snapTargets.push(...boundaryTargets);\r\n    }\r\n\r\n    // Find grid snap targets (if enabled)\r\n    if (this.options.enableGridSnap) {\r\n      const gridTarget = this.findGridSnapTarget(targetTime, tolerance);\r\n      if (gridTarget) {\r\n        snapTargets.push(gridTarget);\r\n      }\r\n    }\r\n\r\n    return snapTargets;\r\n  }\r\n\r\n  /**\r\n   * Find zero-crossing snap target\r\n   * @param {number} targetTime - Target time in seconds\r\n   * @param {number} tolerance - Snap tolerance in seconds\r\n   * @returns {Object|null} Zero-crossing snap target or null\r\n   */\r\n  findZeroCrossingSnapTarget(targetTime, tolerance) {\r\n    if (!this.waveformData?.samples || !this.waveformData?.sampleRate) {\r\n      return null;\r\n    }\r\n\r\n    const nearestZeroCrossing = this.zeroCrossingDetector.findNearestZeroCrossing(\r\n      this.waveformData.samples,\r\n      this.waveformData.sampleRate,\r\n      targetTime,\r\n      tolerance\r\n    );\r\n\r\n    if (!nearestZeroCrossing) {\r\n      return null;\r\n    }\r\n\r\n    const distance = Math.abs(nearestZeroCrossing.time - targetTime);\r\n\r\n    return {\r\n      type: 'zero-crossing',\r\n      time: nearestZeroCrossing.time,\r\n      distance,\r\n      priority: this.options.snapPriorities.zeroCrossing,\r\n      quality: nearestZeroCrossing.quality,\r\n      data: nearestZeroCrossing\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Find chop boundary snap targets\r\n   * @param {number} targetTime - Target time in seconds\r\n   * @param {number} tolerance - Snap tolerance in seconds\r\n   * @param {string} excludeChopId - Chop ID to exclude\r\n   * @returns {Array} Array of boundary snap targets\r\n   */\r\n  findChopBoundarySnapTargets(targetTime, tolerance, excludeChopId = null) {\r\n    const targets = [];\r\n\r\n    for (const chop of this.chops) {\r\n      if (chop.id === excludeChopId) continue;\r\n\r\n      // Check start boundary\r\n      const startDistance = Math.abs(chop.startTime - targetTime);\r\n      if (startDistance <= tolerance) {\r\n        targets.push({\r\n          type: 'chop-boundary',\r\n          subType: 'start',\r\n          time: chop.startTime,\r\n          distance: startDistance,\r\n          priority: this.options.snapPriorities.chopBoundary,\r\n          chopId: chop.id,\r\n          data: chop\r\n        });\r\n      }\r\n\r\n      // Check end boundary\r\n      const endDistance = Math.abs(chop.endTime - targetTime);\r\n      if (endDistance <= tolerance) {\r\n        targets.push({\r\n          type: 'chop-boundary',\r\n          subType: 'end',\r\n          time: chop.endTime,\r\n          distance: endDistance,\r\n          priority: this.options.snapPriorities.chopBoundary,\r\n          chopId: chop.id,\r\n          data: chop\r\n        });\r\n      }\r\n    }\r\n\r\n    return targets;\r\n  }\r\n\r\n  /**\r\n   * Find grid snap target (for regular time intervals)\r\n   * @param {number} targetTime - Target time in seconds\r\n   * @param {number} tolerance - Snap tolerance in seconds\r\n   * @returns {Object|null} Grid snap target or null\r\n   */\r\n  findGridSnapTarget(targetTime, tolerance) {\r\n    // Default grid interval (can be made configurable)\r\n    const gridInterval = 1.0; // 1 second intervals\r\n    \r\n    const nearestGridTime = Math.round(targetTime / gridInterval) * gridInterval;\r\n    const distance = Math.abs(nearestGridTime - targetTime);\r\n\r\n    if (distance <= tolerance) {\r\n      return {\r\n        type: 'grid',\r\n        time: nearestGridTime,\r\n        distance,\r\n        priority: this.options.snapPriorities.grid,\r\n        interval: gridInterval\r\n      };\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Apply smart snapping to a time position\r\n   * @param {number} targetTime - Target time in seconds\r\n   * @param {number} pixelsPerSecond - Current viewport pixels per second\r\n   * @param {string} excludeChopId - Chop ID to exclude from boundary snapping\r\n   * @returns {Object} Snapping result with snapped time and snap info\r\n   */\r\n  applySnapping(targetTime, pixelsPerSecond = null, excludeChopId = null) {\r\n    const snapTarget = this.findSnapTarget(targetTime, pixelsPerSecond, excludeChopId);\r\n\r\n    if (snapTarget) {\r\n      return {\r\n        originalTime: targetTime,\r\n        snappedTime: snapTarget.time,\r\n        wasSnapped: true,\r\n        snapTarget,\r\n        snapDistance: snapTarget.distance\r\n      };\r\n    }\r\n\r\n    return {\r\n      originalTime: targetTime,\r\n      snappedTime: targetTime,\r\n      wasSnapped: false,\r\n      snapTarget: null,\r\n      snapDistance: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get visual snap indicators for rendering\r\n   * @param {number} targetTime - Target time in seconds\r\n   * @param {number} pixelsPerSecond - Current viewport pixels per second\r\n   * @param {string} excludeChopId - Chop ID to exclude from boundary snapping\r\n   * @returns {Array} Array of snap indicators for rendering\r\n   */\r\n  getSnapIndicators(targetTime, pixelsPerSecond = null, excludeChopId = null) {\r\n    if (!this.options.showSnapIndicators) {\r\n      return [];\r\n    }\r\n\r\n    const snapTargets = this.findAllSnapTargets(targetTime, pixelsPerSecond, excludeChopId);\r\n    const tolerance = this.calculateSnapTolerance(pixelsPerSecond);\r\n\r\n    return snapTargets\r\n      .filter(target => target.distance <= tolerance)\r\n      .map(target => ({\r\n        type: target.type,\r\n        time: target.time,\r\n        priority: target.priority,\r\n        color: this.getSnapIndicatorColor(target.type),\r\n        width: this.options.snapIndicatorWidth,\r\n        style: this.getSnapIndicatorStyle(target.type),\r\n        label: this.getSnapIndicatorLabel(target)\r\n      }));\r\n  }\r\n\r\n  /**\r\n   * Get snap indicator color based on snap type\r\n   * @param {string} snapType - Type of snap target\r\n   * @returns {string} Color string\r\n   */\r\n  getSnapIndicatorColor(snapType) {\r\n    const colors = {\r\n      'zero-crossing': 'rgba(34, 197, 94, 0.8)', // Green\r\n      'chop-boundary': 'rgba(59, 130, 246, 0.8)', // Blue\r\n      'grid': 'rgba(156, 163, 175, 0.6)', // Gray\r\n      'beat': 'rgba(245, 101, 101, 0.8)' // Red\r\n    };\r\n\r\n    return colors[snapType] || this.options.snapIndicatorColor;\r\n  }\r\n\r\n  /**\r\n   * Get snap indicator style based on snap type\r\n   * @param {string} snapType - Type of snap target\r\n   * @returns {string} Style identifier\r\n   */\r\n  getSnapIndicatorStyle(snapType) {\r\n    const styles = {\r\n      'zero-crossing': 'solid',\r\n      'chop-boundary': 'dashed',\r\n      'grid': 'dotted',\r\n      'beat': 'solid'\r\n    };\r\n\r\n    return styles[snapType] || 'solid';\r\n  }\r\n\r\n  /**\r\n   * Get snap indicator label\r\n   * @param {Object} snapTarget - Snap target object\r\n   * @returns {string} Label text\r\n   */\r\n  getSnapIndicatorLabel(snapTarget) {\r\n    switch (snapTarget.type) {\r\n      case 'zero-crossing':\r\n        return `Zero crossing (${snapTarget.time.toFixed(3)}s)`;\r\n      case 'chop-boundary':\r\n        return `Chop ${snapTarget.subType} (${snapTarget.time.toFixed(3)}s)`;\r\n      case 'grid':\r\n        return `Grid (${snapTarget.time.toFixed(1)}s)`;\r\n      case 'beat':\r\n        return `Beat (${snapTarget.time.toFixed(3)}s)`;\r\n      default:\r\n        return `Snap (${snapTarget.time.toFixed(3)}s)`;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate snap tolerance in seconds based on viewport\r\n   * @param {number} pixelsPerSecond - Current viewport pixels per second\r\n   * @returns {number} Snap tolerance in seconds\r\n   */\r\n  calculateSnapTolerance(pixelsPerSecond) {\r\n    if (pixelsPerSecond && pixelsPerSecond > 0) {\r\n      return this.options.snapTolerance / pixelsPerSecond;\r\n    }\r\n    return this.options.snapToleranceTime;\r\n  }\r\n\r\n  /**\r\n   * Update snapping options\r\n   * @param {Object} newOptions - New options to merge\r\n   */\r\n  updateOptions(newOptions) {\r\n    this.options = { ...this.options, ...newOptions };\r\n    \r\n    // Update zero-crossing detector options if provided\r\n    if (newOptions.zeroCrossingOptions) {\r\n      this.zeroCrossingDetector.updateOptions(newOptions.zeroCrossingOptions);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current snapping configuration\r\n   * @returns {Object} Current options\r\n   */\r\n  getOptions() {\r\n    return { ...this.options };\r\n  }\r\n\r\n  /**\r\n   * Enable or disable specific snap types\r\n   * @param {Object} snapTypes - Object with snap type keys and boolean values\r\n   */\r\n  setSnapTypes(snapTypes) {\r\n    Object.keys(snapTypes).forEach(key => {\r\n      const optionKey = `enable${key.charAt(0).toUpperCase() + key.slice(1)}Snap`;\r\n      if (this.options.hasOwnProperty(optionKey)) {\r\n        this.options[optionKey] = snapTypes[key];\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get statistics about current snap targets\r\n   * @returns {Object} Statistics object\r\n   */\r\n  getSnapStatistics() {\r\n    const stats = {\r\n      zeroCrossings: 0,\r\n      chopBoundaries: this.chops.length * 2,\r\n      cacheStats: this.zeroCrossingDetector.getCacheStats()\r\n    };\r\n\r\n    if (this.waveformData?.samples && this.waveformData?.sampleRate) {\r\n      const zeroCrossings = this.zeroCrossingDetector.findZeroCrossings(\r\n        this.waveformData.samples,\r\n        this.waveformData.sampleRate\r\n      );\r\n      stats.zeroCrossings = zeroCrossings.length;\r\n    }\r\n\r\n    return stats;\r\n  }\r\n\r\n  /**\r\n   * Clear all caches\r\n   */\r\n  clearCaches() {\r\n    this.zeroCrossingDetector.clearCache();\r\n  }\r\n}\r\n\r\nexport default SmartSnapping;","/**\r\n * InteractionManager for handling mouse events on waveform canvas\r\n * Implements click-to-create-chop functionality and hover effects\r\n * Requirements: 2.1, 2.3, 5.5, 3.3, 3.4\r\n */\r\n\r\nimport { SmartSnapping } from '../../services/SmartSnapping.js';\r\n\r\nexport class InteractionManager {\r\n  constructor(canvasRenderer, options = {}) {\r\n    this.canvasRenderer = canvasRenderer;\r\n    this.options = {\r\n      clickThreshold: 5, // pixels - max movement for click vs drag\r\n      hoverDelay: 100, // ms - delay before showing hover info\r\n      snapTolerance: 10, // pixels - snap distance for boundaries\r\n      enableHover: true,\r\n      enableClick: true,\r\n      enableDrag: true,\r\n      enableSmartSnapping: true, // Enable snapping to boundaries and zero-crossings\r\n      enableVisualFeedback: true, // Enable enhanced visual feedback during drag\r\n      enableConflictPrevention: true, // Prevent overlapping chops\r\n      dragSensitivity: 1.0, // Multiplier for drag sensitivity\r\n      // Smart snapping configuration\r\n      snapToleranceTime: 0.05, // seconds\r\n      enableZeroCrossingSnap: true,\r\n      enableChopBoundarySnap: true,\r\n      showSnapIndicators: true,\r\n      ...options\r\n    };\r\n\r\n    // Initialize smart snapping service\r\n    this.smartSnapping = new SmartSnapping({\r\n      snapTolerance: this.options.snapTolerance,\r\n      snapToleranceTime: this.options.snapToleranceTime,\r\n      enableZeroCrossingSnap: this.options.enableZeroCrossingSnap,\r\n      enableChopBoundarySnap: this.options.enableChopBoundarySnap,\r\n      showSnapIndicators: this.options.showSnapIndicators\r\n    });\r\n\r\n    // Interaction state\r\n    this.isMouseDown = false;\r\n    this.isDragging = false;\r\n    this.mouseDownPosition = { x: 0, y: 0 };\r\n    this.currentMousePosition = { x: 0, y: 0 };\r\n    this.hoverTimeout = null;\r\n    this.hoveredElement = null;\r\n    \r\n    // Drag state\r\n    this.dragState = {\r\n      type: null, // 'create-chop', 'move-boundary', 'seek'\r\n      startTime: 0,\r\n      endTime: 0,\r\n      chopId: null,\r\n      boundaryType: null // 'start' or 'end'\r\n    };\r\n\r\n    // Event callbacks\r\n    this.callbacks = {\r\n      onChopCreate: null,\r\n      onChopUpdate: null,\r\n      onTimeSeek: null,\r\n      onHover: null\r\n    };\r\n\r\n    // Current waveform data for zero-crossing detection\r\n    this.waveformData = null;\r\n    \r\n    // Current snap result for visual feedback\r\n    this.currentSnapResult = null;\r\n    \r\n    // Current chops for interaction\r\n    this.currentChops = [];\r\n\r\n    this.initialize();\r\n  }\r\n\r\n  /**\r\n   * Initialize event listeners on interaction layer\r\n   */\r\n  initialize() {\r\n    const layerManager = this.canvasRenderer.getLayerManager();\r\n    const interactionLayer = layerManager.getLayer('interaction');\r\n    \r\n    if (!interactionLayer) {\r\n      console.error('InteractionManager: interaction layer not found');\r\n      return;\r\n    }\r\n\r\n    const canvas = interactionLayer.canvas;\r\n    \r\n    // Mouse event listeners\r\n    canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));\r\n    canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));\r\n    canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));\r\n    canvas.addEventListener('mouseleave', this.handleMouseLeave.bind(this));\r\n    canvas.addEventListener('wheel', this.handleWheel.bind(this));\r\n    \r\n    // Touch event listeners for mobile support\r\n    canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));\r\n    canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));\r\n    canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));\r\n    \r\n    // Prevent context menu on right click\r\n    canvas.addEventListener('contextmenu', (e) => e.preventDefault());\r\n    \r\n    // Keyboard event listeners for navigation shortcuts\r\n    // Make canvas focusable for keyboard events\r\n    canvas.tabIndex = 0;\r\n    canvas.addEventListener('keydown', this.handleKeyDown.bind(this));\r\n    canvas.addEventListener('keyup', this.handleKeyUp.bind(this));\r\n    \r\n    // Set cursor style\r\n    canvas.style.cursor = 'crosshair';\r\n    \r\n    // Track keyboard state\r\n    this.keyState = {\r\n      shift: false,\r\n      ctrl: false,\r\n      alt: false\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Set event callbacks\r\n   */\r\n  setCallbacks(callbacks) {\r\n    this.callbacks = { ...this.callbacks, ...callbacks };\r\n  }\r\n\r\n  /**\r\n   * Set waveform data for zero-crossing detection\r\n   * @param {Object} waveformData - Waveform data with samples and sample rate\r\n   */\r\n  setWaveformData(waveformData) {\r\n    this.waveformData = waveformData;\r\n    this.smartSnapping.setWaveformData(waveformData);\r\n  }\r\n\r\n  /**\r\n   * Set current chops for boundary snapping\r\n   * @param {Array} chops - Array of chop objects\r\n   */\r\n  setCurrentChops(chops) {\r\n    this.currentChops = chops || [];\r\n    this.smartSnapping.setChops(chops);\r\n  }\r\n\r\n  /**\r\n   * Get current chops\r\n   * @returns {Array} Current chops array\r\n   */\r\n  getCurrentChops() {\r\n    return this.currentChops || [];\r\n  }\r\n\r\n  /**\r\n   * Handle mouse down events\r\n   */\r\n  handleMouseDown(event) {\r\n    if (!this.options.enableClick && !this.options.enableDrag) return;\r\n    \r\n    event.preventDefault();\r\n    \r\n    const rect = event.target.getBoundingClientRect();\r\n    const x = event.clientX - rect.left;\r\n    const y = event.clientY - rect.top;\r\n    \r\n    this.isMouseDown = true;\r\n    this.mouseDownPosition = { x, y };\r\n    this.currentMousePosition = { x, y };\r\n    \r\n    // Clear any existing hover state\r\n    this.clearHover();\r\n    \r\n    // Check what was clicked\r\n    const clickedElement = this.getElementAtPosition(x, y);\r\n    \r\n    if (clickedElement) {\r\n      this.handleElementClick(clickedElement, x, y, event);\r\n    } else {\r\n      // Clicked on empty waveform area\r\n      this.initializeChopCreation(x, y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle mouse move events\r\n   */\r\n  handleMouseMove(event) {\r\n    const rect = event.target.getBoundingClientRect();\r\n    const x = event.clientX - rect.left;\r\n    const y = event.clientY - rect.top;\r\n    \r\n    this.currentMousePosition = { x, y };\r\n    \r\n    if (this.isMouseDown) {\r\n      this.handleDragMove(x, y);\r\n    } else if (this.options.enableHover) {\r\n      this.handleHoverMove(x, y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle mouse up events\r\n   */\r\n  handleMouseUp(event) {\r\n    if (!this.isMouseDown) return;\r\n    \r\n    event.preventDefault();\r\n    \r\n    const rect = event.target.getBoundingClientRect();\r\n    const x = event.clientX - rect.left;\r\n    const y = event.clientY - rect.top;\r\n    \r\n    if (this.isDragging) {\r\n      this.finalizeDrag(x, y);\r\n    } else {\r\n      this.handleClick(x, y);\r\n    }\r\n    \r\n    this.resetInteractionState();\r\n  }\r\n\r\n  /**\r\n   * Handle mouse leave events\r\n   */\r\n  handleMouseLeave(event) {\r\n    this.clearHover();\r\n    this.resetInteractionState();\r\n  }\r\n\r\n  /**\r\n   * Handle wheel events for zoom with smooth scaling transitions\r\n   * Implements requirement 4.1 - mouse wheel zoom functionality\r\n   */\r\n  handleWheel(event) {\r\n    event.preventDefault();\r\n    \r\n    const rect = event.target.getBoundingClientRect();\r\n    const x = event.clientX - rect.left;\r\n    \r\n    // Convert mouse position to time for zoom center\r\n    const viewportManager = this.canvasRenderer.getViewportManager();\r\n    const centerTime = viewportManager.pixelToTime(x);\r\n    \r\n    // Calculate zoom factor based on wheel delta and modifiers\r\n    let zoomFactor = 1.25;\r\n    \r\n    // Fine zoom with Shift key\r\n    if (event.shiftKey) {\r\n      zoomFactor = 1.1;\r\n    }\r\n    \r\n    // Coarse zoom with Ctrl key\r\n    if (event.ctrlKey) {\r\n      zoomFactor = 2.0;\r\n    }\r\n    \r\n    // Apply zoom with smooth transition\r\n    if (event.deltaY > 0) {\r\n      this.smoothZoom(viewportManager, 1 / zoomFactor, centerTime);\r\n    } else {\r\n      this.smoothZoom(viewportManager, zoomFactor, centerTime);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply smooth zoom transition\r\n   * Implements requirement 4.1 - smooth scaling transitions\r\n   */\r\n  smoothZoom(viewportManager, zoomFactor, centerTime) {\r\n    const currentZoom = viewportManager.getState().zoomLevel;\r\n    const targetZoom = currentZoom * zoomFactor;\r\n    \r\n    // Clamp to zoom limits\r\n    const { minZoom, maxZoom } = viewportManager.getState();\r\n    const clampedZoom = Math.max(minZoom, Math.min(maxZoom, targetZoom));\r\n    \r\n    if (clampedZoom === currentZoom) return; // No change needed\r\n    \r\n    // Animate zoom transition\r\n    this.animateZoom(viewportManager, currentZoom, clampedZoom, centerTime, 150);\r\n  }\r\n\r\n  /**\r\n   * Animate zoom transition over time\r\n   */\r\n  animateZoom(viewportManager, startZoom, endZoom, centerTime, duration) {\r\n    const startTime = performance.now();\r\n    \r\n    const animate = (currentTime) => {\r\n      const elapsed = currentTime - startTime;\r\n      const progress = Math.min(elapsed / duration, 1);\r\n      \r\n      // Use easeOutCubic for smooth deceleration\r\n      const easeProgress = 1 - Math.pow(1 - progress, 3);\r\n      \r\n      const currentZoom = startZoom + (endZoom - startZoom) * easeProgress;\r\n      viewportManager.setZoom(currentZoom, centerTime);\r\n      \r\n      if (progress < 1) {\r\n        requestAnimationFrame(animate);\r\n      }\r\n    };\r\n    \r\n    requestAnimationFrame(animate);\r\n  }\r\n\r\n  /**\r\n   * Get element at specific position (chop boundary, chop region, etc.)\r\n   */\r\n  getElementAtPosition(x, y) {\r\n    const viewportManager = this.canvasRenderer.getViewportManager();\r\n    const time = viewportManager.pixelToTime(x);\r\n    \r\n    // Check for chop boundaries first (higher priority)\r\n    const chops = this.getCurrentChops();\r\n    \r\n    for (const chop of chops) {\r\n      const startPixel = viewportManager.timeToPixel(chop.startTime);\r\n      const endPixel = viewportManager.timeToPixel(chop.endTime);\r\n      \r\n      // Check start boundary\r\n      if (Math.abs(x - startPixel) <= this.options.snapTolerance) {\r\n        return {\r\n          type: 'chop-boundary',\r\n          chopId: chop.id,\r\n          boundaryType: 'start',\r\n          time: chop.startTime,\r\n          pixel: startPixel\r\n        };\r\n      }\r\n      \r\n      // Check end boundary\r\n      if (Math.abs(x - endPixel) <= this.options.snapTolerance) {\r\n        return {\r\n          type: 'chop-boundary',\r\n          chopId: chop.id,\r\n          boundaryType: 'end',\r\n          time: chop.endTime,\r\n          pixel: endPixel\r\n        };\r\n      }\r\n      \r\n      // Check chop region\r\n      if (time >= chop.startTime && time <= chop.endTime) {\r\n        return {\r\n          type: 'chop-region',\r\n          chopId: chop.id,\r\n          chop: chop,\r\n          time: time,\r\n          pixel: x\r\n        };\r\n      }\r\n    }\r\n    \r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Handle click on specific elements\r\n   */\r\n  handleElementClick(element, x, y, event) {\r\n    switch (element.type) {\r\n      case 'chop-boundary':\r\n        this.initializeBoundaryDrag(element, x, y);\r\n        break;\r\n      case 'chop-region':\r\n        if (event.shiftKey) {\r\n          // Shift+click to select chop\r\n          this.selectChop(element.chopId);\r\n        } else {\r\n          // Regular click to seek to position\r\n          this.seekToTime(element.time);\r\n        }\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize chop creation drag\r\n   */\r\n  initializeChopCreation(x, y) {\r\n    const viewportManager = this.canvasRenderer.getViewportManager();\r\n    const time = viewportManager.pixelToTime(x);\r\n    \r\n    this.dragState = {\r\n      type: 'create-chop',\r\n      startTime: time,\r\n      endTime: time,\r\n      chopId: null,\r\n      boundaryType: null\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Initialize boundary drag operation\r\n   */\r\n  initializeBoundaryDrag(element, x, y) {\r\n    this.dragState = {\r\n      type: 'move-boundary',\r\n      startTime: element.time,\r\n      endTime: element.time,\r\n      chopId: element.chopId,\r\n      boundaryType: element.boundaryType\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Handle drag movement\r\n   */\r\n  handleDragMove(x, y) {\r\n    const distance = Math.sqrt(\r\n      Math.pow(x - this.mouseDownPosition.x, 2) + \r\n      Math.pow(y - this.mouseDownPosition.y, 2)\r\n    );\r\n    \r\n    if (!this.isDragging && distance > this.options.clickThreshold) {\r\n      this.isDragging = true;\r\n      this.startDrag();\r\n    }\r\n    \r\n    if (this.isDragging) {\r\n      this.updateDrag(x, y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start drag operation\r\n   */\r\n  startDrag() {\r\n    const canvas = this.canvasRenderer.getLayerManager().getLayer('interaction').canvas;\r\n    \r\n    switch (this.dragState.type) {\r\n      case 'create-chop':\r\n        canvas.style.cursor = 'col-resize';\r\n        break;\r\n      case 'move-boundary':\r\n        canvas.style.cursor = 'ew-resize';\r\n        break;\r\n      default:\r\n        canvas.style.cursor = 'grabbing';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update drag operation\r\n   */\r\n  updateDrag(x, y) {\r\n    const viewportManager = this.canvasRenderer.getViewportManager();\r\n    const currentTime = viewportManager.pixelToTime(x);\r\n    \r\n    switch (this.dragState.type) {\r\n      case 'create-chop':\r\n        this.dragState.endTime = currentTime;\r\n        this.renderDragPreview();\r\n        break;\r\n      case 'move-boundary':\r\n        this.updateBoundaryDrag(currentTime);\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update boundary drag with constraints and smart snapping\r\n   */\r\n  updateBoundaryDrag(newTime) {\r\n    const chops = this.getCurrentChops();\r\n    const chop = chops.find(c => c.id === this.dragState.chopId);\r\n    \r\n    if (!chop) return;\r\n    \r\n    // Apply smart snapping if enabled\r\n    const snappedTime = this.applySmartSnapping(newTime);\r\n    \r\n    // Apply constraints based on boundary type\r\n    if (this.dragState.boundaryType === 'start') {\r\n      // Start boundary cannot go past end boundary\r\n      this.dragState.startTime = Math.min(snappedTime, chop.endTime - 0.01);\r\n      \r\n      // Check for conflicts with other chops\r\n      const conflictingChop = this.findConflictingChop(this.dragState.startTime, chop.endTime, chop.id);\r\n      if (conflictingChop) {\r\n        this.dragState.startTime = Math.max(this.dragState.startTime, conflictingChop.endTime);\r\n      }\r\n    } else {\r\n      // End boundary cannot go before start boundary\r\n      this.dragState.endTime = Math.max(snappedTime, chop.startTime + 0.01);\r\n      \r\n      // Check for conflicts with other chops\r\n      const conflictingChop = this.findConflictingChop(chop.startTime, this.dragState.endTime, chop.id);\r\n      if (conflictingChop) {\r\n        this.dragState.endTime = Math.min(this.dragState.endTime, conflictingChop.startTime);\r\n      }\r\n    }\r\n    \r\n    this.renderDragPreview();\r\n  }\r\n\r\n  /**\r\n   * Apply smart snapping to zero-crossings and other chop boundaries\r\n   */\r\n  applySmartSnapping(time) {\r\n    if (!this.options.enableSmartSnapping) {\r\n      return time;\r\n    }\r\n\r\n    const viewportManager = this.canvasRenderer.getViewportManager();\r\n    const pixelsPerSecond = viewportManager.getViewportBounds()?.pixelsPerSecond || 80;\r\n    \r\n    // Use smart snapping service\r\n    const snapResult = this.smartSnapping.applySnapping(\r\n      time, \r\n      pixelsPerSecond, \r\n      this.dragState.chopId\r\n    );\r\n    \r\n    // Store snap information for visual feedback\r\n    this.currentSnapResult = snapResult;\r\n    \r\n    return snapResult.snappedTime;\r\n  }\r\n\r\n  /**\r\n   * Find chop that would conflict with the given time range\r\n   */\r\n  findConflictingChop(startTime, endTime, excludeChopId) {\r\n    const chops = this.getCurrentChops();\r\n    \r\n    for (const chop of chops) {\r\n      if (chop.id === excludeChopId) continue;\r\n      \r\n      // Check for overlap\r\n      if (!(endTime <= chop.startTime || startTime >= chop.endTime)) {\r\n        return chop;\r\n      }\r\n    }\r\n    \r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Render drag preview on interaction layer\r\n   */\r\n  renderDragPreview() {\r\n    const layerManager = this.canvasRenderer.getLayerManager();\r\n    const interactionLayer = layerManager.getLayer('interaction');\r\n    \r\n    if (!interactionLayer) return;\r\n    \r\n    const { ctx } = interactionLayer;\r\n    const { width, height } = layerManager.getDimensions();\r\n    const viewportManager = this.canvasRenderer.getViewportManager();\r\n    \r\n    // Clear interaction layer\r\n    layerManager.clearLayer('interaction');\r\n    \r\n    switch (this.dragState.type) {\r\n      case 'create-chop':\r\n        this.renderChopCreationPreview(ctx, viewportManager, width, height);\r\n        break;\r\n      case 'move-boundary':\r\n        this.renderBoundaryMovePreview(ctx, viewportManager, width, height);\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render chop creation preview with enhanced visual feedback\r\n   */\r\n  renderChopCreationPreview(ctx, viewportManager, width, height) {\r\n    const startPixel = viewportManager.timeToPixel(this.dragState.startTime);\r\n    const endPixel = viewportManager.timeToPixel(this.dragState.endTime);\r\n    \r\n    const leftPixel = Math.min(startPixel, endPixel);\r\n    const rightPixel = Math.max(startPixel, endPixel);\r\n    const regionWidth = rightPixel - leftPixel;\r\n    \r\n    if (regionWidth > 1) {\r\n      // Draw preview region with gradient\r\n      const gradient = ctx.createLinearGradient(leftPixel, 0, rightPixel, 0);\r\n      gradient.addColorStop(0, 'rgba(59, 130, 246, 0.4)');\r\n      gradient.addColorStop(0.5, 'rgba(59, 130, 246, 0.2)');\r\n      gradient.addColorStop(1, 'rgba(59, 130, 246, 0.4)');\r\n      \r\n      ctx.fillStyle = gradient;\r\n      ctx.fillRect(leftPixel, 0, regionWidth, height);\r\n      \r\n      // Draw animated boundaries\r\n      const animationOffset = (Date.now() % 1000) / 1000 * 10; // 10px animation cycle\r\n      ctx.strokeStyle = 'rgba(59, 130, 246, 0.9)';\r\n      ctx.lineWidth = 2;\r\n      ctx.setLineDash([8, 4]);\r\n      ctx.lineDashOffset = animationOffset;\r\n      \r\n      ctx.beginPath();\r\n      ctx.moveTo(leftPixel, 0);\r\n      ctx.lineTo(leftPixel, height);\r\n      ctx.moveTo(rightPixel, 0);\r\n      ctx.lineTo(rightPixel, height);\r\n      ctx.stroke();\r\n      \r\n      ctx.setLineDash([]);\r\n      ctx.lineDashOffset = 0;\r\n      \r\n      // Draw drag handles\r\n      this.renderDragHandles(ctx, leftPixel, rightPixel, height);\r\n    }\r\n    \r\n    // Show enhanced timing information\r\n    this.renderEnhancedTimingInfo(ctx, leftPixel, rightPixel, height);\r\n  }\r\n\r\n  /**\r\n   * Render boundary move preview with snap indicators\r\n   */\r\n  renderBoundaryMovePreview(ctx, viewportManager, width, height) {\r\n    const chops = this.getCurrentChops();\r\n    const chop = chops.find(c => c.id === this.dragState.chopId);\r\n    \r\n    if (!chop) return;\r\n    \r\n    // Calculate new boundary position\r\n    let startTime = chop.startTime;\r\n    let endTime = chop.endTime;\r\n    \r\n    if (this.dragState.boundaryType === 'start') {\r\n      startTime = this.dragState.startTime;\r\n    } else {\r\n      endTime = this.dragState.endTime;\r\n    }\r\n    \r\n    const startPixel = viewportManager.timeToPixel(startTime);\r\n    const endPixel = viewportManager.timeToPixel(endTime);\r\n    \r\n    // Draw updated chop region with subtle animation\r\n    const pulseAlpha = 0.2 + 0.1 * Math.sin(Date.now() / 200);\r\n    ctx.fillStyle = `rgba(34, 197, 94, ${pulseAlpha})`;\r\n    ctx.fillRect(startPixel, 0, endPixel - startPixel, height);\r\n    \r\n    // Draw static boundary (not being moved)\r\n    const staticBoundaryPixel = this.dragState.boundaryType === 'start' ? endPixel : startPixel;\r\n    ctx.strokeStyle = 'rgba(34, 197, 94, 0.6)';\r\n    ctx.lineWidth = 1;\r\n    ctx.beginPath();\r\n    ctx.moveTo(staticBoundaryPixel, 0);\r\n    ctx.lineTo(staticBoundaryPixel, height);\r\n    ctx.stroke();\r\n    \r\n    // Highlight the boundary being moved with enhanced visuals\r\n    const boundaryPixel = this.dragState.boundaryType === 'start' ? startPixel : endPixel;\r\n    \r\n    // Draw glow effect\r\n    ctx.shadowColor = 'rgba(34, 197, 94, 0.8)';\r\n    ctx.shadowBlur = 8;\r\n    ctx.strokeStyle = 'rgba(34, 197, 94, 1)';\r\n    ctx.lineWidth = 3;\r\n    ctx.beginPath();\r\n    ctx.moveTo(boundaryPixel, 0);\r\n    ctx.lineTo(boundaryPixel, height);\r\n    ctx.stroke();\r\n    \r\n    // Reset shadow\r\n    ctx.shadowColor = 'transparent';\r\n    ctx.shadowBlur = 0;\r\n    \r\n    // Draw drag handle\r\n    this.renderDragHandle(ctx, boundaryPixel, height / 2, 'active');\r\n    \r\n    // Show snap indicators\r\n    this.renderSnapIndicators(ctx, viewportManager, width, height);\r\n    \r\n    // Show enhanced timing information\r\n    this.renderEnhancedTimingInfo(ctx, startPixel, endPixel, height);\r\n  }\r\n\r\n  /**\r\n   * Render drag handles for boundaries\r\n   */\r\n  renderDragHandles(ctx, leftPixel, rightPixel, height) {\r\n    this.renderDragHandle(ctx, leftPixel, height / 2, 'start');\r\n    this.renderDragHandle(ctx, rightPixel, height / 2, 'end');\r\n  }\r\n\r\n  /**\r\n   * Render individual drag handle\r\n   */\r\n  renderDragHandle(ctx, x, y, type) {\r\n    const handleSize = 8;\r\n    const handleColor = type === 'active' ? 'rgba(34, 197, 94, 1)' : 'rgba(59, 130, 246, 1)';\r\n    \r\n    // Draw handle background\r\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\r\n    ctx.fillRect(x - handleSize / 2, y - handleSize / 2, handleSize, handleSize);\r\n    \r\n    // Draw handle border\r\n    ctx.strokeStyle = handleColor;\r\n    ctx.lineWidth = 2;\r\n    ctx.strokeRect(x - handleSize / 2, y - handleSize / 2, handleSize, handleSize);\r\n    \r\n    // Draw handle grip lines\r\n    ctx.strokeStyle = handleColor;\r\n    ctx.lineWidth = 1;\r\n    ctx.beginPath();\r\n    ctx.moveTo(x - 2, y - 3);\r\n    ctx.lineTo(x - 2, y + 3);\r\n    ctx.moveTo(x, y - 3);\r\n    ctx.lineTo(x, y + 3);\r\n    ctx.moveTo(x + 2, y - 3);\r\n    ctx.lineTo(x + 2, y + 3);\r\n    ctx.stroke();\r\n  }\r\n\r\n  /**\r\n   * Render snap indicators for nearby boundaries and zero-crossings\r\n   */\r\n  renderSnapIndicators(ctx, viewportManager, width, height) {\r\n    if (!this.options.enableSmartSnapping || !this.options.showSnapIndicators) return;\r\n    \r\n    const currentTime = this.dragState.boundaryType === 'start' ? \r\n      this.dragState.startTime : this.dragState.endTime;\r\n    const pixelsPerSecond = viewportManager.getViewportBounds()?.pixelsPerSecond || 80;\r\n    \r\n    // Get snap indicators from smart snapping service\r\n    const snapIndicators = this.smartSnapping.getSnapIndicators(\r\n      currentTime, \r\n      pixelsPerSecond, \r\n      this.dragState.chopId\r\n    );\r\n    \r\n    // Render each snap indicator\r\n    snapIndicators.forEach(indicator => {\r\n      const pixel = viewportManager.timeToPixel(indicator.time);\r\n      \r\n      // Set line style based on indicator type\r\n      ctx.strokeStyle = indicator.color;\r\n      ctx.lineWidth = indicator.width;\r\n      \r\n      switch (indicator.style) {\r\n        case 'dashed':\r\n          ctx.setLineDash([6, 4]);\r\n          break;\r\n        case 'dotted':\r\n          ctx.setLineDash([2, 2]);\r\n          break;\r\n        default:\r\n          ctx.setLineDash([]);\r\n      }\r\n      \r\n      // Draw indicator line\r\n      ctx.beginPath();\r\n      ctx.moveTo(pixel, 0);\r\n      ctx.lineTo(pixel, height);\r\n      ctx.stroke();\r\n      \r\n      // Draw indicator icon based on type\r\n      this.renderSnapIcon(ctx, pixel, height, indicator);\r\n      \r\n      // Reset line dash\r\n      ctx.setLineDash([]);\r\n    });\r\n    \r\n    // Highlight active snap if available\r\n    if (this.currentSnapResult?.wasSnapped) {\r\n      const snapPixel = viewportManager.timeToPixel(this.currentSnapResult.snappedTime);\r\n      \r\n      // Draw glow effect for active snap\r\n      ctx.shadowColor = 'rgba(255, 165, 0, 0.6)';\r\n      ctx.shadowBlur = 8;\r\n      ctx.strokeStyle = 'rgba(255, 165, 0, 1)';\r\n      ctx.lineWidth = 3;\r\n      \r\n      ctx.beginPath();\r\n      ctx.moveTo(snapPixel, 0);\r\n      ctx.lineTo(snapPixel, height);\r\n      ctx.stroke();\r\n      \r\n      // Reset shadow\r\n      ctx.shadowColor = 'transparent';\r\n      ctx.shadowBlur = 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render snap icon based on indicator type\r\n   */\r\n  renderSnapIcon(ctx, x, height, indicator) {\r\n    const iconSize = 8;\r\n    const iconY = height - 20;\r\n    \r\n    ctx.fillStyle = indicator.color;\r\n    \r\n    switch (indicator.type) {\r\n      case 'zero-crossing':\r\n        // Draw sine wave icon\r\n        ctx.beginPath();\r\n        ctx.arc(x, iconY, iconSize / 2, 0, Math.PI * 2);\r\n        ctx.fill();\r\n        \r\n        // Draw small wave inside\r\n        ctx.strokeStyle = 'white';\r\n        ctx.lineWidth = 1;\r\n        ctx.beginPath();\r\n        ctx.moveTo(x - 3, iconY);\r\n        ctx.quadraticCurveTo(x - 1, iconY - 2, x + 1, iconY);\r\n        ctx.quadraticCurveTo(x + 3, iconY + 2, x + 3, iconY);\r\n        ctx.stroke();\r\n        break;\r\n        \r\n      case 'chop-boundary':\r\n        // Draw boundary marker\r\n        ctx.fillRect(x - iconSize / 2, iconY - iconSize / 2, iconSize, iconSize);\r\n        \r\n        // Draw direction indicator\r\n        ctx.fillStyle = 'white';\r\n        if (indicator.subType === 'start') {\r\n          // Left arrow\r\n          ctx.beginPath();\r\n          ctx.moveTo(x - 2, iconY);\r\n          ctx.lineTo(x + 1, iconY - 2);\r\n          ctx.lineTo(x + 1, iconY + 2);\r\n          ctx.fill();\r\n        } else {\r\n          // Right arrow\r\n          ctx.beginPath();\r\n          ctx.moveTo(x + 2, iconY);\r\n          ctx.lineTo(x - 1, iconY - 2);\r\n          ctx.lineTo(x - 1, iconY + 2);\r\n          ctx.fill();\r\n        }\r\n        break;\r\n        \r\n      case 'grid':\r\n        // Draw grid icon\r\n        ctx.fillRect(x - 1, iconY - iconSize / 2, 2, iconSize);\r\n        ctx.fillRect(x - iconSize / 2, iconY - 1, iconSize, 2);\r\n        break;\r\n        \r\n      default:\r\n        // Default snap icon\r\n        ctx.fillRect(x - iconSize / 2, iconY - iconSize / 2, iconSize, iconSize);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Render enhanced timing information during drag\r\n   */\r\n  renderEnhancedTimingInfo(ctx, startPixel, endPixel, height) {\r\n    const startTime = Math.min(this.dragState.startTime, this.dragState.endTime);\r\n    const endTime = Math.max(this.dragState.startTime, this.dragState.endTime);\r\n    const duration = endTime - startTime;\r\n    const centerPixel = (startPixel + endPixel) / 2;\r\n    \r\n    // Prepare timing text\r\n    const durationText = `${duration.toFixed(3)}s`;\r\n    const startText = `${startTime.toFixed(3)}s`;\r\n    const endText = `${endTime.toFixed(3)}s`;\r\n    \r\n    // Calculate text dimensions\r\n    ctx.font = '11px monospace';\r\n    const durationWidth = ctx.measureText(durationText).width;\r\n    const startWidth = ctx.measureText(startText).width;\r\n    const endWidth = ctx.measureText(endText).width;\r\n    \r\n    const padding = 6;\r\n    const lineHeight = 14;\r\n    const totalHeight = lineHeight * 3 + padding * 2;\r\n    const maxWidth = Math.max(durationWidth, startWidth, endWidth) + padding * 2;\r\n    \r\n    // Position tooltip\r\n    let tooltipX = centerPixel - maxWidth / 2;\r\n    let tooltipY = height - totalHeight - 10;\r\n    \r\n    // Adjust position if near edges\r\n    const { width } = this.canvasRenderer.getLayerManager().getDimensions();\r\n    if (tooltipX < 5) tooltipX = 5;\r\n    if (tooltipX + maxWidth > width - 5) tooltipX = width - maxWidth - 5;\r\n    if (tooltipY < 5) tooltipY = Math.min(startPixel, endPixel) + 20;\r\n    \r\n    // Draw tooltip background with rounded corners\r\n    this.drawRoundedRect(ctx, tooltipX, tooltipY, maxWidth, totalHeight, 4);\r\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';\r\n    ctx.fill();\r\n    \r\n    // Draw tooltip border\r\n    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';\r\n    ctx.lineWidth = 1;\r\n    ctx.stroke();\r\n    \r\n    // Draw timing text\r\n    ctx.fillStyle = 'white';\r\n    ctx.textAlign = 'center';\r\n    const textX = tooltipX + maxWidth / 2;\r\n    \r\n    ctx.fillText(durationText, textX, tooltipY + padding + lineHeight);\r\n    \r\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';\r\n    ctx.font = '10px monospace';\r\n    ctx.fillText(`Start: ${startText}`, textX, tooltipY + padding + lineHeight * 2);\r\n    ctx.fillText(`End: ${endText}`, textX, tooltipY + padding + lineHeight * 3);\r\n  }\r\n\r\n  /**\r\n   * Draw rounded rectangle helper\r\n   */\r\n  drawRoundedRect(ctx, x, y, width, height, radius) {\r\n    ctx.beginPath();\r\n    ctx.moveTo(x + radius, y);\r\n    ctx.lineTo(x + width - radius, y);\r\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\r\n    ctx.lineTo(x + width, y + height - radius);\r\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\r\n    ctx.lineTo(x + radius, y + height);\r\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\r\n    ctx.lineTo(x, y + radius);\r\n    ctx.quadraticCurveTo(x, y, x + radius, y);\r\n    ctx.closePath();\r\n  }\r\n\r\n  /**\r\n   * Handle click events (non-drag)\r\n   */\r\n  handleClick(x, y) {\r\n    if (!this.options.enableClick) return;\r\n    \r\n    const viewportManager = this.canvasRenderer.getViewportManager();\r\n    const time = viewportManager.pixelToTime(x);\r\n    \r\n    // Create chop at click position\r\n    this.createChopAtTime(time);\r\n  }\r\n\r\n  /**\r\n   * Finalize drag operation\r\n   */\r\n  finalizeDrag(x, y) {\r\n    switch (this.dragState.type) {\r\n      case 'create-chop':\r\n        this.finalizeChopCreation();\r\n        break;\r\n      case 'move-boundary':\r\n        this.finalizeBoundaryMove();\r\n        break;\r\n    }\r\n    \r\n    // Clear interaction layer\r\n    const layerManager = this.canvasRenderer.getLayerManager();\r\n    layerManager.clearLayer('interaction');\r\n  }\r\n\r\n  /**\r\n   * Finalize chop creation with conflict prevention\r\n   */\r\n  finalizeChopCreation() {\r\n    let startTime = Math.min(this.dragState.startTime, this.dragState.endTime);\r\n    let endTime = Math.max(this.dragState.startTime, this.dragState.endTime);\r\n    const duration = endTime - startTime;\r\n    \r\n    // Only create chop if duration is meaningful (> 10ms)\r\n    if (duration > 0.01) {\r\n      // Apply conflict prevention if enabled\r\n      if (this.options.enableConflictPrevention) {\r\n        const conflictingChop = this.findConflictingChop(startTime, endTime, null);\r\n        if (conflictingChop) {\r\n          // Adjust boundaries to avoid conflict\r\n          if (startTime < conflictingChop.startTime) {\r\n            endTime = Math.min(endTime, conflictingChop.startTime);\r\n          } else {\r\n            startTime = Math.max(startTime, conflictingChop.endTime);\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Ensure minimum duration after conflict resolution\r\n      if (endTime - startTime > 0.01) {\r\n        this.createChop(startTime, endTime);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Finalize boundary move\r\n   */\r\n  finalizeBoundaryMove() {\r\n    const chops = this.getCurrentChops();\r\n    const chop = chops.find(c => c.id === this.dragState.chopId);\r\n    \r\n    if (!chop) return;\r\n    \r\n    const updates = {};\r\n    \r\n    if (this.dragState.boundaryType === 'start') {\r\n      updates.startTime = this.dragState.startTime;\r\n    } else {\r\n      updates.endTime = this.dragState.endTime;\r\n    }\r\n    \r\n    this.updateChop(this.dragState.chopId, updates);\r\n  }\r\n\r\n  /**\r\n   * Handle hover movement\r\n   */\r\n  handleHoverMove(x, y) {\r\n    // Clear existing hover timeout\r\n    if (this.hoverTimeout) {\r\n      clearTimeout(this.hoverTimeout);\r\n    }\r\n    \r\n    // Set new hover timeout\r\n    this.hoverTimeout = setTimeout(() => {\r\n      this.showHoverInfo(x, y);\r\n    }, this.options.hoverDelay);\r\n  }\r\n\r\n  /**\r\n   * Show hover information\r\n   */\r\n  showHoverInfo(x, y) {\r\n    const element = this.getElementAtPosition(x, y);\r\n    const viewportManager = this.canvasRenderer.getViewportManager();\r\n    const time = viewportManager.pixelToTime(x);\r\n    \r\n    if (element) {\r\n      this.showElementHover(element, x, y);\r\n    } else {\r\n      this.showTimeHover(time, x, y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Show enhanced hover info for specific elements with detailed timing information\r\n   * Implements requirement 5.5 - detailed timing and duration information\r\n   */\r\n  showElementHover(element, x, y) {\r\n    const layerManager = this.canvasRenderer.getLayerManager();\r\n    const interactionLayer = layerManager.getLayer('interaction');\r\n    \r\n    if (!interactionLayer) return;\r\n    \r\n    const { ctx } = interactionLayer;\r\n    const { height } = layerManager.getDimensions();\r\n    \r\n    // Clear previous hover\r\n    layerManager.clearLayer('interaction');\r\n    \r\n    let tooltipData = null;\r\n    \r\n    switch (element.type) {\r\n      case 'chop-boundary':\r\n        tooltipData = this.createBoundaryTooltipData(element);\r\n        break;\r\n      case 'chop-region':\r\n        tooltipData = this.createChopTooltipData(element);\r\n        break;\r\n    }\r\n    \r\n    if (tooltipData) {\r\n      this.renderEnhancedTooltip(ctx, tooltipData, x, y);\r\n      this.hoveredElement = element;\r\n      \r\n      // Notify parent component about hover state for visual feedback\r\n      if (this.callbacks.onHover) {\r\n        this.callbacks.onHover(element, x, y);\r\n      }\r\n    }\r\n    \r\n    // Update cursor\r\n    const canvas = interactionLayer.canvas;\r\n    switch (element.type) {\r\n      case 'chop-boundary':\r\n        canvas.style.cursor = 'ew-resize';\r\n        break;\r\n      case 'chop-region':\r\n        canvas.style.cursor = 'pointer';\r\n        break;\r\n      default:\r\n        canvas.style.cursor = 'crosshair';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create detailed tooltip data for chop boundaries\r\n   */\r\n  createBoundaryTooltipData(element) {\r\n    const chop = this.getCurrentChops().find(c => c.id === element.chopId);\r\n    if (!chop) return null;\r\n    \r\n    const duration = chop.endTime - chop.startTime;\r\n    const boundaryType = element.boundaryType === 'start' ? 'Start' : 'End';\r\n    \r\n    return {\r\n      title: `${boundaryType} Boundary`,\r\n      color: 'rgba(34, 197, 94, 0.9)',\r\n      lines: [\r\n        `Time: ${element.time.toFixed(3)}s`,\r\n        `Chop: ${chop.padId || chop.name || chop.id.slice(0, 8)}`,\r\n        `Duration: ${duration.toFixed(3)}s`,\r\n        `Range: ${chop.startTime.toFixed(3)}s - ${chop.endTime.toFixed(3)}s`\r\n      ],\r\n      actions: [\r\n        'Drag to adjust boundary',\r\n        'Shift+Click to select chop'\r\n      ]\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create detailed tooltip data for chop regions\r\n   */\r\n  createChopTooltipData(element) {\r\n    const chop = element.chop;\r\n    const duration = chop.endTime - chop.startTime;\r\n    const currentTime = element.time;\r\n    const relativeTime = currentTime - chop.startTime;\r\n    const progress = (relativeTime / duration) * 100;\r\n    \r\n    // Analyze relationships with other chops\r\n    const relationships = this.analyzeChopRelationships(chop);\r\n    \r\n    const tooltipData = {\r\n      title: `Chop ${chop.padId || chop.name || chop.id.slice(0, 8)}`,\r\n      color: chop.color || 'rgba(59, 130, 246, 0.9)',\r\n      lines: [\r\n        `Duration: ${duration.toFixed(3)}s`,\r\n        `Start: ${chop.startTime.toFixed(3)}s`,\r\n        `End: ${chop.endTime.toFixed(3)}s`,\r\n        `Position: ${relativeTime.toFixed(3)}s (${progress.toFixed(1)}%)`\r\n      ],\r\n      actions: [\r\n        'Click to seek to position',\r\n        'Shift+Click to select',\r\n        'Drag boundaries to adjust'\r\n      ]\r\n    };\r\n    \r\n    // Add relationship information\r\n    if (relationships.length > 0) {\r\n      tooltipData.lines.push(''); // Separator\r\n      tooltipData.lines.push('Relationships:');\r\n      relationships.forEach(rel => {\r\n        switch (rel.type) {\r\n          case 'overlap':\r\n            const severity = rel.severity > 0.5 ? 'Major' : 'Minor';\r\n            tooltipData.lines.push(`⚠ ${severity} overlap with ${rel.chop.padId || rel.chop.id.slice(0, 3)}`);\r\n            break;\r\n          case 'adjacent-after':\r\n            tooltipData.lines.push(`→ Adjacent to ${rel.chop.padId || rel.chop.id.slice(0, 3)}`);\r\n            break;\r\n          case 'adjacent-before':\r\n            tooltipData.lines.push(`← Adjacent from ${rel.chop.padId || rel.chop.id.slice(0, 3)}`);\r\n            break;\r\n        }\r\n      });\r\n    }\r\n    \r\n    return tooltipData;\r\n  }\r\n\r\n  /**\r\n   * Analyze relationships between current chop and others\r\n   */\r\n  analyzeChopRelationships(currentChop) {\r\n    const allChops = this.getCurrentChops();\r\n    const relationships = [];\r\n    const tolerance = 0.05; // 50ms tolerance for adjacency\r\n    \r\n    allChops.forEach(otherChop => {\r\n      if (otherChop.id === currentChop.id) return;\r\n      \r\n      // Check for overlap\r\n      if (!(currentChop.endTime <= otherChop.startTime || currentChop.startTime >= otherChop.endTime)) {\r\n        const overlapStart = Math.max(currentChop.startTime, otherChop.startTime);\r\n        const overlapEnd = Math.min(currentChop.endTime, otherChop.endTime);\r\n        const overlapDuration = overlapEnd - overlapStart;\r\n        \r\n        const currentDuration = currentChop.endTime - currentChop.startTime;\r\n        const otherDuration = otherChop.endTime - otherChop.startTime;\r\n        const minDuration = Math.min(currentDuration, otherDuration);\r\n        \r\n        relationships.push({\r\n          type: 'overlap',\r\n          chop: otherChop,\r\n          severity: overlapDuration / minDuration\r\n        });\r\n      }\r\n      // Check for adjacency\r\n      else if (Math.abs(currentChop.endTime - otherChop.startTime) <= tolerance) {\r\n        relationships.push({\r\n          type: 'adjacent-after',\r\n          chop: otherChop,\r\n          gap: otherChop.startTime - currentChop.endTime\r\n        });\r\n      }\r\n      else if (Math.abs(otherChop.endTime - currentChop.startTime) <= tolerance) {\r\n        relationships.push({\r\n          type: 'adjacent-before',\r\n          chop: otherChop,\r\n          gap: currentChop.startTime - otherChop.endTime\r\n        });\r\n      }\r\n    });\r\n    \r\n    return relationships;\r\n  }\r\n\r\n  /**\r\n   * Show hover info for time position\r\n   */\r\n  showTimeHover(time, x, y) {\r\n    const layerManager = this.canvasRenderer.getLayerManager();\r\n    const interactionLayer = layerManager.getLayer('interaction');\r\n    \r\n    if (!interactionLayer) return;\r\n    \r\n    const { ctx } = interactionLayer;\r\n    \r\n    // Clear previous hover\r\n    layerManager.clearLayer('interaction');\r\n    \r\n    const timeText = `${time.toFixed(3)}s`;\r\n    this.renderHoverTooltip(ctx, timeText, x, y, 'rgba(255, 255, 255, 0.9)');\r\n    \r\n    // Reset cursor\r\n    interactionLayer.canvas.style.cursor = 'crosshair';\r\n  }\r\n\r\n  /**\r\n   * Render enhanced tooltip with detailed information that doesn't interfere with UI\r\n   * Implements requirement: hover tooltips that do not interfere with the rest of the ui\r\n   */\r\n  renderEnhancedTooltip(ctx, tooltipData, x, y) {\r\n    const padding = 10;\r\n    const lineHeight = 14;\r\n    const titleHeight = 16;\r\n    const fontSize = 11;\r\n    const titleFontSize = 12;\r\n    \r\n    // Calculate tooltip dimensions\r\n    ctx.font = `${fontSize}px monospace`;\r\n    let maxWidth = 0;\r\n    \r\n    // Measure title\r\n    ctx.font = `bold ${titleFontSize}px monospace`;\r\n    const titleWidth = ctx.measureText(tooltipData.title).width;\r\n    maxWidth = Math.max(maxWidth, titleWidth);\r\n    \r\n    // Measure content lines\r\n    ctx.font = `${fontSize}px monospace`;\r\n    tooltipData.lines.forEach(line => {\r\n      if (line.trim()) {\r\n        const lineWidth = ctx.measureText(line).width;\r\n        maxWidth = Math.max(maxWidth, lineWidth);\r\n      }\r\n    });\r\n    \r\n    // Measure action lines (smaller font)\r\n    ctx.font = `${fontSize - 1}px monospace`;\r\n    if (tooltipData.actions) {\r\n      tooltipData.actions.forEach(action => {\r\n        const actionWidth = ctx.measureText(action).width;\r\n        maxWidth = Math.max(maxWidth, actionWidth);\r\n      });\r\n    }\r\n    \r\n    const tooltipWidth = maxWidth + padding * 2;\r\n    const contentLines = tooltipData.lines.filter(line => line.trim()).length;\r\n    const actionLines = tooltipData.actions ? tooltipData.actions.length : 0;\r\n    const separatorHeight = (tooltipData.actions && actionLines > 0) ? 6 : 0;\r\n    const tooltipHeight = titleHeight + (contentLines * lineHeight) + separatorHeight + (actionLines * (lineHeight - 2)) + padding * 2;\r\n    \r\n    // Smart positioning to avoid UI interference\r\n    const { width, height } = this.canvasRenderer.getLayerManager().getDimensions();\r\n    let tooltipX = x + 15; // Offset from cursor\r\n    let tooltipY = y - tooltipHeight - 10;\r\n    \r\n    // Adjust horizontal position\r\n    if (tooltipX + tooltipWidth > width - 10) {\r\n      tooltipX = x - tooltipWidth - 15; // Show on left side\r\n    }\r\n    if (tooltipX < 10) {\r\n      tooltipX = 10; // Minimum margin\r\n    }\r\n    \r\n    // Adjust vertical position\r\n    if (tooltipY < 10) {\r\n      tooltipY = y + 20; // Show below cursor\r\n    }\r\n    if (tooltipY + tooltipHeight > height - 10) {\r\n      tooltipY = height - tooltipHeight - 10; // Keep within bounds\r\n    }\r\n    \r\n    // Draw tooltip with rounded corners and shadow\r\n    this.drawTooltipBackground(ctx, tooltipX, tooltipY, tooltipWidth, tooltipHeight, tooltipData.color);\r\n    \r\n    // Draw content\r\n    let currentY = tooltipY + padding + titleHeight - 2;\r\n    \r\n    // Draw title\r\n    ctx.font = `bold ${titleFontSize}px monospace`;\r\n    ctx.fillStyle = tooltipData.color;\r\n    ctx.textAlign = 'left';\r\n    ctx.fillText(tooltipData.title, tooltipX + padding, currentY);\r\n    \r\n    currentY += 4; // Small gap after title\r\n    \r\n    // Draw content lines\r\n    ctx.font = `${fontSize}px monospace`;\r\n    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\r\n    \r\n    tooltipData.lines.forEach(line => {\r\n      if (line.trim()) {\r\n        currentY += lineHeight;\r\n        \r\n        // Color-code special lines\r\n        if (line.includes('⚠')) {\r\n          ctx.fillStyle = 'rgba(245, 158, 11, 0.9)'; // Warning color\r\n        } else if (line.includes('→') || line.includes('←')) {\r\n          ctx.fillStyle = 'rgba(34, 197, 94, 0.9)'; // Success color\r\n        } else if (line.includes('Relationships:')) {\r\n          ctx.fillStyle = 'rgba(156, 163, 175, 0.9)'; // Gray color\r\n        } else {\r\n          ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';\r\n        }\r\n        \r\n        ctx.fillText(line, tooltipX + padding, currentY);\r\n      }\r\n    });\r\n    \r\n    // Draw separator line if actions exist\r\n    if (tooltipData.actions && actionLines > 0) {\r\n      currentY += separatorHeight;\r\n      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';\r\n      ctx.lineWidth = 1;\r\n      ctx.beginPath();\r\n      ctx.moveTo(tooltipX + padding, currentY - 2);\r\n      ctx.lineTo(tooltipX + tooltipWidth - padding, currentY - 2);\r\n      ctx.stroke();\r\n    }\r\n    \r\n    // Draw action lines\r\n    if (tooltipData.actions) {\r\n      ctx.font = `${fontSize - 1}px monospace`;\r\n      ctx.fillStyle = 'rgba(156, 163, 175, 0.8)';\r\n      \r\n      tooltipData.actions.forEach(action => {\r\n        currentY += lineHeight - 2;\r\n        ctx.fillText(`• ${action}`, tooltipX + padding, currentY);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Draw tooltip background with rounded corners and shadow\r\n   */\r\n  drawTooltipBackground(ctx, x, y, width, height, accentColor) {\r\n    const radius = 6;\r\n    \r\n    // Draw shadow\r\n    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';\r\n    ctx.shadowBlur = 8;\r\n    ctx.shadowOffsetX = 2;\r\n    ctx.shadowOffsetY = 2;\r\n    \r\n    // Draw background\r\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.92)';\r\n    this.drawRoundedRect(ctx, x, y, width, height, radius);\r\n    ctx.fill();\r\n    \r\n    // Reset shadow\r\n    ctx.shadowColor = 'transparent';\r\n    ctx.shadowBlur = 0;\r\n    ctx.shadowOffsetX = 0;\r\n    ctx.shadowOffsetY = 0;\r\n    \r\n    // Draw border with accent color\r\n    ctx.strokeStyle = accentColor;\r\n    ctx.lineWidth = 2;\r\n    this.drawRoundedRect(ctx, x, y, width, height, radius);\r\n    ctx.stroke();\r\n    \r\n    // Draw subtle inner glow\r\n    ctx.strokeStyle = `${accentColor}40`;\r\n    ctx.lineWidth = 1;\r\n    this.drawRoundedRect(ctx, x + 1, y + 1, width - 2, height - 2, radius - 1);\r\n    ctx.stroke();\r\n  }\r\n\r\n  /**\r\n   * Render simple hover tooltip (fallback)\r\n   */\r\n  renderHoverTooltip(ctx, text, x, y, color) {\r\n    const tooltipData = {\r\n      title: text,\r\n      color: color,\r\n      lines: [],\r\n      actions: null\r\n    };\r\n    \r\n    this.renderEnhancedTooltip(ctx, tooltipData, x, y);\r\n  }\r\n\r\n  /**\r\n   * Clear hover state\r\n   */\r\n  clearHover() {\r\n    if (this.hoverTimeout) {\r\n      clearTimeout(this.hoverTimeout);\r\n      this.hoverTimeout = null;\r\n    }\r\n    \r\n    if (this.hoveredElement) {\r\n      const layerManager = this.canvasRenderer.getLayerManager();\r\n      layerManager.clearLayer('interaction');\r\n      \r\n      // Reset cursor\r\n      const interactionLayer = layerManager.getLayer('interaction');\r\n      if (interactionLayer) {\r\n        interactionLayer.canvas.style.cursor = 'crosshair';\r\n      }\r\n      \r\n      this.hoveredElement = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reset interaction state\r\n   */\r\n  resetInteractionState() {\r\n    this.isMouseDown = false;\r\n    this.isDragging = false;\r\n    this.dragState = {\r\n      type: null,\r\n      startTime: 0,\r\n      endTime: 0,\r\n      chopId: null,\r\n      boundaryType: null\r\n    };\r\n    \r\n    // Reset cursor\r\n    const layerManager = this.canvasRenderer.getLayerManager();\r\n    const interactionLayer = layerManager.getLayer('interaction');\r\n    if (interactionLayer) {\r\n      interactionLayer.canvas.style.cursor = 'crosshair';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Touch event handlers for mobile support\r\n   */\r\n  handleTouchStart(event) {\r\n    event.preventDefault();\r\n    const touch = event.touches[0];\r\n    const mouseEvent = {\r\n      type: 'mousedown',\r\n      clientX: touch.clientX,\r\n      clientY: touch.clientY,\r\n      preventDefault: () => {},\r\n      target: event.target\r\n    };\r\n    this.handleMouseDown(mouseEvent);\r\n  }\r\n\r\n  handleTouchMove(event) {\r\n    event.preventDefault();\r\n    const touch = event.touches[0];\r\n    const mouseEvent = {\r\n      type: 'mousemove',\r\n      clientX: touch.clientX,\r\n      clientY: touch.clientY,\r\n      preventDefault: () => {},\r\n      target: event.target\r\n    };\r\n    this.handleMouseMove(mouseEvent);\r\n  }\r\n\r\n  handleTouchEnd(event) {\r\n    event.preventDefault();\r\n    const mouseEvent = {\r\n      type: 'mouseup',\r\n      clientX: this.currentMousePosition.x,\r\n      clientY: this.currentMousePosition.y,\r\n      preventDefault: () => {},\r\n      target: event.target\r\n    };\r\n    this.handleMouseUp(mouseEvent);\r\n  }\r\n\r\n  /**\r\n   * Handle keyboard down events for navigation shortcuts\r\n   * Implements requirement 4.4 - keyboard shortcuts for zoom and navigation\r\n   */\r\n  handleKeyDown(event) {\r\n    // Update key state\r\n    this.keyState.shift = event.shiftKey;\r\n    this.keyState.ctrl = event.ctrlKey;\r\n    this.keyState.alt = event.altKey;\r\n    \r\n    const viewportManager = this.canvasRenderer.getViewportManager();\r\n    const viewport = viewportManager.getState();\r\n    \r\n    switch (event.code) {\r\n      // Zoom controls\r\n      case 'Equal': // Plus key\r\n      case 'NumpadAdd':\r\n        if (event.ctrlKey || event.metaKey) {\r\n          event.preventDefault();\r\n          this.smoothZoom(viewportManager, 1.5, viewport.centerTime);\r\n        }\r\n        break;\r\n        \r\n      case 'Minus':\r\n      case 'NumpadSubtract':\r\n        if (event.ctrlKey || event.metaKey) {\r\n          event.preventDefault();\r\n          this.smoothZoom(viewportManager, 1 / 1.5, viewport.centerTime);\r\n        }\r\n        break;\r\n        \r\n      case 'Digit0':\r\n      case 'Numpad0':\r\n        if (event.ctrlKey || event.metaKey) {\r\n          event.preventDefault();\r\n          this.animateZoomToFit(viewportManager);\r\n        }\r\n        break;\r\n        \r\n      // Navigation controls\r\n      case 'ArrowLeft':\r\n        event.preventDefault();\r\n        this.handleKeyboardPan(viewportManager, 'left', event.shiftKey);\r\n        break;\r\n        \r\n      case 'ArrowRight':\r\n        event.preventDefault();\r\n        this.handleKeyboardPan(viewportManager, 'right', event.shiftKey);\r\n        break;\r\n        \r\n      case 'Home':\r\n        event.preventDefault();\r\n        this.animatePanToTime(viewportManager, 0);\r\n        break;\r\n        \r\n      case 'End':\r\n        event.preventDefault();\r\n        this.animatePanToTime(viewportManager, viewport.audioDuration);\r\n        break;\r\n        \r\n      // Zoom presets\r\n      case 'Digit1':\r\n        if (event.ctrlKey || event.metaKey) {\r\n          event.preventDefault();\r\n          this.animateZoomToLevel(viewportManager, 1.0, viewport.centerTime);\r\n        }\r\n        break;\r\n        \r\n      case 'Digit2':\r\n        if (event.ctrlKey || event.metaKey) {\r\n          event.preventDefault();\r\n          this.animateZoomToLevel(viewportManager, 2.0, viewport.centerTime);\r\n        }\r\n        break;\r\n        \r\n      case 'Digit5':\r\n        if (event.ctrlKey || event.metaKey) {\r\n          event.preventDefault();\r\n          this.animateZoomToLevel(viewportManager, 5.0, viewport.centerTime);\r\n        }\r\n        break;\r\n        \r\n      // Fine navigation with Page keys\r\n      case 'PageUp':\r\n        event.preventDefault();\r\n        this.handleKeyboardPan(viewportManager, 'left', true);\r\n        break;\r\n        \r\n      case 'PageDown':\r\n        event.preventDefault();\r\n        this.handleKeyboardPan(viewportManager, 'right', true);\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle keyboard up events\r\n   */\r\n  handleKeyUp(event) {\r\n    // Update key state\r\n    this.keyState.shift = event.shiftKey;\r\n    this.keyState.ctrl = event.ctrlKey;\r\n    this.keyState.alt = event.altKey;\r\n  }\r\n\r\n  /**\r\n   * Handle keyboard-based panning\r\n   * Implements requirement 4.2 - pan/scroll navigation\r\n   */\r\n  handleKeyboardPan(viewportManager, direction, isLarge = false) {\r\n    const viewport = viewportManager.getState();\r\n    const visibleDuration = viewport.visibleTimeRange.end - viewport.visibleTimeRange.start;\r\n    \r\n    // Calculate pan distance based on current zoom level\r\n    let panDistance = visibleDuration * 0.1; // 10% of visible range\r\n    \r\n    if (isLarge) {\r\n      panDistance = visibleDuration * 0.5; // 50% for large steps\r\n    }\r\n    \r\n    const targetTime = direction === 'left' ? \r\n      viewport.centerTime - panDistance : \r\n      viewport.centerTime + panDistance;\r\n    \r\n    this.animatePanToTime(viewportManager, targetTime);\r\n  }\r\n\r\n  /**\r\n   * Animate pan to specific time with smooth transition\r\n   */\r\n  animatePanToTime(viewportManager, targetTime, duration = 200) {\r\n    const startTime = performance.now();\r\n    const currentCenterTime = viewportManager.getState().centerTime;\r\n    \r\n    const animate = (currentTime) => {\r\n      const elapsed = currentTime - startTime;\r\n      const progress = Math.min(elapsed / duration, 1);\r\n      \r\n      // Use easeOutCubic for smooth deceleration\r\n      const easeProgress = 1 - Math.pow(1 - progress, 3);\r\n      \r\n      const newTime = currentCenterTime + (targetTime - currentCenterTime) * easeProgress;\r\n      viewportManager.panToTime(newTime);\r\n      \r\n      if (progress < 1) {\r\n        requestAnimationFrame(animate);\r\n      }\r\n    };\r\n    \r\n    requestAnimationFrame(animate);\r\n  }\r\n\r\n  /**\r\n   * Animate zoom to specific level\r\n   */\r\n  animateZoomToLevel(viewportManager, targetZoom, centerTime, duration = 200) {\r\n    const startTime = performance.now();\r\n    const currentZoom = viewportManager.getState().zoomLevel;\r\n    \r\n    const animate = (currentTime) => {\r\n      const elapsed = currentTime - startTime;\r\n      const progress = Math.min(elapsed / duration, 1);\r\n      \r\n      // Use easeOutCubic for smooth deceleration\r\n      const easeProgress = 1 - Math.pow(1 - progress, 3);\r\n      \r\n      const zoom = currentZoom + (targetZoom - currentZoom) * easeProgress;\r\n      viewportManager.setZoom(zoom, centerTime);\r\n      \r\n      if (progress < 1) {\r\n        requestAnimationFrame(animate);\r\n      }\r\n    };\r\n    \r\n    requestAnimationFrame(animate);\r\n  }\r\n\r\n  /**\r\n   * Animate zoom to fit with smooth transition\r\n   */\r\n  animateZoomToFit(viewportManager, duration = 300) {\r\n    const viewport = viewportManager.getState();\r\n    const targetCenterTime = viewport.audioDuration / 2;\r\n    \r\n    // Calculate zoom to fit\r\n    const { canvasDimensions, audioDuration } = viewport;\r\n    const basePixelsPerSecond = 100;\r\n    const requiredPixelsPerSecond = canvasDimensions.width / audioDuration;\r\n    const targetZoom = Math.max(viewport.minZoom, requiredPixelsPerSecond / basePixelsPerSecond);\r\n    \r\n    // Animate both zoom and pan simultaneously\r\n    const startTime = performance.now();\r\n    const currentZoom = viewport.zoomLevel;\r\n    const currentCenterTime = viewport.centerTime;\r\n    \r\n    const animate = (currentTime) => {\r\n      const elapsed = currentTime - startTime;\r\n      const progress = Math.min(elapsed / duration, 1);\r\n      \r\n      // Use easeOutCubic for smooth deceleration\r\n      const easeProgress = 1 - Math.pow(1 - progress, 3);\r\n      \r\n      const zoom = currentZoom + (targetZoom - currentZoom) * easeProgress;\r\n      const centerTime = currentCenterTime + (targetCenterTime - currentCenterTime) * easeProgress;\r\n      \r\n      viewportManager.setZoom(zoom, centerTime);\r\n      \r\n      if (progress < 1) {\r\n        requestAnimationFrame(animate);\r\n      }\r\n    };\r\n    \r\n    requestAnimationFrame(animate);\r\n  }\r\n\r\n  /**\r\n   * Utility methods for external integration\r\n   */\r\n\r\n  /**\r\n   * Create chop at specific time (click functionality)\r\n   */\r\n  createChopAtTime(time) {\r\n    if (this.callbacks.onChopCreate) {\r\n      // Create a small chop (100ms) centered on click time\r\n      const duration = 0.1;\r\n      const startTime = Math.max(0, time - duration / 2);\r\n      const endTime = startTime + duration;\r\n      \r\n      this.callbacks.onChopCreate(startTime, endTime);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create chop with specific start and end times\r\n   */\r\n  createChop(startTime, endTime) {\r\n    if (this.callbacks.onChopCreate) {\r\n      this.callbacks.onChopCreate(startTime, endTime);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update existing chop\r\n   */\r\n  updateChop(chopId, updates) {\r\n    if (this.callbacks.onChopUpdate) {\r\n      this.callbacks.onChopUpdate(chopId, updates);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Seek to specific time\r\n   */\r\n  seekToTime(time) {\r\n    if (this.callbacks.onTimeSeek) {\r\n      this.callbacks.onTimeSeek(time);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Select chop\r\n   */\r\n  selectChop(chopId) {\r\n    if (this.callbacks.onChopUpdate) {\r\n      this.callbacks.onChopUpdate(chopId, { selected: true });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current chops from parent component\r\n   * This should be set by the parent component\r\n   */\r\n  getCurrentChops() {\r\n    return this.currentChops || [];\r\n  }\r\n\r\n  /**\r\n   * Set current chops for interaction detection\r\n   */\r\n  setCurrentChops(chops) {\r\n    this.currentChops = chops;\r\n  }\r\n\r\n  /**\r\n   * Convert pixel position to time with precision\r\n   */\r\n  pixelToTime(pixel) {\r\n    const viewportManager = this.canvasRenderer.getViewportManager();\r\n    return viewportManager.pixelToTime(pixel);\r\n  }\r\n\r\n  /**\r\n   * Convert time to pixel position with precision\r\n   */\r\n  timeToPixel(time) {\r\n    const viewportManager = this.canvasRenderer.getViewportManager();\r\n    return viewportManager.timeToPixel(time);\r\n  }\r\n\r\n  /**\r\n   * Enable or disable specific interaction types\r\n   */\r\n  setInteractionEnabled(type, enabled) {\r\n    switch (type) {\r\n      case 'click':\r\n        this.options.enableClick = enabled;\r\n        break;\r\n      case 'drag':\r\n        this.options.enableDrag = enabled;\r\n        break;\r\n      case 'hover':\r\n        this.options.enableHover = enabled;\r\n        if (!enabled) {\r\n          this.clearHover();\r\n        }\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroy interaction manager and cleanup\r\n   */\r\n  destroy() {\r\n    this.clearHover();\r\n    this.resetInteractionState();\r\n    \r\n    const layerManager = this.canvasRenderer.getLayerManager();\r\n    const interactionLayer = layerManager.getLayer('interaction');\r\n    \r\n    if (interactionLayer) {\r\n      const canvas = interactionLayer.canvas;\r\n      \r\n      // Remove event listeners\r\n      canvas.removeEventListener('mousedown', this.handleMouseDown);\r\n      canvas.removeEventListener('mousemove', this.handleMouseMove);\r\n      canvas.removeEventListener('mouseup', this.handleMouseUp);\r\n      canvas.removeEventListener('mouseleave', this.handleMouseLeave);\r\n      canvas.removeEventListener('wheel', this.handleWheel);\r\n      canvas.removeEventListener('touchstart', this.handleTouchStart);\r\n      canvas.removeEventListener('touchmove', this.handleTouchMove);\r\n      canvas.removeEventListener('touchend', this.handleTouchEnd);\r\n    }\r\n  }\r\n}\r\n\r\nexport default InteractionManager;"],"names":["ZoomControls","viewportManager","className","showPresets","showNavigationInfo","compact","viewport","setViewport","useState","navigationInfo","setNavigationInfo","zoomPresets","setZoomPresets","isExpanded","setIsExpanded","useEffect","updateViewport","newViewport","getNavigationInfo","getZoomPresets","getState","addListener","handleZoomIn","useCallback","zoomIn","handleZoomOut","zoomOut","handleZoomToFit","zoomToFit","handleZoomPreset","preset","setZoom","zoomLevel","centerTime","handlePanLeft","panDistance","visibleTimeRange","end","start","panToTime","handlePanRight","handleGoToStart","handleGoToEnd","audioDuration","formatTime","time","Math","floor","toFixed","padStart","jsxs","motion","div","initial","opacity","y","animate","transition","duration","children","jsx","onClick","disabled","canZoomOut","title","zoom","canZoomIn","canPanLeft","canPanRight","AnimatePresence","height","exit","detailLevel","style","width","visiblePercentage","marginLeft","startPercentage","length","map","index","abs","description","name","ZeroCrossingDetector","constructor","options","this","minDistance","amplitudeThreshold","analysisWindow","maxSearchDistance","zeroCrossingCache","Map","findZeroCrossings","samples","sampleRate","cacheKey","generateCacheKey","has","get","zeroCrossings","lastZeroCrossing","i","prevSample","currentSample","quality","analyzeZeroCrossingQuality","isSignificant","push","sampleIndex","score","amplitude","slope","set","findNearestZeroCrossing","targetTime","tolerance","searchTolerance","nearestCrossing","Infinity","crossing","distance","findOptimalCutPoints","startTime","endTime","startSample","endSample","startZeroCrossing","endZeroCrossing","result","originalStart","originalEnd","optimizedStart","optimizedEnd","startImprovement","endImprovement","improvement","calculateCutQualityImprovement","avgImprovement","crossingIndex","windowSize","threshold","halfWindow","startIndex","max","endIndex","min","rmsSum","sampleCount","rmsAmplitude","sqrt","nextSample","windowStart","windowEnd","originalIndex","zeroCrossingIndex","originalClickPotential","getZeroCrossingsInRange","filter","reduce","sum","sample","clearCache","clear","getCacheStats","size","keys","Array","from","updateOptions","newOptions","SmartSnapping","snapTolerance","snapToleranceTime","enableZeroCrossingSnap","enableChopBoundarySnap","enableGridSnap","enableBeatSnap","snapPriorities","zeroCrossing","chopBoundary","grid","beat","showSnapIndicators","snapIndicatorColor","snapIndicatorWidth","zeroCrossingOptions","zeroCrossingDetector","snapTargets","waveformData","chops","setWaveformData","setChops","findSnapTarget","pixelsPerSecond","excludeChopId","findAllSnapTargets","sort","a","b","priority","calculateSnapTolerance","zeroCrossingTarget","findZeroCrossingSnapTarget","boundaryTargets","findChopBoundarySnapTargets","gridTarget","findGridSnapTarget","nearestZeroCrossing","type","data","targets","chop","id","startDistance","subType","chopId","endDistance","nearestGridTime","round","interval","applySnapping","snapTarget","originalTime","snappedTime","wasSnapped","snapDistance","getSnapIndicators","target","color","getSnapIndicatorColor","getSnapIndicatorStyle","label","getSnapIndicatorLabel","snapType","getOptions","setSnapTypes","snapTypes","Object","forEach","key","optionKey","charAt","toUpperCase","slice","hasOwnProperty","getSnapStatistics","stats","chopBoundaries","cacheStats","clearCaches","InteractionManager","canvasRenderer","clickThreshold","hoverDelay","enableHover","enableClick","enableDrag","enableSmartSnapping","enableVisualFeedback","enableConflictPrevention","dragSensitivity","smartSnapping","isMouseDown","isDragging","mouseDownPosition","x","currentMousePosition","hoverTimeout","hoveredElement","dragState","boundaryType","callbacks","onChopCreate","onChopUpdate","onTimeSeek","onHover","currentSnapResult","currentChops","initialize","interactionLayer","getLayerManager","getLayer","canvas","addEventListener","handleMouseDown","bind","handleMouseMove","handleMouseUp","handleMouseLeave","handleWheel","handleTouchStart","handleTouchMove","handleTouchEnd","e","preventDefault","tabIndex","handleKeyDown","handleKeyUp","cursor","keyState","shift","ctrl","alt","setCallbacks","setCurrentChops","getCurrentChops","event","rect","getBoundingClientRect","clientX","left","clientY","top","clearHover","clickedElement","getElementAtPosition","handleElementClick","initializeChopCreation","handleDragMove","handleHoverMove","finalizeDrag","handleClick","resetInteractionState","getViewportManager","pixelToTime","zoomFactor","shiftKey","ctrlKey","deltaY","smoothZoom","currentZoom","targetZoom","minZoom","maxZoom","clampedZoom","animateZoom","startZoom","endZoom","performance","now","currentTime","elapsed","progress","easeProgress","pow","requestAnimationFrame","startPixel","timeToPixel","endPixel","pixel","element","initializeBoundaryDrag","selectChop","seekToTime","startDrag","updateDrag","renderDragPreview","updateBoundaryDrag","newTime","find","c","applySmartSnapping","conflictingChop","findConflictingChop","getViewportBounds","snapResult","layerManager","ctx","getDimensions","clearLayer","renderChopCreationPreview","renderBoundaryMovePreview","leftPixel","rightPixel","regionWidth","gradient","createLinearGradient","addColorStop","fillStyle","fillRect","animationOffset","Date","strokeStyle","lineWidth","setLineDash","lineDashOffset","beginPath","moveTo","lineTo","stroke","renderDragHandles","renderEnhancedTimingInfo","pulseAlpha","sin","staticBoundaryPixel","boundaryPixel","shadowColor","shadowBlur","renderDragHandle","renderSnapIndicators","handleColor","handleSize","strokeRect","indicator","renderSnapIcon","snapPixel","iconY","arc","iconSize","PI","fill","quadraticCurveTo","centerPixel","durationText","startText","endText","font","durationWidth","measureText","startWidth","endWidth","maxWidth","padding","tooltipX","tooltipY","lineHeight","drawRoundedRect","textAlign","textX","fillText","radius","closePath","createChopAtTime","finalizeChopCreation","finalizeBoundaryMove","createChop","updates","updateChop","clearTimeout","setTimeout","showHoverInfo","showElementHover","showTimeHover","tooltipData","createBoundaryTooltipData","createChopTooltipData","renderEnhancedTooltip","lines","padId","actions","relativeTime","relationships","analyzeChopRelationships","rel","severity","currentChop","allChops","otherChop","gap","overlapStart","overlapDuration","currentDuration","otherDuration","minDuration","timeText","renderHoverTooltip","titleWidth","line","trim","action","actionWidth","tooltipWidth","contentLines","actionLines","separatorHeight","tooltipHeight","drawTooltipBackground","currentY","includes","accentColor","shadowOffsetX","shadowOffsetY","text","touch","touches","mouseEvent","altKey","code","metaKey","animateZoomToFit","handleKeyboardPan","animatePanToTime","animateZoomToLevel","direction","isLarge","visibleDuration","currentCenterTime","targetCenterTime","canvasDimensions","requiredPixelsPerSecond","selected","setInteractionEnabled","enabled","destroy","removeEventListener"],"mappings":"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"}