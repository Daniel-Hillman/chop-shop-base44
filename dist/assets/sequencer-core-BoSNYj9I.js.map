{"version":3,"file":"sequencer-core-BoSNYj9I.js","sources":["../../src/utils/HighPerformanceRenderer.js","../../src/services/sequencer/HighPerformanceSequencerEngine.js","../../src/services/sequencer/SamplerPatternValidator.js","../../src/services/sequencer/SamplerPatternManager.js","../../src/services/sequencer/YouTubePlayerInterface.js","../../src/services/sequencer/SamplerChopIntegration.js","../../src/services/sequencer/OptimizedSamplerSequencerService.js"],"sourcesContent":["/**\r\n * @fileoverview High Performance Renderer\r\n * Optimized rendering system that prevents UI updates from affecting audio timing\r\n * Uses RAF batching, virtual scrolling, and efficient DOM updates\r\n */\r\n\r\n/**\r\n * High-performance renderer for sequencer UI\r\n * Prevents visual updates from interfering with audio timing\r\n */\r\nclass HighPerformanceRenderer {\r\n  constructor() {\r\n    /** @type {Set<Function>} */\r\n    this.pendingUpdates = new Set();\r\n    \r\n    /** @type {number|null} */\r\n    this.rafId = null;\r\n    \r\n    /** @type {boolean} */\r\n    this.isRendering = false;\r\n    \r\n    /** @type {Map<string, any>} */\r\n    this.renderCache = new Map();\r\n    \r\n    /** @type {IntersectionObserver|null} */\r\n    this.visibilityObserver = null;\r\n    \r\n    /** @type {Set<Element>} */\r\n    this.visibleElements = new Set();\r\n    \r\n    /** @type {Object} */\r\n    this.performanceMetrics = {\r\n      frameTime: 0,\r\n      droppedFrames: 0,\r\n      renderCalls: 0,\r\n      cacheHits: 0\r\n    };\r\n    \r\n    this.initializeVisibilityObserver();\r\n  }\r\n\r\n  /**\r\n   * Initialize intersection observer for visibility tracking\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  initializeVisibilityObserver() {\r\n    this.visibilityObserver = new IntersectionObserver(\r\n      (entries) => {\r\n        entries.forEach(entry => {\r\n          if (entry.isIntersecting) {\r\n            this.visibleElements.add(entry.target);\r\n          } else {\r\n            this.visibleElements.delete(entry.target);\r\n          }\r\n        });\r\n      },\r\n      {\r\n        rootMargin: '50px', // Pre-render elements slightly outside viewport\r\n        threshold: 0\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Schedule a render update with batching\r\n   * @param {Function} updateFunction - Function to execute during render\r\n   * @param {string} key - Optional cache key for deduplication\r\n   * @returns {void}\r\n   */\r\n  scheduleUpdate(updateFunction, key = null) {\r\n    if (key && this.renderCache.has(key)) {\r\n      this.performanceMetrics.cacheHits++;\r\n      return;\r\n    }\r\n\r\n    this.pendingUpdates.add(updateFunction);\r\n    \r\n    if (key) {\r\n      this.renderCache.set(key, true);\r\n    }\r\n\r\n    if (!this.rafId) {\r\n      this.rafId = requestAnimationFrame(() => this.executeRender());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute batched render updates\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  executeRender() {\r\n    if (this.isRendering) {\r\n      return;\r\n    }\r\n\r\n    this.isRendering = true;\r\n    const startTime = performance.now();\r\n\r\n    try {\r\n      // Execute all pending updates in a single frame\r\n      this.pendingUpdates.forEach(updateFunction => {\r\n        try {\r\n          updateFunction();\r\n        } catch (error) {\r\n          console.error('Render update error:', error);\r\n        }\r\n      });\r\n\r\n      this.pendingUpdates.clear();\r\n      this.renderCache.clear();\r\n      \r\n      // Update performance metrics\r\n      this.performanceMetrics.frameTime = performance.now() - startTime;\r\n      this.performanceMetrics.renderCalls++;\r\n      \r\n      // Check for dropped frames (>16.67ms = 60fps)\r\n      if (this.performanceMetrics.frameTime > 16.67) {\r\n        this.performanceMetrics.droppedFrames++;\r\n      }\r\n\r\n    } finally {\r\n      this.isRendering = false;\r\n      this.rafId = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create optimized step indicator component\r\n   * @param {number} stepIndex - Step index\r\n   * @param {boolean} isActive - Whether step is currently active\r\n   * @param {boolean} isTriggered - Whether step is triggered\r\n   * @returns {HTMLElement} Optimized step element\r\n   */\r\n  createOptimizedStepIndicator(stepIndex, isActive, isTriggered) {\r\n    const element = document.createElement('div');\r\n    element.className = 'sequencer-step';\r\n    element.dataset.step = stepIndex;\r\n    \r\n    // Use CSS transforms for hardware acceleration\r\n    element.style.transform = 'translateZ(0)';\r\n    element.style.willChange = 'transform, opacity';\r\n    \r\n    // Pre-calculate styles for different states\r\n    const baseStyles = {\r\n      width: '20px',\r\n      height: '20px',\r\n      borderRadius: '4px',\r\n      transition: 'none', // Disable transitions for performance\r\n      cursor: 'pointer'\r\n    };\r\n    \r\n    Object.assign(element.style, baseStyles);\r\n    \r\n    this.updateStepIndicator(element, isActive, isTriggered);\r\n    \r\n    return element;\r\n  }\r\n\r\n  /**\r\n   * Update step indicator with minimal DOM manipulation\r\n   * @param {HTMLElement} element - Step element\r\n   * @param {boolean} isActive - Whether step is currently active\r\n   * @param {boolean} isTriggered - Whether step is triggered\r\n   * @returns {void}\r\n   */\r\n  updateStepIndicator(element, isActive, isTriggered) {\r\n    const cacheKey = `step-${element.dataset.step}-${isActive}-${isTriggered}`;\r\n    \r\n    this.scheduleUpdate(() => {\r\n      // Only update if element is visible\r\n      if (!this.visibleElements.has(element)) {\r\n        return;\r\n      }\r\n\r\n      let backgroundColor, opacity, transform;\r\n      \r\n      if (isActive) {\r\n        backgroundColor = '#3b82f6'; // Blue for active\r\n        opacity = '1';\r\n        transform = 'translateZ(0) scale(1.1)';\r\n      } else if (isTriggered) {\r\n        backgroundColor = '#10b981'; // Green for triggered\r\n        opacity = '0.8';\r\n        transform = 'translateZ(0) scale(1)';\r\n      } else {\r\n        backgroundColor = '#374151'; // Gray for inactive\r\n        opacity = '0.6';\r\n        transform = 'translateZ(0) scale(1)';\r\n      }\r\n      \r\n      // Batch style updates\r\n      element.style.backgroundColor = backgroundColor;\r\n      element.style.opacity = opacity;\r\n      element.style.transform = transform;\r\n    }, cacheKey);\r\n  }\r\n\r\n  /**\r\n   * Create virtual scrolling container for large lists\r\n   * @param {Array} items - Items to render\r\n   * @param {Function} renderItem - Function to render individual items\r\n   * @param {number} itemHeight - Height of each item\r\n   * @returns {HTMLElement} Virtual scrolling container\r\n   */\r\n  createVirtualScrollContainer(items, renderItem, itemHeight = 50) {\r\n    const container = document.createElement('div');\r\n    container.style.position = 'relative';\r\n    container.style.overflow = 'auto';\r\n    container.style.height = '300px'; // Fixed height for virtual scrolling\r\n    \r\n    const viewport = document.createElement('div');\r\n    viewport.style.height = `${items.length * itemHeight}px`;\r\n    container.appendChild(viewport);\r\n    \r\n    const visibleItems = new Map();\r\n    \r\n    const updateVisibleItems = () => {\r\n      const scrollTop = container.scrollTop;\r\n      const containerHeight = container.clientHeight;\r\n      \r\n      const startIndex = Math.floor(scrollTop / itemHeight);\r\n      const endIndex = Math.min(\r\n        items.length - 1,\r\n        Math.ceil((scrollTop + containerHeight) / itemHeight)\r\n      );\r\n      \r\n      // Remove items that are no longer visible\r\n      visibleItems.forEach((element, index) => {\r\n        if (index < startIndex || index > endIndex) {\r\n          element.remove();\r\n          visibleItems.delete(index);\r\n        }\r\n      });\r\n      \r\n      // Add newly visible items\r\n      for (let i = startIndex; i <= endIndex; i++) {\r\n        if (!visibleItems.has(i)) {\r\n          const element = renderItem(items[i], i);\r\n          element.style.position = 'absolute';\r\n          element.style.top = `${i * itemHeight}px`;\r\n          element.style.height = `${itemHeight}px`;\r\n          element.style.width = '100%';\r\n          \r\n          viewport.appendChild(element);\r\n          visibleItems.set(i, element);\r\n        }\r\n      }\r\n    };\r\n    \r\n    // Throttled scroll handler\r\n    let scrollTimeout;\r\n    container.addEventListener('scroll', () => {\r\n      if (scrollTimeout) {\r\n        clearTimeout(scrollTimeout);\r\n      }\r\n      scrollTimeout = setTimeout(updateVisibleItems, 16); // ~60fps\r\n    });\r\n    \r\n    // Initial render\r\n    updateVisibleItems();\r\n    \r\n    return container;\r\n  }\r\n\r\n  /**\r\n   * Optimize element for hardware acceleration\r\n   * @param {HTMLElement} element - Element to optimize\r\n   * @returns {void}\r\n   */\r\n  optimizeElement(element) {\r\n    // Enable hardware acceleration\r\n    element.style.transform = 'translateZ(0)';\r\n    element.style.backfaceVisibility = 'hidden';\r\n    element.style.perspective = '1000px';\r\n    \r\n    // Optimize for animations\r\n    element.style.willChange = 'transform, opacity';\r\n    \r\n    // Track visibility\r\n    this.visibilityObserver.observe(element);\r\n  }\r\n\r\n  /**\r\n   * Create optimized animation using CSS transforms\r\n   * @param {HTMLElement} element - Element to animate\r\n   * @param {Object} keyframes - Animation keyframes\r\n   * @param {number} duration - Animation duration in ms\r\n   * @returns {Animation} Web Animation API animation\r\n   */\r\n  createOptimizedAnimation(element, keyframes, duration = 300) {\r\n    // Use Web Animation API for better performance\r\n    const animation = element.animate(keyframes, {\r\n      duration,\r\n      easing: 'cubic-bezier(0.4, 0, 0.2, 1)',\r\n      fill: 'forwards'\r\n    });\r\n    \r\n    // Clean up after animation\r\n    animation.addEventListener('finish', () => {\r\n      animation.cancel();\r\n    });\r\n    \r\n    return animation;\r\n  }\r\n\r\n  /**\r\n   * Batch DOM reads to prevent layout thrashing\r\n   * @param {Function[]} readFunctions - Functions that read from DOM\r\n   * @returns {Array} Results from read functions\r\n   */\r\n  batchDOMReads(readFunctions) {\r\n    const results = [];\r\n    \r\n    this.scheduleUpdate(() => {\r\n      readFunctions.forEach(readFn => {\r\n        try {\r\n          results.push(readFn());\r\n        } catch (error) {\r\n          console.error('DOM read error:', error);\r\n          results.push(null);\r\n        }\r\n      });\r\n    });\r\n    \r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * Batch DOM writes to prevent layout thrashing\r\n   * @param {Function[]} writeFunctions - Functions that write to DOM\r\n   * @returns {void}\r\n   */\r\n  batchDOMWrites(writeFunctions) {\r\n    this.scheduleUpdate(() => {\r\n      writeFunctions.forEach(writeFn => {\r\n        try {\r\n          writeFn();\r\n        } catch (error) {\r\n          console.error('DOM write error:', error);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get current performance metrics\r\n   * @returns {Object} Performance metrics\r\n   */\r\n  getPerformanceMetrics() {\r\n    return { ...this.performanceMetrics };\r\n  }\r\n\r\n  /**\r\n   * Reset performance metrics\r\n   * @returns {void}\r\n   */\r\n  resetPerformanceMetrics() {\r\n    this.performanceMetrics = {\r\n      frameTime: 0,\r\n      droppedFrames: 0,\r\n      renderCalls: 0,\r\n      cacheHits: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Cleanup resources\r\n   * @returns {void}\r\n   */\r\n  cleanup() {\r\n    if (this.rafId) {\r\n      cancelAnimationFrame(this.rafId);\r\n      this.rafId = null;\r\n    }\r\n    \r\n    if (this.visibilityObserver) {\r\n      this.visibilityObserver.disconnect();\r\n      this.visibilityObserver = null;\r\n    }\r\n    \r\n    this.pendingUpdates.clear();\r\n    this.renderCache.clear();\r\n    this.visibleElements.clear();\r\n  }\r\n}\r\n\r\nexport { HighPerformanceRenderer };","/**\r\n * @fileoverview High Performance Sequencer Engine\r\n * Ultra-optimized sequencer engine using Web Audio API timing and AudioWorklet\r\n * Eliminates lag and ensures consistent playback under all conditions\r\n */\r\n\r\n/**\r\n * High-performance sequencer engine optimized for zero-lag playback\r\n * Uses Web Audio API scheduling and dedicated audio thread\r\n */\r\nclass HighPerformanceSequencerEngine {\r\n  constructor() {\r\n    /** @type {AudioContext|null} */\r\n    this.audioContext = null;\r\n    \r\n    /** @type {AudioWorkletNode|null} */\r\n    this.schedulerNode = null;\r\n    \r\n    /** @type {boolean} */\r\n    this.isPlaying = false;\r\n    \r\n    /** @type {boolean} */\r\n    this.isPaused = false;\r\n    \r\n    /** @type {number} */\r\n    this.currentStep = 0;\r\n    \r\n    /** @type {number} */\r\n    this.bpm = 160;\r\n    \r\n    /** @type {number} */\r\n    this.stepResolution = 16;\r\n    \r\n    /** @type {Function[]} */\r\n    this.stepCallbacks = [];\r\n    \r\n    /** @type {Function[]} */\r\n    this.stateChangeCallbacks = [];\r\n    \r\n    /** @type {Object|null} */\r\n    this.youtubePlayer = null;\r\n    \r\n    /** @type {boolean} */\r\n    this.isInitialized = false;\r\n    \r\n    /** @type {number} */\r\n    this.lookAhead = 25.0; // 25ms lookahead\r\n    \r\n    /** @type {number} */\r\n    this.scheduleAheadTime = 0.1; // 100ms scheduling window\r\n    \r\n    /** @type {number} */\r\n    this.nextStepTime = 0;\r\n    \r\n    /** @type {number} */\r\n    this.timerID = null;\r\n    \r\n    /** @type {Map<number, number>} */\r\n    this.scheduledSteps = new Map();\r\n    \r\n    /** @type {Object} */\r\n    this.performanceMetrics = {\r\n      jitter: 0,\r\n      drift: 0,\r\n      cpuUsage: 0,\r\n      lastMeasurement: 0\r\n    };\r\n    \r\n    /** @type {OffscreenCanvas|null} */\r\n    this.offscreenCanvas = null;\r\n    \r\n    /** @type {Worker|null} */\r\n    this.schedulerWorker = null;\r\n  }\r\n\r\n  /**\r\n   * Initialize the high-performance sequencer engine\r\n   * @param {Object} youtubePlayer - YouTube player instance\r\n   * @returns {Promise<boolean>} Whether initialization was successful\r\n   */\r\n  async initialize(youtubePlayer) {\r\n    try {\r\n      if (!youtubePlayer) {\r\n        throw new Error('YouTube player is required');\r\n      }\r\n\r\n      this.youtubePlayer = youtubePlayer;\r\n\r\n      // Initialize Web Audio Context with optimal settings\r\n      await this.initializeAudioContext();\r\n      \r\n      // Initialize high-precision scheduler\r\n      await this.initializeScheduler();\r\n      \r\n      // Initialize performance monitoring\r\n      this.initializePerformanceMonitoring();\r\n      \r\n      this.isInitialized = true;\r\n      return true;\r\n\r\n    } catch (error) {\r\n      console.error('Failed to initialize HighPerformanceSequencerEngine:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize Web Audio Context with optimal settings\r\n   * @private\r\n   * @returns {Promise<void>}\r\n   */\r\n  async initializeAudioContext() {\r\n    // Create audio context with optimal latency settings\r\n    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({\r\n      latencyHint: 'interactive',\r\n      sampleRate: 44100\r\n    });\r\n\r\n    // Resume context if suspended\r\n    if (this.audioContext.state === 'suspended') {\r\n      await this.audioContext.resume();\r\n    }\r\n\r\n    // Create a silent gain node to keep context active\r\n    const silentGain = this.audioContext.createGain();\r\n    silentGain.gain.value = 0;\r\n    silentGain.connect(this.audioContext.destination);\r\n    \r\n    // Create silent oscillator to prevent context suspension\r\n    const oscillator = this.audioContext.createOscillator();\r\n    oscillator.frequency.value = 440;\r\n    oscillator.connect(silentGain);\r\n    oscillator.start();\r\n  }\r\n\r\n  /**\r\n   * Initialize high-precision scheduler using Web Workers\r\n   * @private\r\n   * @returns {Promise<void>}\r\n   */\r\n  async initializeScheduler() {\r\n    // Create dedicated worker for timing\r\n    const workerCode = `\r\n      let timerID = null;\r\n      let interval = 25; // 25ms for ultra-precise timing\r\n      \r\n      self.onmessage = function(e) {\r\n        if (e.data === \"start\") {\r\n          timerID = setInterval(() => {\r\n            self.postMessage(\"tick\");\r\n          }, interval);\r\n        } else if (e.data === \"stop\") {\r\n          if (timerID) {\r\n            clearInterval(timerID);\r\n            timerID = null;\r\n          }\r\n        } else if (e.data.type === \"setInterval\") {\r\n          interval = e.data.interval;\r\n          if (timerID) {\r\n            clearInterval(timerID);\r\n            timerID = setInterval(() => {\r\n              self.postMessage(\"tick\");\r\n            }, interval);\r\n          }\r\n        }\r\n      };\r\n    `;\r\n\r\n    const blob = new Blob([workerCode], { type: 'application/javascript' });\r\n    this.schedulerWorker = new Worker(URL.createObjectURL(blob));\r\n    \r\n    this.schedulerWorker.onmessage = (e) => {\r\n      if (e.data === \"tick\") {\r\n        this.scheduler();\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Initialize performance monitoring\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  initializePerformanceMonitoring() {\r\n    // Monitor performance metrics every second\r\n    setInterval(() => {\r\n      this.updatePerformanceMetrics();\r\n    }, 1000);\r\n  }\r\n\r\n  /**\r\n   * High-precision scheduler function\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  scheduler() {\r\n    if (!this.isPlaying || !this.audioContext) {\r\n      return;\r\n    }\r\n\r\n    const currentTime = this.audioContext.currentTime;\r\n    \r\n    // Schedule steps within the lookahead window\r\n    while (this.nextStepTime < currentTime + this.scheduleAheadTime) {\r\n      this.scheduleStep(this.nextStepTime);\r\n      this.nextStepTime += this.getStepDuration() / 1000; // Convert to seconds\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Schedule a single step\r\n   * @private\r\n   * @param {number} time - Audio context time to schedule step\r\n   * @returns {void}\r\n   */\r\n  scheduleStep(time) {\r\n    const stepNumber = this.currentStep;\r\n    \r\n    // Use setTimeout with precise timing for callback execution\r\n    const delay = (time - this.audioContext.currentTime) * 1000;\r\n    \r\n    setTimeout(() => {\r\n      if (this.isPlaying) {\r\n        this.executeStep(stepNumber);\r\n      }\r\n    }, Math.max(0, delay));\r\n    \r\n    this.currentStep = (this.currentStep + 1) % this.stepResolution;\r\n  }\r\n\r\n  /**\r\n   * Execute step callbacks with minimal overhead\r\n   * @private\r\n   * @param {number} stepNumber - Step number to execute\r\n   * @returns {void}\r\n   */\r\n  executeStep(stepNumber) {\r\n    const executionTime = performance.now();\r\n    \r\n    // Execute callbacks with error isolation\r\n    for (let i = 0; i < this.stepCallbacks.length; i++) {\r\n      try {\r\n        this.stepCallbacks[i](stepNumber, executionTime);\r\n      } catch (error) {\r\n        console.error('Step callback error:', error);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start sequencer playback with high-precision timing\r\n   * @returns {void}\r\n   */\r\n  start() {\r\n    if (!this.isInitialized) {\r\n      throw new Error('Engine must be initialized before starting');\r\n    }\r\n\r\n    if (this.isPlaying) {\r\n      return;\r\n    }\r\n\r\n    // Reset position if not paused\r\n    if (!this.isPaused) {\r\n      this.currentStep = 0;\r\n    }\r\n\r\n    this.isPlaying = true;\r\n    this.isPaused = false;\r\n    \r\n    // Set next step time to current audio context time\r\n    this.nextStepTime = this.audioContext.currentTime;\r\n    \r\n    // Start high-precision scheduler\r\n    this.schedulerWorker.postMessage(\"start\");\r\n    \r\n    this.notifyStateChange();\r\n  }\r\n\r\n  /**\r\n   * Stop sequencer playback\r\n   * @returns {void}\r\n   */\r\n  stop() {\r\n    if (!this.isPlaying && !this.isPaused) {\r\n      return;\r\n    }\r\n\r\n    this.isPlaying = false;\r\n    this.isPaused = false;\r\n    this.currentStep = 0;\r\n    \r\n    // Stop scheduler worker\r\n    this.schedulerWorker.postMessage(\"stop\");\r\n    \r\n    // Clear scheduled steps\r\n    this.scheduledSteps.clear();\r\n    \r\n    this.notifyStateChange();\r\n  }\r\n\r\n  /**\r\n   * Pause sequencer playback\r\n   * @returns {void}\r\n   */\r\n  pause() {\r\n    if (!this.isPlaying) {\r\n      return;\r\n    }\r\n\r\n    this.isPlaying = false;\r\n    this.isPaused = true;\r\n    \r\n    this.schedulerWorker.postMessage(\"stop\");\r\n    \r\n    this.notifyStateChange();\r\n  }\r\n\r\n  /**\r\n   * Resume sequencer playback\r\n   * @returns {void}\r\n   */\r\n  resume() {\r\n    if (!this.isPaused) {\r\n      return;\r\n    }\r\n\r\n    this.isPlaying = true;\r\n    this.isPaused = false;\r\n    \r\n    this.nextStepTime = this.audioContext.currentTime;\r\n    this.schedulerWorker.postMessage(\"start\");\r\n    \r\n    this.notifyStateChange();\r\n  }\r\n\r\n  /**\r\n   * Set BPM with immediate effect\r\n   * @param {number} newBpm - New BPM value\r\n   * @returns {void}\r\n   */\r\n  setBPM(newBpm) {\r\n    if (newBpm < 60 || newBpm > 200) {\r\n      throw new Error('BPM must be between 60 and 200');\r\n    }\r\n\r\n    this.bpm = newBpm;\r\n    \r\n    // Update scheduler interval for new BPM\r\n    const newInterval = Math.max(10, this.getStepDuration() / 4);\r\n    this.schedulerWorker.postMessage({\r\n      type: \"setInterval\",\r\n      interval: newInterval\r\n    });\r\n    \r\n    this.notifyStateChange();\r\n  }\r\n\r\n  /**\r\n   * Get step duration in milliseconds\r\n   * @returns {number} Step duration in milliseconds\r\n   */\r\n  getStepDuration() {\r\n    return (60 / this.bpm / this.stepResolution) * 4 * 1000;\r\n  }\r\n\r\n  /**\r\n   * Jump YouTube player to timestamp with zero-lag optimization\r\n   * @param {number} timestamp - Timestamp in seconds\r\n   * @param {boolean} maintainPlayback - Whether to maintain playback state\r\n   * @returns {Promise<boolean>} Whether jump was successful\r\n   */\r\n  async jumpToTimestamp(timestamp, maintainPlayback = true) {\r\n    if (!this.youtubePlayer) {\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const wasPlaying = this.youtubePlayer.getPlayerState() === 1;\r\n      \r\n      // Use seekTo with allowSeekAhead for faster seeking\r\n      this.youtubePlayer.seekTo(timestamp, true);\r\n      \r\n      // Minimal delay for seek completion\r\n      await new Promise(resolve => setTimeout(resolve, 5));\r\n      \r\n      if (maintainPlayback && wasPlaying) {\r\n        this.youtubePlayer.playVideo();\r\n      }\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('Timestamp jump failed:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update performance metrics\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  updatePerformanceMetrics() {\r\n    const now = performance.now();\r\n    \r\n    if (this.performanceMetrics.lastMeasurement > 0) {\r\n      const deltaTime = now - this.performanceMetrics.lastMeasurement;\r\n      \r\n      // Calculate jitter (timing variance)\r\n      const expectedDelta = 1000; // 1 second\r\n      this.performanceMetrics.jitter = Math.abs(deltaTime - expectedDelta);\r\n      \r\n      // Estimate CPU usage based on timing precision\r\n      this.performanceMetrics.cpuUsage = Math.min(100, this.performanceMetrics.jitter * 2);\r\n    }\r\n    \r\n    this.performanceMetrics.lastMeasurement = now;\r\n  }\r\n\r\n  /**\r\n   * Get current performance metrics\r\n   * @returns {Object} Performance metrics\r\n   */\r\n  getPerformanceMetrics() {\r\n    return { ...this.performanceMetrics };\r\n  }\r\n\r\n  /**\r\n   * Add step callback\r\n   * @param {Function} callback - Callback function\r\n   * @returns {void}\r\n   */\r\n  addStepCallback(callback) {\r\n    if (typeof callback === 'function') {\r\n      this.stepCallbacks.push(callback);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove step callback\r\n   * @param {Function} callback - Callback function to remove\r\n   * @returns {void}\r\n   */\r\n  removeStepCallback(callback) {\r\n    const index = this.stepCallbacks.indexOf(callback);\r\n    if (index > -1) {\r\n      this.stepCallbacks.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add state change callback\r\n   * @param {Function} callback - Callback function\r\n   * @returns {void}\r\n   */\r\n  addStateChangeCallback(callback) {\r\n    if (typeof callback === 'function') {\r\n      this.stateChangeCallbacks.push(callback);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove state change callback\r\n   * @param {Function} callback - Callback function to remove\r\n   * @returns {void}\r\n   */\r\n  removeStateChangeCallback(callback) {\r\n    const index = this.stateChangeCallbacks.indexOf(callback);\r\n    if (index > -1) {\r\n      this.stateChangeCallbacks.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Notify state change callbacks\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  notifyStateChange() {\r\n    const state = this.getState();\r\n    this.stateChangeCallbacks.forEach(callback => {\r\n      try {\r\n        callback(state);\r\n      } catch (error) {\r\n        console.error('State change callback error:', error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get current sequencer state\r\n   * @returns {Object} Current state\r\n   */\r\n  getState() {\r\n    return {\r\n      isPlaying: this.isPlaying,\r\n      isPaused: this.isPaused,\r\n      currentStep: this.currentStep,\r\n      bpm: this.bpm,\r\n      stepResolution: this.stepResolution,\r\n      performanceMetrics: this.getPerformanceMetrics()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Cleanup resources\r\n   * @returns {void}\r\n   */\r\n  cleanup() {\r\n    this.stop();\r\n    \r\n    if (this.schedulerWorker) {\r\n      this.schedulerWorker.terminate();\r\n      this.schedulerWorker = null;\r\n    }\r\n    \r\n    if (this.audioContext) {\r\n      this.audioContext.close();\r\n      this.audioContext = null;\r\n    }\r\n    \r\n    this.stepCallbacks = [];\r\n    this.stateChangeCallbacks = [];\r\n    this.isInitialized = false;\r\n  }\r\n}\r\n\r\nexport { HighPerformanceSequencerEngine };","/**\r\n * @fileoverview Sampler Pattern Data Validator\r\n * Enhanced validation and sanitization for sampler pattern data\r\n * Requirements: 5.5, 5.6 - Pattern data validation and error handling\r\n */\r\n\r\n/**\r\n * Comprehensive pattern data validator with error recovery\r\n */\r\nclass SamplerPatternValidator {\r\n  constructor() {\r\n    this.validationRules = {\r\n      pattern: {\r\n        requiredFields: ['id', 'name', 'bpm', 'currentBank', 'banks'],\r\n        bpmRange: { min: 60, max: 200 },\r\n        maxBanks: 4,\r\n        maxNameLength: 100\r\n      },\r\n      bank: {\r\n        requiredFields: ['bankId', 'name', 'tracks'],\r\n        tracksPerBank: 16,\r\n        maxNameLength: 50\r\n      },\r\n      track: {\r\n        requiredFields: ['trackIndex', 'steps'],\r\n        stepsPerTrack: 16\r\n      }\r\n    };\r\n\r\n    this.errorCounts = {\r\n      validationErrors: 0,\r\n      sanitizationAttempts: 0,\r\n      recoveryAttempts: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validate and sanitize pattern data\r\n   * @param {Object} pattern - Pattern to validate\r\n   * @param {Object} options - Validation options\r\n   * @returns {Object} Validation result with sanitized data\r\n   */\r\n  validateAndSanitize(pattern, options = {}) {\r\n    const {\r\n      strict = false,\r\n      autoFix = true,\r\n      throwOnError = false\r\n    } = options;\r\n\r\n    const result = {\r\n      isValid: false,\r\n      sanitizedPattern: null,\r\n      errors: [],\r\n      warnings: [],\r\n      fixes: []\r\n    };\r\n\r\n    try {\r\n      // Basic structure validation\r\n      const structureValidation = this.validateStructure(pattern);\r\n      result.errors.push(...structureValidation.errors);\r\n      result.warnings.push(...structureValidation.warnings);\r\n\r\n      if (structureValidation.errors.length > 0 && strict) {\r\n        result.isValid = false;\r\n        if (throwOnError) {\r\n          throw new Error(`Pattern validation failed: ${structureValidation.errors.join(', ')}`);\r\n        }\r\n        return result;\r\n      }\r\n\r\n      // Attempt sanitization if auto-fix is enabled\r\n      let sanitizedPattern = pattern;\r\n      if (autoFix && (structureValidation.errors.length > 0 || structureValidation.warnings.length > 0)) {\r\n        const sanitizationResult = this.sanitizePattern(pattern);\r\n        sanitizedPattern = sanitizationResult.pattern;\r\n        result.fixes.push(...sanitizationResult.fixes);\r\n        result.warnings.push(...sanitizationResult.warnings);\r\n        this.errorCounts.sanitizationAttempts++;\r\n      }\r\n\r\n      // Validate sanitized pattern\r\n      const finalValidation = this.validateStructure(sanitizedPattern);\r\n      \r\n      if (finalValidation.errors.length === 0) {\r\n        result.isValid = true;\r\n        result.sanitizedPattern = sanitizedPattern;\r\n      } else {\r\n        result.errors.push(...finalValidation.errors);\r\n        \r\n        if (throwOnError) {\r\n          throw new Error(`Pattern validation failed after sanitization: ${finalValidation.errors.join(', ')}`);\r\n        }\r\n      }\r\n\r\n      return result;\r\n\r\n    } catch (error) {\r\n      this.errorCounts.validationErrors++;\r\n      result.errors.push(`Validation exception: ${error.message}`);\r\n      \r\n      if (throwOnError) {\r\n        throw error;\r\n      }\r\n      \r\n      return result;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate pattern structure\r\n   * @private\r\n   * @param {Object} pattern - Pattern to validate\r\n   * @returns {Object} Validation result\r\n   */\r\n  validateStructure(pattern) {\r\n    const errors = [];\r\n    const warnings = [];\r\n\r\n    // Null/undefined check\r\n    if (!pattern || typeof pattern !== 'object') {\r\n      errors.push('Pattern must be a valid object');\r\n      return { errors, warnings };\r\n    }\r\n\r\n    // Required fields validation\r\n    const missingFields = this.validationRules.pattern.requiredFields.filter(\r\n      field => !(field in pattern)\r\n    );\r\n    if (missingFields.length > 0) {\r\n      errors.push(`Missing required fields: ${missingFields.join(', ')}`);\r\n    }\r\n\r\n    // ID validation\r\n    if (pattern.id && (typeof pattern.id !== 'string' || pattern.id.trim().length === 0)) {\r\n      errors.push('Pattern ID must be a non-empty string');\r\n    }\r\n\r\n    // Name validation\r\n    if (pattern.name) {\r\n      if (typeof pattern.name !== 'string') {\r\n        errors.push('Pattern name must be a string');\r\n      } else if (pattern.name.length > this.validationRules.pattern.maxNameLength) {\r\n        warnings.push(`Pattern name exceeds maximum length (${this.validationRules.pattern.maxNameLength})`);\r\n      }\r\n    }\r\n\r\n    // BPM validation\r\n    if (pattern.bpm !== undefined) {\r\n      if (typeof pattern.bpm !== 'number' || isNaN(pattern.bpm)) {\r\n        errors.push('BPM must be a valid number');\r\n      } else if (pattern.bpm < this.validationRules.pattern.bpmRange.min || \r\n                 pattern.bpm > this.validationRules.pattern.bpmRange.max) {\r\n        errors.push(`BPM must be between ${this.validationRules.pattern.bpmRange.min} and ${this.validationRules.pattern.bpmRange.max}`);\r\n      }\r\n    }\r\n\r\n    // Current bank validation\r\n    if (pattern.currentBank !== undefined) {\r\n      if (typeof pattern.currentBank !== 'number' || pattern.currentBank < 0) {\r\n        errors.push('Current bank must be a non-negative number');\r\n      }\r\n    }\r\n\r\n    // Banks validation\r\n    if (pattern.banks) {\r\n      if (!Array.isArray(pattern.banks)) {\r\n        errors.push('Banks must be an array');\r\n      } else {\r\n        if (pattern.banks.length === 0) {\r\n          errors.push('Pattern must have at least one bank');\r\n        } else if (pattern.banks.length > this.validationRules.pattern.maxBanks) {\r\n          warnings.push(`Pattern has more than ${this.validationRules.pattern.maxBanks} banks`);\r\n        }\r\n\r\n        // Validate each bank\r\n        pattern.banks.forEach((bank, index) => {\r\n          const bankValidation = this.validateBank(bank, index);\r\n          errors.push(...bankValidation.errors.map(err => `Bank ${index}: ${err}`));\r\n          warnings.push(...bankValidation.warnings.map(warn => `Bank ${index}: ${warn}`));\r\n        });\r\n\r\n        // Check current bank index\r\n        if (pattern.currentBank >= pattern.banks.length) {\r\n          errors.push('Current bank index exceeds available banks');\r\n        }\r\n      }\r\n    }\r\n\r\n    // Metadata validation\r\n    if (pattern.metadata) {\r\n      if (typeof pattern.metadata !== 'object') {\r\n        warnings.push('Metadata should be an object');\r\n      } else {\r\n        if (pattern.metadata.created && !this.isValidISODate(pattern.metadata.created)) {\r\n          warnings.push('Invalid created date in metadata');\r\n        }\r\n        if (pattern.metadata.modified && !this.isValidISODate(pattern.metadata.modified)) {\r\n          warnings.push('Invalid modified date in metadata');\r\n        }\r\n      }\r\n    }\r\n\r\n    return { errors, warnings };\r\n  }\r\n\r\n  /**\r\n   * Validate bank structure\r\n   * @private\r\n   * @param {Object} bank - Bank to validate\r\n   * @param {number} index - Bank index\r\n   * @returns {Object} Validation result\r\n   */\r\n  validateBank(bank, index) {\r\n    const errors = [];\r\n    const warnings = [];\r\n\r\n    if (!bank || typeof bank !== 'object') {\r\n      errors.push('Bank must be a valid object');\r\n      return { errors, warnings };\r\n    }\r\n\r\n    // Required fields\r\n    const missingFields = this.validationRules.bank.requiredFields.filter(\r\n      field => !(field in bank)\r\n    );\r\n    if (missingFields.length > 0) {\r\n      errors.push(`Missing required fields: ${missingFields.join(', ')}`);\r\n    }\r\n\r\n    // Bank ID validation\r\n    if (bank.bankId !== undefined) {\r\n      if (typeof bank.bankId !== 'number' || bank.bankId !== index) {\r\n        errors.push(`Bank ID should match index (expected ${index}, got ${bank.bankId})`);\r\n      }\r\n    }\r\n\r\n    // Name validation\r\n    if (bank.name) {\r\n      if (typeof bank.name !== 'string') {\r\n        errors.push('Bank name must be a string');\r\n      } else if (bank.name.length > this.validationRules.bank.maxNameLength) {\r\n        warnings.push(`Bank name exceeds maximum length (${this.validationRules.bank.maxNameLength})`);\r\n      }\r\n    }\r\n\r\n    // Tracks validation\r\n    if (bank.tracks) {\r\n      if (!Array.isArray(bank.tracks)) {\r\n        errors.push('Tracks must be an array');\r\n      } else {\r\n        if (bank.tracks.length !== this.validationRules.bank.tracksPerBank) {\r\n          errors.push(`Bank must have exactly ${this.validationRules.bank.tracksPerBank} tracks`);\r\n        }\r\n\r\n        // Validate each track\r\n        bank.tracks.forEach((track, trackIndex) => {\r\n          const trackValidation = this.validateTrack(track, trackIndex);\r\n          errors.push(...trackValidation.errors.map(err => `Track ${trackIndex}: ${err}`));\r\n          warnings.push(...trackValidation.warnings.map(warn => `Track ${trackIndex}: ${warn}`));\r\n        });\r\n      }\r\n    }\r\n\r\n    return { errors, warnings };\r\n  }\r\n\r\n  /**\r\n   * Validate track structure\r\n   * @private\r\n   * @param {Object} track - Track to validate\r\n   * @param {number} index - Track index\r\n   * @returns {Object} Validation result\r\n   */\r\n  validateTrack(track, index) {\r\n    const errors = [];\r\n    const warnings = [];\r\n\r\n    if (!track || typeof track !== 'object') {\r\n      errors.push('Track must be a valid object');\r\n      return { errors, warnings };\r\n    }\r\n\r\n    // Required fields\r\n    const missingFields = this.validationRules.track.requiredFields.filter(\r\n      field => !(field in track)\r\n    );\r\n    if (missingFields.length > 0) {\r\n      errors.push(`Missing required fields: ${missingFields.join(', ')}`);\r\n    }\r\n\r\n    // Track index validation\r\n    if (track.trackIndex !== undefined) {\r\n      if (typeof track.trackIndex !== 'number' || track.trackIndex !== index) {\r\n        errors.push(`Track index should match position (expected ${index}, got ${track.trackIndex})`);\r\n      }\r\n    }\r\n\r\n    // Chop ID validation\r\n    if (track.chopId !== undefined && track.chopId !== null) {\r\n      if (typeof track.chopId !== 'string' || track.chopId.trim().length === 0) {\r\n        warnings.push('Chop ID should be a non-empty string or null');\r\n      } else if (!/^[A-D]\\d{1,2}$/.test(track.chopId)) {\r\n        warnings.push(`Chop ID format may be invalid: ${track.chopId}`);\r\n      }\r\n    }\r\n\r\n    // Steps validation\r\n    if (track.steps) {\r\n      if (!Array.isArray(track.steps)) {\r\n        errors.push('Steps must be an array');\r\n      } else {\r\n        if (track.steps.length !== this.validationRules.track.stepsPerTrack) {\r\n          errors.push(`Track must have exactly ${this.validationRules.track.stepsPerTrack} steps`);\r\n        }\r\n\r\n        // Validate each step\r\n        track.steps.forEach((step, stepIndex) => {\r\n          if (typeof step !== 'boolean') {\r\n            errors.push(`Step ${stepIndex} must be a boolean value`);\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    return { errors, warnings };\r\n  }\r\n\r\n  /**\r\n   * Sanitize pattern data by fixing common issues\r\n   * @private\r\n   * @param {Object} pattern - Pattern to sanitize\r\n   * @returns {Object} Sanitization result\r\n   */\r\n  sanitizePattern(pattern) {\r\n    const fixes = [];\r\n    const warnings = [];\r\n    const sanitized = JSON.parse(JSON.stringify(pattern)); // Deep clone\r\n\r\n    try {\r\n      // Fix missing or invalid ID\r\n      if (!sanitized.id || typeof sanitized.id !== 'string') {\r\n        sanitized.id = this.generatePatternId();\r\n        fixes.push('Generated new pattern ID');\r\n      }\r\n\r\n      // Fix missing or invalid name\r\n      if (!sanitized.name || typeof sanitized.name !== 'string') {\r\n        sanitized.name = 'Untitled Pattern';\r\n        fixes.push('Set default pattern name');\r\n      } else if (sanitized.name.length > this.validationRules.pattern.maxNameLength) {\r\n        sanitized.name = sanitized.name.substring(0, this.validationRules.pattern.maxNameLength);\r\n        fixes.push('Truncated pattern name to maximum length');\r\n      }\r\n\r\n      // Fix invalid BPM\r\n      if (typeof sanitized.bpm !== 'number' || isNaN(sanitized.bpm)) {\r\n        sanitized.bpm = 120;\r\n        fixes.push('Set default BPM to 120');\r\n      } else {\r\n        const { min, max } = this.validationRules.pattern.bpmRange;\r\n        if (sanitized.bpm < min) {\r\n          sanitized.bpm = min;\r\n          fixes.push(`Adjusted BPM to minimum value (${min})`);\r\n        } else if (sanitized.bpm > max) {\r\n          sanitized.bpm = max;\r\n          fixes.push(`Adjusted BPM to maximum value (${max})`);\r\n        }\r\n      }\r\n\r\n      // Fix current bank\r\n      if (typeof sanitized.currentBank !== 'number' || sanitized.currentBank < 0) {\r\n        sanitized.currentBank = 0;\r\n        fixes.push('Reset current bank to 0');\r\n      }\r\n\r\n      // Fix banks array\r\n      if (!Array.isArray(sanitized.banks)) {\r\n        sanitized.banks = this.createDefaultBanks();\r\n        fixes.push('Created default banks structure');\r\n      } else {\r\n        // Ensure at least one bank\r\n        if (sanitized.banks.length === 0) {\r\n          sanitized.banks = this.createDefaultBanks();\r\n          fixes.push('Added default banks (was empty)');\r\n        }\r\n\r\n        // Sanitize each bank\r\n        sanitized.banks.forEach((bank, index) => {\r\n          const bankResult = this.sanitizeBank(bank, index);\r\n          sanitized.banks[index] = bankResult.bank;\r\n          fixes.push(...bankResult.fixes.map(fix => `Bank ${index}: ${fix}`));\r\n          warnings.push(...bankResult.warnings.map(warn => `Bank ${index}: ${warn}`));\r\n        });\r\n\r\n        // Fix current bank index if out of range\r\n        if (sanitized.currentBank >= sanitized.banks.length) {\r\n          sanitized.currentBank = 0;\r\n          fixes.push('Reset current bank index to valid range');\r\n        }\r\n      }\r\n\r\n      // Add or fix metadata\r\n      if (!sanitized.metadata || typeof sanitized.metadata !== 'object') {\r\n        sanitized.metadata = {};\r\n        fixes.push('Added metadata object');\r\n      }\r\n\r\n      const now = new Date().toISOString();\r\n      if (!sanitized.metadata.created || !this.isValidISODate(sanitized.metadata.created)) {\r\n        sanitized.metadata.created = now;\r\n        fixes.push('Set creation date');\r\n      }\r\n      \r\n      sanitized.metadata.modified = now;\r\n      fixes.push('Updated modification date');\r\n\r\n      return { pattern: sanitized, fixes, warnings };\r\n\r\n    } catch (error) {\r\n      warnings.push(`Sanitization error: ${error.message}`);\r\n      return { pattern: sanitized, fixes, warnings };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sanitize bank data\r\n   * @private\r\n   * @param {Object} bank - Bank to sanitize\r\n   * @param {number} index - Bank index\r\n   * @returns {Object} Sanitization result\r\n   */\r\n  sanitizeBank(bank, index) {\r\n    const fixes = [];\r\n    const warnings = [];\r\n    const sanitized = { ...bank };\r\n\r\n    // Fix bank ID\r\n    if (typeof sanitized.bankId !== 'number' || sanitized.bankId !== index) {\r\n      sanitized.bankId = index;\r\n      fixes.push('Fixed bank ID');\r\n    }\r\n\r\n    // Fix bank name\r\n    if (!sanitized.name || typeof sanitized.name !== 'string') {\r\n      sanitized.name = `Bank ${String.fromCharCode(65 + index)}`;\r\n      fixes.push('Set default bank name');\r\n    } else if (sanitized.name.length > this.validationRules.bank.maxNameLength) {\r\n      sanitized.name = sanitized.name.substring(0, this.validationRules.bank.maxNameLength);\r\n      fixes.push('Truncated bank name');\r\n    }\r\n\r\n    // Fix tracks array\r\n    if (!Array.isArray(sanitized.tracks)) {\r\n      sanitized.tracks = this.createDefaultTracks();\r\n      fixes.push('Created default tracks');\r\n    } else {\r\n      // Ensure correct number of tracks\r\n      while (sanitized.tracks.length < this.validationRules.bank.tracksPerBank) {\r\n        sanitized.tracks.push(this.createDefaultTrack(sanitized.tracks.length));\r\n        fixes.push(`Added missing track ${sanitized.tracks.length - 1}`);\r\n      }\r\n\r\n      if (sanitized.tracks.length > this.validationRules.bank.tracksPerBank) {\r\n        sanitized.tracks = sanitized.tracks.slice(0, this.validationRules.bank.tracksPerBank);\r\n        fixes.push('Removed excess tracks');\r\n      }\r\n\r\n      // Sanitize each track\r\n      sanitized.tracks.forEach((track, trackIndex) => {\r\n        const trackResult = this.sanitizeTrack(track, trackIndex);\r\n        sanitized.tracks[trackIndex] = trackResult.track;\r\n        fixes.push(...trackResult.fixes.map(fix => `Track ${trackIndex}: ${fix}`));\r\n        warnings.push(...trackResult.warnings.map(warn => `Track ${trackIndex}: ${warn}`));\r\n      });\r\n    }\r\n\r\n    return { bank: sanitized, fixes, warnings };\r\n  }\r\n\r\n  /**\r\n   * Sanitize track data\r\n   * @private\r\n   * @param {Object} track - Track to sanitize\r\n   * @param {number} index - Track index\r\n   * @returns {Object} Sanitization result\r\n   */\r\n  sanitizeTrack(track, index) {\r\n    const fixes = [];\r\n    const warnings = [];\r\n    const sanitized = { ...track };\r\n\r\n    // Fix track index\r\n    if (typeof sanitized.trackIndex !== 'number' || sanitized.trackIndex !== index) {\r\n      sanitized.trackIndex = index;\r\n      fixes.push('Fixed track index');\r\n    }\r\n\r\n    // Validate chop ID format\r\n    if (sanitized.chopId !== undefined && sanitized.chopId !== null) {\r\n      if (typeof sanitized.chopId !== 'string' || sanitized.chopId.trim().length === 0) {\r\n        sanitized.chopId = null;\r\n        fixes.push('Cleared invalid chop ID');\r\n      } else if (!/^[A-D]\\d{1,2}$/.test(sanitized.chopId)) {\r\n        warnings.push(`Chop ID format may be invalid: ${sanitized.chopId}`);\r\n      }\r\n    }\r\n\r\n    // Fix steps array\r\n    if (!Array.isArray(sanitized.steps)) {\r\n      sanitized.steps = new Array(this.validationRules.track.stepsPerTrack).fill(false);\r\n      fixes.push('Created default steps array');\r\n    } else {\r\n      // Ensure correct number of steps\r\n      while (sanitized.steps.length < this.validationRules.track.stepsPerTrack) {\r\n        sanitized.steps.push(false);\r\n        fixes.push(`Added missing step ${sanitized.steps.length - 1}`);\r\n      }\r\n\r\n      if (sanitized.steps.length > this.validationRules.track.stepsPerTrack) {\r\n        sanitized.steps = sanitized.steps.slice(0, this.validationRules.track.stepsPerTrack);\r\n        fixes.push('Removed excess steps');\r\n      }\r\n\r\n      // Fix non-boolean steps\r\n      sanitized.steps.forEach((step, stepIndex) => {\r\n        if (typeof step !== 'boolean') {\r\n          sanitized.steps[stepIndex] = Boolean(step);\r\n          fixes.push(`Fixed step ${stepIndex} to boolean`);\r\n        }\r\n      });\r\n    }\r\n\r\n    return { track: sanitized, fixes, warnings };\r\n  }\r\n\r\n  /**\r\n   * Create default banks structure\r\n   * @private\r\n   * @returns {Array} Default banks\r\n   */\r\n  createDefaultBanks() {\r\n    const banks = [];\r\n    for (let i = 0; i < 2; i++) { // Initially 2 banks\r\n      banks.push({\r\n        bankId: i,\r\n        name: `Bank ${String.fromCharCode(65 + i)}`,\r\n        tracks: this.createDefaultTracks()\r\n      });\r\n    }\r\n    return banks;\r\n  }\r\n\r\n  /**\r\n   * Create default tracks structure\r\n   * @private\r\n   * @returns {Array} Default tracks\r\n   */\r\n  createDefaultTracks() {\r\n    const tracks = [];\r\n    for (let i = 0; i < this.validationRules.bank.tracksPerBank; i++) {\r\n      tracks.push(this.createDefaultTrack(i));\r\n    }\r\n    return tracks;\r\n  }\r\n\r\n  /**\r\n   * Create default track structure\r\n   * @private\r\n   * @param {number} index - Track index\r\n   * @returns {Object} Default track\r\n   */\r\n  createDefaultTrack(index) {\r\n    return {\r\n      trackIndex: index,\r\n      chopId: null,\r\n      steps: new Array(this.validationRules.track.stepsPerTrack).fill(false)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generate a unique pattern ID\r\n   * @private\r\n   * @returns {string} Unique pattern ID\r\n   */\r\n  generatePatternId() {\r\n    return `sampler_pattern_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\r\n  }\r\n\r\n  /**\r\n   * Check if a string is a valid ISO date\r\n   * @private\r\n   * @param {string} dateString - Date string to validate\r\n   * @returns {boolean} Whether the date is valid\r\n   */\r\n  isValidISODate(dateString) {\r\n    if (typeof dateString !== 'string') return false;\r\n    const date = new Date(dateString);\r\n    return date instanceof Date && !isNaN(date.getTime()) && date.toISOString() === dateString;\r\n  }\r\n\r\n  /**\r\n   * Get validation statistics\r\n   * @returns {Object} Validation statistics\r\n   */\r\n  getStats() {\r\n    return { ...this.errorCounts };\r\n  }\r\n\r\n  /**\r\n   * Reset validation statistics\r\n   */\r\n  resetStats() {\r\n    this.errorCounts = {\r\n      validationErrors: 0,\r\n      sanitizationAttempts: 0,\r\n      recoveryAttempts: 0\r\n    };\r\n  }\r\n}\r\n\r\n// Create and export singleton instance\r\nconst samplerPatternValidator = new SamplerPatternValidator();\r\n\r\nexport default samplerPatternValidator;\r\nexport { SamplerPatternValidator };","/**\r\n * @fileoverview Sampler Pattern Management Service\r\n * Manages pattern data specifically for the sampler drum sequencer\r\n * Handles bank organization and chop-to-track assignment\r\n */\r\n\r\nimport samplerPatternValidator from './SamplerPatternValidator.js';\r\n\r\n/**\r\n * Manages sampler sequencer patterns and bank organization\r\n */\r\nclass SamplerPatternManager {\r\n  constructor() {\r\n    /** @type {Object} */\r\n    this.currentPattern = null;\r\n    \r\n    /** @type {number} */\r\n    this.currentBank = 0;\r\n    \r\n    /** @type {number} */\r\n    this.maxBanks = 4; // A, B, C, D (initially 2)\r\n    \r\n    /** @type {number} */\r\n    this.tracksPerBank = 16;\r\n    \r\n    /** @type {number} */\r\n    this.stepsPerTrack = 16;\r\n    \r\n    /** @type {Map<string, Object>} */\r\n    this.chopAssignments = new Map(); // chopId -> trackIndex mapping\r\n  }\r\n\r\n  /**\r\n   * Create a new sampler pattern with validation\r\n   * @param {string} name - Pattern name\r\n   * @param {number} bpm - Initial BPM\r\n   * @returns {Object} New pattern creation result\r\n   */\r\n  createPattern(name = 'New Pattern', bpm = 140) {\r\n    try {\r\n      const pattern = {\r\n        id: this.generatePatternId(),\r\n        name: name,\r\n        bpm: bpm,\r\n        currentBank: 0,\r\n        banks: this.createDefaultBanks(),\r\n        metadata: {\r\n          created: new Date().toISOString(),\r\n          modified: new Date().toISOString()\r\n        }\r\n      };\r\n\r\n      // Validate the created pattern\r\n      const validationResult = samplerPatternValidator.validateAndSanitize(pattern, {\r\n        autoFix: true,\r\n        strict: false,\r\n        throwOnError: false\r\n      });\r\n\r\n      if (!validationResult.isValid) {\r\n        console.error('Created pattern failed validation:', validationResult.errors);\r\n        // Use sanitized version if available\r\n        if (validationResult.sanitizedPattern) {\r\n          this.currentPattern = validationResult.sanitizedPattern;\r\n        } else {\r\n          throw new Error('Failed to create valid pattern');\r\n        }\r\n      } else {\r\n        this.currentPattern = validationResult.sanitizedPattern || pattern;\r\n      }\r\n\r\n      this.currentBank = 0;\r\n      this.chopAssignments.clear();\r\n      \r\n      return {\r\n        success: true,\r\n        pattern: this.currentPattern,\r\n        fixes: validationResult.fixes || [],\r\n        warnings: validationResult.warnings || []\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('Failed to create pattern:', error);\r\n      return {\r\n        success: false,\r\n        error: error.message,\r\n        pattern: null\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create default bank structure\r\n   * @private\r\n   * @returns {Array} Array of bank objects\r\n   */\r\n  createDefaultBanks() {\r\n    const banks = [];\r\n    \r\n    // Initially create 2 banks (A and B), expandable to 4\r\n    for (let bankIndex = 0; bankIndex < 2; bankIndex++) {\r\n      const bankName = String.fromCharCode(65 + bankIndex); // A, B, C, D\r\n      \r\n      banks.push({\r\n        bankId: bankIndex,\r\n        name: `Bank ${bankName}`,\r\n        tracks: this.createDefaultTracks()\r\n      });\r\n    }\r\n    \r\n    return banks;\r\n  }\r\n\r\n  /**\r\n   * Create default tracks for a bank\r\n   * @private\r\n   * @returns {Array} Array of track objects\r\n   */\r\n  createDefaultTracks() {\r\n    const tracks = [];\r\n    \r\n    for (let trackIndex = 0; trackIndex < this.tracksPerBank; trackIndex++) {\r\n      tracks.push({\r\n        trackIndex: trackIndex,\r\n        chopId: null, // Will be assigned when chops are available\r\n        steps: new Array(this.stepsPerTrack).fill(false)\r\n      });\r\n    }\r\n    \r\n    return tracks;\r\n  }\r\n\r\n  /**\r\n   * Toggle a step on/off\r\n   * @param {number} trackIndex - Track index (0-15)\r\n   * @param {number} stepIndex - Step index (0-15)\r\n   * @returns {void}\r\n   */\r\n  toggleStep(trackIndex, stepIndex) {\r\n    if (!this.currentPattern) {\r\n      throw new Error('No pattern is currently loaded');\r\n    }\r\n\r\n    if (trackIndex < 0 || trackIndex >= this.tracksPerBank) {\r\n      throw new Error(`Track index must be between 0 and ${this.tracksPerBank - 1}`);\r\n    }\r\n\r\n    if (stepIndex < 0 || stepIndex >= this.stepsPerTrack) {\r\n      throw new Error(`Step index must be between 0 and ${this.stepsPerTrack - 1}`);\r\n    }\r\n\r\n    const currentBankData = this.getCurrentBankData();\r\n    if (!currentBankData) {\r\n      throw new Error('Current bank data not found');\r\n    }\r\n\r\n    const track = currentBankData.tracks[trackIndex];\r\n    if (!track) {\r\n      throw new Error(`Track ${trackIndex} not found in current bank`);\r\n    }\r\n\r\n    // Toggle the step\r\n    track.steps[stepIndex] = !track.steps[stepIndex];\r\n\r\n    // Update pattern metadata\r\n    this.currentPattern.metadata.modified = new Date().toISOString();\r\n  }\r\n\r\n  /**\r\n   * Set step state\r\n   * @param {number} trackIndex - Track index (0-15)\r\n   * @param {number} stepIndex - Step index (0-15)\r\n   * @param {boolean} active - Step active state\r\n   * @returns {void}\r\n   */\r\n  setStep(trackIndex, stepIndex, active) {\r\n    if (!this.currentPattern) {\r\n      throw new Error('No pattern is currently loaded');\r\n    }\r\n\r\n    if (trackIndex < 0 || trackIndex >= this.tracksPerBank) {\r\n      throw new Error(`Track index must be between 0 and ${this.tracksPerBank - 1}`);\r\n    }\r\n\r\n    if (stepIndex < 0 || stepIndex >= this.stepsPerTrack) {\r\n      throw new Error(`Step index must be between 0 and ${this.stepsPerTrack - 1}`);\r\n    }\r\n\r\n    const currentBankData = this.getCurrentBankData();\r\n    if (!currentBankData) {\r\n      throw new Error('Current bank data not found');\r\n    }\r\n\r\n    const track = currentBankData.tracks[trackIndex];\r\n    if (!track) {\r\n      throw new Error(`Track ${trackIndex} not found in current bank`);\r\n    }\r\n\r\n    // Set the step\r\n    track.steps[stepIndex] = active;\r\n\r\n    // Update pattern metadata\r\n    this.currentPattern.metadata.modified = new Date().toISOString();\r\n  }\r\n\r\n  /**\r\n   * Get step state\r\n   * @param {number} trackIndex - Track index (0-15)\r\n   * @param {number} stepIndex - Step index (0-15)\r\n   * @returns {boolean} Step active state\r\n   */\r\n  getStep(trackIndex, stepIndex) {\r\n    if (!this.currentPattern) {\r\n      return false;\r\n    }\r\n\r\n    const currentBankData = this.getCurrentBankData();\r\n    if (!currentBankData) {\r\n      return false;\r\n    }\r\n\r\n    const track = currentBankData.tracks[trackIndex];\r\n    if (!track || stepIndex < 0 || stepIndex >= track.steps.length) {\r\n      return false;\r\n    }\r\n\r\n    return track.steps[stepIndex];\r\n  }\r\n\r\n  /**\r\n   * Switch to a different bank\r\n   * @param {number} bankIndex - Bank index (0-3)\r\n   * @returns {void}\r\n   */\r\n  switchBank(bankIndex) {\r\n    if (!this.currentPattern) {\r\n      throw new Error('No pattern is currently loaded');\r\n    }\r\n\r\n    if (bankIndex < 0 || bankIndex >= this.currentPattern.banks.length) {\r\n      throw new Error(`Bank index must be between 0 and ${this.currentPattern.banks.length - 1}`);\r\n    }\r\n\r\n    this.currentBank = bankIndex;\r\n    this.currentPattern.currentBank = bankIndex;\r\n    \r\n    // Update pattern metadata\r\n    this.currentPattern.metadata.modified = new Date().toISOString();\r\n  }\r\n\r\n  /**\r\n   * Get current bank data\r\n   * @returns {Object|null} Current bank data\r\n   */\r\n  getCurrentBankData() {\r\n    if (!this.currentPattern || !this.currentPattern.banks) {\r\n      return null;\r\n    }\r\n\r\n    return this.currentPattern.banks[this.currentBank] || null;\r\n  }\r\n\r\n  /**\r\n   * Assign chop to track\r\n   * @param {string} chopId - Chop identifier (e.g., 'A0', 'B5')\r\n   * @param {number} trackIndex - Track index (0-15)\r\n   * @returns {void}\r\n   */\r\n  assignChopToTrack(chopId, trackIndex) {\r\n    if (!this.currentPattern) {\r\n      throw new Error('No pattern is currently loaded');\r\n    }\r\n\r\n    if (trackIndex < 0 || trackIndex >= this.tracksPerBank) {\r\n      throw new Error(`Track index must be between 0 and ${this.tracksPerBank - 1}`);\r\n    }\r\n\r\n    const currentBankData = this.getCurrentBankData();\r\n    if (!currentBankData) {\r\n      throw new Error('Current bank data not found');\r\n    }\r\n\r\n    const track = currentBankData.tracks[trackIndex];\r\n    if (!track) {\r\n      throw new Error(`Track ${trackIndex} not found in current bank`);\r\n    }\r\n\r\n    // Remove previous assignment if exists\r\n    if (track.chopId) {\r\n      this.chopAssignments.delete(track.chopId);\r\n    }\r\n\r\n    // Assign new chop\r\n    track.chopId = chopId;\r\n    if (chopId) {\r\n      this.chopAssignments.set(chopId, trackIndex);\r\n    }\r\n\r\n    // Update pattern metadata\r\n    this.currentPattern.metadata.modified = new Date().toISOString();\r\n  }\r\n\r\n  /**\r\n   * Auto-assign chops to tracks based on chop data\r\n   * @param {Array} chops - Array of chop objects\r\n   * @returns {void}\r\n   */\r\n  autoAssignChops(chops) {\r\n    if (!this.currentPattern || !Array.isArray(chops)) {\r\n      return;\r\n    }\r\n\r\n    // Clear existing assignments\r\n    this.chopAssignments.clear();\r\n\r\n    // Group chops by bank\r\n    const chopsByBank = this.groupChopsByBank(chops);\r\n\r\n    // Assign chops to each bank\r\n    Object.entries(chopsByBank).forEach(([bankLetter, bankChops]) => {\r\n      const bankIndex = bankLetter.charCodeAt(0) - 65; // A=0, B=1, etc.\r\n      \r\n      if (bankIndex >= 0 && bankIndex < this.currentPattern.banks.length) {\r\n        const bankData = this.currentPattern.banks[bankIndex];\r\n        \r\n        bankChops.forEach((chop, index) => {\r\n          if (index < this.tracksPerBank) {\r\n            const track = bankData.tracks[index];\r\n            track.chopId = chop.padId;\r\n            this.chopAssignments.set(chop.padId, index);\r\n          }\r\n        });\r\n      }\r\n    });\r\n\r\n    // Update pattern metadata\r\n    this.currentPattern.metadata.modified = new Date().toISOString();\r\n  }\r\n\r\n  /**\r\n   * Group chops by bank letter\r\n   * @private\r\n   * @param {Array} chops - Array of chop objects\r\n   * @returns {Object} Chops grouped by bank letter\r\n   */\r\n  groupChopsByBank(chops) {\r\n    const grouped = {};\r\n    \r\n    chops.forEach(chop => {\r\n      if (chop.padId && typeof chop.padId === 'string') {\r\n        const bankLetter = chop.padId.charAt(0).toUpperCase();\r\n        if (!grouped[bankLetter]) {\r\n          grouped[bankLetter] = [];\r\n        }\r\n        grouped[bankLetter].push(chop);\r\n      }\r\n    });\r\n\r\n    // Sort chops within each bank by pad number\r\n    Object.keys(grouped).forEach(bankLetter => {\r\n      grouped[bankLetter].sort((a, b) => {\r\n        const aNum = parseInt(a.padId.slice(1)) || 0;\r\n        const bNum = parseInt(b.padId.slice(1)) || 0;\r\n        return aNum - bNum;\r\n      });\r\n    });\r\n\r\n    return grouped;\r\n  }\r\n\r\n  /**\r\n   * Get chop assignment for track\r\n   * @param {number} trackIndex - Track index\r\n   * @returns {string|null} Chop ID or null\r\n   */\r\n  getChopForTrack(trackIndex) {\r\n    const currentBankData = this.getCurrentBankData();\r\n    if (!currentBankData) {\r\n      return null;\r\n    }\r\n\r\n    const track = currentBankData.tracks[trackIndex];\r\n    return track ? track.chopId : null;\r\n  }\r\n\r\n  /**\r\n   * Get track assignment for chop\r\n   * @param {string} chopId - Chop ID\r\n   * @returns {number|null} Track index or null\r\n   */\r\n  getTrackForChop(chopId) {\r\n    return this.chopAssignments.get(chopId) || null;\r\n  }\r\n\r\n  /**\r\n   * Get active steps for current step\r\n   * @param {number} stepIndex - Current step index\r\n   * @returns {Array} Array of active track indices\r\n   */\r\n  getActiveStepsForStep(stepIndex) {\r\n    const currentBankData = this.getCurrentBankData();\r\n    if (!currentBankData) {\r\n      return [];\r\n    }\r\n\r\n    const activeTracks = [];\r\n    \r\n    currentBankData.tracks.forEach((track, trackIndex) => {\r\n      if (track.steps[stepIndex] && track.chopId) {\r\n        activeTracks.push({\r\n          trackIndex,\r\n          chopId: track.chopId\r\n        });\r\n      }\r\n    });\r\n\r\n    return activeTracks;\r\n  }\r\n\r\n  /**\r\n   * Clear all steps in current bank\r\n   * @returns {void}\r\n   */\r\n  clearCurrentBank() {\r\n    const currentBankData = this.getCurrentBankData();\r\n    if (!currentBankData) {\r\n      return;\r\n    }\r\n\r\n    currentBankData.tracks.forEach(track => {\r\n      track.steps.fill(false);\r\n    });\r\n\r\n    // Update pattern metadata\r\n    this.currentPattern.metadata.modified = new Date().toISOString();\r\n  }\r\n\r\n  /**\r\n   * Clear all steps in all banks\r\n   * @returns {void}\r\n   */\r\n  clearAllBanks() {\r\n    if (!this.currentPattern) {\r\n      return;\r\n    }\r\n\r\n    this.currentPattern.banks.forEach(bank => {\r\n      bank.tracks.forEach(track => {\r\n        track.steps.fill(false);\r\n      });\r\n    });\r\n\r\n    // Update pattern metadata\r\n    this.currentPattern.metadata.modified = new Date().toISOString();\r\n  }\r\n\r\n  /**\r\n   * Get current pattern\r\n   * @returns {Object|null} Current pattern\r\n   */\r\n  getCurrentPattern() {\r\n    return this.currentPattern;\r\n  }\r\n\r\n  /**\r\n   * Set current pattern with enhanced validation and error recovery\r\n   * @param {Object} pattern - Pattern to set as current\r\n   * @param {Object} options - Validation options\r\n   * @returns {Object} Validation result\r\n   */\r\n  setCurrentPattern(pattern, options = {}) {\r\n    const {\r\n      autoFix = true,\r\n      strict = false,\r\n      throwOnError = false\r\n    } = options;\r\n\r\n    if (!pattern) {\r\n      this.currentPattern = null;\r\n      this.currentBank = 0;\r\n      this.chopAssignments.clear();\r\n      return { success: true, pattern: null };\r\n    }\r\n\r\n    try {\r\n      // Validate and sanitize pattern using enhanced validator\r\n      const validationResult = samplerPatternValidator.validateAndSanitize(pattern, {\r\n        autoFix,\r\n        strict,\r\n        throwOnError\r\n      });\r\n\r\n      if (!validationResult.isValid) {\r\n        const errorMessage = `Pattern validation failed: ${validationResult.errors.join(', ')}`;\r\n        \r\n        if (throwOnError) {\r\n          throw new Error(errorMessage);\r\n        }\r\n        \r\n        console.error(errorMessage);\r\n        return {\r\n          success: false,\r\n          errors: validationResult.errors,\r\n          warnings: validationResult.warnings,\r\n          pattern: null\r\n        };\r\n      }\r\n\r\n      // Use sanitized pattern\r\n      this.currentPattern = validationResult.sanitizedPattern;\r\n      this.currentBank = this.currentPattern.currentBank || 0;\r\n      this.rebuildChopAssignments();\r\n\r\n      // Log fixes and warnings if any\r\n      if (validationResult.fixes.length > 0) {\r\n        console.log('Pattern fixes applied:', validationResult.fixes);\r\n      }\r\n      if (validationResult.warnings.length > 0) {\r\n        console.warn('Pattern validation warnings:', validationResult.warnings);\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        pattern: this.currentPattern,\r\n        fixes: validationResult.fixes,\r\n        warnings: validationResult.warnings\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('Failed to set current pattern:', error);\r\n      \r\n      if (throwOnError) {\r\n        throw error;\r\n      }\r\n      \r\n      return {\r\n        success: false,\r\n        errors: [error.message],\r\n        pattern: null\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rebuild chop assignments from pattern data\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  rebuildChopAssignments() {\r\n    this.chopAssignments.clear();\r\n    \r\n    if (!this.currentPattern) {\r\n      return;\r\n    }\r\n\r\n    this.currentPattern.banks.forEach(bank => {\r\n      bank.tracks.forEach((track, trackIndex) => {\r\n        if (track.chopId) {\r\n          this.chopAssignments.set(track.chopId, trackIndex);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Validate pattern data\r\n   * @param {Object} pattern - Pattern to validate\r\n   * @returns {boolean} Whether pattern is valid\r\n   */\r\n  validatePattern(pattern) {\r\n    if (!pattern || typeof pattern !== 'object') {\r\n      return false;\r\n    }\r\n\r\n    // Check required fields\r\n    if (!pattern.id || typeof pattern.id !== 'string') {\r\n      return false;\r\n    }\r\n\r\n    if (!pattern.name || typeof pattern.name !== 'string') {\r\n      return false;\r\n    }\r\n\r\n    if (typeof pattern.bpm !== 'number' || pattern.bpm < 60 || pattern.bpm > 200) {\r\n      return false;\r\n    }\r\n\r\n    if (typeof pattern.currentBank !== 'number' || pattern.currentBank < 0) {\r\n      return false;\r\n    }\r\n\r\n    // Validate banks\r\n    if (!Array.isArray(pattern.banks) || pattern.banks.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    // Validate each bank\r\n    for (const bank of pattern.banks) {\r\n      if (!this.validateBank(bank)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Validate bank data\r\n   * @private\r\n   * @param {Object} bank - Bank to validate\r\n   * @returns {boolean} Whether bank is valid\r\n   */\r\n  validateBank(bank) {\r\n    if (!bank || typeof bank !== 'object') {\r\n      return false;\r\n    }\r\n\r\n    if (typeof bank.bankId !== 'number' || bank.bankId < 0) {\r\n      return false;\r\n    }\r\n\r\n    if (!bank.name || typeof bank.name !== 'string') {\r\n      return false;\r\n    }\r\n\r\n    if (!Array.isArray(bank.tracks) || bank.tracks.length !== this.tracksPerBank) {\r\n      return false;\r\n    }\r\n\r\n    // Validate each track\r\n    for (const track of bank.tracks) {\r\n      if (!this.validateTrack(track)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Validate track data\r\n   * @private\r\n   * @param {Object} track - Track to validate\r\n   * @returns {boolean} Whether track is valid\r\n   */\r\n  validateTrack(track) {\r\n    if (!track || typeof track !== 'object') {\r\n      return false;\r\n    }\r\n\r\n    if (typeof track.trackIndex !== 'number' || track.trackIndex < 0) {\r\n      return false;\r\n    }\r\n\r\n    if (!Array.isArray(track.steps) || track.steps.length !== this.stepsPerTrack) {\r\n      return false;\r\n    }\r\n\r\n    // Validate each step\r\n    for (const step of track.steps) {\r\n      if (typeof step !== 'boolean') {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Generate a unique pattern ID\r\n   * @private\r\n   * @returns {string} Unique pattern ID\r\n   */\r\n  generatePatternId() {\r\n    return `sampler_pattern_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  /**\r\n   * Get pattern statistics\r\n   * @returns {Object} Pattern statistics\r\n   */\r\n  getPatternStats() {\r\n    if (!this.currentPattern) {\r\n      return {\r\n        totalSteps: 0,\r\n        activeSteps: 0,\r\n        assignedTracks: 0,\r\n        totalTracks: 0\r\n      };\r\n    }\r\n\r\n    let totalSteps = 0;\r\n    let activeSteps = 0;\r\n    let assignedTracks = 0;\r\n    let totalTracks = 0;\r\n\r\n    this.currentPattern.banks.forEach(bank => {\r\n      bank.tracks.forEach(track => {\r\n        totalTracks++;\r\n        totalSteps += track.steps.length;\r\n        \r\n        if (track.chopId) {\r\n          assignedTracks++;\r\n        }\r\n        \r\n        track.steps.forEach(step => {\r\n          if (step) {\r\n            activeSteps++;\r\n          }\r\n        });\r\n      });\r\n    });\r\n\r\n    return {\r\n      totalSteps,\r\n      activeSteps,\r\n      assignedTracks,\r\n      totalTracks\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clean up resources\r\n   * @returns {void}\r\n   */\r\n  destroy() {\r\n    this.currentPattern = null;\r\n    this.chopAssignments.clear();\r\n    this.currentBank = 0;\r\n    \r\n    console.log('SamplerPatternManager destroyed');\r\n  }\r\n}\r\n\r\nexport { SamplerPatternManager };","/**\r\n * @fileoverview YouTube Player Integration Interface\r\n * Provides a clean interface for sequencer to control YouTube video playback\r\n * Handles error recovery and provides fallback mechanisms\r\n */\r\n\r\n/**\r\n * Interface for YouTube player integration with sequencer\r\n * Provides error handling and graceful degradation\r\n */\r\nclass YouTubePlayerInterface {\r\n  constructor() {\r\n    /** @type {Object|null} */\r\n    this.youtubePlayer = null;\r\n    \r\n    /** @type {boolean} */\r\n    this.isConnected = false;\r\n    \r\n    /** @type {boolean} */\r\n    this.isDegraded = false;\r\n    \r\n    /** @type {string} */\r\n    this.degradationReason = null;\r\n    \r\n    /** @type {Array} */\r\n    this.errorLog = [];\r\n    \r\n    /** @type {number} */\r\n    this.lastSeekTime = 0;\r\n    \r\n    /** @type {boolean} */\r\n    this.isSeekInProgress = false;\r\n    \r\n    /** @type {Function[]} */\r\n    this.errorCallbacks = [];\r\n    \r\n    /** @type {Function[]} */\r\n    this.degradationCallbacks = [];\r\n    \r\n    /** @type {Object} */\r\n    this.stats = {\r\n      totalSeeks: 0,\r\n      successfulSeeks: 0,\r\n      failedSeeks: 0,\r\n      averageSeekLatency: 0,\r\n      degradationEvents: 0,\r\n      recoveryEvents: 0\r\n    };\r\n    \r\n    /** @type {Object} */\r\n    this.degradationConfig = {\r\n      maxConsecutiveFailures: 50, // Much more tolerant - only degrade after many failures\r\n      failureTimeWindow: 120000, // 2 minutes window\r\n      autoRecoveryInterval: 10000 // Try recovery every 10 seconds\r\n    };\r\n    \r\n    /** @type {Array} */\r\n    this.recentFailures = [];\r\n    \r\n    /** @type {number|null} */\r\n    this.autoRecoveryTimer = null;\r\n  }\r\n\r\n  /**\r\n   * Connect to YouTube player instance\r\n   * @param {Object} youtubePlayer - YouTube player instance\r\n   * @returns {boolean} Whether connection was successful\r\n   */\r\n  connect(youtubePlayer) {\r\n    if (!youtubePlayer) {\r\n      console.warn('No YouTube player provided - sequencer will work without video control');\r\n      return false;\r\n    }\r\n\r\n    // Validate player has required methods\r\n    const requiredMethods = ['seekTo', 'getCurrentTime', 'getPlayerState'];\r\n    const missingMethods = requiredMethods.filter(method => \r\n      typeof youtubePlayer[method] !== 'function'\r\n    );\r\n\r\n    if (missingMethods.length > 0) {\r\n      console.warn(`YouTube player missing required methods: ${missingMethods.join(', ')} - video control will be limited`);\r\n      // Still connect but with limited functionality\r\n    }\r\n\r\n    this.youtubePlayer = youtubePlayer;\r\n    this.isConnected = true;\r\n    \r\n    // Clear any existing degradation since we have a new connection\r\n    if (this.isDegraded) {\r\n      this.exitDegradedMode('New player connection established');\r\n    }\r\n    \r\n    console.log('YouTubePlayerInterface connected successfully');\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Disconnect from YouTube player\r\n   * @returns {void}\r\n   */\r\n  disconnect() {\r\n    this.youtubePlayer = null;\r\n    this.isConnected = false;\r\n    this.isSeekInProgress = false;\r\n    \r\n    console.log('YouTubePlayerInterface disconnected');\r\n  }\r\n\r\n  /**\r\n   * Jump to timestamp with error handling and graceful degradation\r\n   * @param {number} timestamp - Timestamp in seconds\r\n   * @param {boolean} allowSeek - Whether seeking is allowed (default: true)\r\n   * @param {boolean} maintainPlayback - Whether to maintain current playback state (default: true)\r\n   * @returns {Promise<boolean>} Whether seek was successful\r\n   */\r\n  async jumpToTimestamp(timestamp, allowSeek = true, maintainPlayback = true) {\r\n    // Handle degraded mode\r\n    if (this.isDegraded) {\r\n      console.log(`Seek skipped in degraded mode: ${timestamp}s (reason: ${this.degradationReason})`);\r\n      return false;\r\n    }\r\n\r\n    // Validate timestamp\r\n    if (typeof timestamp !== 'number' || isNaN(timestamp) || timestamp < 0) {\r\n      console.warn(`Invalid timestamp provided: ${timestamp}`);\r\n      return false;\r\n    }\r\n\r\n    if (!this.isConnected || !this.youtubePlayer) {\r\n      console.warn('YouTube player not connected, skipping seek');\r\n      return false;\r\n    }\r\n\r\n    if (!allowSeek) {\r\n      console.log('Seek operation skipped (not allowed)');\r\n      return true;\r\n    }\r\n\r\n    // For drum sequencer, allow rapid seeks by canceling previous seek\r\n    if (this.isSeekInProgress) {\r\n      // Don't block, just override the previous seek\r\n    }\r\n\r\n    const startTime = performance.now();\r\n    this.isSeekInProgress = true;\r\n    this.stats.totalSeeks++;\r\n\r\n    try {\r\n      // Check if player is in a valid state for seeking\r\n      const playerState = this.youtubePlayer.getPlayerState();\r\n      if (playerState === -1) { // Unstarted\r\n        this.handleSeekFailure('Cannot seek: player not ready');\r\n        return false;\r\n      }\r\n\r\n      // Store current playback state\r\n      const wasPlaying = playerState === 1; // YT.PlayerState.PLAYING\r\n      \r\n      // Perform the seek with allowSeekAhead parameter for better performance\r\n      this.youtubePlayer.seekTo(timestamp, true);\r\n      this.lastSeekTime = timestamp;\r\n      \r\n      // Handle playback state synchronization\r\n      if (maintainPlayback) {\r\n        // Reduced delay for drum sequencer performance (was 50ms)\r\n        await new Promise(resolve => setTimeout(resolve, 10));\r\n        \r\n        if (wasPlaying && this.youtubePlayer.getPlayerState() !== 1) {\r\n          // Resume playback if it was playing before seek\r\n          this.youtubePlayer.playVideo();\r\n        } else if (!wasPlaying && this.youtubePlayer.getPlayerState() === 1) {\r\n          // Pause if it wasn't playing before seek\r\n          this.youtubePlayer.pauseVideo();\r\n        }\r\n      }\r\n      \r\n      // Update stats and clear recent failures on success\r\n      const latency = performance.now() - startTime;\r\n      this.updateSeekLatency(latency);\r\n      this.stats.successfulSeeks++;\r\n      this.clearRecentFailures();\r\n      \r\n      return true;\r\n\r\n    } catch (error) {\r\n      this.handleSeekFailure(`Seek failed: ${error.message}`);\r\n      return false;\r\n    } finally {\r\n      this.isSeekInProgress = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Fast seek for drum sequencer chop triggering\r\n   * Optimized for rapid seeks without playback state management\r\n   * @param {number} timestamp - Timestamp to seek to\r\n   * @returns {boolean} Whether seek was initiated\r\n   */\r\n  fastSeekForChop(timestamp) {\r\n    // Validate timestamp\r\n    if (typeof timestamp !== 'number' || isNaN(timestamp) || timestamp < 0) {\r\n      return false;\r\n    }\r\n\r\n    if (!this.isConnected || !this.youtubePlayer) {\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      // Direct seek without state management for speed\r\n      this.youtubePlayer.seekTo(timestamp, true);\r\n      this.lastSeekTime = timestamp;\r\n      this.stats.totalSeeks++;\r\n      this.stats.successfulSeeks++;\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      // Don't handle the error here, let the service try fallback methods\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle seek failure with degradation logic\r\n   * @private\r\n   * @param {string} errorMessage - Error message\r\n   */\r\n  handleSeekFailure(errorMessage) {\r\n    this.logError(errorMessage);\r\n    this.stats.failedSeeks++;\r\n    \r\n    // Track recent failures for degradation decision\r\n    this.recentFailures.push({\r\n      timestamp: Date.now(),\r\n      error: errorMessage\r\n    });\r\n    \r\n    // Clean old failures outside the time window\r\n    const now = Date.now();\r\n    this.recentFailures = this.recentFailures.filter(\r\n      failure => now - failure.timestamp < this.degradationConfig.failureTimeWindow\r\n    );\r\n    \r\n    // Check if we should enter degraded mode\r\n    if (this.recentFailures.length >= this.degradationConfig.maxConsecutiveFailures) {\r\n      this.enterDegradedMode('Too many consecutive seek failures');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enter degraded mode with automatic recovery\r\n   * @param {string} reason - Reason for degradation\r\n   */\r\n  enterDegradedMode(reason) {\r\n    if (this.isDegraded) {\r\n      return; // Already in degraded mode\r\n    }\r\n    \r\n    console.warn(`Entering degraded mode: ${reason}`);\r\n    \r\n    this.isDegraded = true;\r\n    this.degradationReason = reason;\r\n    this.stats.degradationEvents++;\r\n    \r\n    // Notify degradation callbacks\r\n    this.degradationCallbacks.forEach(callback => {\r\n      try {\r\n        callback({\r\n          type: 'degradation',\r\n          reason,\r\n          timestamp: Date.now()\r\n        });\r\n      } catch (error) {\r\n        console.error('Error in degradation callback:', error);\r\n      }\r\n    });\r\n    \r\n    // Set up automatic recovery attempt\r\n    this.scheduleAutoRecovery();\r\n  }\r\n\r\n  /**\r\n   * Exit degraded mode\r\n   * @param {string} reason - Reason for recovery\r\n   */\r\n  exitDegradedMode(reason = 'Manual recovery') {\r\n    if (!this.isDegraded) {\r\n      return; // Not in degraded mode\r\n    }\r\n    \r\n    console.log(`Exiting degraded mode: ${reason}`);\r\n    \r\n    this.isDegraded = false;\r\n    this.degradationReason = null;\r\n    this.stats.recoveryEvents++;\r\n    this.clearRecentFailures();\r\n    \r\n    // Clear auto-recovery timer\r\n    if (this.autoRecoveryTimer) {\r\n      clearTimeout(this.autoRecoveryTimer);\r\n      this.autoRecoveryTimer = null;\r\n    }\r\n    \r\n    // Notify degradation callbacks\r\n    this.degradationCallbacks.forEach(callback => {\r\n      try {\r\n        callback({\r\n          type: 'recovery',\r\n          reason,\r\n          timestamp: Date.now()\r\n        });\r\n      } catch (error) {\r\n        console.error('Error in degradation callback:', error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Schedule automatic recovery attempt\r\n   * @private\r\n   */\r\n  scheduleAutoRecovery() {\r\n    if (this.autoRecoveryTimer) {\r\n      clearTimeout(this.autoRecoveryTimer);\r\n    }\r\n    \r\n    this.autoRecoveryTimer = setTimeout(async () => {\r\n      console.log('Attempting automatic recovery from degraded mode...');\r\n      \r\n      const recovered = await this.attemptRecovery();\r\n      if (recovered) {\r\n        this.exitDegradedMode('Automatic recovery successful');\r\n      } else {\r\n        console.log('Automatic recovery failed, remaining in degraded mode');\r\n        // Schedule another recovery attempt\r\n        this.scheduleAutoRecovery();\r\n      }\r\n    }, this.degradationConfig.autoRecoveryInterval);\r\n  }\r\n\r\n  /**\r\n   * Clear recent failures\r\n   * @private\r\n   */\r\n  clearRecentFailures() {\r\n    this.recentFailures = [];\r\n  }\r\n\r\n  /**\r\n   * Get current playback time\r\n   * @returns {number} Current time in seconds, or 0 if unavailable\r\n   */\r\n  getCurrentTime() {\r\n    if (!this.isConnected || !this.youtubePlayer) {\r\n      return 0;\r\n    }\r\n\r\n    try {\r\n      return this.youtubePlayer.getCurrentTime() || 0;\r\n    } catch (error) {\r\n      this.logError(`Failed to get current time: ${error.message}`);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get player state\r\n   * @returns {number} Player state, or -1 if unavailable\r\n   */\r\n  getPlayerState() {\r\n    if (!this.isConnected || !this.youtubePlayer) {\r\n      return -1;\r\n    }\r\n\r\n    try {\r\n      return this.youtubePlayer.getPlayerState();\r\n    } catch (error) {\r\n      this.logError(`Failed to get player state: ${error.message}`);\r\n      return -1;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get detailed player state information\r\n   * @returns {Object} Detailed player state\r\n   */\r\n  getDetailedPlayerState() {\r\n    if (!this.isConnected || !this.youtubePlayer) {\r\n      return {\r\n        state: -1,\r\n        currentTime: 0,\r\n        duration: 0,\r\n        isPlaying: false,\r\n        isPaused: false,\r\n        isBuffering: false,\r\n        isReady: false\r\n      };\r\n    }\r\n\r\n    try {\r\n      const state = this.youtubePlayer.getPlayerState();\r\n      const currentTime = this.youtubePlayer.getCurrentTime() || 0;\r\n      const duration = this.youtubePlayer.getDuration() || 0;\r\n\r\n      return {\r\n        state,\r\n        currentTime,\r\n        duration,\r\n        isPlaying: state === 1, // YT.PlayerState.PLAYING\r\n        isPaused: state === 2,  // YT.PlayerState.PAUSED\r\n        isBuffering: state === 3, // YT.PlayerState.BUFFERING\r\n        isReady: state !== -1,   // Not unstarted\r\n        isEnded: state === 0     // YT.PlayerState.ENDED\r\n      };\r\n    } catch (error) {\r\n      this.logError(`Failed to get detailed player state: ${error.message}`);\r\n      return {\r\n        state: -1,\r\n        currentTime: 0,\r\n        duration: 0,\r\n        isPlaying: false,\r\n        isPaused: false,\r\n        isBuffering: false,\r\n        isReady: false,\r\n        isEnded: false\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Synchronize player state with external state\r\n   * @param {Object} targetState - Target state to synchronize to\r\n   * @param {boolean} targetState.isPlaying - Target playing state\r\n   * @param {number} targetState.currentTime - Target time position\r\n   * @returns {Promise<boolean>} Whether synchronization was successful\r\n   */\r\n  async synchronizeState(targetState) {\r\n    if (!this.isConnected || !this.youtubePlayer) {\r\n      this.logError('Cannot synchronize: YouTube player not connected');\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const currentState = this.getDetailedPlayerState();\r\n      let syncSuccess = true;\r\n\r\n      // Synchronize time position if specified and different\r\n      if (typeof targetState.currentTime === 'number') {\r\n        const timeDifference = Math.abs(currentState.currentTime - targetState.currentTime);\r\n        \r\n        // Only seek if time difference is significant (>0.5 seconds)\r\n        if (timeDifference > 0.5) {\r\n          const seekSuccess = await this.jumpToTimestamp(\r\n            targetState.currentTime, \r\n            true, \r\n            targetState.isPlaying !== undefined ? targetState.isPlaying : currentState.isPlaying\r\n          );\r\n          if (!seekSuccess) {\r\n            syncSuccess = false;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Synchronize playback state if specified\r\n      if (typeof targetState.isPlaying === 'boolean') {\r\n        // Small delay to allow any seek operation to complete\r\n        await new Promise(resolve => setTimeout(resolve, 100));\r\n        \r\n        const updatedState = this.getDetailedPlayerState();\r\n        \r\n        if (targetState.isPlaying && !updatedState.isPlaying) {\r\n          this.youtubePlayer.playVideo();\r\n          console.log('Synchronized player to playing state');\r\n        } else if (!targetState.isPlaying && updatedState.isPlaying) {\r\n          this.youtubePlayer.pauseVideo();\r\n          console.log('Synchronized player to paused state');\r\n        }\r\n      }\r\n\r\n      return syncSuccess;\r\n    } catch (error) {\r\n      this.logError(`State synchronization failed: ${error.message}`);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if player is ready for operations\r\n   * @returns {boolean} Whether player is ready\r\n   */\r\n  isPlayerReady() {\r\n    if (!this.isConnected || !this.youtubePlayer) {\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const state = this.youtubePlayer.getPlayerState();\r\n      return state !== -1; // Not unstarted\r\n    } catch (error) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get connection status\r\n   * @returns {Object} Connection status information\r\n   */\r\n  getStatus() {\r\n    return {\r\n      isConnected: this.isConnected,\r\n      isPlayerReady: this.isPlayerReady(),\r\n      isSeekInProgress: this.isSeekInProgress,\r\n      isDegraded: this.isDegraded,\r\n      degradationReason: this.degradationReason,\r\n      lastSeekTime: this.lastSeekTime,\r\n      errorCount: this.errorLog.length,\r\n      recentFailures: this.recentFailures.length,\r\n      stats: { ...this.stats }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get recent errors\r\n   * @param {number} limit - Maximum number of errors to return\r\n   * @returns {Array} Recent error entries\r\n   */\r\n  getRecentErrors(limit = 10) {\r\n    return this.errorLog.slice(-limit);\r\n  }\r\n\r\n  /**\r\n   * Clear error log\r\n   * @returns {void}\r\n   */\r\n  clearErrors() {\r\n    this.errorLog = [];\r\n  }\r\n\r\n  /**\r\n   * Add error callback\r\n   * @param {Function} callback - Error callback function\r\n   */\r\n  onError(callback) {\r\n    if (typeof callback === 'function') {\r\n      this.errorCallbacks.push(callback);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove error callback\r\n   * @param {Function} callback - Callback to remove\r\n   */\r\n  removeErrorCallback(callback) {\r\n    const index = this.errorCallbacks.indexOf(callback);\r\n    if (index > -1) {\r\n      this.errorCallbacks.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Force exit from degraded mode (manual recovery)\r\n   * @returns {boolean} Whether recovery was successful\r\n   */\r\n  forceRecovery() {\r\n    if (!this.isDegraded) {\r\n      console.log('Not in degraded mode, no recovery needed');\r\n      return true;\r\n    }\r\n\r\n    console.log('Forcing recovery from degraded mode...');\r\n    \r\n    // Clear failure history\r\n    this.clearRecentFailures();\r\n    \r\n    // Test basic player functionality\r\n    if (this.youtubePlayer && typeof this.youtubePlayer.getCurrentTime === 'function') {\r\n      try {\r\n        // Try a simple operation to test if player is working\r\n        this.youtubePlayer.getCurrentTime();\r\n        this.exitDegradedMode('Manual recovery - player test successful');\r\n        return true;\r\n      } catch (error) {\r\n        console.warn('Player test failed during recovery:', error);\r\n        // Still exit degraded mode for sequencer functionality\r\n        this.exitDegradedMode('Manual recovery - forced exit despite test failure');\r\n        return true;\r\n      }\r\n    }\r\n    \r\n    // Exit degraded mode even if we can't test the player\r\n    this.exitDegradedMode('Manual recovery - forced exit');\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Force exit from degraded mode for sequencer use\r\n   * @returns {void}\r\n   */\r\n  forceExitDegradedMode() {\r\n    if (this.isDegraded) {\r\n      console.log('🔄 Force exiting degraded mode for sequencer use');\r\n      this.clearRecentFailures();\r\n      this.exitDegradedMode('Forced exit for sequencer playback');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add degradation callback\r\n   * @param {Function} callback - Degradation callback function\r\n   */\r\n  onDegradation(callback) {\r\n    if (typeof callback === 'function') {\r\n      this.degradationCallbacks.push(callback);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove degradation callback\r\n   * @param {Function} callback - Callback to remove\r\n   */\r\n  removeDegradationCallback(callback) {\r\n    const index = this.degradationCallbacks.indexOf(callback);\r\n    if (index > -1) {\r\n      this.degradationCallbacks.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Force exit from degraded mode\r\n   * @returns {Promise<boolean>} Whether recovery was successful\r\n   */\r\n  async forceRecovery() {\r\n    console.log('Forcing recovery from degraded mode...');\r\n    \r\n    const recovered = await this.attemptRecovery();\r\n    if (recovered) {\r\n      this.exitDegradedMode('Forced recovery');\r\n      return true;\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Test connection with player\r\n   * @returns {Promise<boolean>} Whether connection test passed\r\n   */\r\n  async testConnection() {\r\n    if (!this.isConnected || !this.youtubePlayer) {\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      // Test basic operations\r\n      const currentTime = this.getCurrentTime();\r\n      const playerState = this.getPlayerState();\r\n      \r\n      console.log(`Connection test: time=${currentTime}, state=${playerState}`);\r\n      return true;\r\n    } catch (error) {\r\n      this.logError(`Connection test failed: ${error.message}`);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attempt to recover from connection errors\r\n   * @returns {Promise<boolean>} Whether recovery was successful\r\n   */\r\n  async attemptRecovery() {\r\n    if (!this.youtubePlayer) {\r\n      this.logError('Cannot recover: no YouTube player instance');\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      console.log('Attempting YouTube player recovery...');\r\n      \r\n      // Reset connection state\r\n      this.isSeekInProgress = false;\r\n      \r\n      // Test if player is responsive\r\n      const testPassed = await this.testConnection();\r\n      \r\n      if (testPassed) {\r\n        console.log('YouTube player recovery successful');\r\n        return true;\r\n      } else {\r\n        this.logError('YouTube player recovery failed: connection test failed');\r\n        return false;\r\n      }\r\n    } catch (error) {\r\n      this.logError(`Recovery attempt failed: ${error.message}`);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle player errors with automatic recovery\r\n   * @param {Error} error - Error that occurred\r\n   * @returns {Promise<boolean>} Whether error was handled successfully\r\n   */\r\n  async handlePlayerError(error) {\r\n    this.logError(`Player error occurred: ${error.message}`);\r\n    \r\n    const errorType = this.classifyPlayerError(error);\r\n    \r\n    // Attempt automatic recovery based on error type\r\n    switch (errorType) {\r\n      case 'seek_error':\r\n      case 'state_error':\r\n      case 'timing_error':\r\n        console.log('Attempting automatic recovery for recoverable player error...');\r\n        return await this.attemptRecovery();\r\n        \r\n      case 'network_error':\r\n        console.log('Network error detected, attempting connection recovery...');\r\n        return await this.attemptNetworkRecovery();\r\n        \r\n      case 'permission_error':\r\n      case 'unavailable_error':\r\n        console.log('Permanent error detected, no recovery possible');\r\n        return false;\r\n        \r\n      default:\r\n        console.log('Unknown error type, attempting general recovery...');\r\n        return await this.attemptRecovery();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Classify player error for appropriate handling\r\n   * @param {Error} error - Error to classify\r\n   * @returns {string} Error type classification\r\n   */\r\n  classifyPlayerError(error) {\r\n    const message = error.message.toLowerCase();\r\n    \r\n    if (message.includes('seek') || message.includes('timestamp')) {\r\n      return 'seek_error';\r\n    }\r\n    if (message.includes('state') || message.includes('player state')) {\r\n      return 'state_error';\r\n    }\r\n    if (message.includes('timing') || message.includes('sync')) {\r\n      return 'timing_error';\r\n    }\r\n    if (message.includes('network') || message.includes('connection') || message.includes('timeout')) {\r\n      return 'network_error';\r\n    }\r\n    if (message.includes('permission') || message.includes('forbidden') || message.includes('unauthorized')) {\r\n      return 'permission_error';\r\n    }\r\n    if (message.includes('unavailable') || message.includes('private') || message.includes('deleted')) {\r\n      return 'unavailable_error';\r\n    }\r\n    \r\n    return 'unknown_error';\r\n  }\r\n\r\n  /**\r\n   * Attempt network-specific recovery\r\n   * @returns {Promise<boolean>} Whether network recovery was successful\r\n   */\r\n  async attemptNetworkRecovery() {\r\n    try {\r\n      console.log('Attempting network recovery...');\r\n      \r\n      // Wait for potential network recovery\r\n      await new Promise(resolve => setTimeout(resolve, 2000));\r\n      \r\n      // Test basic connectivity\r\n      if (!navigator.onLine) {\r\n        this.logError('Device is offline, cannot recover network connection');\r\n        return false;\r\n      }\r\n      \r\n      // Test player responsiveness\r\n      const testPassed = await this.testConnection();\r\n      \r\n      if (testPassed) {\r\n        console.log('Network recovery successful');\r\n        return true;\r\n      } else {\r\n        this.logError('Network recovery failed: player still unresponsive');\r\n        return false;\r\n      }\r\n    } catch (error) {\r\n      this.logError(`Network recovery attempt failed: ${error.message}`);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get error recovery suggestions based on error type\r\n   * @param {string} errorMessage - Error message\r\n   * @returns {Object} Recovery suggestions\r\n   */\r\n  getErrorRecoverySuggestions(errorMessage) {\r\n    const suggestions = {\r\n      userAction: 'Try refreshing the page',\r\n      technicalAction: 'Reconnect YouTube player',\r\n      canRetry: true\r\n    };\r\n\r\n    if (errorMessage.includes('not connected') || errorMessage.includes('not ready')) {\r\n      suggestions.userAction = 'Wait for video to load completely';\r\n      suggestions.technicalAction = 'Reinitialize player connection';\r\n    } else if (errorMessage.includes('seek') || errorMessage.includes('timestamp')) {\r\n      suggestions.userAction = 'Try playing the video first';\r\n      suggestions.technicalAction = 'Verify video is seekable';\r\n    } else if (errorMessage.includes('state')) {\r\n      suggestions.userAction = 'Check if video is still available';\r\n      suggestions.technicalAction = 'Refresh player state';\r\n    } else if (errorMessage.includes('network') || errorMessage.includes('timeout')) {\r\n      suggestions.userAction = 'Check your internet connection';\r\n      suggestions.technicalAction = 'Retry with network recovery';\r\n      suggestions.canRetry = true;\r\n    }\r\n\r\n    return suggestions;\r\n  }\r\n\r\n  /**\r\n   * Get performance statistics\r\n   * @returns {Object} Performance statistics\r\n   */\r\n  getPerformanceStats() {\r\n    const successRate = this.stats.totalSeeks > 0 \r\n      ? (this.stats.successfulSeeks / this.stats.totalSeeks) * 100 \r\n      : 0;\r\n\r\n    return {\r\n      ...this.stats,\r\n      successRate: successRate.toFixed(2),\r\n      errorRate: (100 - successRate).toFixed(2)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Reset statistics\r\n   * @returns {void}\r\n   */\r\n  resetStats() {\r\n    this.stats = {\r\n      totalSeeks: 0,\r\n      successfulSeeks: 0,\r\n      failedSeeks: 0,\r\n      averageSeekLatency: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Log error with timestamp\r\n   * @private\r\n   * @param {string} message - Error message\r\n   */\r\n  logError(message) {\r\n    const errorEntry = {\r\n      timestamp: new Date().toISOString(),\r\n      message: message\r\n    };\r\n\r\n    this.errorLog.push(errorEntry);\r\n    \r\n    // Keep only last 50 errors\r\n    if (this.errorLog.length > 50) {\r\n      this.errorLog = this.errorLog.slice(-50);\r\n    }\r\n\r\n    console.error(`YouTubePlayerInterface: ${message}`);\r\n\r\n    // Notify error callbacks\r\n    this.errorCallbacks.forEach(callback => {\r\n      try {\r\n        callback(errorEntry);\r\n      } catch (error) {\r\n        console.error('Error in error callback:', error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update seek latency statistics\r\n   * @private\r\n   * @param {number} latency - Seek latency in milliseconds\r\n   */\r\n  updateSeekLatency(latency) {\r\n    const total = this.stats.averageSeekLatency * (this.stats.successfulSeeks - 1);\r\n    this.stats.averageSeekLatency = (total + latency) / this.stats.successfulSeeks;\r\n  }\r\n\r\n  /**\r\n   * Clean up resources\r\n   * @returns {void}\r\n   */\r\n  destroy() {\r\n    // Clear auto-recovery timer\r\n    if (this.autoRecoveryTimer) {\r\n      clearTimeout(this.autoRecoveryTimer);\r\n      this.autoRecoveryTimer = null;\r\n    }\r\n    \r\n    this.disconnect();\r\n    this.errorCallbacks = [];\r\n    this.degradationCallbacks = [];\r\n    this.errorLog = [];\r\n    this.recentFailures = [];\r\n    this.resetStats();\r\n    \r\n    this.isDegraded = false;\r\n    this.degradationReason = null;\r\n    \r\n    console.log('YouTubePlayerInterface destroyed');\r\n  }\r\n}\r\n\r\nexport { YouTubePlayerInterface };","/**\r\n * @fileoverview Sampler Chop Integration Service\r\n * Handles integration between chopper functionality and sampler sequencer\r\n * Manages automatic chop assignment and updates\r\n */\r\n\r\n/**\r\n * Manages integration between chops and sampler sequencer\r\n */\r\nclass SamplerChopIntegration {\r\n  constructor(patternManager) {\r\n    /** @type {SamplerPatternManager} */\r\n    this.patternManager = patternManager;\r\n    \r\n    /** @type {Array} */\r\n    this.currentChops = [];\r\n    \r\n    /** @type {Map} */\r\n    this.chopListeners = new Map();\r\n    \r\n    /** @type {Function|null} */\r\n    this.onChopAssignmentChange = null;\r\n  }\r\n\r\n  /**\r\n   * Set callback for chop assignment changes\r\n   * @param {Function} callback - Callback function\r\n   * @returns {void}\r\n   */\r\n  setChopAssignmentChangeCallback(callback) {\r\n    this.onChopAssignmentChange = callback;\r\n  }\r\n\r\n  /**\r\n   * Update chops and handle automatic assignment\r\n   * @param {Array} chops - Array of chop objects\r\n   * @returns {void}\r\n   */\r\n  updateChops(chops) {\r\n    if (!Array.isArray(chops)) {\r\n      console.warn('Invalid chops data provided to updateChops');\r\n      return;\r\n    }\r\n\r\n    const previousChops = [...this.currentChops];\r\n    this.currentChops = [...chops];\r\n\r\n    // Detect changes\r\n    const changes = this.detectChopChanges(previousChops, chops);\r\n    \r\n    if (changes.added.length > 0) {\r\n      this.handleNewChops(changes.added);\r\n    }\r\n    \r\n    if (changes.removed.length > 0) {\r\n      this.handleRemovedChops(changes.removed);\r\n    }\r\n    \r\n    if (changes.modified.length > 0) {\r\n      this.handleModifiedChops(changes.modified);\r\n    }\r\n\r\n    // If this is the first time we're getting chops, auto-assign them all\r\n    if (previousChops.length === 0 && chops.length > 0) {\r\n      this.patternManager.autoAssignChops(this.currentChops);\r\n    }\r\n\r\n    // Always notify listeners of potential changes\r\n    this.notifyChopAssignmentChange();\r\n  }\r\n\r\n  /**\r\n   * Detect changes between previous and current chops\r\n   * @private\r\n   * @param {Array} previousChops - Previous chops array\r\n   * @param {Array} currentChops - Current chops array\r\n   * @returns {Object} Changes object with added, removed, and modified arrays\r\n   */\r\n  detectChopChanges(previousChops, currentChops) {\r\n    const changes = {\r\n      added: [],\r\n      removed: [],\r\n      modified: []\r\n    };\r\n\r\n    // Create maps for efficient lookup\r\n    const previousMap = new Map(previousChops.map(chop => [chop.padId, chop]));\r\n    const currentMap = new Map(currentChops.map(chop => [chop.padId, chop]));\r\n\r\n    // Find added chops\r\n    for (const chop of currentChops) {\r\n      if (!previousMap.has(chop.padId)) {\r\n        changes.added.push(chop);\r\n      }\r\n    }\r\n\r\n    // Find removed chops\r\n    for (const chop of previousChops) {\r\n      if (!currentMap.has(chop.padId)) {\r\n        changes.removed.push(chop);\r\n      }\r\n    }\r\n\r\n    // Find modified chops (timestamp changes)\r\n    for (const chop of currentChops) {\r\n      const previousChop = previousMap.get(chop.padId);\r\n      if (previousChop && this.hasChopChanged(previousChop, chop)) {\r\n        changes.modified.push({\r\n          previous: previousChop,\r\n          current: chop\r\n        });\r\n      }\r\n    }\r\n\r\n    return changes;\r\n  }\r\n\r\n  /**\r\n   * Check if chop has changed (timestamps or other properties)\r\n   * @private\r\n   * @param {Object} previousChop - Previous chop\r\n   * @param {Object} currentChop - Current chop\r\n   * @returns {boolean} Whether chop has changed\r\n   */\r\n  hasChopChanged(previousChop, currentChop) {\r\n    return (\r\n      previousChop.startTime !== currentChop.startTime ||\r\n      previousChop.endTime !== currentChop.endTime ||\r\n      previousChop.color !== currentChop.color\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Handle new chops - auto-assign to next available tracks\r\n   * @private\r\n   * @param {Array} newChops - Array of new chops\r\n   * @returns {void}\r\n   */\r\n  handleNewChops(newChops) {\r\n    if (!this.patternManager.getCurrentPattern()) {\r\n      console.warn('No pattern loaded, cannot assign new chops');\r\n      return;\r\n    }\r\n\r\n    console.log(`🎯 Handling ${newChops.length} new chops - auto-assigning to tracks`);\r\n\r\n    // Use the pattern manager's auto-assignment for immediate assignment\r\n    this.patternManager.autoAssignChops(this.currentChops);\r\n    \r\n    console.log('✅ Auto-assignment complete');\r\n  }\r\n\r\n  /**\r\n   * Handle removed chops - clear track assignments\r\n   * @private\r\n   * @param {Array} removedChops - Array of removed chops\r\n   * @returns {void}\r\n   */\r\n  handleRemovedChops(removedChops) {\r\n    if (!this.patternManager.getCurrentPattern()) {\r\n      return;\r\n    }\r\n\r\n    console.log(`Handling ${removedChops.length} removed chops`);\r\n\r\n    removedChops.forEach(chop => {\r\n      // Find and clear the track assignment across all banks\r\n      const pattern = this.patternManager.getCurrentPattern();\r\n      \r\n      pattern.banks.forEach((bank, bankIndex) => {\r\n        bank.tracks.forEach((track, trackIndex) => {\r\n          if (track.chopId === chop.padId) {\r\n            // Switch to the bank temporarily to clear the assignment\r\n            const originalBank = this.patternManager.currentBank;\r\n            this.patternManager.switchBank(bankIndex);\r\n            this.patternManager.assignChopToTrack(null, trackIndex);\r\n            this.patternManager.switchBank(originalBank);\r\n            \r\n            console.log(`Cleared chop assignment for track ${trackIndex} in bank ${bankIndex} (chop ${chop.padId})`);\r\n          }\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle modified chops - update existing assignments\r\n   * @private\r\n   * @param {Array} modifiedChops - Array of modified chop objects\r\n   * @returns {void}\r\n   */\r\n  handleModifiedChops(modifiedChops) {\r\n    console.log(`Handling ${modifiedChops.length} modified chops`);\r\n\r\n    // For modified chops, we don't need to change track assignments\r\n    // The sequencer will automatically use the updated timestamps\r\n    // Just log the changes for debugging\r\n    modifiedChops.forEach(({ previous, current }) => {\r\n      console.log(`Chop ${current.padId} modified:`, {\r\n        startTime: `${previous.startTime} -> ${current.startTime}`,\r\n        endTime: `${previous.endTime} -> ${current.endTime}`\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Group chops by bank letter\r\n   * @private\r\n   * @param {Array} chops - Array of chops\r\n   * @returns {Object} Chops grouped by bank letter\r\n   */\r\n  groupChopsByBank(chops) {\r\n    const grouped = {};\r\n    \r\n    chops.forEach(chop => {\r\n      // Skip invalid chops\r\n      if (!chop || typeof chop !== 'object' || !chop.padId || typeof chop.padId !== 'string') {\r\n        return;\r\n      }\r\n      \r\n      const bankLetter = chop.padId.charAt(0).toUpperCase();\r\n      if (!grouped[bankLetter]) {\r\n        grouped[bankLetter] = [];\r\n      }\r\n      grouped[bankLetter].push(chop);\r\n    });\r\n\r\n    // Sort chops within each bank by pad number\r\n    Object.keys(grouped).forEach(bankLetter => {\r\n      grouped[bankLetter].sort((a, b) => {\r\n        const aNum = parseInt(a.padId.slice(1)) || 0;\r\n        const bNum = parseInt(b.padId.slice(1)) || 0;\r\n        return aNum - bNum;\r\n      });\r\n    });\r\n\r\n    return grouped;\r\n  }\r\n\r\n  /**\r\n   * Assign chops to tracks in a specific bank\r\n   * @private\r\n   * @param {Array} chops - Chops to assign\r\n   * @param {number} bankIndex - Bank index\r\n   * @returns {void}\r\n   */\r\n  assignChopsToBank(chops, bankIndex) {\r\n    const pattern = this.patternManager.getCurrentPattern();\r\n    \r\n    if (!pattern || !pattern.banks[bankIndex]) {\r\n      console.warn(`Bank ${bankIndex} not found in current pattern`);\r\n      return;\r\n    }\r\n\r\n    const bank = pattern.banks[bankIndex];\r\n    console.log(`🎯 Assigning ${chops.length} chops to bank ${bankIndex}:`, chops.map(c => c.padId));\r\n    \r\n    chops.forEach((chop, index) => {\r\n      if (index < bank.tracks.length) {\r\n        // Find next available track or use the track corresponding to the chop number\r\n        const chopNumber = parseInt(chop.padId.slice(1)) || 0;\r\n        const targetTrackIndex = Math.min(chopNumber, bank.tracks.length - 1);\r\n        \r\n        console.log(`🔍 Assigning chop ${chop.padId} (number ${chopNumber}) to target track ${targetTrackIndex}`);\r\n        \r\n        // Switch to the target bank before assignment\r\n        const originalBank = this.patternManager.currentBank;\r\n        this.patternManager.switchBank(bankIndex);\r\n        \r\n        // Check if target track is available\r\n        if (!bank.tracks[targetTrackIndex].chopId) {\r\n          this.patternManager.assignChopToTrack(chop.padId, targetTrackIndex);\r\n          console.log(`✅ Assigned chop ${chop.padId} to track ${targetTrackIndex} in bank ${bankIndex}`);\r\n        } else {\r\n          // Find next available track\r\n          const availableTrackIndex = this.findNextAvailableTrack(bank);\r\n          if (availableTrackIndex !== -1) {\r\n            this.patternManager.assignChopToTrack(chop.padId, availableTrackIndex);\r\n            console.log(`✅ Assigned chop ${chop.padId} to available track ${availableTrackIndex} in bank ${bankIndex}`);\r\n          } else {\r\n            console.warn(`❌ No available tracks in bank ${bankIndex} for chop ${chop.padId}`);\r\n          }\r\n        }\r\n        \r\n        // Switch back to original bank\r\n        this.patternManager.switchBank(originalBank);\r\n      }\r\n    });\r\n    \r\n    // Debug: Show final assignments\r\n    console.log(`📊 Final track assignments for bank ${bankIndex}:`, \r\n      bank.tracks.map((track, i) => ({ track: i, chopId: track.chopId })).filter(t => t.chopId)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Find next available track in a bank\r\n   * @private\r\n   * @param {Object} bank - Bank object\r\n   * @returns {number} Track index or -1 if none available\r\n   */\r\n  findNextAvailableTrack(bank) {\r\n    for (let i = 0; i < bank.tracks.length; i++) {\r\n      if (!bank.tracks[i].chopId) {\r\n        return i;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Get chop data for a specific track\r\n   * @param {number} trackIndex - Track index\r\n   * @returns {Object|null} Chop data or null\r\n   */\r\n  getChopForTrack(trackIndex) {\r\n    const chopId = this.patternManager.getChopForTrack(trackIndex);\r\n    \r\n    if (!chopId) {\r\n      return null;\r\n    }\r\n\r\n    return this.currentChops.find(chop => chop.padId === chopId) || null;\r\n  }\r\n\r\n  /**\r\n   * Get all chops for current bank\r\n   * @returns {Array} Array of chops for current bank\r\n   */\r\n  getChopsForCurrentBank() {\r\n    const pattern = this.patternManager.getCurrentPattern();\r\n    \r\n    if (!pattern) {\r\n      return [];\r\n    }\r\n\r\n    const currentBankData = this.patternManager.getCurrentBankData();\r\n    \r\n    if (!currentBankData) {\r\n      return [];\r\n    }\r\n\r\n    const chops = [];\r\n    \r\n    currentBankData.tracks.forEach(track => {\r\n      if (track.chopId) {\r\n        const chop = this.currentChops.find(c => c.padId === track.chopId);\r\n        if (chop) {\r\n          chops.push(chop);\r\n        }\r\n      }\r\n    });\r\n\r\n    return chops;\r\n  }\r\n\r\n  /**\r\n   * Get chop assignments for current bank\r\n   * @returns {Array} Array of track assignments\r\n   */\r\n  getCurrentBankAssignments() {\r\n    const currentBankData = this.patternManager.getCurrentBankData();\r\n    \r\n    if (!currentBankData) {\r\n      return [];\r\n    }\r\n\r\n    return currentBankData.tracks.map((track, index) => ({\r\n      trackIndex: index,\r\n      chopId: track.chopId,\r\n      chop: track.chopId ? this.currentChops.find(c => c.padId === track.chopId) : null\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Force reassignment of all chops\r\n   * @returns {void}\r\n   */\r\n  reassignAllChops() {\r\n    if (!this.patternManager.getCurrentPattern()) {\r\n      console.warn('No pattern loaded, cannot reassign chops');\r\n      return;\r\n    }\r\n\r\n    console.log('Force reassigning all chops');\r\n    \r\n    // Clear all existing assignments\r\n    this.clearAllAssignments();\r\n    \r\n    // Reassign all current chops\r\n    this.patternManager.autoAssignChops(this.currentChops);\r\n    \r\n    // Notify listeners\r\n    this.notifyChopAssignmentChange();\r\n  }\r\n\r\n  /**\r\n   * Clear all chop assignments\r\n   * @returns {void}\r\n   */\r\n  clearAllAssignments() {\r\n    const pattern = this.patternManager.getCurrentPattern();\r\n    \r\n    if (!pattern) {\r\n      return;\r\n    }\r\n\r\n    pattern.banks.forEach(bank => {\r\n      bank.tracks.forEach((track, trackIndex) => {\r\n        if (track.chopId) {\r\n          this.patternManager.assignChopToTrack(null, trackIndex);\r\n        }\r\n      });\r\n    });\r\n\r\n    console.log('Cleared all chop assignments');\r\n  }\r\n\r\n  /**\r\n   * Notify listeners of chop assignment changes\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  notifyChopAssignmentChange() {\r\n    if (this.onChopAssignmentChange) {\r\n      const assignments = this.getCurrentBankAssignments();\r\n      this.onChopAssignmentChange(assignments);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get integration statistics\r\n   * @returns {Object} Integration statistics\r\n   */\r\n  getIntegrationStats() {\r\n    const pattern = this.patternManager.getCurrentPattern();\r\n    \r\n    if (!pattern) {\r\n      return {\r\n        totalChops: this.currentChops.length,\r\n        assignedChops: 0,\r\n        unassignedChops: this.currentChops.length,\r\n        totalTracks: 0,\r\n        assignedTracks: 0\r\n      };\r\n    }\r\n\r\n    let totalTracks = 0;\r\n    let assignedTracks = 0;\r\n    const assignedChopIds = new Set();\r\n\r\n    pattern.banks.forEach(bank => {\r\n      bank.tracks.forEach(track => {\r\n        totalTracks++;\r\n        if (track.chopId) {\r\n          assignedTracks++;\r\n          assignedChopIds.add(track.chopId);\r\n        }\r\n      });\r\n    });\r\n\r\n    return {\r\n      totalChops: this.currentChops.length,\r\n      assignedChops: assignedChopIds.size,\r\n      unassignedChops: this.currentChops.length - assignedChopIds.size,\r\n      totalTracks,\r\n      assignedTracks\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Handle explicit chop deletion (called when user deletes a chop)\r\n   * @param {string} chopId - ID of the deleted chop\r\n   * @returns {void}\r\n   */\r\n  handleChopDeletion(chopId) {\r\n    console.log(`🗑️ Handling explicit chop deletion: ${chopId}`);\r\n    \r\n    // Remove from current chops\r\n    this.currentChops = this.currentChops.filter(chop => chop.padId !== chopId);\r\n    \r\n    // Find and clear the track assignment\r\n    const trackIndex = this.patternManager.getTrackForChop(chopId);\r\n    \r\n    if (trackIndex !== null) {\r\n      // Clear the chop assignment but preserve the pattern data\r\n      this.patternManager.assignChopToTrack(null, trackIndex);\r\n      console.log(`✅ Cleared chop assignment for track ${trackIndex} (chop ${chopId})`);\r\n    }\r\n    \r\n    // Notify listeners of changes\r\n    this.notifyChopAssignmentChange();\r\n  }\r\n\r\n  /**\r\n   * Handle explicit chop creation (called when user creates a new chop)\r\n   * @param {Object} newChop - The newly created chop\r\n   * @returns {void}\r\n   */\r\n  handleChopCreation(newChop) {\r\n    console.log(`➕ Handling explicit chop creation: ${newChop.padId}`);\r\n    \r\n    // Add to current chops if not already present\r\n    const existingIndex = this.currentChops.findIndex(chop => chop.padId === newChop.padId);\r\n    if (existingIndex === -1) {\r\n      this.currentChops.push(newChop);\r\n    } else {\r\n      // Update existing chop\r\n      this.currentChops[existingIndex] = newChop;\r\n    }\r\n    \r\n    // Handle as new chop for assignment\r\n    this.handleNewChops([newChop]);\r\n  }\r\n\r\n  /**\r\n   * Handle explicit chop modification (called when user modifies chop timestamps)\r\n   * @param {Object} modifiedChop - The modified chop\r\n   * @returns {void}\r\n   */\r\n  handleChopModification(modifiedChop) {\r\n    console.log(`🔄 Handling explicit chop modification: ${modifiedChop.padId}`);\r\n    \r\n    // Update in current chops\r\n    const existingIndex = this.currentChops.findIndex(chop => chop.padId === modifiedChop.padId);\r\n    if (existingIndex !== -1) {\r\n      const previousChop = this.currentChops[existingIndex];\r\n      this.currentChops[existingIndex] = modifiedChop;\r\n      \r\n      // Handle as modified chop\r\n      this.handleModifiedChops([{\r\n        previous: previousChop,\r\n        current: modifiedChop\r\n      }]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up resources\r\n   * @returns {void}\r\n   */\r\n  destroy() {\r\n    this.currentChops = [];\r\n    this.chopListeners.clear();\r\n    this.onChopAssignmentChange = null;\r\n    \r\n    console.log('SamplerChopIntegration destroyed');\r\n  }\r\n}\r\n\r\nexport { SamplerChopIntegration };","/**\r\n * @fileoverview Optimized Sampler Sequencer Service\r\n * High-performance version using the optimized engine and rendering system\r\n * Eliminates lag and ensures smooth playback under all conditions\r\n */\r\n\r\nimport { HighPerformanceSequencerEngine } from './HighPerformanceSequencerEngine.js';\r\nimport { SamplerPatternManager } from './SamplerPatternManager.js';\r\nimport { YouTubePlayerInterface } from './YouTubePlayerInterface.js';\r\nimport { SamplerChopIntegration } from './SamplerChopIntegration.js';\r\nimport { HighPerformanceRenderer } from '../../utils/HighPerformanceRenderer.js';\r\n\r\n/**\r\n * Optimized sampler sequencer service with zero-lag performance\r\n * Uses high-performance engine and optimized rendering\r\n */\r\nclass OptimizedSamplerSequencerService {\r\n  constructor() {\r\n    /** @type {HighPerformanceSequencerEngine} */\r\n    this.engine = new HighPerformanceSequencerEngine();\r\n    \r\n    /** @type {SamplerPatternManager} */\r\n    this.patternManager = new SamplerPatternManager();\r\n    \r\n    /** @type {YouTubePlayerInterface} */\r\n    this.youtubeInterface = new YouTubePlayerInterface();\r\n    \r\n    /** @type {SamplerChopIntegration} */\r\n    this.chopIntegration = new SamplerChopIntegration(this.patternManager);\r\n    \r\n    /** @type {HighPerformanceRenderer} */\r\n    this.renderer = new HighPerformanceRenderer();\r\n    \r\n    /** @type {boolean} */\r\n    this.isInitialized = false;\r\n    \r\n    /** @type {Map<string, Object>} */\r\n    this.chopsData = new Map();\r\n    \r\n    /** @type {Function[]} */\r\n    this.stepCallbacks = [];\r\n    \r\n    /** @type {Function[]} */\r\n    this.stateChangeCallbacks = [];\r\n    \r\n    /** @type {Function[]} */\r\n    this.errorCallbacks = [];\r\n    \r\n    /** @type {Object} */\r\n    this.performanceConfig = {\r\n      maxConcurrentChops: 8, // Limit concurrent chop playback\r\n      audioLookahead: 25, // 25ms audio lookahead\r\n      renderThrottle: 16, // 60fps render throttling\r\n      memoryCleanupInterval: 30000 // 30s memory cleanup\r\n    };\r\n    \r\n    /** @type {Set<string>} */\r\n    this.activeChops = new Set();\r\n    \r\n    /** @type {number} */\r\n    this.lastCleanupTime = 0;\r\n    \r\n    this.setupEngineCallbacks();\r\n    this.setupPerformanceOptimizations();\r\n  }\r\n\r\n  /**\r\n   * Initialize the optimized sampler sequencer service\r\n   * @param {Object} youtubePlayer - YouTube player instance\r\n   * @param {Array} chops - Initial chop data\r\n   * @returns {Promise<boolean>} Whether initialization was successful\r\n   */\r\n  async initialize(youtubePlayer, chops = []) {\r\n    try {\r\n      // Initialize high-performance engine\r\n      const engineInitialized = await this.engine.initialize(youtubePlayer);\r\n      if (!engineInitialized) {\r\n        throw new Error('Failed to initialize high-performance engine');\r\n      }\r\n\r\n      // Connect YouTube player interface with optimizations\r\n      const connectionResult = this.youtubeInterface.connect(youtubePlayer);\r\n      if (!connectionResult) {\r\n        throw new Error('Failed to connect YouTube player interface');\r\n      }\r\n\r\n      // Create initial pattern\r\n      const patternResult = this.patternManager.createPattern('Default Pattern');\r\n      if (!patternResult.success) {\r\n        throw new Error('Failed to create default pattern');\r\n      }\r\n\r\n      // Load and optimize chops data\r\n      this.loadChopsData(chops);\r\n      this.optimizeChopsForPerformance();\r\n\r\n      // Initialize chop integration with performance callbacks\r\n      this.chopIntegration.setChopAssignmentChangeCallback((assignments) => {\r\n        this.renderer.scheduleUpdate(() => {\r\n          this.notifyStateChange(this.engine.getState());\r\n        }, 'chop-assignments');\r\n      });\r\n\r\n      this.chopIntegration.updateChops(chops);\r\n\r\n      this.isInitialized = true;\r\n      return true;\r\n\r\n    } catch (error) {\r\n      console.error('Failed to initialize OptimizedSamplerSequencerService:', error);\r\n      this.notifyError(error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Setup engine callbacks with performance optimizations\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  setupEngineCallbacks() {\r\n    // High-performance step callback\r\n    this.engine.addStepCallback((stepNumber, executionTime) => {\r\n      this.handleOptimizedStep(stepNumber, executionTime);\r\n    });\r\n\r\n    // Optimized state change callback\r\n    this.engine.addStateChangeCallback((state) => {\r\n      this.renderer.scheduleUpdate(() => {\r\n        this.notifyStateChange(state);\r\n      }, `state-${state.currentStep}-${state.isPlaying}`);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Setup performance optimizations\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  setupPerformanceOptimizations() {\r\n    // Memory cleanup interval\r\n    setInterval(() => {\r\n      this.performMemoryCleanup();\r\n    }, this.performanceConfig.memoryCleanupInterval);\r\n\r\n    // Performance monitoring\r\n    setInterval(() => {\r\n      this.monitorPerformance();\r\n    }, 5000); // Every 5 seconds\r\n  }\r\n\r\n  /**\r\n   * Handle optimized step execution\r\n   * @private\r\n   * @param {number} stepNumber - Current step number\r\n   * @param {number} executionTime - Execution timestamp\r\n   * @returns {void}\r\n   */\r\n  handleOptimizedStep(stepNumber, executionTime) {\r\n    try {\r\n      const pattern = this.patternManager.getCurrentPattern();\r\n      if (!pattern) return;\r\n\r\n      // Get triggered chops for this step with performance limits\r\n      const triggeredChops = this.getTriggeredChopsForStep(stepNumber, pattern);\r\n      \r\n      // Limit concurrent chops for performance\r\n      const availableSlots = this.performanceConfig.maxConcurrentChops - this.activeChops.size;\r\n      const chopsToPlay = triggeredChops.slice(0, availableSlots);\r\n\r\n      // Execute chop playback with minimal overhead\r\n      chopsToPlay.forEach(chopId => {\r\n        this.executeChopPlayback(chopId, executionTime);\r\n      });\r\n\r\n      // Notify step callbacks with batched updates\r\n      this.renderer.scheduleUpdate(() => {\r\n        this.stepCallbacks.forEach(callback => {\r\n          try {\r\n            callback(stepNumber, executionTime);\r\n          } catch (error) {\r\n            console.error('Step callback error:', error);\r\n          }\r\n        });\r\n      }, `step-${stepNumber}`);\r\n\r\n    } catch (error) {\r\n      console.error('Optimized step handling error:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute chop playback with performance optimizations\r\n   * @private\r\n   * @param {string} chopId - Chop ID to play\r\n   * @param {number} executionTime - Execution timestamp\r\n   * @returns {void}\r\n   */\r\n  executeChopPlayback(chopId, executionTime) {\r\n    const chopData = this.chopsData.get(chopId);\r\n    if (!chopData) return;\r\n\r\n    try {\r\n      // Mark chop as active\r\n      this.activeChops.add(chopId);\r\n\r\n      // Execute timestamp jump with minimal delay\r\n      this.engine.jumpToTimestamp(chopData.startTime, true);\r\n\r\n      // Schedule chop cleanup\r\n      setTimeout(() => {\r\n        this.activeChops.delete(chopId);\r\n      }, chopData.duration * 1000 || 1000);\r\n\r\n    } catch (error) {\r\n      console.error('Chop playback error:', error);\r\n      this.activeChops.delete(chopId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get triggered chops for a specific step\r\n   * @private\r\n   * @param {number} stepNumber - Step number\r\n   * @param {Object} pattern - Current pattern\r\n   * @returns {Array<string>} Array of chop IDs to trigger\r\n   */\r\n  getTriggeredChopsForStep(stepNumber, pattern) {\r\n    const triggeredChops = [];\r\n    \r\n    if (!pattern.tracks) return triggeredChops;\r\n\r\n    pattern.tracks.forEach(track => {\r\n      if (track.steps && track.steps[stepNumber] && track.steps[stepNumber].active) {\r\n        const assignments = this.chopIntegration.getChopAssignments();\r\n        const chopId = assignments[track.id];\r\n        if (chopId) {\r\n          triggeredChops.push(chopId);\r\n        }\r\n      }\r\n    });\r\n\r\n    return triggeredChops;\r\n  }\r\n\r\n  /**\r\n   * Load chops data with performance optimizations\r\n   * @private\r\n   * @param {Array} chops - Chop data array\r\n   * @returns {void}\r\n   */\r\n  loadChopsData(chops) {\r\n    this.chopsData.clear();\r\n    \r\n    chops.forEach(chop => {\r\n      if (chop && chop.id) {\r\n        // Pre-calculate chop metadata for performance\r\n        const optimizedChop = {\r\n          ...chop,\r\n          duration: chop.endTime - chop.startTime,\r\n          isOptimized: true,\r\n          preloadTime: Date.now()\r\n        };\r\n        \r\n        this.chopsData.set(chop.id, optimizedChop);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Optimize chops for performance\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  optimizeChopsForPerformance() {\r\n    // Sort chops by usage frequency (most used first)\r\n    const chopUsage = new Map();\r\n    \r\n    this.chopsData.forEach((chop, chopId) => {\r\n      chopUsage.set(chopId, 0);\r\n    });\r\n\r\n    // Pre-warm frequently used chops\r\n    const frequentChops = Array.from(chopUsage.entries())\r\n      .sort((a, b) => b[1] - a[1])\r\n      .slice(0, this.performanceConfig.maxConcurrentChops);\r\n\r\n    frequentChops.forEach(([chopId]) => {\r\n      const chop = this.chopsData.get(chopId);\r\n      if (chop) {\r\n        chop.isPreWarmed = true;\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Perform memory cleanup\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  performMemoryCleanup() {\r\n    const now = Date.now();\r\n    \r\n    // Clean up old active chops\r\n    this.activeChops.forEach(chopId => {\r\n      const chop = this.chopsData.get(chopId);\r\n      if (chop && now - chop.preloadTime > 60000) { // 1 minute old\r\n        this.activeChops.delete(chopId);\r\n      }\r\n    });\r\n\r\n    // Clear renderer cache\r\n    this.renderer.resetPerformanceMetrics();\r\n\r\n    this.lastCleanupTime = now;\r\n  }\r\n\r\n  /**\r\n   * Monitor performance and adjust settings\r\n   * @private\r\n   * @returns {void}\r\n   */\r\n  monitorPerformance() {\r\n    const engineMetrics = this.engine.getPerformanceMetrics();\r\n    const renderMetrics = this.renderer.getPerformanceMetrics();\r\n\r\n    // Adjust performance settings based on metrics\r\n    if (engineMetrics.jitter > 10) { // High jitter\r\n      this.performanceConfig.maxConcurrentChops = Math.max(4, this.performanceConfig.maxConcurrentChops - 1);\r\n    } else if (engineMetrics.jitter < 2) { // Low jitter\r\n      this.performanceConfig.maxConcurrentChops = Math.min(8, this.performanceConfig.maxConcurrentChops + 1);\r\n    }\r\n\r\n    // Log performance if issues detected\r\n    if (engineMetrics.jitter > 20 || renderMetrics.droppedFrames > 5) {\r\n      console.warn('Performance issues detected:', {\r\n        engineJitter: engineMetrics.jitter,\r\n        droppedFrames: renderMetrics.droppedFrames,\r\n        activeChops: this.activeChops.size\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start sequencer playback\r\n   * @returns {void}\r\n   */\r\n  start() {\r\n    if (!this.isInitialized) {\r\n      throw new Error('Service must be initialized before starting');\r\n    }\r\n    \r\n    this.engine.start();\r\n  }\r\n\r\n  /**\r\n   * Stop sequencer playback\r\n   * @returns {void}\r\n   */\r\n  stop() {\r\n    this.engine.stop();\r\n    this.activeChops.clear();\r\n  }\r\n\r\n  /**\r\n   * Pause sequencer playback\r\n   * @returns {void}\r\n   */\r\n  pause() {\r\n    this.engine.pause();\r\n  }\r\n\r\n  /**\r\n   * Resume sequencer playback\r\n   * @returns {void}\r\n   */\r\n  resume() {\r\n    this.engine.resume();\r\n  }\r\n\r\n  /**\r\n   * Set BPM with performance validation\r\n   * @param {number} bpm - New BPM value\r\n   * @returns {void}\r\n   */\r\n  setBPM(bpm) {\r\n    if (bpm < 60 || bpm > 200) {\r\n      throw new Error('BPM must be between 60 and 200');\r\n    }\r\n    \r\n    this.engine.setBPM(bpm);\r\n  }\r\n\r\n  /**\r\n   * Get current BPM\r\n   * @returns {number} Current BPM\r\n   */\r\n  getBPM() {\r\n    return this.engine.bpm;\r\n  }\r\n\r\n  /**\r\n   * Get current sequencer state\r\n   * @returns {Object} Current state with performance metrics\r\n   */\r\n  getState() {\r\n    const engineState = this.engine.getState();\r\n    const renderMetrics = this.renderer.getPerformanceMetrics();\r\n    \r\n    return {\r\n      ...engineState,\r\n      activeChops: this.activeChops.size,\r\n      performanceConfig: this.performanceConfig,\r\n      renderMetrics\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Add step callback\r\n   * @param {Function} callback - Callback function\r\n   * @returns {void}\r\n   */\r\n  addStepCallback(callback) {\r\n    if (typeof callback === 'function') {\r\n      this.stepCallbacks.push(callback);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove step callback\r\n   * @param {Function} callback - Callback function to remove\r\n   * @returns {void}\r\n   */\r\n  removeStepCallback(callback) {\r\n    const index = this.stepCallbacks.indexOf(callback);\r\n    if (index > -1) {\r\n      this.stepCallbacks.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add state change callback\r\n   * @param {Function} callback - Callback function\r\n   * @returns {void}\r\n   */\r\n  addStateChangeCallback(callback) {\r\n    if (typeof callback === 'function') {\r\n      this.stateChangeCallbacks.push(callback);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove state change callback\r\n   * @param {Function} callback - Callback function to remove\r\n   * @returns {void}\r\n   */\r\n  removeStateChangeCallback(callback) {\r\n    const index = this.stateChangeCallbacks.indexOf(callback);\r\n    if (index > -1) {\r\n      this.stateChangeCallbacks.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add error callback\r\n   * @param {Function} callback - Callback function\r\n   * @returns {void}\r\n   */\r\n  addErrorCallback(callback) {\r\n    if (typeof callback === 'function') {\r\n      this.errorCallbacks.push(callback);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Notify state change callbacks\r\n   * @private\r\n   * @param {Object} state - Current state\r\n   * @returns {void}\r\n   */\r\n  notifyStateChange(state) {\r\n    this.stateChangeCallbacks.forEach(callback => {\r\n      try {\r\n        callback(state);\r\n      } catch (error) {\r\n        console.error('State change callback error:', error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Notify error callbacks\r\n   * @private\r\n   * @param {Error} error - Error object\r\n   * @returns {void}\r\n   */\r\n  notifyError(error) {\r\n    this.errorCallbacks.forEach(callback => {\r\n      try {\r\n        callback(error);\r\n      } catch (callbackError) {\r\n        console.error('Error callback error:', callbackError);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get performance metrics\r\n   * @returns {Object} Combined performance metrics\r\n   */\r\n  getPerformanceMetrics() {\r\n    return {\r\n      engine: this.engine.getPerformanceMetrics(),\r\n      renderer: this.renderer.getPerformanceMetrics(),\r\n      service: {\r\n        activeChops: this.activeChops.size,\r\n        totalChops: this.chopsData.size,\r\n        lastCleanup: this.lastCleanupTime,\r\n        config: this.performanceConfig\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Cleanup resources\r\n   * @returns {void}\r\n   */\r\n  cleanup() {\r\n    this.stop();\r\n    \r\n    this.engine.cleanup();\r\n    this.renderer.cleanup();\r\n    \r\n    this.chopsData.clear();\r\n    this.activeChops.clear();\r\n    this.stepCallbacks = [];\r\n    this.stateChangeCallbacks = [];\r\n    this.errorCallbacks = [];\r\n    \r\n    this.isInitialized = false;\r\n  }\r\n}\r\n\r\nexport { OptimizedSamplerSequencerService };"],"names":["HighPerformanceRenderer","constructor","this","pendingUpdates","Set","rafId","isRendering","renderCache","Map","visibilityObserver","visibleElements","performanceMetrics","frameTime","droppedFrames","renderCalls","cacheHits","initializeVisibilityObserver","IntersectionObserver","entries","forEach","entry","isIntersecting","add","target","delete","rootMargin","threshold","scheduleUpdate","updateFunction","key","has","set","requestAnimationFrame","executeRender","startTime","performance","now","error","clear","createOptimizedStepIndicator","stepIndex","isActive","isTriggered","element","document","createElement","className","dataset","step","style","transform","willChange","Object","assign","width","height","borderRadius","transition","cursor","updateStepIndicator","cacheKey","backgroundColor","opacity","createVirtualScrollContainer","items","renderItem","itemHeight","container","position","overflow","viewport","length","appendChild","visibleItems","updateVisibleItems","scrollTop","containerHeight","clientHeight","startIndex","Math","floor","endIndex","min","ceil","index","remove","i","top","scrollTimeout","addEventListener","clearTimeout","setTimeout","optimizeElement","backfaceVisibility","perspective","observe","createOptimizedAnimation","keyframes","duration","animation","animate","easing","fill","cancel","batchDOMReads","readFunctions","results","readFn","push","batchDOMWrites","writeFunctions","writeFn","getPerformanceMetrics","resetPerformanceMetrics","cleanup","cancelAnimationFrame","disconnect","HighPerformanceSequencerEngine","audioContext","schedulerNode","isPlaying","isPaused","currentStep","bpm","stepResolution","stepCallbacks","stateChangeCallbacks","youtubePlayer","isInitialized","lookAhead","scheduleAheadTime","nextStepTime","timerID","scheduledSteps","jitter","drift","cpuUsage","lastMeasurement","offscreenCanvas","schedulerWorker","initialize","Error","initializeAudioContext","initializeScheduler","initializePerformanceMonitoring","window","AudioContext","webkitAudioContext","latencyHint","sampleRate","state","resume","silentGain","createGain","gain","value","connect","destination","oscillator","createOscillator","frequency","start","blob","Blob","type","Worker","URL","createObjectURL","onmessage","e","data","scheduler","setInterval","updatePerformanceMetrics","currentTime","scheduleStep","getStepDuration","time","stepNumber","delay","executeStep","max","executionTime","postMessage","notifyStateChange","stop","pause","setBPM","newBpm","newInterval","interval","jumpToTimestamp","timestamp","maintainPlayback","wasPlaying","getPlayerState","seekTo","Promise","resolve","playVideo","deltaTime","expectedDelta","abs","addStepCallback","callback","removeStepCallback","indexOf","splice","addStateChangeCallback","removeStateChangeCallback","getState","terminate","close","samplerPatternValidator","validationRules","pattern","requiredFields","bpmRange","maxBanks","maxNameLength","bank","tracksPerBank","track","stepsPerTrack","errorCounts","validationErrors","sanitizationAttempts","recoveryAttempts","validateAndSanitize","options","strict","autoFix","throwOnError","result","isValid","sanitizedPattern","errors","warnings","fixes","structureValidation","validateStructure","join","sanitizationResult","sanitizePattern","finalValidation","message","missingFields","filter","field","id","trim","name","isNaN","currentBank","banks","Array","isArray","bankValidation","validateBank","map","err","warn","metadata","created","isValidISODate","modified","bankId","tracks","trackIndex","trackValidation","validateTrack","chopId","test","steps","sanitized","JSON","parse","stringify","generatePatternId","substring","createDefaultBanks","bankResult","sanitizeBank","fix","Date","toISOString","String","fromCharCode","createDefaultTrack","slice","trackResult","sanitizeTrack","createDefaultTracks","Boolean","random","toString","dateString","date","getTime","getStats","resetStats","SamplerPatternManager","currentPattern","chopAssignments","createPattern","validationResult","success","bankIndex","bankName","toggleStep","currentBankData","getCurrentBankData","setStep","active","getStep","switchBank","assignChopToTrack","autoAssignChops","chops","chopsByBank","groupChopsByBank","bankLetter","bankChops","charCodeAt","bankData","chop","padId","grouped","charAt","toUpperCase","keys","sort","a","b","parseInt","getChopForTrack","getTrackForChop","get","getActiveStepsForStep","activeTracks","clearCurrentBank","clearAllBanks","getCurrentPattern","setCurrentPattern","errorMessage","rebuildChopAssignments","validatePattern","substr","getPatternStats","totalSteps","activeSteps","assignedTracks","totalTracks","destroy","YouTubePlayerInterface","isConnected","isDegraded","degradationReason","errorLog","lastSeekTime","isSeekInProgress","errorCallbacks","degradationCallbacks","stats","totalSeeks","successfulSeeks","failedSeeks","averageSeekLatency","degradationEvents","recoveryEvents","degradationConfig","maxConsecutiveFailures","failureTimeWindow","autoRecoveryInterval","recentFailures","autoRecoveryTimer","method","exitDegradedMode","allowSeek","playerState","handleSeekFailure","pauseVideo","latency","updateSeekLatency","clearRecentFailures","fastSeekForChop","logError","failure","enterDegradedMode","reason","scheduleAutoRecovery","async","attemptRecovery","getCurrentTime","getDetailedPlayerState","isBuffering","isReady","getDuration","isEnded","synchronizeState","targetState","currentState","syncSuccess","updatedState","isPlayerReady","getStatus","errorCount","getRecentErrors","limit","clearErrors","onError","removeErrorCallback","forceRecovery","forceExitDegradedMode","onDegradation","removeDegradationCallback","testConnection","handlePlayerError","classifyPlayerError","attemptNetworkRecovery","toLowerCase","includes","navigator","onLine","getErrorRecoverySuggestions","suggestions","userAction","technicalAction","canRetry","getPerformanceStats","successRate","toFixed","errorRate","errorEntry","total","SamplerChopIntegration","patternManager","currentChops","chopListeners","onChopAssignmentChange","setChopAssignmentChangeCallback","updateChops","previousChops","changes","detectChopChanges","added","handleNewChops","removed","handleRemovedChops","handleModifiedChops","notifyChopAssignmentChange","previousMap","currentMap","previousChop","hasChopChanged","previous","current","currentChop","endTime","color","newChops","removedChops","originalBank","modifiedChops","assignChopsToBank","chopNumber","targetTrackIndex","availableTrackIndex","findNextAvailableTrack","find","getChopsForCurrentBank","c","getCurrentBankAssignments","reassignAllChops","clearAllAssignments","assignments","getIntegrationStats","totalChops","assignedChops","unassignedChops","assignedChopIds","size","handleChopDeletion","handleChopCreation","newChop","existingIndex","findIndex","handleChopModification","modifiedChop","OptimizedSamplerSequencerService","engine","youtubeInterface","chopIntegration","renderer","chopsData","performanceConfig","maxConcurrentChops","audioLookahead","renderThrottle","memoryCleanupInterval","activeChops","lastCleanupTime","setupEngineCallbacks","setupPerformanceOptimizations","loadChopsData","optimizeChopsForPerformance","notifyError","handleOptimizedStep","performMemoryCleanup","monitorPerformance","triggeredChops","getTriggeredChopsForStep","availableSlots","executeChopPlayback","chopData","getChopAssignments","optimizedChop","isOptimized","preloadTime","chopUsage","from","isPreWarmed","engineMetrics","renderMetrics","getBPM","engineState","addErrorCallback","callbackError","service","lastCleanup","config"],"mappings":"AAUA,MAAMA,EACJ,WAAAC,GAEEC,KAAKC,mBAAqBC,IAG1BF,KAAKG,MAAQ,KAGbH,KAAKI,aAAc,EAGnBJ,KAAKK,gBAAkBC,IAGvBN,KAAKO,mBAAqB,KAG1BP,KAAKQ,oBAAsBN,IAG3BF,KAAKS,mBAAqB,CACxBC,UAAW,EACXC,cAAe,EACfC,YAAa,EACbC,UAAW,GAGbb,KAAKc,8BACP,CAOA,4BAAAA,GACEd,KAAKO,mBAAqB,IAAIQ,qBAC3BC,IACCA,EAAQC,QAAQC,IACVA,EAAMC,eACRnB,KAAKQ,gBAAgBY,IAAIF,EAAMG,QAE/BrB,KAAKQ,gBAAgBc,OAAOJ,EAAMG,WAIxC,CACEE,WAAY,OACZC,UAAW,GAGjB,CAQA,cAAAC,CAAeC,EAAgBC,EAAM,MAC/BA,GAAO3B,KAAKK,YAAYuB,IAAID,GAC9B3B,KAAKS,mBAAmBI,aAI1Bb,KAAKC,eAAemB,IAAIM,GAEpBC,GACF3B,KAAKK,YAAYwB,IAAIF,GAAK,GAGvB3B,KAAKG,QACRH,KAAKG,MAAQ2B,sBAAsB,IAAM9B,KAAK+B,kBAElD,CAOA,aAAAA,GACE,GAAI/B,KAAKI,YACP,OAGFJ,KAAKI,aAAc,EACnB,MAAM4B,EAAYC,YAAYC,MAE9B,IAEElC,KAAKC,eAAegB,QAAQS,IAC1B,IACEA,GACF,OAASS,GAET,IAGFnC,KAAKC,eAAemC,QACpBpC,KAAKK,YAAY+B,QAGjBpC,KAAKS,mBAAmBC,UAAYuB,YAAYC,MAAQF,EACxDhC,KAAKS,mBAAmBG,cAGpBZ,KAAKS,mBAAmBC,UAAY,OACtCV,KAAKS,mBAAmBE,eAG5B,CAAA,QACEX,KAAKI,aAAc,EACnBJ,KAAKG,MAAQ,IACf,CACF,CASA,4BAAAkC,CAA6BC,EAAWC,EAAUC,GAChD,MAAMC,EAAUC,SAASC,cAAc,OACvCF,EAAQG,UAAY,iBACpBH,EAAQI,QAAQC,KAAOR,EAGvBG,EAAQM,MAAMC,UAAY,gBAC1BP,EAAQM,MAAME,WAAa,qBAe3B,OAJAC,OAAOC,OAAOV,EAAQM,MARH,CACjBK,MAAO,OACPC,OAAQ,OACRC,aAAc,MACdC,WAAY,OACZC,OAAQ,YAKVxD,KAAKyD,oBAAoBhB,EAASF,EAAUC,GAErCC,CACT,CASA,mBAAAgB,CAAoBhB,EAASF,EAAUC,GACrC,MAAMkB,EAAW,QAAQjB,EAAQI,QAAQC,QAAQP,KAAYC,IAE7DxC,KAAKyB,eAAe,KAElB,IAAKzB,KAAKQ,gBAAgBoB,IAAIa,GAC5B,OAGF,IAAIkB,EAAiBC,EAASZ,EAE1BT,GACFoB,EAAkB,UAClBC,EAAU,IACVZ,EAAY,4BACHR,GACTmB,EAAkB,UAClBC,EAAU,MACVZ,EAAY,2BAEZW,EAAkB,UAClBC,EAAU,MACVZ,EAAY,0BAIdP,EAAQM,MAAMY,gBAAkBA,EAChClB,EAAQM,MAAMa,QAAUA,EACxBnB,EAAQM,MAAMC,UAAYA,GACzBU,EACL,CASA,4BAAAG,CAA6BC,EAAOC,EAAYC,EAAa,IAC3D,MAAMC,EAAYvB,SAASC,cAAc,OACzCsB,EAAUlB,MAAMmB,SAAW,WAC3BD,EAAUlB,MAAMoB,SAAW,OAC3BF,EAAUlB,MAAMM,OAAS,QAEzB,MAAMe,EAAW1B,SAASC,cAAc,OACxCyB,EAASrB,MAAMM,OAAYS,EAAMO,OAASL,EAAlB,KACxBC,EAAUK,YAAYF,GAEtB,MAAMG,MAAmBjE,IAEnBkE,EAAqB,KACzB,MAAMC,EAAYR,EAAUQ,UACtBC,EAAkBT,EAAUU,aAE5BC,EAAaC,KAAKC,MAAML,EAAYT,GACpCe,EAAWF,KAAKG,IACpBlB,EAAMO,OAAS,EACfQ,KAAKI,MAAMR,EAAYC,GAAmBV,IAI5CO,EAAatD,QAAQ,CAACwB,EAASyC,MACzBA,EAAQN,GAAcM,EAAQH,KAChCtC,EAAQ0C,SACRZ,EAAajD,OAAO4D,MAKxB,IAAA,IAASE,EAAIR,EAAYQ,GAAKL,EAAUK,IACtC,IAAKb,EAAa3C,IAAIwD,GAAI,CACxB,MAAM3C,EAAUsB,EAAWD,EAAMsB,GAAIA,GACrC3C,EAAQM,MAAMmB,SAAW,WACzBzB,EAAQM,MAAMsC,IAASD,EAAIpB,EAAP,KACpBvB,EAAQM,MAAMM,OAAS,GAAGW,MAC1BvB,EAAQM,MAAMK,MAAQ,OAEtBgB,EAASE,YAAY7B,GACrB8B,EAAa1C,IAAIuD,EAAG3C,EACtB,GAKJ,IAAI6C,EAWJ,OAVArB,EAAUsB,iBAAiB,SAAU,KAC/BD,GACFE,aAAaF,GAEfA,EAAgBG,WAAWjB,EAAoB,MAIjDA,IAEOP,CACT,CAOA,eAAAyB,CAAgBjD,GAEdA,EAAQM,MAAMC,UAAY,gBAC1BP,EAAQM,MAAM4C,mBAAqB,SACnClD,EAAQM,MAAM6C,YAAc,SAG5BnD,EAAQM,MAAME,WAAa,qBAG3BjD,KAAKO,mBAAmBsF,QAAQpD,EAClC,CASA,wBAAAqD,CAAyBrD,EAASsD,EAAWC,EAAW,KAEtD,MAAMC,EAAYxD,EAAQyD,QAAQH,EAAW,CAC3CC,WACAG,OAAQ,+BACRC,KAAM,aAQR,OAJAH,EAAUV,iBAAiB,SAAU,KACnCU,EAAUI,WAGLJ,CACT,CAOA,aAAAK,CAAcC,GACZ,MAAMC,EAAU,GAahB,OAXAxG,KAAKyB,eAAe,KAClB8E,EAActF,QAAQwF,IACpB,IACED,EAAQE,KAAKD,IACf,OAAStE,GAEPqE,EAAQE,KAAK,KACf,MAIGF,CACT,CAOA,cAAAG,CAAeC,GACb5G,KAAKyB,eAAe,KAClBmF,EAAe3F,QAAQ4F,IACrB,IACEA,GACF,OAAS1E,GAET,KAGN,CAMA,qBAAA2E,GACE,MAAO,IAAK9G,KAAKS,mBACnB,CAMA,uBAAAsG,GACE/G,KAAKS,mBAAqB,CACxBC,UAAW,EACXC,cAAe,EACfC,YAAa,EACbC,UAAW,EAEf,CAMA,OAAAmG,GACMhH,KAAKG,QACP8G,qBAAqBjH,KAAKG,OAC1BH,KAAKG,MAAQ,MAGXH,KAAKO,qBACPP,KAAKO,mBAAmB2G,aACxBlH,KAAKO,mBAAqB,MAG5BP,KAAKC,eAAemC,QACpBpC,KAAKK,YAAY+B,QACjBpC,KAAKQ,gBAAgB4B,OACvB,ECvXF,MAAM+E,EACJ,WAAApH,GAEEC,KAAKoH,aAAe,KAGpBpH,KAAKqH,cAAgB,KAGrBrH,KAAKsH,WAAY,EAGjBtH,KAAKuH,UAAW,EAGhBvH,KAAKwH,YAAc,EAGnBxH,KAAKyH,IAAM,IAGXzH,KAAK0H,eAAiB,GAGtB1H,KAAK2H,cAAgB,GAGrB3H,KAAK4H,qBAAuB,GAG5B5H,KAAK6H,cAAgB,KAGrB7H,KAAK8H,eAAgB,EAGrB9H,KAAK+H,UAAY,GAGjB/H,KAAKgI,kBAAoB,GAGzBhI,KAAKiI,aAAe,EAGpBjI,KAAKkI,QAAU,KAGflI,KAAKmI,mBAAqB7H,IAG1BN,KAAKS,mBAAqB,CACxB2H,OAAQ,EACRC,MAAO,EACPC,SAAU,EACVC,gBAAiB,GAInBvI,KAAKwI,gBAAkB,KAGvBxI,KAAKyI,gBAAkB,IACzB,CAOA,gBAAMC,CAAWb,GACf,IACE,IAAKA,EACH,MAAM,IAAIc,MAAM,8BAelB,OAZA3I,KAAK6H,cAAgBA,QAGf7H,KAAK4I,+BAGL5I,KAAK6I,sBAGX7I,KAAK8I,kCAEL9I,KAAK8H,eAAgB,GACd,CAET,OAAS3F,GAEP,OAAO,CACT,CACF,CAOA,4BAAMyG,GAEJ5I,KAAKoH,aAAe,IAAK2B,OAAOC,cAAgBD,OAAOE,oBAAoB,CACzEC,YAAa,cACbC,WAAY,QAIkB,cAA5BnJ,KAAKoH,aAAagC,aACdpJ,KAAKoH,aAAaiC,SAI1B,MAAMC,EAAatJ,KAAKoH,aAAamC,aACrCD,EAAWE,KAAKC,MAAQ,EACxBH,EAAWI,QAAQ1J,KAAKoH,aAAauC,aAGrC,MAAMC,EAAa5J,KAAKoH,aAAayC,mBACrCD,EAAWE,UAAUL,MAAQ,IAC7BG,EAAWF,QAAQJ,GACnBM,EAAWG,OACb,CAOA,yBAAMlB,GAEJ,MA0BMmB,EAAO,IAAIC,KAAK,CA1BH,wtBA0BiB,CAAEC,KAAM,2BAC5ClK,KAAKyI,gBAAkB,IAAI0B,OAAOC,IAAIC,gBAAgBL,IAEtDhK,KAAKyI,gBAAgB6B,UAAaC,IACjB,SAAXA,EAAEC,MACJxK,KAAKyK,YAGX,CAOA,+BAAA3B,GAEE4B,YAAY,KACV1K,KAAK2K,4BACJ,IACL,CAOA,SAAAF,GACE,IAAKzK,KAAKsH,YAActH,KAAKoH,aAC3B,OAGF,MAAMwD,EAAc5K,KAAKoH,aAAawD,YAGtC,KAAO5K,KAAKiI,aAAe2C,EAAc5K,KAAKgI,mBAC5ChI,KAAK6K,aAAa7K,KAAKiI,cACvBjI,KAAKiI,cAAgBjI,KAAK8K,kBAAoB,GAElD,CAQA,YAAAD,CAAaE,GACX,MAAMC,EAAahL,KAAKwH,YAGlByD,EAAiD,KAAxCF,EAAO/K,KAAKoH,aAAawD,aAExCnF,WAAW,KACLzF,KAAKsH,WACPtH,KAAKkL,YAAYF,IAElBnG,KAAKsG,IAAI,EAAGF,IAEfjL,KAAKwH,aAAexH,KAAKwH,YAAc,GAAKxH,KAAK0H,cACnD,CAQA,WAAAwD,CAAYF,GACV,MAAMI,EAAgBnJ,YAAYC,MAGlC,IAAA,IAASkD,EAAI,EAAGA,EAAIpF,KAAK2H,cAActD,OAAQe,IAC7C,IACEpF,KAAK2H,cAAcvC,GAAG4F,EAAYI,EACpC,OAASjJ,GAET,CAEJ,CAMA,KAAA4H,GACE,IAAK/J,KAAK8H,cACR,MAAM,IAAIa,MAAM,8CAGd3I,KAAKsH,YAKJtH,KAAKuH,WACRvH,KAAKwH,YAAc,GAGrBxH,KAAKsH,WAAY,EACjBtH,KAAKuH,UAAW,EAGhBvH,KAAKiI,aAAejI,KAAKoH,aAAawD,YAGtC5K,KAAKyI,gBAAgB4C,YAAY,SAEjCrL,KAAKsL,oBACP,CAMA,IAAAC,IACOvL,KAAKsH,WAActH,KAAKuH,YAI7BvH,KAAKsH,WAAY,EACjBtH,KAAKuH,UAAW,EAChBvH,KAAKwH,YAAc,EAGnBxH,KAAKyI,gBAAgB4C,YAAY,QAGjCrL,KAAKmI,eAAe/F,QAEpBpC,KAAKsL,oBACP,CAMA,KAAAE,GACOxL,KAAKsH,YAIVtH,KAAKsH,WAAY,EACjBtH,KAAKuH,UAAW,EAEhBvH,KAAKyI,gBAAgB4C,YAAY,QAEjCrL,KAAKsL,oBACP,CAMA,MAAAjC,GACOrJ,KAAKuH,WAIVvH,KAAKsH,WAAY,EACjBtH,KAAKuH,UAAW,EAEhBvH,KAAKiI,aAAejI,KAAKoH,aAAawD,YACtC5K,KAAKyI,gBAAgB4C,YAAY,SAEjCrL,KAAKsL,oBACP,CAOA,MAAAG,CAAOC,GACL,GAAIA,EAAS,IAAMA,EAAS,IAC1B,MAAM,IAAI/C,MAAM,kCAGlB3I,KAAKyH,IAAMiE,EAGX,MAAMC,EAAc9G,KAAKsG,IAAI,GAAInL,KAAK8K,kBAAoB,GAC1D9K,KAAKyI,gBAAgB4C,YAAY,CAC/BnB,KAAM,cACN0B,SAAUD,IAGZ3L,KAAKsL,mBACP,CAMA,eAAAR,GACE,OAAQ,GAAK9K,KAAKyH,IAAMzH,KAAK0H,eAAkB,EAAI,GACrD,CAQA,qBAAMmE,CAAgBC,EAAWC,GAAmB,GAClD,IAAK/L,KAAK6H,cACR,OAAO,EAGT,IACE,MAAMmE,EAAqD,IAAxChM,KAAK6H,cAAcoE,iBAYtC,OATAjM,KAAK6H,cAAcqE,OAAOJ,GAAW,SAG/B,IAAIK,QAAQC,GAAW3G,WAAW2G,EAAS,IAE7CL,GAAoBC,GACtBhM,KAAK6H,cAAcwE,aAGd,CACT,OAASlK,GAEP,OAAO,CACT,CACF,CAOA,wBAAAwI,GACE,MAAMzI,EAAMD,YAAYC,MAExB,GAAIlC,KAAKS,mBAAmB8H,gBAAkB,EAAG,CAC/C,MAAM+D,EAAYpK,EAAMlC,KAAKS,mBAAmB8H,gBAG1CgE,EAAgB,IACtBvM,KAAKS,mBAAmB2H,OAASvD,KAAK2H,IAAIF,EAAYC,GAGtDvM,KAAKS,mBAAmB6H,SAAWzD,KAAKG,IAAI,IAAsC,EAAjChF,KAAKS,mBAAmB2H,OAC3E,CAEApI,KAAKS,mBAAmB8H,gBAAkBrG,CAC5C,CAMA,qBAAA4E,GACE,MAAO,IAAK9G,KAAKS,mBACnB,CAOA,eAAAgM,CAAgBC,GACU,mBAAbA,GACT1M,KAAK2H,cAAcjB,KAAKgG,EAE5B,CAOA,kBAAAC,CAAmBD,GACjB,MAAMxH,EAAQlF,KAAK2H,cAAciF,QAAQF,GACrCxH,GAAQ,GACVlF,KAAK2H,cAAckF,OAAO3H,EAAO,EAErC,CAOA,sBAAA4H,CAAuBJ,GACG,mBAAbA,GACT1M,KAAK4H,qBAAqBlB,KAAKgG,EAEnC,CAOA,yBAAAK,CAA0BL,GACxB,MAAMxH,EAAQlF,KAAK4H,qBAAqBgF,QAAQF,GAC5CxH,GAAQ,GACVlF,KAAK4H,qBAAqBiF,OAAO3H,EAAO,EAE5C,CAOA,iBAAAoG,GACE,MAAMlC,EAAQpJ,KAAKgN,WACnBhN,KAAK4H,qBAAqB3G,QAAQyL,IAChC,IACEA,EAAStD,EACX,OAASjH,GAET,GAEJ,CAMA,QAAA6K,GACE,MAAO,CACL1F,UAAWtH,KAAKsH,UAChBC,SAAUvH,KAAKuH,SACfC,YAAaxH,KAAKwH,YAClBC,IAAKzH,KAAKyH,IACVC,eAAgB1H,KAAK0H,eACrBjH,mBAAoBT,KAAK8G,wBAE7B,CAMA,OAAAE,GACEhH,KAAKuL,OAEDvL,KAAKyI,kBACPzI,KAAKyI,gBAAgBwE,YACrBjN,KAAKyI,gBAAkB,MAGrBzI,KAAKoH,eACPpH,KAAKoH,aAAa8F,QAClBlN,KAAKoH,aAAe,MAGtBpH,KAAK2H,cAAgB,GACrB3H,KAAK4H,qBAAuB,GAC5B5H,KAAK8H,eAAgB,CACvB,ECkGF,MAAMqF,EAA0B,IArmBhC,MACE,WAAApN,GACEC,KAAKoN,gBAAkB,CACrBC,QAAS,CACPC,eAAgB,CAAC,KAAM,OAAQ,MAAO,cAAe,SACrDC,SAAU,CAAEvI,IAAK,GAAImG,IAAK,KAC1BqC,SAAU,EACVC,cAAe,KAEjBC,KAAM,CACJJ,eAAgB,CAAC,SAAU,OAAQ,UACnCK,cAAe,GACfF,cAAe,IAEjBG,MAAO,CACLN,eAAgB,CAAC,aAAc,SAC/BO,cAAe,KAInB7N,KAAK8N,YAAc,CACjBC,iBAAkB,EAClBC,qBAAsB,EACtBC,iBAAkB,EAEtB,CAQA,mBAAAC,CAAoBb,EAASc,EAAU,IACrC,MAAMC,OACJA,GAAS,EAAAC,QACTA,GAAU,EAAAC,aACVA,GAAe,GACbH,EAEEI,EAAS,CACbC,SAAS,EACTC,iBAAkB,KAClBC,OAAQ,GACRC,SAAU,GACVC,MAAO,IAGT,IAEE,MAAMC,EAAsB7O,KAAK8O,kBAAkBzB,GAInD,GAHAkB,EAAOG,OAAOhI,QAAQmI,EAAoBH,QAC1CH,EAAOI,SAASjI,QAAQmI,EAAoBF,UAExCE,EAAoBH,OAAOrK,OAAS,GAAK+J,EAAQ,CAEnD,GADAG,EAAOC,SAAU,EACbF,EACF,MAAM,IAAI3F,MAAM,8BAA8BkG,EAAoBH,OAAOK,KAAK,SAEhF,OAAOR,CACT,CAGA,IAAIE,EAAmBpB,EACvB,GAAIgB,IAAYQ,EAAoBH,OAAOrK,OAAS,GAAKwK,EAAoBF,SAAStK,OAAS,GAAI,CACjG,MAAM2K,EAAqBhP,KAAKiP,gBAAgB5B,GAChDoB,EAAmBO,EAAmB3B,QACtCkB,EAAOK,MAAMlI,QAAQsI,EAAmBJ,OACxCL,EAAOI,SAASjI,QAAQsI,EAAmBL,UAC3C3O,KAAK8N,YAAYE,sBACnB,CAGA,MAAMkB,EAAkBlP,KAAK8O,kBAAkBL,GAE/C,GAAsC,IAAlCS,EAAgBR,OAAOrK,OACzBkK,EAAOC,SAAU,EACjBD,EAAOE,iBAAmBA,OAI1B,GAFAF,EAAOG,OAAOhI,QAAQwI,EAAgBR,QAElCJ,EACF,MAAM,IAAI3F,MAAM,iDAAiDuG,EAAgBR,OAAOK,KAAK,SAIjG,OAAOR,CAET,OAASpM,GAIP,GAHAnC,KAAK8N,YAAYC,mBACjBQ,EAAOG,OAAOhI,KAAK,yBAAyBvE,EAAMgN,WAE9Cb,EACF,MAAMnM,EAGR,OAAOoM,CACT,CACF,CAQA,iBAAAO,CAAkBzB,GAChB,MAAMqB,EAAS,GACTC,EAAW,GAGjB,IAAKtB,GAA8B,iBAAZA,EAErB,OADAqB,EAAOhI,KAAK,kCACL,CAAEgI,SAAQC,YAInB,MAAMS,EAAgBpP,KAAKoN,gBAAgBC,QAAQC,eAAe+B,OAChEC,KAAWA,KAASjC,IA4EtB,OA1EI+B,EAAc/K,OAAS,GACzBqK,EAAOhI,KAAK,4BAA4B0I,EAAcL,KAAK,UAIzD1B,EAAQkC,IAA6B,iBAAflC,EAAQkC,IAAgD,IAA7BlC,EAAQkC,GAAGC,OAAOnL,QACrEqK,EAAOhI,KAAK,yCAIV2G,EAAQoC,OACkB,iBAAjBpC,EAAQoC,KACjBf,EAAOhI,KAAK,iCACH2G,EAAQoC,KAAKpL,OAASrE,KAAKoN,gBAAgBC,QAAQI,eAC5DkB,EAASjI,KAAK,wCAAwC1G,KAAKoN,gBAAgBC,QAAQI,wBAKnE,IAAhBJ,EAAQ5F,MACiB,iBAAhB4F,EAAQ5F,KAAoBiI,MAAMrC,EAAQ5F,KACnDiH,EAAOhI,KAAK,+BACH2G,EAAQ5F,IAAMzH,KAAKoN,gBAAgBC,QAAQE,SAASvI,KACpDqI,EAAQ5F,IAAMzH,KAAKoN,gBAAgBC,QAAQE,SAASpC,MAC7DuD,EAAOhI,KAAK,uBAAuB1G,KAAKoN,gBAAgBC,QAAQE,SAASvI,WAAWhF,KAAKoN,gBAAgBC,QAAQE,SAASpC,aAKlG,IAAxBkC,EAAQsC,cACyB,iBAAxBtC,EAAQsC,aAA4BtC,EAAQsC,YAAc,IACnEjB,EAAOhI,KAAK,8CAKZ2G,EAAQuC,QACLC,MAAMC,QAAQzC,EAAQuC,QAGI,IAAzBvC,EAAQuC,MAAMvL,OAChBqK,EAAOhI,KAAK,uCACH2G,EAAQuC,MAAMvL,OAASrE,KAAKoN,gBAAgBC,QAAQG,UAC7DmB,EAASjI,KAAK,yBAAyB1G,KAAKoN,gBAAgBC,QAAQG,kBAItEH,EAAQuC,MAAM3O,QAAQ,CAACyM,EAAMxI,KAC3B,MAAM6K,EAAiB/P,KAAKgQ,aAAatC,EAAMxI,GAC/CwJ,EAAOhI,QAAQqJ,EAAerB,OAAOuB,IAAIC,GAAO,QAAQhL,MAAUgL,MAClEvB,EAASjI,QAAQqJ,EAAepB,SAASsB,IAAIE,GAAQ,QAAQjL,MAAUiL,QAIrE9C,EAAQsC,aAAetC,EAAQuC,MAAMvL,QACvCqK,EAAOhI,KAAK,+CAjBdgI,EAAOhI,KAAK,2BAuBZ2G,EAAQ+C,WACsB,iBAArB/C,EAAQ+C,SACjBzB,EAASjI,KAAK,iCAEV2G,EAAQ+C,SAASC,UAAYrQ,KAAKsQ,eAAejD,EAAQ+C,SAASC,UACpE1B,EAASjI,KAAK,oCAEZ2G,EAAQ+C,SAASG,WAAavQ,KAAKsQ,eAAejD,EAAQ+C,SAASG,WACrE5B,EAASjI,KAAK,uCAKb,CAAEgI,SAAQC,WACnB,CASA,YAAAqB,CAAatC,EAAMxI,GACjB,MAAMwJ,EAAS,GACTC,EAAW,GAEjB,IAAKjB,GAAwB,iBAATA,EAElB,OADAgB,EAAOhI,KAAK,+BACL,CAAEgI,SAAQC,YAInB,MAAMS,EAAgBpP,KAAKoN,gBAAgBM,KAAKJ,eAAe+B,OAC7DC,KAAWA,KAAS5B,IAwCtB,OAtCI0B,EAAc/K,OAAS,GACzBqK,EAAOhI,KAAK,4BAA4B0I,EAAcL,KAAK,cAIzC,IAAhBrB,EAAK8C,SACoB,iBAAhB9C,EAAK8C,QAAuB9C,EAAK8C,SAAWtL,GACrDwJ,EAAOhI,KAAK,wCAAwCxB,UAAcwI,EAAK8C,YAKvE9C,EAAK+B,OACkB,iBAAd/B,EAAK+B,KACdf,EAAOhI,KAAK,8BACHgH,EAAK+B,KAAKpL,OAASrE,KAAKoN,gBAAgBM,KAAKD,eACtDkB,EAASjI,KAAK,qCAAqC1G,KAAKoN,gBAAgBM,KAAKD,mBAK7EC,EAAK+C,SACFZ,MAAMC,QAAQpC,EAAK+C,SAGlB/C,EAAK+C,OAAOpM,SAAWrE,KAAKoN,gBAAgBM,KAAKC,eACnDe,EAAOhI,KAAK,0BAA0B1G,KAAKoN,gBAAgBM,KAAKC,wBAIlED,EAAK+C,OAAOxP,QAAQ,CAAC2M,EAAO8C,KAC1B,MAAMC,EAAkB3Q,KAAK4Q,cAAchD,EAAO8C,GAClDhC,EAAOhI,QAAQiK,EAAgBjC,OAAOuB,IAAIC,GAAO,SAASQ,MAAeR,MACzEvB,EAASjI,QAAQiK,EAAgBhC,SAASsB,IAAIE,GAAQ,SAASO,MAAeP,SAVhFzB,EAAOhI,KAAK,4BAeT,CAAEgI,SAAQC,WACnB,CASA,aAAAiC,CAAchD,EAAO1I,GACnB,MAAMwJ,EAAS,GACTC,EAAW,GAEjB,IAAKf,GAA0B,iBAAVA,EAEnB,OADAc,EAAOhI,KAAK,gCACL,CAAEgI,SAAQC,YAInB,MAAMS,EAAgBpP,KAAKoN,gBAAgBQ,MAAMN,eAAe+B,OAC9DC,KAAWA,KAAS1B,IAwCtB,OAtCIwB,EAAc/K,OAAS,GACzBqK,EAAOhI,KAAK,4BAA4B0I,EAAcL,KAAK,cAIpC,IAArBnB,EAAM8C,aACwB,iBAArB9C,EAAM8C,YAA2B9C,EAAM8C,aAAexL,GAC/DwJ,EAAOhI,KAAK,+CAA+CxB,UAAc0I,EAAM8C,qBAK9D,IAAjB9C,EAAMiD,QAAyC,OAAjBjD,EAAMiD,SACV,iBAAjBjD,EAAMiD,QAAsD,IAA/BjD,EAAMiD,OAAOrB,OAAOnL,OAC1DsK,EAASjI,KAAK,gDACJ,iBAAiBoK,KAAKlD,EAAMiD,SACtClC,EAASjI,KAAK,kCAAkCkH,EAAMiD,WAKtDjD,EAAMmD,QACHlB,MAAMC,QAAQlC,EAAMmD,QAGnBnD,EAAMmD,MAAM1M,SAAWrE,KAAKoN,gBAAgBQ,MAAMC,eACpDa,EAAOhI,KAAK,2BAA2B1G,KAAKoN,gBAAgBQ,MAAMC,uBAIpED,EAAMmD,MAAM9P,QAAQ,CAAC6B,EAAMR,KACL,kBAATQ,GACT4L,EAAOhI,KAAK,QAAQpE,gCATxBoM,EAAOhI,KAAK,2BAeT,CAAEgI,SAAQC,WACnB,CAQA,eAAAM,CAAgB5B,GACd,MAAMuB,EAAQ,GACRD,EAAW,GACXqC,EAAYC,KAAKC,MAAMD,KAAKE,UAAU9D,IAE5C,IAiBE,GAfK2D,EAAUzB,IAA8B,iBAAjByB,EAAUzB,KACpCyB,EAAUzB,GAAKvP,KAAKoR,oBACpBxC,EAAMlI,KAAK,6BAIRsK,EAAUvB,MAAkC,iBAAnBuB,EAAUvB,KAG7BuB,EAAUvB,KAAKpL,OAASrE,KAAKoN,gBAAgBC,QAAQI,gBAC9DuD,EAAUvB,KAAOuB,EAAUvB,KAAK4B,UAAU,EAAGrR,KAAKoN,gBAAgBC,QAAQI,eAC1EmB,EAAMlI,KAAK,8CAJXsK,EAAUvB,KAAO,mBACjBb,EAAMlI,KAAK,6BAOgB,iBAAlBsK,EAAUvJ,KAAoBiI,MAAMsB,EAAUvJ,KACvDuJ,EAAUvJ,IAAM,IAChBmH,EAAMlI,KAAK,8BACN,CACL,MAAM1B,IAAEA,EAAAmG,IAAKA,GAAQnL,KAAKoN,gBAAgBC,QAAQE,SAC9CyD,EAAUvJ,IAAMzC,GAClBgM,EAAUvJ,IAAMzC,EAChB4J,EAAMlI,KAAK,kCAAkC1B,OACpCgM,EAAUvJ,IAAM0D,IACzB6F,EAAUvJ,IAAM0D,EAChByD,EAAMlI,KAAK,kCAAkCyE,MAEjD,EAGqC,iBAA1B6F,EAAUrB,aAA4BqB,EAAUrB,YAAc,KACvEqB,EAAUrB,YAAc,EACxBf,EAAMlI,KAAK,4BAIRmJ,MAAMC,QAAQkB,EAAUpB,QAKI,IAA3BoB,EAAUpB,MAAMvL,SAClB2M,EAAUpB,MAAQ5P,KAAKsR,qBACvB1C,EAAMlI,KAAK,oCAIbsK,EAAUpB,MAAM3O,QAAQ,CAACyM,EAAMxI,KAC7B,MAAMqM,EAAavR,KAAKwR,aAAa9D,EAAMxI,GAC3C8L,EAAUpB,MAAM1K,GAASqM,EAAW7D,KACpCkB,EAAMlI,QAAQ6K,EAAW3C,MAAMqB,IAAIwB,GAAO,QAAQvM,MAAUuM,MAC5D9C,EAASjI,QAAQ6K,EAAW5C,SAASsB,IAAIE,GAAQ,QAAQjL,MAAUiL,QAIjEa,EAAUrB,aAAeqB,EAAUpB,MAAMvL,SAC3C2M,EAAUrB,YAAc,EACxBf,EAAMlI,KAAK,8CApBbsK,EAAUpB,MAAQ5P,KAAKsR,qBACvB1C,EAAMlI,KAAK,oCAwBRsK,EAAUZ,UAA0C,iBAAvBY,EAAUZ,WAC1CY,EAAUZ,SAAW,GACrBxB,EAAMlI,KAAK,0BAGb,MAAMxE,GAAA,IAAUwP,MAAOC,cASvB,OARKX,EAAUZ,SAASC,SAAYrQ,KAAKsQ,eAAeU,EAAUZ,SAASC,WACzEW,EAAUZ,SAASC,QAAUnO,EAC7B0M,EAAMlI,KAAK,sBAGbsK,EAAUZ,SAASG,SAAWrO,EAC9B0M,EAAMlI,KAAK,6BAEJ,CAAE2G,QAAS2D,EAAWpC,QAAOD,WAEtC,OAASxM,GAEP,OADAwM,EAASjI,KAAK,uBAAuBvE,EAAMgN,WACpC,CAAE9B,QAAS2D,EAAWpC,QAAOD,WACtC,CACF,CASA,YAAA6C,CAAa9D,EAAMxI,GACjB,MAAM0J,EAAQ,GACRD,EAAW,GACXqC,EAAY,IAAKtD,GAkBvB,GAfgC,iBAArBsD,EAAUR,QAAuBQ,EAAUR,SAAWtL,IAC/D8L,EAAUR,OAAStL,EACnB0J,EAAMlI,KAAK,kBAIRsK,EAAUvB,MAAkC,iBAAnBuB,EAAUvB,KAG7BuB,EAAUvB,KAAKpL,OAASrE,KAAKoN,gBAAgBM,KAAKD,gBAC3DuD,EAAUvB,KAAOuB,EAAUvB,KAAK4B,UAAU,EAAGrR,KAAKoN,gBAAgBM,KAAKD,eACvEmB,EAAMlI,KAAK,yBAJXsK,EAAUvB,KAAO,QAAQmC,OAAOC,aAAa,GAAK3M,KAClD0J,EAAMlI,KAAK,0BAORmJ,MAAMC,QAAQkB,EAAUP,QAGtB,CAEL,KAAOO,EAAUP,OAAOpM,OAASrE,KAAKoN,gBAAgBM,KAAKC,eACzDqD,EAAUP,OAAO/J,KAAK1G,KAAK8R,mBAAmBd,EAAUP,OAAOpM,SAC/DuK,EAAMlI,KAAK,wBAAuBsK,EAAUP,OAAOpM,OAAS,IAG1D2M,EAAUP,OAAOpM,OAASrE,KAAKoN,gBAAgBM,KAAKC,gBACtDqD,EAAUP,OAASO,EAAUP,OAAOsB,MAAM,EAAG/R,KAAKoN,gBAAgBM,KAAKC,eACvEiB,EAAMlI,KAAK,0BAIbsK,EAAUP,OAAOxP,QAAQ,CAAC2M,EAAO8C,KAC/B,MAAMsB,EAAchS,KAAKiS,cAAcrE,EAAO8C,GAC9CM,EAAUP,OAAOC,GAAcsB,EAAYpE,MAC3CgB,EAAMlI,QAAQsL,EAAYpD,MAAMqB,IAAIwB,GAAO,SAASf,MAAee,MACnE9C,EAASjI,QAAQsL,EAAYrD,SAASsB,IAAIE,GAAQ,SAASO,MAAeP,OAE9E,MArBEa,EAAUP,OAASzQ,KAAKkS,sBACxBtD,EAAMlI,KAAK,0BAsBb,MAAO,CAAEgH,KAAMsD,EAAWpC,QAAOD,WACnC,CASA,aAAAsD,CAAcrE,EAAO1I,GACnB,MAAM0J,EAAQ,GACRD,EAAW,GACXqC,EAAY,IAAKpD,GAmBvB,GAhBoC,iBAAzBoD,EAAUN,YAA2BM,EAAUN,aAAexL,IACvE8L,EAAUN,WAAaxL,EACvB0J,EAAMlI,KAAK,2BAIY,IAArBsK,EAAUH,QAA6C,OAArBG,EAAUH,SACd,iBAArBG,EAAUH,QAA0D,IAAnCG,EAAUH,OAAOrB,OAAOnL,QAClE2M,EAAUH,OAAS,KACnBjC,EAAMlI,KAAK,4BACD,iBAAiBoK,KAAKE,EAAUH,SAC1ClC,EAASjI,KAAK,kCAAkCsK,EAAUH,WAKzDhB,MAAMC,QAAQkB,EAAUD,OAGtB,CAEL,KAAOC,EAAUD,MAAM1M,OAASrE,KAAKoN,gBAAgBQ,MAAMC,eACzDmD,EAAUD,MAAMrK,MAAK,GACrBkI,EAAMlI,KAAK,uBAAsBsK,EAAUD,MAAM1M,OAAS,IAGxD2M,EAAUD,MAAM1M,OAASrE,KAAKoN,gBAAgBQ,MAAMC,gBACtDmD,EAAUD,MAAQC,EAAUD,MAAMgB,MAAM,EAAG/R,KAAKoN,gBAAgBQ,MAAMC,eACtEe,EAAMlI,KAAK,yBAIbsK,EAAUD,MAAM9P,QAAQ,CAAC6B,EAAMR,KACT,kBAATQ,IACTkO,EAAUD,MAAMzO,GAAa6P,QAAQrP,GACrC8L,EAAMlI,KAAK,cAAcpE,kBAG/B,MArBE0O,EAAUD,MAAQ,IAAIlB,MAAM7P,KAAKoN,gBAAgBQ,MAAMC,eAAezH,MAAK,GAC3EwI,EAAMlI,KAAK,+BAsBb,MAAO,CAAEkH,MAAOoD,EAAWpC,QAAOD,WACpC,CAOA,kBAAA2C,GACE,MAAM1B,EAAQ,GACd,IAAA,IAASxK,EAAI,EAAGA,EAAI,EAAGA,IACrBwK,EAAMlJ,KAAK,CACT8J,OAAQpL,EACRqK,KAAM,QAAQmC,OAAOC,aAAa,GAAKzM,KACvCqL,OAAQzQ,KAAKkS,wBAGjB,OAAOtC,CACT,CAOA,mBAAAsC,GACE,MAAMzB,EAAS,GACf,IAAA,IAASrL,EAAI,EAAGA,EAAIpF,KAAKoN,gBAAgBM,KAAKC,cAAevI,IAC3DqL,EAAO/J,KAAK1G,KAAK8R,mBAAmB1M,IAEtC,OAAOqL,CACT,CAQA,kBAAAqB,CAAmB5M,GACjB,MAAO,CACLwL,WAAYxL,EACZ2L,OAAQ,KACRE,MAAO,IAAIlB,MAAM7P,KAAKoN,gBAAgBQ,MAAMC,eAAezH,MAAK,GAEpE,CAOA,iBAAAgL,GACE,MAAO,mBAAmBM,KAAKxP,SAAS2C,KAAKuN,SAASC,SAAS,IAAIhB,UAAU,EAAG,IAClF,CAQA,cAAAf,CAAegC,GACb,GAA0B,iBAAfA,EAAyB,OAAO,EAC3C,MAAMC,EAAO,IAAIb,KAAKY,GACtB,OAAOC,aAAgBb,OAAShC,MAAM6C,EAAKC,YAAcD,EAAKZ,gBAAkBW,CAClF,CAMA,QAAAG,GACE,MAAO,IAAKzS,KAAK8N,YACnB,CAKA,UAAA4E,GACE1S,KAAK8N,YAAc,CACjBC,iBAAkB,EAClBC,qBAAsB,EACtBC,iBAAkB,EAEtB,GC/lBF,MAAM0E,EACJ,WAAA5S,GAEEC,KAAK4S,eAAiB,KAGtB5S,KAAK2P,YAAc,EAGnB3P,KAAKwN,SAAW,EAGhBxN,KAAK2N,cAAgB,GAGrB3N,KAAK6N,cAAgB,GAGrB7N,KAAK6S,oBAAsBvS,GAC7B,CAQA,aAAAwS,CAAcrD,EAAO,cAAehI,EAAM,KACxC,IACE,MAAM4F,EAAU,CACdkC,GAAIvP,KAAKoR,oBACT3B,OACAhI,MACAkI,YAAa,EACbC,MAAO5P,KAAKsR,qBACZlB,SAAU,CACRC,SAAA,IAAaqB,MAAOC,cACpBpB,UAAA,IAAcmB,MAAOC,gBAKnBoB,EAAmB5F,EAAwBe,oBAAoBb,EAAS,CAC5EgB,SAAS,EACTD,QAAQ,EACRE,cAAc,IAGhB,GAAKyE,EAAiBvE,QASpBxO,KAAK4S,eAAiBG,EAAiBtE,kBAAoBpB,MAT9B,CAG7B,IAAI0F,EAAiBtE,iBAGnB,MAAM,IAAI9F,MAAM,kCAFhB3I,KAAK4S,eAAiBG,EAAiBtE,gBAI3C,CAOA,OAHAzO,KAAK2P,YAAc,EACnB3P,KAAK6S,gBAAgBzQ,QAEd,CACL4Q,SAAS,EACT3F,QAASrN,KAAK4S,eACdhE,MAAOmE,EAAiBnE,OAAS,GACjCD,SAAUoE,EAAiBpE,UAAY,GAG3C,OAASxM,GAEP,MAAO,CACL6Q,SAAS,EACT7Q,MAAOA,EAAMgN,QACb9B,QAAS,KAEb,CACF,CAOA,kBAAAiE,GACE,MAAM1B,EAAQ,GAGd,IAAA,IAASqD,EAAY,EAAGA,EAAY,EAAGA,IAAa,CAClD,MAAMC,EAAWtB,OAAOC,aAAa,GAAKoB,GAE1CrD,EAAMlJ,KAAK,CACT8J,OAAQyC,EACRxD,KAAM,QAAQyD,IACdzC,OAAQzQ,KAAKkS,uBAEjB,CAEA,OAAOtC,CACT,CAOA,mBAAAsC,GACE,MAAMzB,EAAS,GAEf,IAAA,IAASC,EAAa,EAAGA,EAAa1Q,KAAK2N,cAAe+C,IACxDD,EAAO/J,KAAK,CACVgK,aACAG,OAAQ,KACRE,MAAO,IAAIlB,MAAM7P,KAAK6N,eAAezH,MAAK,KAI9C,OAAOqK,CACT,CAQA,UAAA0C,CAAWzC,EAAYpO,GACrB,IAAKtC,KAAK4S,eACR,MAAM,IAAIjK,MAAM,kCAGlB,GAAI+H,EAAa,GAAKA,GAAc1Q,KAAK2N,cACvC,MAAM,IAAIhF,MAAM,sCAAqC3I,KAAK2N,cAAgB,IAG5E,GAAIrL,EAAY,GAAKA,GAAatC,KAAK6N,cACrC,MAAM,IAAIlF,MAAM,qCAAoC3I,KAAK6N,cAAgB,IAG3E,MAAMuF,EAAkBpT,KAAKqT,qBAC7B,IAAKD,EACH,MAAM,IAAIzK,MAAM,+BAGlB,MAAMiF,EAAQwF,EAAgB3C,OAAOC,GACrC,IAAK9C,EACH,MAAM,IAAIjF,MAAM,SAAS+H,+BAI3B9C,EAAMmD,MAAMzO,IAAcsL,EAAMmD,MAAMzO,GAGtCtC,KAAK4S,eAAexC,SAASG,UAAA,IAAemB,MAAOC,aACrD,CASA,OAAA2B,CAAQ5C,EAAYpO,EAAWiR,GAC7B,IAAKvT,KAAK4S,eACR,MAAM,IAAIjK,MAAM,kCAGlB,GAAI+H,EAAa,GAAKA,GAAc1Q,KAAK2N,cACvC,MAAM,IAAIhF,MAAM,sCAAqC3I,KAAK2N,cAAgB,IAG5E,GAAIrL,EAAY,GAAKA,GAAatC,KAAK6N,cACrC,MAAM,IAAIlF,MAAM,qCAAoC3I,KAAK6N,cAAgB,IAG3E,MAAMuF,EAAkBpT,KAAKqT,qBAC7B,IAAKD,EACH,MAAM,IAAIzK,MAAM,+BAGlB,MAAMiF,EAAQwF,EAAgB3C,OAAOC,GACrC,IAAK9C,EACH,MAAM,IAAIjF,MAAM,SAAS+H,+BAI3B9C,EAAMmD,MAAMzO,GAAaiR,EAGzBvT,KAAK4S,eAAexC,SAASG,UAAA,IAAemB,MAAOC,aACrD,CAQA,OAAA6B,CAAQ9C,EAAYpO,GAClB,IAAKtC,KAAK4S,eACR,OAAO,EAGT,MAAMQ,EAAkBpT,KAAKqT,qBAC7B,IAAKD,EACH,OAAO,EAGT,MAAMxF,EAAQwF,EAAgB3C,OAAOC,GACrC,SAAK9C,GAAStL,EAAY,GAAKA,GAAasL,EAAMmD,MAAM1M,SAIjDuJ,EAAMmD,MAAMzO,EACrB,CAOA,UAAAmR,CAAWR,GACT,IAAKjT,KAAK4S,eACR,MAAM,IAAIjK,MAAM,kCAGlB,GAAIsK,EAAY,GAAKA,GAAajT,KAAK4S,eAAehD,MAAMvL,OAC1D,MAAM,IAAIsE,MAAM,qCAAoC3I,KAAK4S,eAAehD,MAAMvL,OAAS,IAGzFrE,KAAK2P,YAAcsD,EACnBjT,KAAK4S,eAAejD,YAAcsD,EAGlCjT,KAAK4S,eAAexC,SAASG,UAAA,IAAemB,MAAOC,aACrD,CAMA,kBAAA0B,GACE,OAAKrT,KAAK4S,gBAAmB5S,KAAK4S,eAAehD,OAI1C5P,KAAK4S,eAAehD,MAAM5P,KAAK2P,cAH7B,IAIX,CAQA,iBAAA+D,CAAkB7C,EAAQH,GACxB,IAAK1Q,KAAK4S,eACR,MAAM,IAAIjK,MAAM,kCAGlB,GAAI+H,EAAa,GAAKA,GAAc1Q,KAAK2N,cACvC,MAAM,IAAIhF,MAAM,sCAAqC3I,KAAK2N,cAAgB,IAG5E,MAAMyF,EAAkBpT,KAAKqT,qBAC7B,IAAKD,EACH,MAAM,IAAIzK,MAAM,+BAGlB,MAAMiF,EAAQwF,EAAgB3C,OAAOC,GACrC,IAAK9C,EACH,MAAM,IAAIjF,MAAM,SAAS+H,+BAIvB9C,EAAMiD,QACR7Q,KAAK6S,gBAAgBvR,OAAOsM,EAAMiD,QAIpCjD,EAAMiD,OAASA,EACXA,GACF7Q,KAAK6S,gBAAgBhR,IAAIgP,EAAQH,GAInC1Q,KAAK4S,eAAexC,SAASG,UAAA,IAAemB,MAAOC,aACrD,CAOA,eAAAgC,CAAgBC,GACd,IAAK5T,KAAK4S,iBAAmB/C,MAAMC,QAAQ8D,GACzC,OAIF5T,KAAK6S,gBAAgBzQ,QAGrB,MAAMyR,EAAc7T,KAAK8T,iBAAiBF,GAG1C1Q,OAAOlC,QAAQ6S,GAAa5S,QAAQ,EAAE8S,EAAYC,MAChD,MAAMf,EAAYc,EAAWE,WAAW,GAAK,GAE7C,GAAIhB,GAAa,GAAKA,EAAYjT,KAAK4S,eAAehD,MAAMvL,OAAQ,CAClE,MAAM6P,EAAWlU,KAAK4S,eAAehD,MAAMqD,GAE3Ce,EAAU/S,QAAQ,CAACkT,EAAMjP,KACvB,GAAIA,EAAQlF,KAAK2N,cAAe,CAChBuG,EAASzD,OAAOvL,GACxB2L,OAASsD,EAAKC,MACpBpU,KAAK6S,gBAAgBhR,IAAIsS,EAAKC,MAAOlP,EACvC,GAEJ,IAIFlF,KAAK4S,eAAexC,SAASG,UAAA,IAAemB,MAAOC,aACrD,CAQA,gBAAAmC,CAAiBF,GACf,MAAMS,EAAU,CAAA,EAqBhB,OAnBAT,EAAM3S,QAAQkT,IACZ,GAAIA,EAAKC,OAA+B,iBAAfD,EAAKC,MAAoB,CAChD,MAAML,EAAaI,EAAKC,MAAME,OAAO,GAAGC,cACnCF,EAAQN,KACXM,EAAQN,GAAc,IAExBM,EAAQN,GAAYrN,KAAKyN,EAC3B,IAIFjR,OAAOsR,KAAKH,GAASpT,QAAQ8S,IAC3BM,EAAQN,GAAYU,KAAK,CAACC,EAAGC,KACdC,SAASF,EAAEN,MAAMrC,MAAM,KAAO,IAC9B6C,SAASD,EAAEP,MAAMrC,MAAM,KAAO,MAKxCsC,CACT,CAOA,eAAAQ,CAAgBnE,GACd,MAAM0C,EAAkBpT,KAAKqT,qBAC7B,IAAKD,EACH,OAAO,KAGT,MAAMxF,EAAQwF,EAAgB3C,OAAOC,GACrC,OAAO9C,EAAQA,EAAMiD,OAAS,IAChC,CAOA,eAAAiE,CAAgBjE,GACd,OAAO7Q,KAAK6S,gBAAgBkC,IAAIlE,IAAW,IAC7C,CAOA,qBAAAmE,CAAsB1S,GACpB,MAAM8Q,EAAkBpT,KAAKqT,qBAC7B,IAAKD,EACH,MAAO,GAGT,MAAM6B,EAAe,GAWrB,OATA7B,EAAgB3C,OAAOxP,QAAQ,CAAC2M,EAAO8C,KACjC9C,EAAMmD,MAAMzO,IAAcsL,EAAMiD,QAClCoE,EAAavO,KAAK,CAChBgK,aACAG,OAAQjD,EAAMiD,WAKboE,CACT,CAMA,gBAAAC,GACE,MAAM9B,EAAkBpT,KAAKqT,qBACxBD,IAILA,EAAgB3C,OAAOxP,QAAQ2M,IAC7BA,EAAMmD,MAAM3K,MAAK,KAInBpG,KAAK4S,eAAexC,SAASG,UAAA,IAAemB,MAAOC,cACrD,CAMA,aAAAwD,GACOnV,KAAK4S,iBAIV5S,KAAK4S,eAAehD,MAAM3O,QAAQyM,IAChCA,EAAK+C,OAAOxP,QAAQ2M,IAClBA,EAAMmD,MAAM3K,MAAK,OAKrBpG,KAAK4S,eAAexC,SAASG,UAAA,IAAemB,MAAOC,cACrD,CAMA,iBAAAyD,GACE,OAAOpV,KAAK4S,cACd,CAQA,iBAAAyC,CAAkBhI,EAASc,EAAU,IACnC,MAAME,QACJA,GAAU,EAAAD,OACVA,GAAS,EAAAE,aACTA,GAAe,GACbH,EAEJ,IAAKd,EAIH,OAHArN,KAAK4S,eAAiB,KACtB5S,KAAK2P,YAAc,EACnB3P,KAAK6S,gBAAgBzQ,QACd,CAAE4Q,SAAS,EAAM3F,QAAS,MAGnC,IAEE,MAAM0F,EAAmB5F,EAAwBe,oBAAoBb,EAAS,CAC5EgB,UACAD,SACAE,iBAGF,IAAKyE,EAAiBvE,QAAS,CAC7B,MAAM8G,EAAe,8BAA8BvC,EAAiBrE,OAAOK,KAAK,QAEhF,GAAIT,EACF,MAAM,IAAI3F,MAAM2M,GAIlB,MAAO,CACLtC,SAAS,EACTtE,OAAQqE,EAAiBrE,OACzBC,SAAUoE,EAAiBpE,SAC3BtB,QAAS,KAEb,CAeA,OAZArN,KAAK4S,eAAiBG,EAAiBtE,iBACvCzO,KAAK2P,YAAc3P,KAAK4S,eAAejD,aAAe,EACtD3P,KAAKuV,yBAGDxC,EAAiBnE,MAAMvK,OAGvB0O,EAAiBpE,SAAStK,OAIvB,CACL2O,SAAS,EACT3F,QAASrN,KAAK4S,eACdhE,MAAOmE,EAAiBnE,MACxBD,SAAUoE,EAAiBpE,SAG/B,OAASxM,GAGP,GAAImM,EACF,MAAMnM,EAGR,MAAO,CACL6Q,SAAS,EACTtE,OAAQ,CAACvM,EAAMgN,SACf9B,QAAS,KAEb,CACF,CAOA,sBAAAkI,GACEvV,KAAK6S,gBAAgBzQ,QAEhBpC,KAAK4S,gBAIV5S,KAAK4S,eAAehD,MAAM3O,QAAQyM,IAChCA,EAAK+C,OAAOxP,QAAQ,CAAC2M,EAAO8C,KACtB9C,EAAMiD,QACR7Q,KAAK6S,gBAAgBhR,IAAI+L,EAAMiD,OAAQH,MAI/C,CAOA,eAAA8E,CAAgBnI,GACd,IAAKA,GAA8B,iBAAZA,EACrB,OAAO,EAIT,IAAKA,EAAQkC,IAA4B,iBAAflC,EAAQkC,GAChC,OAAO,EAGT,IAAKlC,EAAQoC,MAAgC,iBAAjBpC,EAAQoC,KAClC,OAAO,EAGT,GAA2B,iBAAhBpC,EAAQ5F,KAAoB4F,EAAQ5F,IAAM,IAAM4F,EAAQ5F,IAAM,IACvE,OAAO,EAGT,GAAmC,iBAAxB4F,EAAQsC,aAA4BtC,EAAQsC,YAAc,EACnE,OAAO,EAIT,IAAKE,MAAMC,QAAQzC,EAAQuC,QAAmC,IAAzBvC,EAAQuC,MAAMvL,OACjD,OAAO,EAIT,IAAA,MAAWqJ,KAAQL,EAAQuC,MACzB,IAAK5P,KAAKgQ,aAAatC,GACrB,OAAO,EAIX,OAAO,CACT,CAQA,YAAAsC,CAAatC,GACX,IAAKA,GAAwB,iBAATA,EAClB,OAAO,EAGT,GAA2B,iBAAhBA,EAAK8C,QAAuB9C,EAAK8C,OAAS,EACnD,OAAO,EAGT,IAAK9C,EAAK+B,MAA6B,iBAAd/B,EAAK+B,KAC5B,OAAO,EAGT,IAAKI,MAAMC,QAAQpC,EAAK+C,SAAW/C,EAAK+C,OAAOpM,SAAWrE,KAAK2N,cAC7D,OAAO,EAIT,IAAA,MAAWC,KAASF,EAAK+C,OACvB,IAAKzQ,KAAK4Q,cAAchD,GACtB,OAAO,EAIX,OAAO,CACT,CAQA,aAAAgD,CAAchD,GACZ,IAAKA,GAA0B,iBAAVA,EACnB,OAAO,EAGT,GAAgC,iBAArBA,EAAM8C,YAA2B9C,EAAM8C,WAAa,EAC7D,OAAO,EAGT,IAAKb,MAAMC,QAAQlC,EAAMmD,QAAUnD,EAAMmD,MAAM1M,SAAWrE,KAAK6N,cAC7D,OAAO,EAIT,IAAA,MAAW/K,KAAQ8K,EAAMmD,MACvB,GAAoB,kBAATjO,EACT,OAAO,EAIX,OAAO,CACT,CAOA,iBAAAsO,GACE,MAAO,mBAAmBM,KAAKxP,SAAS2C,KAAKuN,SAASC,SAAS,IAAIoD,OAAO,EAAG,IAC/E,CAMA,eAAAC,GACE,IAAK1V,KAAK4S,eACR,MAAO,CACL+C,WAAY,EACZC,YAAa,EACbC,eAAgB,EAChBC,YAAa,GAIjB,IAAIH,EAAa,EACbC,EAAc,EACdC,EAAiB,EACjBC,EAAc,EAmBlB,OAjBA9V,KAAK4S,eAAehD,MAAM3O,QAAQyM,IAChCA,EAAK+C,OAAOxP,QAAQ2M,IAClBkI,IACAH,GAAc/H,EAAMmD,MAAM1M,OAEtBuJ,EAAMiD,QACRgF,IAGFjI,EAAMmD,MAAM9P,QAAQ6B,IACdA,GACF8S,UAMD,CACLD,aACAC,cACAC,iBACAC,cAEJ,CAMA,OAAAC,GACE/V,KAAK4S,eAAiB,KACtB5S,KAAK6S,gBAAgBzQ,QACrBpC,KAAK2P,YAAc,CAGrB,ECjtBF,MAAMqG,EACJ,WAAAjW,GAEEC,KAAK6H,cAAgB,KAGrB7H,KAAKiW,aAAc,EAGnBjW,KAAKkW,YAAa,EAGlBlW,KAAKmW,kBAAoB,KAGzBnW,KAAKoW,SAAW,GAGhBpW,KAAKqW,aAAe,EAGpBrW,KAAKsW,kBAAmB,EAGxBtW,KAAKuW,eAAiB,GAGtBvW,KAAKwW,qBAAuB,GAG5BxW,KAAKyW,MAAQ,CACXC,WAAY,EACZC,gBAAiB,EACjBC,YAAa,EACbC,mBAAoB,EACpBC,kBAAmB,EACnBC,eAAgB,GAIlB/W,KAAKgX,kBAAoB,CACvBC,uBAAwB,GACxBC,kBAAmB,KACnBC,qBAAsB,KAIxBnX,KAAKoX,eAAiB,GAGtBpX,KAAKqX,kBAAoB,IAC3B,CAOA,OAAA3N,CAAQ7B,GACN,IAAKA,EAEH,OAAO,EAuBT,MAnBwB,CAAC,SAAU,iBAAkB,kBACdwH,OAAOiI,GACX,mBAA1BzP,EAAcyP,IAGJjT,OAKnBrE,KAAK6H,cAAgBA,EACrB7H,KAAKiW,aAAc,EAGfjW,KAAKkW,YACPlW,KAAKuX,iBAAiB,sCAIjB,CACT,CAMA,UAAArQ,GACElH,KAAK6H,cAAgB,KACrB7H,KAAKiW,aAAc,EACnBjW,KAAKsW,kBAAmB,CAG1B,CASA,qBAAMzK,CAAgBC,EAAW0L,GAAY,EAAMzL,GAAmB,GAEpE,GAAI/L,KAAKkW,WAEP,OAAO,EAIT,GAAyB,iBAAdpK,GAA0B4D,MAAM5D,IAAcA,EAAY,EAEnE,OAAO,EAGT,IAAK9L,KAAKiW,cAAgBjW,KAAK6H,cAE7B,OAAO,EAGT,IAAK2P,EAEH,OAAO,EAILxX,KAAKsW,iBAIT,MAAMtU,EAAYC,YAAYC,MAC9BlC,KAAKsW,kBAAmB,EACxBtW,KAAKyW,MAAMC,aAEX,IAEE,MAAMe,EAAczX,KAAK6H,cAAcoE,iBACvC,IAAoB,IAAhBwL,EAEF,OADAzX,KAAK0X,kBAAkB,kCAChB,EAIT,MAAM1L,EAA6B,IAAhByL,EAGnBzX,KAAK6H,cAAcqE,OAAOJ,GAAW,GACrC9L,KAAKqW,aAAevK,EAGhBC,UAEI,IAAII,QAAQC,GAAW3G,WAAW2G,EAAS,KAE7CJ,GAAsD,IAAxChM,KAAK6H,cAAcoE,iBAEnCjM,KAAK6H,cAAcwE,YACTL,GAAsD,IAAxChM,KAAK6H,cAAcoE,kBAE3CjM,KAAK6H,cAAc8P,cAKvB,MAAMC,EAAU3V,YAAYC,MAAQF,EAKpC,OAJAhC,KAAK6X,kBAAkBD,GACvB5X,KAAKyW,MAAME,kBACX3W,KAAK8X,uBAEE,CAET,OAAS3V,GAEP,OADAnC,KAAK0X,kBAAkB,gBAAgBvV,EAAMgN,YACtC,CACT,CAAA,QACEnP,KAAKsW,kBAAmB,CAC1B,CACF,CAQA,eAAAyB,CAAgBjM,GAEd,GAAyB,iBAAdA,GAA0B4D,MAAM5D,IAAcA,EAAY,EACnE,OAAO,EAGT,IAAK9L,KAAKiW,cAAgBjW,KAAK6H,cAC7B,OAAO,EAGT,IAOE,OALA7H,KAAK6H,cAAcqE,OAAOJ,GAAW,GACrC9L,KAAKqW,aAAevK,EACpB9L,KAAKyW,MAAMC,aACX1W,KAAKyW,MAAME,mBAEJ,CACT,OAASxU,GAEP,MAAMA,CACR,CACF,CAOA,iBAAAuV,CAAkBpC,GAChBtV,KAAKgY,SAAS1C,GACdtV,KAAKyW,MAAMG,cAGX5W,KAAKoX,eAAe1Q,KAAK,CACvBoF,UAAW4F,KAAKxP,MAChBC,MAAOmT,IAIT,MAAMpT,EAAMwP,KAAKxP,MACjBlC,KAAKoX,eAAiBpX,KAAKoX,eAAe/H,OACxC4I,GAAW/V,EAAM+V,EAAQnM,UAAY9L,KAAKgX,kBAAkBE,mBAI1DlX,KAAKoX,eAAe/S,QAAUrE,KAAKgX,kBAAkBC,wBACvDjX,KAAKkY,kBAAkB,qCAE3B,CAMA,iBAAAA,CAAkBC,GACZnY,KAAKkW,aAMTlW,KAAKkW,YAAa,EAClBlW,KAAKmW,kBAAoBgC,EACzBnY,KAAKyW,MAAMK,oBAGX9W,KAAKwW,qBAAqBvV,QAAQyL,IAChC,IACEA,EAAS,CACPxC,KAAM,cACNiO,SACArM,UAAW4F,KAAKxP,OAEpB,OAASC,GAET,IAIFnC,KAAKoY,uBACP,CAMA,gBAAAb,CAAiBY,EAAS,mBACnBnY,KAAKkW,aAMVlW,KAAKkW,YAAa,EAClBlW,KAAKmW,kBAAoB,KACzBnW,KAAKyW,MAAMM,iBACX/W,KAAK8X,sBAGD9X,KAAKqX,oBACP7R,aAAaxF,KAAKqX,mBAClBrX,KAAKqX,kBAAoB,MAI3BrX,KAAKwW,qBAAqBvV,QAAQyL,IAChC,IACEA,EAAS,CACPxC,KAAM,WACNiO,SACArM,UAAW4F,KAAKxP,OAEpB,OAASC,GAET,IAEJ,CAMA,oBAAAiW,GACMpY,KAAKqX,mBACP7R,aAAaxF,KAAKqX,mBAGpBrX,KAAKqX,kBAAoB5R,WAAW4S,gBAGVrY,KAAKsY,kBAE3BtY,KAAKuX,iBAAiB,iCAItBvX,KAAKoY,wBAENpY,KAAKgX,kBAAkBG,qBAC5B,CAMA,mBAAAW,GACE9X,KAAKoX,eAAiB,EACxB,CAMA,cAAAmB,GACE,IAAKvY,KAAKiW,cAAgBjW,KAAK6H,cAC7B,OAAO,EAGT,IACE,OAAO7H,KAAK6H,cAAc0Q,kBAAoB,CAChD,OAASpW,GAEP,OADAnC,KAAKgY,SAAS,+BAA+B7V,EAAMgN,WAC5C,CACT,CACF,CAMA,cAAAlD,GACE,IAAKjM,KAAKiW,cAAgBjW,KAAK6H,cAC7B,OAAO,EAGT,IACE,OAAO7H,KAAK6H,cAAcoE,gBAC5B,OAAS9J,GAEP,OADAnC,KAAKgY,SAAS,+BAA+B7V,EAAMgN,YAC5C,CACT,CACF,CAMA,sBAAAqJ,GACE,IAAKxY,KAAKiW,cAAgBjW,KAAK6H,cAC7B,MAAO,CACLuB,OAAO,EACPwB,YAAa,EACb5E,SAAU,EACVsB,WAAW,EACXC,UAAU,EACVkR,aAAa,EACbC,SAAS,GAIb,IACE,MAAMtP,EAAQpJ,KAAK6H,cAAcoE,iBAC3BrB,EAAc5K,KAAK6H,cAAc0Q,kBAAoB,EAG3D,MAAO,CACLnP,QACAwB,cACA5E,SALehG,KAAK6H,cAAc8Q,eAAiB,EAMnDrR,UAAqB,IAAV8B,EACX7B,SAAoB,IAAV6B,EACVqP,YAAuB,IAAVrP,EACbsP,SAAmB,IAAVtP,EACTwP,QAAmB,IAAVxP,EAEb,OAASjH,GAEP,OADAnC,KAAKgY,SAAS,wCAAwC7V,EAAMgN,WACrD,CACL/F,OAAO,EACPwB,YAAa,EACb5E,SAAU,EACVsB,WAAW,EACXC,UAAU,EACVkR,aAAa,EACbC,SAAS,EACTE,SAAS,EAEb,CACF,CASA,sBAAMC,CAAiBC,GACrB,IAAK9Y,KAAKiW,cAAgBjW,KAAK6H,cAE7B,OADA7H,KAAKgY,SAAS,qDACP,EAGT,IACE,MAAMe,EAAe/Y,KAAKwY,yBAC1B,IAAIQ,GAAc,EAGlB,GAAuC,iBAA5BF,EAAYlO,YAA0B,CAI/C,GAHuB/F,KAAK2H,IAAIuM,EAAanO,YAAckO,EAAYlO,aAGlD,GAAK,OACE5K,KAAK6L,gBAC7BiN,EAAYlO,aACZ,OAC0B,IAA1BkO,EAAYxR,UAA0BwR,EAAYxR,UAAYyR,EAAazR,aAG3E0R,GAAc,EAElB,CACF,CAGA,GAAqC,kBAA1BF,EAAYxR,UAAyB,OAExC,IAAI6E,QAAQC,GAAW3G,WAAW2G,EAAS,MAEjD,MAAM6M,EAAejZ,KAAKwY,yBAEtBM,EAAYxR,YAAc2R,EAAa3R,UACzCtH,KAAK6H,cAAcwE,aAETyM,EAAYxR,WAAa2R,EAAa3R,WAChDtH,KAAK6H,cAAc8P,YAGvB,CAEA,OAAOqB,CACT,OAAS7W,GAEP,OADAnC,KAAKgY,SAAS,iCAAiC7V,EAAMgN,YAC9C,CACT,CACF,CAMA,aAAA+J,GACE,IAAKlZ,KAAKiW,cAAgBjW,KAAK6H,cAC7B,OAAO,EAGT,IAEE,OAAiB,IADH7H,KAAK6H,cAAcoE,gBAEnC,OAAS9J,GACP,OAAO,CACT,CACF,CAMA,SAAAgX,GACE,MAAO,CACLlD,YAAajW,KAAKiW,YAClBiD,cAAelZ,KAAKkZ,gBACpB5C,iBAAkBtW,KAAKsW,iBACvBJ,WAAYlW,KAAKkW,WACjBC,kBAAmBnW,KAAKmW,kBACxBE,aAAcrW,KAAKqW,aACnB+C,WAAYpZ,KAAKoW,SAAS/R,OAC1B+S,eAAgBpX,KAAKoX,eAAe/S,OACpCoS,MAAO,IAAKzW,KAAKyW,OAErB,CAOA,eAAA4C,CAAgBC,EAAQ,IACtB,OAAOtZ,KAAKoW,SAASrE,OAAOuH,EAC9B,CAMA,WAAAC,GACEvZ,KAAKoW,SAAW,EAClB,CAMA,OAAAoD,CAAQ9M,GACkB,mBAAbA,GACT1M,KAAKuW,eAAe7P,KAAKgG,EAE7B,CAMA,mBAAA+M,CAAoB/M,GAClB,MAAMxH,EAAQlF,KAAKuW,eAAe3J,QAAQF,GACtCxH,GAAQ,GACVlF,KAAKuW,eAAe1J,OAAO3H,EAAO,EAEtC,CAMA,aAAAwU,GACE,IAAK1Z,KAAKkW,WAER,OAAO,EAST,GAHAlW,KAAK8X,sBAGD9X,KAAK6H,eAA8D,mBAAtC7H,KAAK6H,cAAc0Q,eAClD,IAIE,OAFAvY,KAAK6H,cAAc0Q,iBACnBvY,KAAKuX,iBAAiB,6CACf,CACT,OAASpV,GAIP,OADAnC,KAAKuX,iBAAiB,uDACf,CACT,CAKF,OADAvX,KAAKuX,iBAAiB,kCACf,CACT,CAMA,qBAAAoC,GACM3Z,KAAKkW,aAEPlW,KAAK8X,sBACL9X,KAAKuX,iBAAiB,sCAE1B,CAMA,aAAAqC,CAAclN,GACY,mBAAbA,GACT1M,KAAKwW,qBAAqB9P,KAAKgG,EAEnC,CAMA,yBAAAmN,CAA0BnN,GACxB,MAAMxH,EAAQlF,KAAKwW,qBAAqB5J,QAAQF,GAC5CxH,GAAQ,GACVlF,KAAKwW,qBAAqB3J,OAAO3H,EAAO,EAE5C,CAMA,mBAAMwU,GAIJ,eADwB1Z,KAAKsY,qBAE3BtY,KAAKuX,iBAAiB,oBACf,EAIX,CAMA,oBAAMuC,GACJ,IAAK9Z,KAAKiW,cAAgBjW,KAAK6H,cAC7B,OAAO,EAGT,IAEsB7H,KAAKuY,iBACLvY,KAAKiM,iBAGzB,OAAO,CACT,OAAS9J,GAEP,OADAnC,KAAKgY,SAAS,2BAA2B7V,EAAMgN,YACxC,CACT,CACF,CAMA,qBAAMmJ,GACJ,IAAKtY,KAAK6H,cAER,OADA7H,KAAKgY,SAAS,+CACP,EAGT,IAIEhY,KAAKsW,kBAAmB,EAKxB,eAFyBtW,KAAK8Z,oBAM5B9Z,KAAKgY,SAAS,2DACP,EAEX,OAAS7V,GAEP,OADAnC,KAAKgY,SAAS,4BAA4B7V,EAAMgN,YACzC,CACT,CACF,CAOA,uBAAM4K,CAAkB5X,GACtBnC,KAAKgY,SAAS,0BAA0B7V,EAAMgN,WAK9C,OAHkBnP,KAAKga,oBAAoB7X,IAIzC,IAAK,aACL,IAAK,cACL,IAAK,eAaL,QAEE,aAAanC,KAAKsY,kBAXpB,IAAK,gBAEH,aAAatY,KAAKia,yBAEpB,IAAK,mBACL,IAAK,oBAEH,OAAO,EAMb,CAOA,mBAAAD,CAAoB7X,GAClB,MAAMgN,EAAUhN,EAAMgN,QAAQ+K,cAE9B,OAAI/K,EAAQgL,SAAS,SAAWhL,EAAQgL,SAAS,aACxC,aAELhL,EAAQgL,SAAS,UAAYhL,EAAQgL,SAAS,gBACzC,cAELhL,EAAQgL,SAAS,WAAahL,EAAQgL,SAAS,QAC1C,eAELhL,EAAQgL,SAAS,YAAchL,EAAQgL,SAAS,eAAiBhL,EAAQgL,SAAS,WAC7E,gBAELhL,EAAQgL,SAAS,eAAiBhL,EAAQgL,SAAS,cAAgBhL,EAAQgL,SAAS,gBAC/E,mBAELhL,EAAQgL,SAAS,gBAAkBhL,EAAQgL,SAAS,YAAchL,EAAQgL,SAAS,WAC9E,oBAGF,eACT,CAMA,4BAAMF,GACJ,IAOE,SAHM,IAAI9N,QAAQC,GAAW3G,WAAW2G,EAAS,OAG5CgO,UAAUC,OAEb,OADAra,KAAKgY,SAAS,yDACP,EAMT,eAFyBhY,KAAK8Z,oBAM5B9Z,KAAKgY,SAAS,uDACP,EAEX,OAAS7V,GAEP,OADAnC,KAAKgY,SAAS,oCAAoC7V,EAAMgN,YACjD,CACT,CACF,CAOA,2BAAAmL,CAA4BhF,GAC1B,MAAMiF,EAAc,CAClBC,WAAY,0BACZC,gBAAiB,2BACjBC,UAAU,GAkBZ,OAfIpF,EAAa6E,SAAS,kBAAoB7E,EAAa6E,SAAS,cAClEI,EAAYC,WAAa,oCACzBD,EAAYE,gBAAkB,kCACrBnF,EAAa6E,SAAS,SAAW7E,EAAa6E,SAAS,cAChEI,EAAYC,WAAa,8BACzBD,EAAYE,gBAAkB,4BACrBnF,EAAa6E,SAAS,UAC/BI,EAAYC,WAAa,oCACzBD,EAAYE,gBAAkB,yBACrBnF,EAAa6E,SAAS,YAAc7E,EAAa6E,SAAS,cACnEI,EAAYC,WAAa,iCACzBD,EAAYE,gBAAkB,8BAC9BF,EAAYG,UAAW,GAGlBH,CACT,CAMA,mBAAAI,GACE,MAAMC,EAAc5a,KAAKyW,MAAMC,WAAa,EACvC1W,KAAKyW,MAAME,gBAAkB3W,KAAKyW,MAAMC,WAAc,IACvD,EAEJ,MAAO,IACF1W,KAAKyW,MACRmE,YAAaA,EAAYC,QAAQ,GACjCC,WAAY,IAAMF,GAAaC,QAAQ,GAE3C,CAMA,UAAAnI,GACE1S,KAAKyW,MAAQ,CACXC,WAAY,EACZC,gBAAiB,EACjBC,YAAa,EACbC,mBAAoB,EAExB,CAOA,QAAAmB,CAAS7I,GACP,MAAM4L,EAAa,CACjBjP,WAAA,IAAe4F,MAAOC,cACtBxC,WAGFnP,KAAKoW,SAAS1P,KAAKqU,GAGf/a,KAAKoW,SAAS/R,OAAS,KACzBrE,KAAKoW,SAAWpW,KAAKoW,SAASrE,OAAM,KAMtC/R,KAAKuW,eAAetV,QAAQyL,IAC1B,IACEA,EAASqO,EACX,OAAS5Y,GAET,GAEJ,CAOA,iBAAA0V,CAAkBD,GAChB,MAAMoD,EAAQhb,KAAKyW,MAAMI,oBAAsB7W,KAAKyW,MAAME,gBAAkB,GAC5E3W,KAAKyW,MAAMI,oBAAsBmE,EAAQpD,GAAW5X,KAAKyW,MAAME,eACjE,CAMA,OAAAZ,GAEM/V,KAAKqX,oBACP7R,aAAaxF,KAAKqX,mBAClBrX,KAAKqX,kBAAoB,MAG3BrX,KAAKkH,aACLlH,KAAKuW,eAAiB,GACtBvW,KAAKwW,qBAAuB,GAC5BxW,KAAKoW,SAAW,GAChBpW,KAAKoX,eAAiB,GACtBpX,KAAK0S,aAEL1S,KAAKkW,YAAa,EAClBlW,KAAKmW,kBAAoB,IAG3B,EC14BF,MAAM8E,EACJ,WAAAlb,CAAYmb,GAEVlb,KAAKkb,eAAiBA,EAGtBlb,KAAKmb,aAAe,GAGpBnb,KAAKob,kBAAoB9a,IAGzBN,KAAKqb,uBAAyB,IAChC,CAOA,+BAAAC,CAAgC5O,GAC9B1M,KAAKqb,uBAAyB3O,CAChC,CAOA,WAAA6O,CAAY3H,GACV,IAAK/D,MAAMC,QAAQ8D,GAEjB,OAGF,MAAM4H,EAAgB,IAAIxb,KAAKmb,cAC/Bnb,KAAKmb,aAAe,IAAIvH,GAGxB,MAAM6H,EAAUzb,KAAK0b,kBAAkBF,EAAe5H,GAElD6H,EAAQE,MAAMtX,OAAS,GACzBrE,KAAK4b,eAAeH,EAAQE,OAG1BF,EAAQI,QAAQxX,OAAS,GAC3BrE,KAAK8b,mBAAmBL,EAAQI,SAG9BJ,EAAQlL,SAASlM,OAAS,GAC5BrE,KAAK+b,oBAAoBN,EAAQlL,UAIN,IAAzBiL,EAAcnX,QAAgBuP,EAAMvP,OAAS,GAC/CrE,KAAKkb,eAAevH,gBAAgB3T,KAAKmb,cAI3Cnb,KAAKgc,4BACP,CASA,iBAAAN,CAAkBF,EAAeL,GAC/B,MAAMM,EAAU,CACdE,MAAO,GACPE,QAAS,GACTtL,SAAU,IAIN0L,EAAc,IAAI3b,IAAIkb,EAAcvL,IAAIkE,GAAQ,CAACA,EAAKC,MAAOD,KAC7D+H,EAAa,IAAI5b,IAAI6a,EAAalL,IAAIkE,GAAQ,CAACA,EAAKC,MAAOD,KAGjE,IAAA,MAAWA,KAAQgH,EACZc,EAAYra,IAAIuS,EAAKC,QACxBqH,EAAQE,MAAMjV,KAAKyN,GAKvB,IAAA,MAAWA,KAAQqH,EACZU,EAAWta,IAAIuS,EAAKC,QACvBqH,EAAQI,QAAQnV,KAAKyN,GAKzB,IAAA,MAAWA,KAAQgH,EAAc,CAC/B,MAAMgB,EAAeF,EAAYlH,IAAIZ,EAAKC,OACtC+H,GAAgBnc,KAAKoc,eAAeD,EAAchI,IACpDsH,EAAQlL,SAAS7J,KAAK,CACpB2V,SAAUF,EACVG,QAASnI,GAGf,CAEA,OAAOsH,CACT,CASA,cAAAW,CAAeD,EAAcI,GAC3B,OACEJ,EAAana,YAAcua,EAAYva,WACvCma,EAAaK,UAAYD,EAAYC,SACrCL,EAAaM,QAAUF,EAAYE,KAEvC,CAQA,cAAAb,CAAec,GACR1c,KAAKkb,eAAe9F,qBAQzBpV,KAAKkb,eAAevH,gBAAgB3T,KAAKmb,aAG3C,CAQA,kBAAAW,CAAmBa,GACZ3c,KAAKkb,eAAe9F,qBAMzBuH,EAAa1b,QAAQkT,IAEHnU,KAAKkb,eAAe9F,oBAE5BxF,MAAM3O,QAAQ,CAACyM,EAAMuF,KAC3BvF,EAAK+C,OAAOxP,QAAQ,CAAC2M,EAAO8C,KAC1B,GAAI9C,EAAMiD,SAAWsD,EAAKC,MAAO,CAE/B,MAAMwI,EAAe5c,KAAKkb,eAAevL,YACzC3P,KAAKkb,eAAezH,WAAWR,GAC/BjT,KAAKkb,eAAexH,kBAAkB,KAAMhD,GAC5C1Q,KAAKkb,eAAezH,WAAWmJ,EAGjC,OAIR,CAQA,mBAAAb,CAAoBc,GAMlBA,EAAc5b,QAAQ,EAAGob,WAAUC,gBAMrC,CAQA,gBAAAxI,CAAiBF,GACf,MAAMS,EAAU,CAAA,EAwBhB,OAtBAT,EAAM3S,QAAQkT,IAEZ,IAAKA,GAAwB,iBAATA,IAAsBA,EAAKC,OAA+B,iBAAfD,EAAKC,MAClE,OAGF,MAAML,EAAaI,EAAKC,MAAME,OAAO,GAAGC,cACnCF,EAAQN,KACXM,EAAQN,GAAc,IAExBM,EAAQN,GAAYrN,KAAKyN,KAI3BjR,OAAOsR,KAAKH,GAASpT,QAAQ8S,IAC3BM,EAAQN,GAAYU,KAAK,CAACC,EAAGC,KACdC,SAASF,EAAEN,MAAMrC,MAAM,KAAO,IAC9B6C,SAASD,EAAEP,MAAMrC,MAAM,KAAO,MAKxCsC,CACT,CASA,iBAAAyI,CAAkBlJ,EAAOX,GACvB,MAAM5F,EAAUrN,KAAKkb,eAAe9F,oBAEpC,IAAK/H,IAAYA,EAAQuC,MAAMqD,GAE7B,OAGF,MAAMvF,EAAOL,EAAQuC,MAAMqD,GAG3BW,EAAM3S,QAAQ,CAACkT,EAAMjP,KACnB,GAAIA,EAAQwI,EAAK+C,OAAOpM,OAAQ,CAE9B,MAAM0Y,EAAanI,SAAST,EAAKC,MAAMrC,MAAM,KAAO,EAC9CiL,EAAmBnY,KAAKG,IAAI+X,EAAYrP,EAAK+C,OAAOpM,OAAS,GAK7DuY,EAAe5c,KAAKkb,eAAevL,YAIzC,GAHA3P,KAAKkb,eAAezH,WAAWR,GAG1BvF,EAAK+C,OAAOuM,GAAkBnM,OAG5B,CAEL,MAAMoM,EAAsBjd,KAAKkd,uBAAuBxP,IAC5B,IAAxBuP,GACFjd,KAAKkb,eAAexH,kBAAkBS,EAAKC,MAAO6I,EAKtD,MAXEjd,KAAKkb,eAAexH,kBAAkBS,EAAKC,MAAO4I,GAcpDhd,KAAKkb,eAAezH,WAAWmJ,EACjC,GAOJ,CAQA,sBAAAM,CAAuBxP,GACrB,IAAA,IAAStI,EAAI,EAAGA,EAAIsI,EAAK+C,OAAOpM,OAAQe,IACtC,IAAKsI,EAAK+C,OAAOrL,GAAGyL,OAClB,OAAOzL,EAGX,OAAO,CACT,CAOA,eAAAyP,CAAgBnE,GACd,MAAMG,EAAS7Q,KAAKkb,eAAerG,gBAAgBnE,GAEnD,OAAKG,GAIE7Q,KAAKmb,aAAagC,QAAahJ,EAAKC,QAAUvD,IAH5C,IAIX,CAMA,sBAAAuM,GAGE,IAFgBpd,KAAKkb,eAAe9F,oBAGlC,MAAO,GAGT,MAAMhC,EAAkBpT,KAAKkb,eAAe7H,qBAE5C,IAAKD,EACH,MAAO,GAGT,MAAMQ,EAAQ,GAWd,OATAR,EAAgB3C,OAAOxP,QAAQ2M,IAC7B,GAAIA,EAAMiD,OAAQ,CAChB,MAAMsD,EAAOnU,KAAKmb,aAAagC,QAAUE,EAAEjJ,QAAUxG,EAAMiD,QACvDsD,GACFP,EAAMlN,KAAKyN,EAEf,IAGKP,CACT,CAMA,yBAAA0J,GACE,MAAMlK,EAAkBpT,KAAKkb,eAAe7H,qBAE5C,OAAKD,EAIEA,EAAgB3C,OAAOR,IAAI,CAACrC,EAAO1I,KAAA,CACxCwL,WAAYxL,EACZ2L,OAAQjD,EAAMiD,OACdsD,KAAMvG,EAAMiD,OAAS7Q,KAAKmb,aAAagC,KAAKE,GAAKA,EAAEjJ,QAAUxG,EAAMiD,QAAU,QANtE,EAQX,CAMA,gBAAA0M,GACOvd,KAAKkb,eAAe9F,sBAQzBpV,KAAKwd,sBAGLxd,KAAKkb,eAAevH,gBAAgB3T,KAAKmb,cAGzCnb,KAAKgc,6BACP,CAMA,mBAAAwB,GACE,MAAMnQ,EAAUrN,KAAKkb,eAAe9F,oBAE/B/H,GAILA,EAAQuC,MAAM3O,QAAQyM,IACpBA,EAAK+C,OAAOxP,QAAQ,CAAC2M,EAAO8C,KACtB9C,EAAMiD,QACR7Q,KAAKkb,eAAexH,kBAAkB,KAAMhD,MAMpD,CAOA,0BAAAsL,GACE,GAAIhc,KAAKqb,uBAAwB,CAC/B,MAAMoC,EAAczd,KAAKsd,4BACzBtd,KAAKqb,uBAAuBoC,EAC9B,CACF,CAMA,mBAAAC,GACE,MAAMrQ,EAAUrN,KAAKkb,eAAe9F,oBAEpC,IAAK/H,EACH,MAAO,CACLsQ,WAAY3d,KAAKmb,aAAa9W,OAC9BuZ,cAAe,EACfC,gBAAiB7d,KAAKmb,aAAa9W,OACnCyR,YAAa,EACbD,eAAgB,GAIpB,IAAIC,EAAc,EACdD,EAAiB,EACrB,MAAMiI,MAAsB5d,IAY5B,OAVAmN,EAAQuC,MAAM3O,QAAQyM,IACpBA,EAAK+C,OAAOxP,QAAQ2M,IAClBkI,IACIlI,EAAMiD,SACRgF,IACAiI,EAAgB1c,IAAIwM,EAAMiD,aAKzB,CACL8M,WAAY3d,KAAKmb,aAAa9W,OAC9BuZ,cAAeE,EAAgBC,KAC/BF,gBAAiB7d,KAAKmb,aAAa9W,OAASyZ,EAAgBC,KAC5DjI,cACAD,iBAEJ,CAOA,kBAAAmI,CAAmBnN,GAIjB7Q,KAAKmb,aAAenb,KAAKmb,aAAa9L,OAAO8E,GAAQA,EAAKC,QAAUvD,GAGpE,MAAMH,EAAa1Q,KAAKkb,eAAepG,gBAAgBjE,GAEpC,OAAfH,GAEF1Q,KAAKkb,eAAexH,kBAAkB,KAAMhD,GAK9C1Q,KAAKgc,4BACP,CAOA,kBAAAiC,CAAmBC,GAIjB,MAAMC,EAAgBne,KAAKmb,aAAaiD,aAAkBjK,EAAKC,QAAU8J,EAAQ9J,QAC3D,IAAlB+J,EACFne,KAAKmb,aAAazU,KAAKwX,GAGvBle,KAAKmb,aAAagD,GAAiBD,EAIrCle,KAAK4b,eAAe,CAACsC,GACvB,CAOA,sBAAAG,CAAuBC,GAIrB,MAAMH,EAAgBne,KAAKmb,aAAaiD,aAAkBjK,EAAKC,QAAUkK,EAAalK,OACtF,IAAsB,IAAlB+J,EAAsB,CACxB,MAAMhC,EAAenc,KAAKmb,aAAagD,GACvCne,KAAKmb,aAAagD,GAAiBG,EAGnCte,KAAK+b,oBAAoB,CAAC,CACxBM,SAAUF,EACVG,QAASgC,IAEb,CACF,CAMA,OAAAvI,GACE/V,KAAKmb,aAAe,GACpBnb,KAAKob,cAAchZ,QACnBpC,KAAKqb,uBAAyB,IAGhC,ECnhBF,MAAMkD,EACJ,WAAAxe,GAEEC,KAAKwe,OAAS,IAAIrX,EAGlBnH,KAAKkb,eAAiB,IAAIvI,EAG1B3S,KAAKye,iBAAmB,IAAIzI,EAG5BhW,KAAK0e,gBAAkB,IAAIzD,EAAuBjb,KAAKkb,gBAGvDlb,KAAK2e,SAAW,IAAI7e,EAGpBE,KAAK8H,eAAgB,EAGrB9H,KAAK4e,cAAgBte,IAGrBN,KAAK2H,cAAgB,GAGrB3H,KAAK4H,qBAAuB,GAG5B5H,KAAKuW,eAAiB,GAGtBvW,KAAK6e,kBAAoB,CACvBC,mBAAoB,EACpBC,eAAgB,GAChBC,eAAgB,GAChBC,sBAAuB,KAIzBjf,KAAKkf,gBAAkBhf,IAGvBF,KAAKmf,gBAAkB,EAEvBnf,KAAKof,uBACLpf,KAAKqf,+BACP,CAQA,gBAAM3W,CAAWb,EAAe+L,EAAQ,IACtC,IAGE,WADgC5T,KAAKwe,OAAO9V,WAAWb,IAErD,MAAM,IAAIc,MAAM,gDAKlB,IADyB3I,KAAKye,iBAAiB/U,QAAQ7B,GAErD,MAAM,IAAIc,MAAM,8CAKlB,IADsB3I,KAAKkb,eAAepI,cAAc,mBACrCE,QACjB,MAAM,IAAIrK,MAAM,oCAiBlB,OAbA3I,KAAKsf,cAAc1L,GACnB5T,KAAKuf,8BAGLvf,KAAK0e,gBAAgBpD,gCAAiCmC,IACpDzd,KAAK2e,SAASld,eAAe,KAC3BzB,KAAKsL,kBAAkBtL,KAAKwe,OAAOxR,aAClC,sBAGLhN,KAAK0e,gBAAgBnD,YAAY3H,GAEjC5T,KAAK8H,eAAgB,GACd,CAET,OAAS3F,GAGP,OADAnC,KAAKwf,YAAYrd,IACV,CACT,CACF,CAOA,oBAAAid,GAEEpf,KAAKwe,OAAO/R,gBAAgB,CAACzB,EAAYI,KACvCpL,KAAKyf,oBAAoBzU,EAAYI,KAIvCpL,KAAKwe,OAAO1R,uBAAwB1D,IAClCpJ,KAAK2e,SAASld,eAAe,KAC3BzB,KAAKsL,kBAAkBlC,IACtB,SAASA,EAAM5B,eAAe4B,EAAM9B,cAE3C,CAOA,6BAAA+X,GAEE3U,YAAY,KACV1K,KAAK0f,wBACJ1f,KAAK6e,kBAAkBI,uBAG1BvU,YAAY,KACV1K,KAAK2f,sBACJ,IACL,CASA,mBAAAF,CAAoBzU,EAAYI,GAC9B,IACE,MAAMiC,EAAUrN,KAAKkb,eAAe9F,oBACpC,IAAK/H,EAAS,OAGd,MAAMuS,EAAiB5f,KAAK6f,yBAAyB7U,EAAYqC,GAG3DyS,EAAiB9f,KAAK6e,kBAAkBC,mBAAqB9e,KAAKkf,YAAYnB,KAChE6B,EAAe7N,MAAM,EAAG+N,GAGhC7e,QAAQ4P,IAClB7Q,KAAK+f,oBAAoBlP,EAAQzF,KAInCpL,KAAK2e,SAASld,eAAe,KAC3BzB,KAAK2H,cAAc1G,QAAQyL,IACzB,IACEA,EAAS1B,EAAYI,EACvB,OAASjJ,GAET,KAED,QAAQ6I,IAEb,OAAS7I,GAET,CACF,CASA,mBAAA4d,CAAoBlP,EAAQzF,GAC1B,MAAM4U,EAAWhgB,KAAK4e,UAAU7J,IAAIlE,GACpC,GAAKmP,EAEL,IAEEhgB,KAAKkf,YAAY9d,IAAIyP,GAGrB7Q,KAAKwe,OAAO3S,gBAAgBmU,EAAShe,WAAW,GAGhDyD,WAAW,KACTzF,KAAKkf,YAAY5d,OAAOuP,IACH,IAApBmP,EAASha,UAAmB,IAEjC,OAAS7D,GAEPnC,KAAKkf,YAAY5d,OAAOuP,EAC1B,CACF,CASA,wBAAAgP,CAAyB7U,EAAYqC,GACnC,MAAMuS,EAAiB,GAEvB,OAAKvS,EAAQoD,QAEbpD,EAAQoD,OAAOxP,QAAQ2M,IACrB,GAAIA,EAAMmD,OAASnD,EAAMmD,MAAM/F,IAAe4C,EAAMmD,MAAM/F,GAAYuI,OAAQ,CAC5E,MACM1C,EADc7Q,KAAK0e,gBAAgBuB,qBACdrS,EAAM2B,IAC7BsB,GACF+O,EAAelZ,KAAKmK,EAExB,IAGK+O,GAZqBA,CAa9B,CAQA,aAAAN,CAAc1L,GACZ5T,KAAK4e,UAAUxc,QAEfwR,EAAM3S,QAAQkT,IACZ,GAAIA,GAAQA,EAAK5E,GAAI,CAEnB,MAAM2Q,EAAgB,IACjB/L,EACHnO,SAAUmO,EAAKqI,QAAUrI,EAAKnS,UAC9Bme,aAAa,EACbC,YAAa1O,KAAKxP,OAGpBlC,KAAK4e,UAAU/c,IAAIsS,EAAK5E,GAAI2Q,EAC9B,GAEJ,CAOA,2BAAAX,GAEE,MAAMc,MAAgB/f,IAEtBN,KAAK4e,UAAU3d,QAAQ,CAACkT,EAAMtD,KAC5BwP,EAAUxe,IAAIgP,EAAQ,KAIFhB,MAAMyQ,KAAKD,EAAUrf,WACxCyT,KAAK,CAACC,EAAGC,IAAMA,EAAE,GAAKD,EAAE,IACxB3C,MAAM,EAAG/R,KAAK6e,kBAAkBC,oBAErB7d,QAAQ,EAAE4P,MACtB,MAAMsD,EAAOnU,KAAK4e,UAAU7J,IAAIlE,GAC5BsD,IACFA,EAAKoM,aAAc,IAGzB,CAOA,oBAAAb,GACE,MAAMxd,EAAMwP,KAAKxP,MAGjBlC,KAAKkf,YAAYje,QAAQ4P,IACvB,MAAMsD,EAAOnU,KAAK4e,UAAU7J,IAAIlE,GAC5BsD,GAAQjS,EAAMiS,EAAKiM,YAAc,KACnCpgB,KAAKkf,YAAY5d,OAAOuP,KAK5B7Q,KAAK2e,SAAS5X,0BAEd/G,KAAKmf,gBAAkBjd,CACzB,CAOA,kBAAAyd,GACE,MAAMa,EAAgBxgB,KAAKwe,OAAO1X,wBAC5B2Z,EAAgBzgB,KAAK2e,SAAS7X,wBAGhC0Z,EAAcpY,OAAS,GACzBpI,KAAK6e,kBAAkBC,mBAAqBja,KAAKsG,IAAI,EAAGnL,KAAK6e,kBAAkBC,mBAAqB,GAC3F0B,EAAcpY,OAAS,IAChCpI,KAAK6e,kBAAkBC,mBAAqBja,KAAKG,IAAI,EAAGhF,KAAK6e,kBAAkBC,mBAAqB,IAIlG0B,EAAcpY,OAAS,IAAMqY,EAAc9f,aAOjD,CAMA,KAAAoJ,GACE,IAAK/J,KAAK8H,cACR,MAAM,IAAIa,MAAM,+CAGlB3I,KAAKwe,OAAOzU,OACd,CAMA,IAAAwB,GACEvL,KAAKwe,OAAOjT,OACZvL,KAAKkf,YAAY9c,OACnB,CAMA,KAAAoJ,GACExL,KAAKwe,OAAOhT,OACd,CAMA,MAAAnC,GACErJ,KAAKwe,OAAOnV,QACd,CAOA,MAAAoC,CAAOhE,GACL,GAAIA,EAAM,IAAMA,EAAM,IACpB,MAAM,IAAIkB,MAAM,kCAGlB3I,KAAKwe,OAAO/S,OAAOhE,EACrB,CAMA,MAAAiZ,GACE,OAAO1gB,KAAKwe,OAAO/W,GACrB,CAMA,QAAAuF,GACE,MAAM2T,EAAc3gB,KAAKwe,OAAOxR,WAC1ByT,EAAgBzgB,KAAK2e,SAAS7X,wBAEpC,MAAO,IACF6Z,EACHzB,YAAalf,KAAKkf,YAAYnB,KAC9Bc,kBAAmB7e,KAAK6e,kBACxB4B,gBAEJ,CAOA,eAAAhU,CAAgBC,GACU,mBAAbA,GACT1M,KAAK2H,cAAcjB,KAAKgG,EAE5B,CAOA,kBAAAC,CAAmBD,GACjB,MAAMxH,EAAQlF,KAAK2H,cAAciF,QAAQF,GACrCxH,GAAQ,GACVlF,KAAK2H,cAAckF,OAAO3H,EAAO,EAErC,CAOA,sBAAA4H,CAAuBJ,GACG,mBAAbA,GACT1M,KAAK4H,qBAAqBlB,KAAKgG,EAEnC,CAOA,yBAAAK,CAA0BL,GACxB,MAAMxH,EAAQlF,KAAK4H,qBAAqBgF,QAAQF,GAC5CxH,GAAQ,GACVlF,KAAK4H,qBAAqBiF,OAAO3H,EAAO,EAE5C,CAOA,gBAAA0b,CAAiBlU,GACS,mBAAbA,GACT1M,KAAKuW,eAAe7P,KAAKgG,EAE7B,CAQA,iBAAApB,CAAkBlC,GAChBpJ,KAAK4H,qBAAqB3G,QAAQyL,IAChC,IACEA,EAAStD,EACX,OAASjH,GAET,GAEJ,CAQA,WAAAqd,CAAYrd,GACVnC,KAAKuW,eAAetV,QAAQyL,IAC1B,IACEA,EAASvK,EACX,OAAS0e,GAET,GAEJ,CAMA,qBAAA/Z,GACE,MAAO,CACL0X,OAAQxe,KAAKwe,OAAO1X,wBACpB6X,SAAU3e,KAAK2e,SAAS7X,wBACxBga,QAAS,CACP5B,YAAalf,KAAKkf,YAAYnB,KAC9BJ,WAAY3d,KAAK4e,UAAUb,KAC3BgD,YAAa/gB,KAAKmf,gBAClB6B,OAAQhhB,KAAK6e,mBAGnB,CAMA,OAAA7X,GACEhH,KAAKuL,OAELvL,KAAKwe,OAAOxX,UACZhH,KAAK2e,SAAS3X,UAEdhH,KAAK4e,UAAUxc,QACfpC,KAAKkf,YAAY9c,QACjBpC,KAAK2H,cAAgB,GACrB3H,KAAK4H,qBAAuB,GAC5B5H,KAAKuW,eAAiB,GAEtBvW,KAAK8H,eAAgB,CACvB"}