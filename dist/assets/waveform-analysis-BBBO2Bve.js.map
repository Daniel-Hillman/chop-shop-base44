{"version":3,"file":"waveform-analysis-BBBO2Bve.js","sources":["../../src/services/WebAudioAnalyzer.js"],"sourcesContent":["/**\r\n * WebAudioAnalyzer - Real-time audio analysis using Web Audio API\r\n * Connects to YouTube iframe audio streams and provides frequency/amplitude analysis\r\n */\r\n\r\nexport class WebAudioAnalyzer {\r\n  constructor(options = {}) {\r\n    this.audioContext = null;\r\n    this.analyserNode = null;\r\n    this.sourceNode = null;\r\n    this.isAnalyzing = false;\r\n    this.sampleRate = options.sampleRate || 44100;\r\n    this.fftSize = options.fftSize || 2048;\r\n    this.smoothingTimeConstant = options.smoothingTimeConstant || 0.8;\r\n    \r\n    // Progressive waveform generation\r\n    this.waveformData = new Float32Array(0);\r\n    this.progressiveBuffer = [];\r\n    this.analysisCallbacks = new Set();\r\n    this.progressCallbacks = new Set();\r\n    \r\n    // Performance monitoring\r\n    this.lastAnalysisTime = 0;\r\n    this.analysisFrameCount = 0;\r\n    this.performanceMetrics = {\r\n      averageAnalysisTime: 0,\r\n      droppedFrames: 0,\r\n      memoryUsage: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Initialize Web Audio API context and analyzer\r\n   */\r\n  async initialize() {\r\n    try {\r\n      // Create audio context with optimal settings\r\n      this.audioContext = new (window.AudioContext || window.webkitAudioContext)({\r\n        sampleRate: this.sampleRate,\r\n        latencyHint: 'interactive'\r\n      });\r\n\r\n      // Resume context if suspended (required by browser autoplay policies)\r\n      if (this.audioContext.state === 'suspended') {\r\n        await this.audioContext.resume();\r\n      }\r\n\r\n      // Create analyzer node with configured settings\r\n      this.analyserNode = this.audioContext.createAnalyser();\r\n      this.analyserNode.fftSize = this.fftSize;\r\n      this.analyserNode.smoothingTimeConstant = this.smoothingTimeConstant;\r\n      this.analyserNode.minDecibels = -90;\r\n      this.analyserNode.maxDecibels = -10;\r\n\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Failed to initialize WebAudioAnalyzer:', error);\r\n      throw new Error(`Web Audio API initialization failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Connect to YouTube iframe audio stream\r\n   * Note: Direct iframe audio access is limited by CORS policies\r\n   * This method attempts various connection strategies\r\n   */\r\n  async connectToYouTubeStream(youtubePlayer) {\r\n    if (!this.audioContext || !this.analyserNode) {\r\n      throw new Error('WebAudioAnalyzer not initialized');\r\n    }\r\n\r\n    try {\r\n      // Strategy 1: Try to capture audio from YouTube iframe (limited by CORS)\r\n      const audioStream = await this._attemptDirectAudioCapture(youtubePlayer);\r\n      \r\n      if (audioStream) {\r\n        return await this._connectAudioStream(audioStream);\r\n      }\r\n\r\n      // Strategy 2: Use MediaElementAudioSourceNode if available\r\n      const mediaElement = await this._getMediaElement(youtubePlayer);\r\n      if (mediaElement) {\r\n        return await this._connectMediaElement(mediaElement);\r\n      }\r\n\r\n      // Strategy 3: Fallback to progressive analysis using available APIs\r\n      return await this._setupProgressiveAnalysis(youtubePlayer);\r\n\r\n    } catch (error) {\r\n      console.warn('Direct YouTube audio connection failed:', error);\r\n      throw new Error(`YouTube audio connection failed: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start real-time frequency and amplitude analysis\r\n   */\r\n  startAnalysis() {\r\n    if (!this.analyserNode || this.isAnalyzing) {\r\n      return;\r\n    }\r\n\r\n    this.isAnalyzing = true;\r\n    this.analysisFrameCount = 0;\r\n    this.lastAnalysisTime = performance.now();\r\n\r\n    // Start analysis loop\r\n    requestAnimationFrame(() => this._analysisLoop());\r\n  }\r\n\r\n  /**\r\n   * Stop analysis and cleanup resources\r\n   */\r\n  stopAnalysis() {\r\n    this.isAnalyzing = false;\r\n    \r\n    if (this.sourceNode) {\r\n      this.sourceNode.disconnect();\r\n      this.sourceNode = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current frequency data\r\n   */\r\n  getFrequencyData() {\r\n    if (!this.analyserNode) return null;\r\n\r\n    const bufferLength = this.analyserNode.frequencyBinCount;\r\n    const dataArray = new Uint8Array(bufferLength);\r\n    this.analyserNode.getByteFrequencyData(dataArray);\r\n    \r\n    return {\r\n      data: dataArray,\r\n      sampleRate: this.audioContext.sampleRate,\r\n      bufferLength,\r\n      nyquistFrequency: this.audioContext.sampleRate / 2\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get current amplitude/time domain data\r\n   */\r\n  getAmplitudeData() {\r\n    if (!this.analyserNode) return null;\r\n\r\n    const bufferLength = this.analyserNode.fftSize;\r\n    const dataArray = new Uint8Array(bufferLength);\r\n    this.analyserNode.getByteTimeDomainData(dataArray);\r\n    \r\n    return {\r\n      data: dataArray,\r\n      sampleRate: this.audioContext.sampleRate,\r\n      bufferLength\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Generate progressive waveform data with configurable sample rates\r\n   */\r\n  async generateProgressiveWaveform(duration, targetSampleRate = 1000) {\r\n    const totalSamples = Math.floor(duration * targetSampleRate);\r\n    const waveformData = new Float32Array(totalSamples);\r\n    const samplesPerUpdate = Math.floor(targetSampleRate / 60); // 60fps updates\r\n    \r\n    let currentSample = 0;\r\n    \r\n    return new Promise((resolve) => {\r\n      const generateChunk = () => {\r\n        const endSample = Math.min(currentSample + samplesPerUpdate, totalSamples);\r\n        \r\n        // Generate waveform chunk based on current audio analysis\r\n        for (let i = currentSample; i < endSample; i++) {\r\n          const amplitudeData = this.getAmplitudeData();\r\n          if (amplitudeData) {\r\n            // Convert byte data to normalized float (-1 to 1)\r\n            const avgAmplitude = this._calculateAverageAmplitude(amplitudeData.data);\r\n            waveformData[i] = (avgAmplitude - 128) / 128;\r\n          } else {\r\n            waveformData[i] = 0;\r\n          }\r\n        }\r\n        \r\n        currentSample = endSample;\r\n        \r\n        // Notify progress callbacks\r\n        const progress = currentSample / totalSamples;\r\n        this.progressCallbacks.forEach(callback => {\r\n          try {\r\n            callback(progress, waveformData.slice(0, currentSample));\r\n          } catch (error) {\r\n            console.error('Progress callback error:', error);\r\n          }\r\n        });\r\n        \r\n        if (currentSample < totalSamples) {\r\n          requestAnimationFrame(generateChunk);\r\n        } else {\r\n          resolve({\r\n            samples: waveformData,\r\n            sampleRate: targetSampleRate,\r\n            duration,\r\n            channels: 1,\r\n            metadata: {\r\n              analysisMethod: 'web-audio-progressive',\r\n              quality: 'high',\r\n              generatedAt: Date.now(),\r\n              sourceInfo: {\r\n                contextSampleRate: this.audioContext?.sampleRate,\r\n                fftSize: this.fftSize\r\n              }\r\n            }\r\n          });\r\n        }\r\n      };\r\n      \r\n      generateChunk();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Add callback for real-time analysis updates\r\n   */\r\n  onAnalysisUpdate(callback) {\r\n    this.analysisCallbacks.add(callback);\r\n    return () => this.analysisCallbacks.delete(callback);\r\n  }\r\n\r\n  /**\r\n   * Add callback for progressive waveform generation progress\r\n   */\r\n  onProgressUpdate(callback) {\r\n    this.progressCallbacks.add(callback);\r\n    return () => this.progressCallbacks.delete(callback);\r\n  }\r\n\r\n  /**\r\n   * Get performance metrics\r\n   */\r\n  getPerformanceMetrics() {\r\n    return { ...this.performanceMetrics };\r\n  }\r\n\r\n  /**\r\n   * Cleanup resources\r\n   */\r\n  dispose() {\r\n    this.stopAnalysis();\r\n    \r\n    if (this.audioContext && this.audioContext.state !== 'closed') {\r\n      this.audioContext.close();\r\n    }\r\n    \r\n    this.analysisCallbacks.clear();\r\n    this.progressCallbacks.clear();\r\n    this.waveformData = null;\r\n    this.progressiveBuffer = null;\r\n  }\r\n\r\n  // Private methods\r\n\r\n  /**\r\n   * Main analysis loop for real-time processing\r\n   */\r\n  _analysisLoop() {\r\n    if (!this.isAnalyzing) return;\r\n\r\n    const startTime = performance.now();\r\n    \r\n    try {\r\n      // Get current audio data\r\n      const frequencyData = this.getFrequencyData();\r\n      const amplitudeData = this.getAmplitudeData();\r\n      \r\n      if (frequencyData && amplitudeData) {\r\n        // Notify analysis callbacks\r\n        this.analysisCallbacks.forEach(callback => {\r\n          try {\r\n            callback({\r\n              frequency: frequencyData,\r\n              amplitude: amplitudeData,\r\n              timestamp: this.audioContext.currentTime\r\n            });\r\n          } catch (error) {\r\n            console.error('Analysis callback error:', error);\r\n          }\r\n        });\r\n      }\r\n      \r\n      // Update performance metrics\r\n      this.analysisFrameCount++;\r\n      const analysisTime = performance.now() - startTime;\r\n      this.performanceMetrics.averageAnalysisTime = \r\n        (this.performanceMetrics.averageAnalysisTime * (this.analysisFrameCount - 1) + analysisTime) / this.analysisFrameCount;\r\n      \r\n      if (analysisTime > 16) { // More than one frame at 60fps\r\n        this.performanceMetrics.droppedFrames++;\r\n      }\r\n      \r\n    } catch (error) {\r\n      console.error('Analysis loop error:', error);\r\n      this.performanceMetrics.droppedFrames++;\r\n    }\r\n    \r\n    // Schedule next analysis frame only if still analyzing\r\n    if (this.isAnalyzing) {\r\n      requestAnimationFrame(() => this._analysisLoop());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attempt direct audio capture from YouTube iframe\r\n   */\r\n  async _attemptDirectAudioCapture(youtubePlayer) {\r\n    try {\r\n      // This is limited by CORS policies for YouTube iframes\r\n      // Most browsers will block this for security reasons\r\n      const iframe = youtubePlayer.getIframe();\r\n      if (!iframe) return null;\r\n\r\n      // Try to get media stream from iframe (usually blocked)\r\n      const stream = await navigator.mediaDevices.getDisplayMedia({\r\n        audio: true,\r\n        video: false\r\n      });\r\n      \r\n      return stream;\r\n    } catch (error) {\r\n      console.warn('Direct audio capture blocked:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get media element from YouTube player if available\r\n   */\r\n  async _getMediaElement(youtubePlayer) {\r\n    try {\r\n      // YouTube API doesn't expose direct media element access\r\n      // This is a placeholder for potential future API changes\r\n      return null;\r\n    } catch (error) {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Connect audio stream to analyzer\r\n   */\r\n  async _connectAudioStream(audioStream) {\r\n    try {\r\n      this.sourceNode = this.audioContext.createMediaStreamSource(audioStream);\r\n      this.sourceNode.connect(this.analyserNode);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Failed to connect audio stream:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Connect media element to analyzer\r\n   */\r\n  async _connectMediaElement(mediaElement) {\r\n    try {\r\n      this.sourceNode = this.audioContext.createMediaElementSource(mediaElement);\r\n      this.sourceNode.connect(this.analyserNode);\r\n      this.analyserNode.connect(this.audioContext.destination);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Failed to connect media element:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Setup progressive analysis for YouTube player\r\n   */\r\n  async _setupProgressiveAnalysis(youtubePlayer) {\r\n    // Create oscillator as placeholder for testing\r\n    // In real implementation, this would use alternative analysis methods\r\n    try {\r\n      const oscillator = this.audioContext.createOscillator();\r\n      const gainNode = this.audioContext.createGain();\r\n      \r\n      oscillator.connect(gainNode);\r\n      gainNode.connect(this.analyserNode);\r\n      gainNode.gain.setValueAtTime(0.01, this.audioContext.currentTime); // Very low volume\r\n      \r\n      oscillator.frequency.setValueAtTime(440, this.audioContext.currentTime);\r\n      oscillator.start();\r\n      \r\n      this.sourceNode = oscillator;\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Failed to setup progressive analysis:', error);\r\n      throw new Error(`Failed to setup progressive analysis: ${error.message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate average amplitude from byte array\r\n   */\r\n  _calculateAverageAmplitude(dataArray) {\r\n    let sum = 0;\r\n    for (let i = 0; i < dataArray.length; i++) {\r\n      sum += dataArray[i];\r\n    }\r\n    return sum / dataArray.length;\r\n  }\r\n}\r\n\r\nexport default WebAudioAnalyzer;"],"names":["WebAudioAnalyzer","constructor","options","this","audioContext","analyserNode","sourceNode","isAnalyzing","sampleRate","fftSize","smoothingTimeConstant","waveformData","Float32Array","progressiveBuffer","analysisCallbacks","Set","progressCallbacks","lastAnalysisTime","analysisFrameCount","performanceMetrics","averageAnalysisTime","droppedFrames","memoryUsage","initialize","window","AudioContext","webkitAudioContext","latencyHint","state","resume","createAnalyser","minDecibels","maxDecibels","error","Error","message","connectToYouTubeStream","youtubePlayer","audioStream","_attemptDirectAudioCapture","_connectAudioStream","mediaElement","_getMediaElement","_connectMediaElement","_setupProgressiveAnalysis","startAnalysis","performance","now","requestAnimationFrame","_analysisLoop","stopAnalysis","disconnect","getFrequencyData","bufferLength","frequencyBinCount","dataArray","Uint8Array","getByteFrequencyData","data","nyquistFrequency","getAmplitudeData","getByteTimeDomainData","generateProgressiveWaveform","duration","targetSampleRate","totalSamples","Math","floor","samplesPerUpdate","currentSample","Promise","resolve","generateChunk","endSample","min","i","amplitudeData","avgAmplitude","_calculateAverageAmplitude","progress","forEach","callback","slice","samples","channels","metadata","analysisMethod","quality","generatedAt","Date","sourceInfo","contextSampleRate","onAnalysisUpdate","add","delete","onProgressUpdate","getPerformanceMetrics","dispose","close","clear","startTime","frequencyData","frequency","amplitude","timestamp","currentTime","analysisTime","getIframe","navigator","mediaDevices","getDisplayMedia","audio","video","createMediaStreamSource","connect","createMediaElementSource","destination","oscillator","createOscillator","gainNode","createGain","gain","setValueAtTime","start","sum","length"],"mappings":"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"}